{"version":3,"file":"metaphorjs.ui.js","mappings":";;;;;;;;;AACA;;AAEA;;;;;;;;;;ACFA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAYA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AAtBA;AA0BA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAnCA;AAwCA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAEA;AAGA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AAnHA;AAwHA;AAAA;AAAA;AAAA;AAAA;AAMA;;AAIA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAIA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACjWA;;AAEA;;;AAGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AA1BA;;;;;;;;;;ACJA;;AACA;;AAEA;;AAEA;AAEA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;;AACA;AACA;AATA;AAaA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AArBA;AAAA;AAAA;AAAA;AAAA;AA8BA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AAEA;AACA;AAEA;;;;;;;;;;ACvEA;;AAEA;;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAEA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;;;;;;;;;;AC5FA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;;;;;;;;;ACpBA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;;;;;;;;;;AC3CA;;AAEA;AAEA;;AAGA;AACA;AACA;AAGA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;ACrCA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AAGA;AAAA;AAAA;AAIA;;AACA;AACA;AACA;AACA;AARA;AAWA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AApBA;AAwBA;AAIA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AA5CA;AA+CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AAEA;AACA;AAEA;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AAGA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AArFA;AAyFA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAIA;;AAIA;AAEA;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAGA;AACA;AACA;AAGA;AACA;;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAKA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AACA;AACA;;AAEA;;AAEA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AA3OA;AA8OA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AAAA;AAAA;AAKA;;AAEA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AAZA;AAcA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAGA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AAEA;AACA;AACA;;AACA;AAEA;AACA;AACA;;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;ACrxBA;AAAA;;AAGA;;;;;;;;;;ACHA;;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;ACDA;;AACA;;AACA;;AACA;;AAEA;AACA;AADA;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAeA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;AAEA;;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAGA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAAA;AAAA;AAAA;;AAKA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;;;AAEA;AACA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AArCA;;AAuCA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAzCA;;AA6CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;;AAhCA;;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAxBA;;AA2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AATA;;AAYA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AA5EA;;AA+EA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AA5BA;AA+BA;AACA;AACA;;AAxCA;;AA2CA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AA/BA;AAkCA;AACA;AACA;;AA1CA;AA6CA;AACA;AACA;;AAlGA;;AAqGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAhHA;;AAoHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AA9CA;;AAiDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AATA;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAvGA;;AA0GA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAjFA;;AAoFA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AArCA;;AAwCA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AArFA;AAwFA;AACA;AACA;;AAj6BA;AAu6BA;AACA;AACA;AACA;;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AADA;AAGA;AACA;AADA;AAJA;AASA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AACA;AAEA;AACA;;AAIA;AACA;AACA;;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAGA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAcA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AAEA;AAAA;AAAA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAKA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AA1BA;;AAgCA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AACA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AAMA;AACA;AACA;;;AAGA;AACA;AACA;AAGA;AACA;;;AACA;AAEA;AACA;AAEA;AACA;AAGA;;;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAGA;;;AACA;AACA;AACA;AACA;;AAGA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAIA;AACA;AACA;;AAEA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AAGA;AACA;;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAGA;AAEA;AAAA;AAGA;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AACA;;AACA;AAIA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;;AAKA;AACA;AACA;AAGA;;;AACA;AACA;;AAEA;AACA;AACA;AAIA;;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAMA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAKA;AAGA;;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAGA;;;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAGA;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAGA;AAEA;AAAA;AAGA;;AAEA;AACA;AACA;;AAEA;;AAGA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AACA;;AACA;AAIA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAKA;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAIA;AAKA;AAEA;AAAA;AAAA;;AAKA;AACA;AACA;;AAGA;AAAA;;AAKA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAGA;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;;AASA;AAEA;AACA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;;AAGA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAKA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAMA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAMA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAUA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AAGA;;AAEA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AACA;AAEA;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAGA;AAEA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAFA;;AAKA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAIA;;AAGA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AAMA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAGA;AAEA;AAEA;AAAA;AAGA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAppDA;AAupDA;AADA;AAMA;AAEA;;;;;;;;;;ACjwFA;;AAEA;AAAA;;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA7DA;;;;;;;;;;ACJA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AANA;;AASA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAvMA;;;;;;;;;;AClBA;;AAEA;AAAA;AAAA;;AAIA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAZA;;AAeA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AAEA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAEA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;;AAGA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AA5OA;;;;;;;;;;ACNA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;;AANA;AASA;AAEA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;;AAEA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AArBA;;AAwBA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAXA;;AAcA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AAEA;;AAGA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAjRA;AAmRA;;;;;;;;;;ACvSA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAGA;AAEA;AAAA;;AAGA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAAA;;AAIA;AACA;AACA;;AAEA;AACA;AAIA;AAEA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AARA;AAUA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AAEA;AAEA;AAAA;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAGA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AA5UA;;;;;;;;;;ACnBA;;AAEA;;AACA;;AAEA;AAGA;AACA;AACA;AACA;AALA;;;;;;;;;;ACNA;;AAEA;;AACA;;AACA;;AAEA;AAIA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AAFA;AAIA;AACA;;;AAGA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AAEA;AACA;AA5CA;;;;;;;;;;ACNA;AAAA;;AAGA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAGA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;AAjDA;;AAoDA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAxIA;;;;;;;;;;ACZA;;AACA;;AACA;;AACA;;AAEA;;AAEA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAFA;AAIA;AAEA;AAIA;AACA;AACA;AAxBA;;;;;;;;;;ACRA;;AAEA;;AACA;;AACA;;AAEA;AAGA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAaA;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AAhBA;;AAmBA;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;;AACA;AACA;AAAA;AACA;AAEA;AACA;AAZA;;AAcA;AACA;AAzCA;;AA4CA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AA9GA;;;;;;;;;;ACPA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAaA;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;AA7CA;;AAgDA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAnFA;;;;;;;;;;ACTA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAEA;AACA;;AACA;AACA;AAAA;;AAEA;AACA;;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AAFA;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AATA;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AAMA;AACA;AACA;AACA;AAFA;AADA;AAPA;AAcA;AACA;AACA;AADA;AADA;AAKA;AACA;AACA;AACA;AADA;AAFA;AAMA;AACA;AADA;AA1BA;AA8BA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAFA;AAOA;AACA;AACA;AACA;AADA;AAFA;AARA;AAeA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAjLA;AAqLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;;;;;;;;;;AC/LA;;AACA;;AACA;;AAEA;AAAA;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;;AAEA;AAGA;AACA;;AAEA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AASA;AAEA;AACA;AACA;AAIA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAtJA;;;;;;;;;;ACTA;;AAEA;;;;;;;;;;ACDA;;AACA;;AACA;;AAEA;AAAA;;AAGA;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;;AACA;;AACA;;AAGA;AAEA;AAAA;AAGA;AACA;AACA;;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAXA;;AA0BA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;;AAIA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;;AAYA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;;AACA;AACA;;AACA;AAEA;AAEA;AACA;;AACA;AACA;;AACA;AAEA;AAEA;AACA;;AACA;AACA;;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AACA;AACA;;AACA;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AACA;AACA;;AACA;AACA;AApCA;;AAuCA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;;AACA;AAAA;AACA;AACA;AAzBA;;AA4BA;AACA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtwBA;AA2wBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAGA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzEA;AA2EA;;;;;;;;;;ACv2BA;AAAA;AAAA;AAAA;;AAKA;;AACA;;AACA;AAEA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAGA;AACA;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAGA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AA3fA;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;;AACA;;AACA;;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AAEA;AAEA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AAGA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAIA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAGA;AAGA;AAAA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAFA;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAIA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAGA;AACA;;AAEA;AAEA;AAAA;AAGA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAjkEA;AAskEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AA/BA;AAkCA;;;;;;;;;;AC/nEA;;AACA;;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAEA;AAAA;;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACzMA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACbA;AAAA;AAAA;;AAIA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AATA;AAYA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAKA;;AAEA;AACA;AACA;AACA;AAGA;;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAzYA;;AA6YA;AACA;AACA;AAGA;AACA;;AAEA;AACA;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAAA;AAGA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAGA;AACA;AACA;AACA;;AACA;AACA;AAOA;;AACA;AACA;AACA;AACA;;AAGA;AACA;;;;;;;;;;AChfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAZA;AAeA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAIA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAcA;AACA;AACA;;AACA;AACA;AACA;;AACA;;AAEA;AACA;AACA;AAGA;;;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAMA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;;;AACA;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AAGA;;;AACA;AACA;AACA;;;AAGA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AA/fA;AAkgBA;AACA;;;;;;;;;;AC9iBA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9GA;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AAZA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAGA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAGA;AAEA;AAGA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAIA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAGA;AAEA;;AAEA;;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AAGA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;;AACA;;AAEA;AACA;AAGA;AAEA;;AAEA;;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;;AAEA;AACA;;AACA;AAEA;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AA/eA;AAmfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AATA;AAWA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;AAAA;;AAKA;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAGA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;AC39BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAYA;;;;;;;;;;ACbA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACTA;;AAEA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AClCA;;AAEA;;AAEA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;;;;;;;;;ACtDA;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAIA;;AACA;AACA;AACA;AACA;;AACA;AACA;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;;;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACvDA;;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AACA;AACA;AA3BA;AA+BA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAEA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAEA;AAEA;;;;;;;;;;AC1HA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAAA;AAEA;AACA;;;;;;;;;;ACbA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;;AAGA;AACA;AACA;AAGA;AACA;;AACA;AACA;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;ACrCA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACRA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACRA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACVA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;;;;;;;;;;ACdA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAIA;;;;;;;;;;ACdA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;;AACA;AACA;;;;;;;;;;ACXA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACRA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;;AAEA;;AAGA;AACA;AACA;;AAEA;AAEA;AACA;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAGA;;;;;;;;;;ACbA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAHA;AAKA;;;;;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACrDA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AAAA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAAA;AAEA;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACPA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACRA;;AAEA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AAEA;AAAA;;AAIA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAHA;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AArJA;AAuJA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AAEA;;;;;;;;;;;;;;;ACnMA;;AACA;;AACA;;AAEA;AAGA;AAEA;;AAEA;AAIA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AA7BA;AAkCA;AACA;AACA;AApCA;AAuCA;;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AA3DA;AA8DA;AACA;AACA;AACA;AACA;AACA;AAnEA;AAsEA;AAAA;AAAA;AAGA;AACA;AA1EA;AA+EA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;;AAEA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AAZA;AAcA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAaA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAMA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA/NA;AA7EA;AAiTA;AAAA;;AAEA;AACA;AACA;;AACA;AACA;AAvTA;AA0TA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAGA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AAhBA;AAkBA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAlSA;AAqSA;AAEA;;;;;;;;;;ACzoBA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;;;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAKA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAKA;AACA;;AAMA;AACA;;AAEA;AACA;;AAMA;AACA;;AAEA;AACA;;AAKA;AACA;;AAEA;AACA;;AAIA;AACA;;AAUA;AACA;AA1JA;AA4JA;AAGA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AApGA;AAyGA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACrTA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;;AAEA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAIA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AA3LA;;AA+LA;AACA;AACA;;AAEA;AAEA;AACA;;;;;;;;;;AC9NA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWA;AAGA;AAEA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;;AAEA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AA3KA;AA8KA;AACA;;;;;;;;;;ACrNA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAxDA;;;;;;;;;;ACHA;;AAGA;;;;;;;;;;ACDA;;AAEA;;;;;;;;;;ACHA;AAGA;;;AACA;AAGA;AAEA;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AAKA;AAEA;AAEA;AAGA;AAEA;;;;;;;;;;ACpCA;;AAEA;AAAA;AAAA;;AAIA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AAfA;AAqBA;AACA;AACA;AACA;AACA;AACA;AADA;AAJA;AAUA;AACA;AACA;AACA;AACA;AACA;AADA;AAJA;AASA;AACA;AADA;AADA;AAOA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AADA;AAJA;AAUA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AADA;AAIA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AADA;AADA;AAFA;AAFA;AAZA;AA2BA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AAnDA;AA0DA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AADA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAGA;AAAA;AAAA;AAAA;AAAA;AAXA;AAeA;AADA;AAnBA;AAwBA;AAEA;AACA;AACA;AArCA;;;;;;;;;;ACnIA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAVA;;;;;;;;;;ACDA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;;;;;;;;;ACbA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAXA;AAcA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAaA;AACA;AADA;AAIA;AACA;AAxBA;;;;;;;;;;ACrBA;;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;;AACA;;AACA;;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;;ACPA;;AACA;;AACA;;AACA;;AAEA;AAAA;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAnBA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAFA;;;;;;;;;;AC9BA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AACA;AAEA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAvDA;AA0DA;AACA;AACA;AAFA;AAFA;;;;;;;;;;AChEA;;AACA;;AACA;;AACA;;AAEA;AAAA;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AA1BA;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAFA;;;;;;;;;;;;;;;;;;;;ACpCA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AAEA;AAAA;AAAA;AAAA;;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AADA;AAGA;AACA;AAEA;AAPA;AASA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAKA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAKA;;AAEA;AACA;;AAKA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AAKA;AAEA;AACA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;;AAEA;AAEA;;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AAFA;AAIA;;AAEA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AACA;;AAMA;AAEA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AADA;AAJA;AAQA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AADA;AAGA;AAJA;AAXA;AAmBA;AACA;AACA;AAEA;AACA;AAncA;AAscA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAFA;;;;;;;;;;ACzdA;;AACA;;AACA;;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AAMA;AAEA;AACA;AAAA;AAAA;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAIA;AAEA;AACA;AAGA;AACA;;;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AAAA;;AAEA;AACA;AACA;;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;;AAIA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAzOA;;;;;;;;;;ACNA;;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AADA;;;;;;;;;;ACTA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AADA;AADA;AAMA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAlCA;AAqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAaA;AACA;AADA;AAIA;AACA;AACA;AACA;AAHA;AAMA;AAEA;AACA;AACA;AADA;AA5BA;;;;;;;;;;AC5CA;;AACA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AApBA;AAuBA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AAEA;AACA;AACA;AAFA;AAZA;;;;;;;;;;AC7BA;;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAxKA;;;;;;;;;;ACJA;;AACA;;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAtBA;;;;;;;;;;ACLA;;AACA;;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAtBA;;;;;;;;;;ACLA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;;AACA;AACA;AAEA;AAxCA;;;;;;;;;;ACNA;;AACA;;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAtBA;;;;;;;;;;ACLA;;AACA;;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAdA;;;;;;;;;;ACLA;;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAJA;AADA;;;;;;;;;;ACVA;;AACA;;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAHA;;;;;;;;;;ACPA;;AACA;;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AAVA;;;;;;;;;;ACXA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAHA;AAMA;AAGA;AACA;AACA;AACA;AAFA;AALA;;;;;;;;;;ACbA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AAEA;AACA;AAEA;AACA;AACA;;AAGA;AAGA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AAGA;AACA;AACA;;AACA;AACA;AACA;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAGA;AAEA;AAGA;AACA;;AACA;;AACA;AACA;AAvKA;AAyKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AADA;;;;;;;;;;ACrLA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AADA;AAGA;AAGA;AACA;AACA;;AAGA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AADA;AAGA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5IA;AA8IA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AADA;;;;;;;;;;AC5JA;;AACA;;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;;AACA;AACA;;AACA;AACA;AAEA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAGA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AACA;AACA;AAFA;AAKA;AACA;;AAEA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AACA;AA1IA;AA4IA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AADA;;;;;;;;;;AClJA;;AACA;;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAGA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AACA;AACA;AAFA;AAKA;AACA;;AAEA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AACA;AAnHA;AAqHA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AADA;;;;;;;;;;AC5HA;;AACA;;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;;AACA;AACA;;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;;AACA;;AACA;AACA;AAEA;AACA;;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAGA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AApKA;AAsKA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AADA;;;;;;;;;;ACjLA;;AACA;;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAKA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AACA;AACA;;;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAfA;AAkBA;AACA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AA7JA;AA+JA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AADA;;;;;;;;;;ACtKA;;AACA;;AACA;;AACA;;AACA;;AAGA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AAEA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AADA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AA9KA;AAgLA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AALA;AAJA;;;;;;;;;;ACrLA;;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AAJA;AAQA;AACA;AACA;AACA;AACA;AAJA;AADA;;;;;;;;;;ACbA;;;AAGA;;;;;;;;;;ACHA;;AAEA;AAAA;AAAA;;AAIA;;AAEA;AACA;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AC3CA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AAEA;AAEA;AACA;AAAA;AAAA;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;;;;;;;;;;AClCA;;AACA;;AAEA;AACA;AACA;;;;;;;;;;ACLA;;AACA;;AACA;;AACA;;AAEA;;;AAGA;AAEA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AAEA;AACA;AAVA;;AAaA;AACA;;;;;;;;;;AC5BA;;AAEA;AAAA;AAAA;;AAIA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;;AAEA;;AAGA;AACA;;;;;;;;;;ACtBA;;AACA;;AAEA;AAAA;AAAA;AAAA;;;AAMA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAIA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAzCA;;AA2CA;AACA;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;;AAKA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAGA;;AACA;AACA;AADA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AAMA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAGA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;;AAGA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AAJA;;AAOA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAlOA;AAqOA;AACA;AACA;AAHA;;;;;;;;;;AClPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAGA;AAEA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAhBA;AAmBA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAxCA;AA2CA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;;AACA;AACA;AACA;;AAzBA;;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AA5JA;;AAgKA;AAEA;AACA;AACA;;AAEA;AACA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AAZA;;AAcA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAGA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAGA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAEA;AAEA;;AAGA;AACA;AACA;;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAIA;;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;;AACA;AAEA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAIA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AAMA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AAGA;AACA;;AACA;AAKA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;AACA;AACA;AAEA;;AAEA;AAAA;;AAGA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAEA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;;AAKA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAEA;AACA;;AAGA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AAEA;AAGA;AAEA;AAEA;AAAA;AAAA;AAIA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;;AAKA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AA18BA;AA68BA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAoBA;;;;;;;;;;ACptCA;AAAA;AAAA;AAAA;;AAKA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAGA;AAGA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAZA;;AAeA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAnBA;AAsBA;AACA;AACA;;AAvHA;AA2HA;AAAA;AAAA;AAKA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAGA;AAEA;AAOA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AAEA;;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAGA;;AAEA;AACA;AAEA;;AACA;AACA;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAGA;AAEA;AAAA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAGA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAhhBA;AAmhBA;AAFA;AAKA;;;;;;;;;;ACjrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAGA;AAGA;AAEA;AAAA;AAIA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAhBA;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AACA;;AAEA;AACA;AACA;;AA3BA;AA6BA;AACA;AACA;;AAhGA;AAoGA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAIA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AAKA;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AAKA;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AACA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAKA;AACA;AACA;;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AACA;;AAEA;;AAEA;AACA;AAAA;AAAA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAGA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAKA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;;AAEA;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAIA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AAKA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAr5BA;AAy5BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzCA;AA8CA;AAEA;;;;;;;;;;ACllCA;;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;;;;;;;;;;ACRA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AAAA;AAIA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAKA;;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvQA;AA2QA;;;;;;;;;;AC/RA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;;;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAIA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAKA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAlOA;;;;;;;;;;ACjBA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAGA;AAEA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AAAA;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AACA;;AAEA;;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAJA;AAKA;AAAA;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AARA;;AAgBA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AAMA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AAEA;AAEA;AACA;AACA;;AAEA;AAAA;;AAGA;AACA;AACA;AACA;AADA;AADA;AAKA;;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;;AAEA;AAEA;AAMA;AACA;AACA;AACA;AAEA;AACA;AAGA;;AACA;AACA;AAEA;AACA;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAUA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAvgBA;AA2gBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAxDA;;;;;;;;;;AChiBA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AACA;AACA;AAfA;AAkBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AACA;AAEA;AACA;AACA;;;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAEA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AADA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AAGA;;AAEA;;AACA;AACA;AACA;AAFA;AAOA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAGA;;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AAGA;;;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAGA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAEA;;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AACA;AAEA;AACA;AACA;;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AADA;AAGA;;AAGA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;;AAGA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AAjoBA;AAooBA;AACA;AACA;AAJA;;;;;;;;;;AClpBA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;;;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAIA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;;AACA;AAGA;AACA;AACA;AACA;;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AAAA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAKA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AAjOA;AAoOA;AACA;AACA;AACA;AACA;AACA;AANA;;;;;;;;;;AClPA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;;AAEA;AACA;AACA;AACA;AAHA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAxLA;AA2LA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3HA;AA6HA;;;;;;;;;;ACzVA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAcA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAKA;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAAA;;AAKA;;AAEA;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAIA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAKA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AADA;;AAIA;AACA;AACA;;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AAEA;;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAKA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AACA;AAEA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAkBA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAMA;AAAA;AAIA;AACA;AACA;AACA;;AACA;AAEA;AAGA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAAA;;AAGA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;;AAGA;;AAEA;AACA;AAGA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAIA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;;AAEA;;AACA;;AAEA;AACA;;AACA;AACA;AACA;AAtoBA;;;;;;;;;;AC1BA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAdA;AAiBA;AACA;AACA;AACA;AACA;AALA;AAhBA;AA0BA;;AAEA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AALA;AAJA;AAAA;AAcA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AAhFA;;AAoFA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAIA;AACA;AACA;AADA;;AAIA;AACA;AACA;AACA;;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAMA;AACA;;AACA;AACA;AAIA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;;AAKA;AACA;AAIA;AACA;AADA;AAGA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AAGA;AACA;AACA;AACA;AAFA;AAKA;AAEA;AAEA;AAEA;AAEA;AAAA;AAGA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAGA;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAOA;AACA;AAFA;AAMA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AAHA;;AAKA;AACA;AAQA;AAEA;AAAA;;AAGA;AACA;AACA;AAEA;AACA;AAGA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAGA;AACA;;;AACA;AACA;;AACA;AACA;AAEA;AACA;;AAEA;;AACA;;AAEA;AACA;AACA;;;AAGA;AAEA;;AAEA;AAGA;;AACA;;AAEA;AACA;;AAKA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;;AACA;;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAIA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AAFA;AAHA;;AASA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;;AAGA;AACA;;AACA;;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AASA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AA7eA;;AAifA;AACA;AACA;;AAEA;AAEA;AAEA;;;;;;;;;;ACznBA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;AAEA;AAAA;AAGA;;AAIA;AACA;AACA;;AAEA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;;AACA;;AACA;;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AA3EA;;;;;;;;;;ACTA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AACA;AACA;AAZA;AAeA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAvBA;AA0BA;AACA;AA3BA;AA+BA;AAAA;;AAGA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AA1DA;AA8DA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAGA;;AAGA;AACA;AACA;;AAEA;AACA;AAvFA;AA0FA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAvGA;AA0GA;AAAA;AAAA;;AAIA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAzHA;AAAA;AA+HA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AACA;AAEA;AAAA;AAGA;AAEA;AAAA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;;AAEA;;AACA;;AAEA;AACA;AACA;AACA;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AAEA;;AACA;AAGA;AAEA;;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;;AAEA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAFA;AAKA;AACA;AAEA;AAEA;AACA;AACA;AARA;AAWA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AAEA;AAEA;AAEA;;AAEA;;AAGA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;;AACA;AACA;;AACA;AAEA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAIA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;;AAEA;AAEA;;AAEA;AACA;AAKA;AADA;AAIA;;AAEA;AAEA;;;AACA;;;AAEA;;;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;;AACA;AACA;AAGA;AACA;AAEA;AACA;;AACA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;;AAKA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AACA;AACA;AAGA;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AA3vBA;AA+vBA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;;;;;;;;;;AClhCA;;AAEA;AACA;;;;;;;;;;ACFA;;AAEA;AAAA;;AAIA;AAEA;AACA;AACA;AACA;AALA;;;;;;;;;;ACNA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAEA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAAA;;AAIA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAAA;AAGA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAnIA;;;;;;;;;;AClBA;;AACA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAIA;AACA;AACA;AAEA;AACA;AACA;AAxBA;;;;;;;;;;ACLA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AACA;AACA;;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAAA;AAEA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AALA;;AAQA;AACA;AACA;;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AAQA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAGA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AAEA;AAEA;AAEA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAIA;AAEA;AAAA;AAAA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAhYA;;;;;;;;;;ACnBA;;AAEA;;;;;;;;;;ACHA;;AACA;;AAEA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAKA;;;;;;;;;;ACdA;AAAA;;AAGA;AAEA;AACA;AAEA;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AA3BA;;;;;;;;;;ACJA;;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAPA;;;;;;;;;;ACLA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAIA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AAGA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AA/HA;AAiIA;AACA;AACA;AACA;AACA;AACA;AANA;;;;;;;;;;AC5IA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AACA;;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;;AAEA;AACA;AACA;AArEA;AAuEA;AACA;AACA;AAHA;AAMA;;;;;;;;;;ACzKA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAIA;AAEA;AAEA;AACA;AACA;AAGA;;;AACA;AACA;AACA;;AAEA;AAEA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;;AAQA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;;;;;;;;;;ACrFA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAIA;AAEA;AAEA;AACA;AACA;AAGA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;;;;;;;;;;AC7DA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAKA;AAEA;;AAEA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAIA;;AAEA;AAEA;AACA;AAEA;;;;;;;;;;ACrHA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;;AACA;AACA;AACA;;AAEA;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;;AAEA;AAEA;;AAEA;AAAA;AAEA;AACA;AACA;AAJA;AAAA;AAOA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAEA;;;;;;;;;;ACxIA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAKA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA7BA;AA+BA;AACA;AACA;AAHA;;;;;;;;;;ACxCA;;AAEA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAVA;;;;;;;;;;ACHA;;AACA;;AAEA;AAAA;AAAA;;AAKA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;;AACA;AACA;AACA;AACA;AAXA;AAcA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAzDA;AA2DA;AACA;AACA;AACA;AACA;AALA;;;;;;;;;;AClEA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AC/CA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AC9BA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAKA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AA3DA;AAgEA;AACA;AACA;AACA;AAEA;AACA;AADA;AAPA;;;;;;;;;;ACzEA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxGA;AA4GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;;AACA;AACA;AACA;;AAEA;AAEA;;AAEA;AAEA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;;;;;;;;;;ACvOA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAGA;AAEA;AADA;AAIA;AACA;AAEA;AACA;AAGA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;;AAIA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAvIA;AA4IA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AAXA;;;;;;;;;;AC1JA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAGA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAGA;AACA;AACA;;AACA;AACA;AAGA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAxPA;AA4PA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAvCA;;;;;;;;;;AC1QA;;AACA;;AAEA;AAAA;;AAIA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAnBA;AAqBA;AACA;AACA;AAHA;;AAMA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AClDA;;AACA;;AACA;;AAEA;;AAEA;AAEA;AAEA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACnEA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAKA;AAEA;AACA;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAhDA;AAkDA;AACA;AAEA;AAEA;AANA;;;;;;;;;;AC3DA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AA7EA;AAiFA;AACA;AAEA;AACA;AACA;AACA;AAPA;;;;;;;;;;ACvFA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAKA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AADA;AAGA;AACA;AAGA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AA/IA;AAiJA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AATA;;;;;;;;;;ACzJA;;AACA;;AAEA;AAAA;;AAIA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACvBA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAEA;AACA;AAEA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA3EA;AA6EA;AACA;AACA;AAHA;;;;;;;;;;ACvFA;;AAEA;AAAA;;AAGA;AAGA;AACA;AACA;;AAEA;AAKA;;;;;;;;;;ACjBA;;AACA;;AACA;;AAEA;;AAEA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;AChCA;;AACA;AAAA;;AAGA;AACA;AACA;;;;;;;;;;ACLA;;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACZA;;AAEA;AACA;AACA;;;;;;;;;;ACNA;;AACA;;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;;;AAGA;AAGA;AACA;AAEA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AADA;;AAIA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAlEA;;;;;;;;;;ACdA;;AAEA;AAEA;AACA;AACA;AACA;;;AACA;AAGA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AClCA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAIA;AAEA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;;;;;;;;;;AClBA;;AACA;;AAEA;AAAA;;AAIA;AAEA;AAAA;AAAA;AAIA;AACA;AACA;;;;;;;;;;ACdA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAKA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AAMA;AACA;AACA;AAEA;AAAA;AAGA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AApEA;AAsEA;AACA;AACA;AACA;AAJA;;;;;;;;;;AC/EA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAJA;;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACrCA;;AACA;;AACA;;AAEA;AAAA;;AAIA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;;;;ACvCA;;AACA;;;;;;;;;;ACDA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AC3BA;;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACfA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAAA;;AAGA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACvBA;;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACzBA;;AAEA;AAEA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACXA;;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;;AAIA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACzDA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;;;;;;;;;AClBA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACbA;;AACA;;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;AAAA;AAKA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACnCA;;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAGA;;;;;;;;;;ACdA;;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAGA;;;;;;;;;;AChBA;;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;ACjCA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACbA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACbA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;;;;;;;;;;AC1CA;;AAEA;AAEA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACVA;;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;AChBA;;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;;AAGA;;AAEA;AACA;;;;;;;;;;ACpCA;;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AACA;;AAEA;AACA;;;;;;;;;;AC3BA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACXA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACbA;;AAEA;;;;;;;;;;ACFA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAIA;AAEA;AACA;;AACA;;AAEA;AACA;AAEA;AAAA;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;ACrCA;;AAEA;AAAA;AAAA;AAAA;;AAMA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA1EA;AA6EA;AACA;;;;;;;;;;ACxKA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AACA;AAJA;;AAOA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AAKA;AAEA;AAEA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACpIA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AAMA;AACA;AAEA;;;;;;;;;;ACtCA;;AAEA;;;;;;;;;;ACFA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;ACnCA;;AAEA;;AAEA;AAEA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;;;;;;;;;AClBA;;AAEA;;AAEA;AAEA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;AClBA;AAEA;;AAEA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AAAA;AAGA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;AC5CA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AACA;AAAA;AAAA;;AAIA;AACA;AAEA;AAEA;AAJA;;AAQA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAEA;AACA;AAAA;AAAA;AAKA;AACA;;AACA;AACA;;AAGA;AACA;AACA;AAGA;;;AACA;;AAIA;AACA;;;AAGA;AAQA;;AAGA;AAEA;AACA;AACA;;;AAGA;AACA;AAGA;;AACA;AAKA;;AAEA;AAMA;AAEA;;;;;;;;;;ACrHA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;ACjDA;AAEA;;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAGA;AACA;AACA;AACA;;;AAGA;;AAGA;AACA;AACA;AACA;;AACA;AACA;;AACA;AAAA;AAAA;AACA;;;AAGA;AAAA;AAAA;;;AAGA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;;AAGA;AAGA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAEA;;AAEA;AAEA;;;;;;;;;;ACxIA;;AAEA;;;;;;;;;;ACFA;;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;AClBA;;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;;AAEA;AACA;;AAEA;AACA;;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;;;;;;;;;;AClDA;;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AAZA;AAcA;;AAEA;AACA;;;;;;;;;;ACxCA;;AAEA;AACA;AAEA;AAAA;AAAA;AAIA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;;;;;;;;;ACnBA;;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AALA;;AASA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;AC9DA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;;AAEA;AAAA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;;;;;;;;;;AC5CA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAAA;AAAA;;AAGA;AACA;AAGA;AACA;;;;;;;;;;ACpBA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACXA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AALA;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAbA;AAeA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;;AAIA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAHA;;AAKA;AACA;AAEA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAHA;;AAKA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AAEA;;;;;;;;;;AC9TA;;AAEA;AAAA;AAGA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACXA;;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA;;;;;;;;;;ACVA;;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA;;;;;;;;;;ACVA;;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA;;;;;;;;;;ACVA;;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;;;AACA;AAGA;AAAA;AAIA;AACA;AAEA;AAGA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYA;AACA;AAEA;;AAIA;AACA;AACA;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAtDA;AAyDA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;;;;;;;;;;AC5FA;;AACA;;AACA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AAGA;;;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAIA;;;;;;;;;;ACpCA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;;AAGA;AAGA;AACA;;AAEA;AACA;;;;;;;;;;ACvBA;;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA;;;;;;;;;;ACVA;;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA;;;;;;;;;;ACVA;;AAEA;;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;;;;;;;;;ACdA;;AACA;;AACA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AADA;;AAIA;AACA;AACA;AAGA;;;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAGA;AACA;AAFA;;AAKA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AAGA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AAFA;AAIA;;;;;;;;;;ACtEA;;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA;;;;;;;;;;ACVA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AANA;AASA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;AC7CA;;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA;;;;;;;;;;ACVA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACnCA;;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA;;;;;;;;;;ACXA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAKA;;;;;;;;;;AChBA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AChCA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;;;;;;;;;;AC1BA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;;;;;;;;;;ACjBA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACZA;;AACA;;AAEA;;AAEA;AACA;AAGA;;;;;;;;;;ACRA;;AACA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAfA;AAkBA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAGA;AACA;;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AChEA;;AACA;;AACA;;AAEA;;AAEA;AAEA;AAAA;AAAA;;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAAA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AAEA;;;;;;;;;;ACxGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;;;;ACZA;;AAEA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;ACtBA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;;AAEA;AACA;AACA;;;;;;;;;;AChCA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;ACzBA;;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;;;;;;;;;ACbA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;;ACNA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AAlCA;;AAqCA;AACA;AACA;AAGA;AACA;;AAGA;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AAEA;AACA;;AAEA;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;ACvFA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;AC9BA;;AACA;AAAA;;AAGA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;AClCA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AAEA;AAEA;AACA;AAEA;;AAGA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AAAA;AAEA;AAFA;;AAKA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;AC/DA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;AChCA;;AACA;;AACA;;AAEA;;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACnBA;;AACA;;AACA;;AAEA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;;;;;;;;;AC1EA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;;;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAIA;AACA;AADA;AAGA;AAEA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;AAFA;AAIA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;;AAEA;AAAA;AACA;AAEA;AACA;AADA;AAGA;AACA;AACA;AAhCA;;AAmCA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAMA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAGA;AACA;AAFA;AAKA;AAEA;AAGA;AACA;AACA;AAHA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AALA;AAQA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAEA;AAEA;AAIA;AAEA;;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;;AAEA;AAIA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAdA;;AAiBA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAKA;AAEA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAFA;AAIA;AANA;AASA;AACA;AACA;AAHA;AAMA;AAAA;AAAA;AACA;AAFA;AAKA;;AACA;AAKA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAIA;AACA;;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AAGA;AACA;AACA;AACA;;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAEA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;AADA;AAGA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;;AACA;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;AACA;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AApBA;AAsBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AAAA;;AAOA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AACA;;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AA9mCA;AAinCA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AAGA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AAEA;;;;;;;;;;ACrvCA;AAAA;AAAA;AAAA;AAAA;;AAQA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAIA;AACA;;AAEA;AACA;AACA;;AAGA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AAGA;;;AACA;AACA;AACA;AAGA;;;AACA;AAGA;;AAMA;AACA;AAGA;;;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AA7DA;AAgEA;AAEA;;;;;;;;;;AC/JA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAaA;AACA;AACA;;AAEA;AAEA;AAEA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AArSA;AAySA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;;;;;;;;;;ACxXA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;;AAKA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AACA;;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAIA;AACA;;AAEA;AACA;AAIA;AACA;AAEA;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AA3MA;AA8MA;;;;;;;;;;AC5PA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AARA;AAAA;AAAA;AAAA;AAcA;AACA;AAfA;AAkBA;AACA;AAnBA;AAsBA;AACA;AACA;AAxBA;AA4BA;AACA;AACA;AADA;AAGA;;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AADA;AAGA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;;AAEA;AACA;AArDA;AAwDA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AA/EA;AAmFA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAKA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAMA;;;AAGA;AACA;;AACA;AAEA;AACA;AAIA;;AAEA;AACA;AACA;;AAEA;AAEA;AAAA;AAYA;AAIA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAKA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAtLA;AA0LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AAJA;AALA;AAAA;;AAaA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;;AAEA;AACA;AAtPA;AA0PA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAIA;AAhRA;AAoRA;AACA;AADA;AAGA;AAvRA;AA2RA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AANA;;AASA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAlUA;AAqUA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AACA;AACA;;AACA;;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAjWA;AAsWA;;AAEA;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAnYA;AAAA;AAAA;AAAA;AAAA;AA2YA;AAIA;AA/YA;AAkZA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AACA;AACA;AACA;;AAGA;AAEA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAMA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AA/ZA;AAmaA;;;;;;;;;;ACr1BA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAGA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAIA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAEA;;AAUA;AAEA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AACA;;AAOA;AAGA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;;AAEA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAAA;AAGA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAGA;AACA;;AAEA;AAEA;;AAGA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAdA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;;AAEA;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AAEA;;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAvJA;AA0JA;;;;;;;;;;AC9jBA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAIA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AAEA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAAA;;AAIA;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAGA;;AACA;AACA;AACA;;AAEA;AACA;AAGA;AACA;;;AACA;AAEA;AAEA;AAEA;AAGA;;AACA;AACA;AACA;AACA;AACA;AAIA;;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AAhBA;;AAqBA;AACA;AAEA;AAEA;AAAA;AAGA;AACA;AAGA;AACA;AAAA;AAGA;AAGA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AACA;AACA;AAEA;AAEA;AAEA;AAAA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAKA;;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAxbA;AA8bA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AAIA;AAEA;;;;;;;;;;AC5hBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;;AACA;AAEA;AACA;AACA;;;AACA;AAEA;;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AACA;AACA;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AADA;AAGA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AADA;AAGA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAxMA;AA4MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAEA;;;;;;;;;;AC5dA;;AACA;;AAEA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;;;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AA5WA;AAgXA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AAfA;AAiBA;AACA;;AAEA;AAEA;;;;;;;;;;ACxgBA;AAAA;AAAA;;AAIA;AAEA;AAEA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA9DA;AAkEA;AAEA;;;;;;;;;;AC1FA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AAnBA;AAuBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AAIA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAvDA;AA2DA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;;AAEA;AAAA;;AAGA;;AACA;AAEA;;AAKA;;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AAjGA;AAoGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAGA;;AAEA;AACA;;;;;;;;;;AClSA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAEA;AAEA;AACA;AACA;AACA;;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAhJA;AAoJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAhBA;AAoBA;AACA;;;;;;;;;;AC3LA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAIA;AAGA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAGA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AACA;AACA;AACA;AACA;AAEA;;AAEA;;AAGA;;AAEA;;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAFA;AAKA;;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;;AAGA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;;;AAGA;AACA;;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAWA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AAEA;AAnNA;AAwNA;AAEA;AAEA;AAEA;AACA;AAPA;AAYA;;;;;;;;;;AChPA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;;AAKA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAfA;AAiBA;AAEA;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAeA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAIA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsBA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;;AAIA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAGA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAEA;AACA;;AACA;AACA;AAIA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAGA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AAjYA;;;;;;;;;;ACbA;;AAEA;;AAGA;AAEA;AACA;AAEA;AAEA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AAtDA;;;;;;;;;;ACNA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;;AAIA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AADA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA3GA;;;;;;;;;;ACbA;;AACA;;AACA;;AAEA;AAAA;;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AACA;;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AA5DA;;;;;;;;;;ACNA;;AAEA;;;;;;;;;;ACJA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACNA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA","sources":["webpack://metaphorjs-ui/../metaphorjs-animate/src/animate/__init.js","webpack://metaphorjs-ui/../metaphorjs-animate/src/animate/animate.js","webpack://metaphorjs-ui/../metaphorjs-animate/src/animate/easing.js","webpack://metaphorjs-ui/../metaphorjs-animate/src/animate/getDuration.js","webpack://metaphorjs-ui/../metaphorjs-animate/src/animate/getPrefixes.js","webpack://metaphorjs-ui/../metaphorjs-animate/src/animate/isCssSupported.js","webpack://metaphorjs-ui/../metaphorjs-animate/src/animate/stop.js","webpack://metaphorjs-ui/../metaphorjs-animate/src/func/raf.js","webpack://metaphorjs-ui/../metaphorjs-class/src/classManagerFactory.js","webpack://metaphorjs-ui/../metaphorjs-class/src/cls.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/__init.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/dialog/Container.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/dialog/Dialog.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/dialog/Manager.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/dialog/Overlay.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/dialog/pointer/Abstract.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/dialog/pointer/Html.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/dialog/position/Abstract.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/dialog/position/Custom.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/dialog/position/Draggable.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/dialog/position/Mouse.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/dialog/position/None.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/dialog/position/Target.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/dialog/position/Window.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/directive/dropdown.js","webpack://metaphorjs-ui/../metaphorjs-dialog/src/mixin/Dialog.js","webpack://metaphorjs-ui/../metaphorjs-model/src/__init.js","webpack://metaphorjs-ui/../metaphorjs-model/src/directive/attr/each.js","webpack://metaphorjs-ui/../metaphorjs-model/src/model/Model.js","webpack://metaphorjs-ui/../metaphorjs-model/src/model/Record.js","webpack://metaphorjs-ui/../metaphorjs-model/src/model/Store.js","webpack://metaphorjs-ui/../metaphorjs-namespace/src/lib/Namespace.js","webpack://metaphorjs-ui/../metaphorjs-namespace/src/var/ns.js","webpack://metaphorjs-ui/../metaphorjs-observable/src/lib/Observable.js","webpack://metaphorjs-ui/../metaphorjs-observable/src/lib/ObservableEvent.js","webpack://metaphorjs-ui/../metaphorjs-observable/src/mixin/Observable.js","webpack://metaphorjs-ui/../metaphorjs-promise/src/lib/Promise.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/MetaphorJs.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/_/_varType.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/async.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/bind.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/browser/joinLocation.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/browser/parseLocation.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/copy.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/emptyFn.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/equals.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/error.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/extend.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/filterArray.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/getRegExp.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/instantiate.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/intercept.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/isArray.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/isBool.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/isDate.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/isFunction.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/isNull.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/isNumber.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/isObject.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/isPlainObject.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/isPrimitive.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/isRegExp.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/isString.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/isThenable.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/isWindow.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/levenshteinDiff.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/levenshteinMove.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/nextUid.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/returnFalse.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/returnTrue.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/sortArray.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/split.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/toArray.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/toBool.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/toCamelCase.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/toString.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/func/ucfirst.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/lib/Cache.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/lib/Color.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/lib/LocalText.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/lib/Provider.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/lib/Queue.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/mixin/Provider.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/var/regexp/email.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/var/regexp/location.js","webpack://metaphorjs-ui/../metaphorjs-shared/src/var/regexp/url.js","webpack://metaphorjs-ui/./dev-test/container.js","webpack://metaphorjs-ui/./src/__init.js","webpack://metaphorjs-ui/./src/filter/color.js","webpack://metaphorjs-ui/./src/ui/button/Button.js","webpack://metaphorjs-ui/./src/ui/button/Group.js","webpack://metaphorjs-ui/./src/ui/dialog/Popup.js","webpack://metaphorjs-ui/./src/ui/field/Checkbox.js","webpack://metaphorjs-ui/./src/ui/field/Field.js","webpack://metaphorjs-ui/./src/ui/field/Input.js","webpack://metaphorjs-ui/./src/ui/field/Select.js","webpack://metaphorjs-ui/./src/ui/field/view/Select.js","webpack://metaphorjs-ui/./src/ui/menu/Divider.js","webpack://metaphorjs-ui/./src/ui/menu/Item.js","webpack://metaphorjs-ui/./src/ui/menu/Menu.js","webpack://metaphorjs-ui/./src/ui/mixin/Selectable.js","webpack://metaphorjs-ui/./src/ui/mixin/WithActiveState.js","webpack://metaphorjs-ui/./src/ui/mixin/WithDisabledState.js","webpack://metaphorjs-ui/./src/ui/mixin/WithDropdown.js","webpack://metaphorjs-ui/./src/ui/mixin/WithLoadingState.js","webpack://metaphorjs-ui/./src/ui/mixin/WithText.js","webpack://metaphorjs-ui/./src/ui/panel/Panel.js","webpack://metaphorjs-ui/./src/ui/toolbar/Divider.js","webpack://metaphorjs-ui/./src/ui/toolbar/Item.js","webpack://metaphorjs-ui/./src/ui/toolbar/Toolbar.js","webpack://metaphorjs-ui/./src/ui/util/Canvas.js","webpack://metaphorjs-ui/./src/ui/util/Color.js","webpack://metaphorjs-ui/./src/ui/util/ColorAlpha.js","webpack://metaphorjs-ui/./src/ui/util/ColorHue.js","webpack://metaphorjs-ui/./src/ui/util/ColorPicker.js","webpack://metaphorjs-ui/./src/ui/util/ColorSV.js","webpack://metaphorjs-ui/./src/ui/util/Pagination.js","webpack://metaphorjs-ui/./src/ui/window/Window.js","webpack://metaphorjs-ui/../metaphorjs-validator/src/__init.js","webpack://metaphorjs-ui/../metaphorjs-validator/src/directive/form.js","webpack://metaphorjs-ui/../metaphorjs-validator/src/directive/validate.js","webpack://metaphorjs-ui/../metaphorjs-validator/src/func/checkable.js","webpack://metaphorjs-ui/../metaphorjs-validator/src/func/empty.js","webpack://metaphorjs-ui/../metaphorjs-validator/src/func/format.js","webpack://metaphorjs-ui/../metaphorjs-validator/src/func/getLength.js","webpack://metaphorjs-ui/../metaphorjs-validator/src/validator/Component.js","webpack://metaphorjs-ui/../metaphorjs-validator/src/validator/Field.js","webpack://metaphorjs-ui/../metaphorjs-validator/src/validator/Group.js","webpack://metaphorjs-ui/../metaphorjs-validator/src/validator/Validator.js","webpack://metaphorjs-ui/../metaphorjs-validator/src/var/messages.js","webpack://metaphorjs-ui/../metaphorjs-validator/src/var/methods.js","webpack://metaphorjs-ui/../metaphorjs/src/app/App.js","webpack://metaphorjs-ui/../metaphorjs/src/app/Component.js","webpack://metaphorjs-ui/../metaphorjs/src/app/Container.js","webpack://metaphorjs-ui/../metaphorjs/src/app/Controller.js","webpack://metaphorjs-ui/../metaphorjs/src/app/Directive.js","webpack://metaphorjs-ui/../metaphorjs/src/app/ListRenderer.js","webpack://metaphorjs-ui/../metaphorjs/src/app/Renderer.js","webpack://metaphorjs-ui/../metaphorjs/src/app/StoreRenderer.js","webpack://metaphorjs-ui/../metaphorjs/src/app/Template.js","webpack://metaphorjs-ui/../metaphorjs/src/app/__init.js","webpack://metaphorjs-ui/../metaphorjs/src/app/component/View.js","webpack://metaphorjs-ui/../metaphorjs/src/app/view/Base.js","webpack://metaphorjs-ui/../metaphorjs/src/app/view/Component.js","webpack://metaphorjs-ui/../metaphorjs/src/app/view/Router.js","webpack://metaphorjs-ui/../metaphorjs/src/bootstrap/apps.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/app.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/autofocus.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/bind-html.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/bind.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/class.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/cmp.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/controller.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/each.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/events.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/focused.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/hide.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/if.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/include.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/init.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/input.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/key.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/model.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/options.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/properties.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/router.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/show.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/source-src.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/src.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/state.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/style.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/transclude.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/attr/view.js","webpack://metaphorjs-ui/../metaphorjs/src/directive/tag/transclude.js","webpack://metaphorjs-ui/../metaphorjs/src/extra-directives/attr/break-if.js","webpack://metaphorjs-ui/../metaphorjs/src/extra-directives/attr/ignore.js","webpack://metaphorjs-ui/../metaphorjs/src/extra-directives/attr/stylesheet.js","webpack://metaphorjs-ui/../metaphorjs/src/extra-directives/attr/update-on.js","webpack://metaphorjs-ui/../metaphorjs/src/extra-directives/tag/bind-html.js","webpack://metaphorjs-ui/../metaphorjs/src/extra-directives/tag/bind.js","webpack://metaphorjs-ui/../metaphorjs/src/extra-directives/tag/if.js","webpack://metaphorjs-ui/../metaphorjs/src/extra-directives/tag/include.js","webpack://metaphorjs-ui/../metaphorjs/src/extra-directives/tag/tag.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/__init.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/collect.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/filter.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/get.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/join.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/l.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/limitTo.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/linkify.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/lowercase.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/map.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/moment.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/numeral.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/offset.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/p.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/pl.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/preloaded.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/r.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/sortBy.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/split.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/toArray.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/ucfirst.js","webpack://metaphorjs-ui/../metaphorjs/src/filter/uppercase.js","webpack://metaphorjs-ui/../metaphorjs/src/func/app/__init.js","webpack://metaphorjs-ui/../metaphorjs/src/func/app/init.js","webpack://metaphorjs-ui/../metaphorjs/src/func/app/prebuilt.js","webpack://metaphorjs-ui/../metaphorjs/src/func/app/resolve.js","webpack://metaphorjs-ui/../metaphorjs/src/func/app/run.js","webpack://metaphorjs-ui/../metaphorjs/src/func/browser/__init.js","webpack://metaphorjs-ui/../metaphorjs/src/func/browser/hasEvent.js","webpack://metaphorjs-ui/../metaphorjs/src/func/browser/isAndroid.js","webpack://metaphorjs-ui/../metaphorjs/src/func/browser/isIE.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/_/_boxSizingReliable.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/_/_getDimensions.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/_/_getScrollTopOrLeft.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/_/_mousewheelHandler.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/__init.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/addClass.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/addListener.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/clone.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/commentWrap.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/data.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/delegate.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/eachNode.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getAttr.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getAttrSet.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getClsReg.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getHeight.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getInnerHeight.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getInnerWidth.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getInputValue.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getOffset.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getOffsetParent.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getOuterHeight.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getOuterWidth.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getParentDocument.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getPosition.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getScrollLeft.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getScrollParent.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getScrollTop.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getStyle.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/getWidth.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/hasClass.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/is.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/isAttached.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/isField.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/isVisible.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/normalizeEvent.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/onReady.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/preloadImage.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/removeAttr.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/removeClass.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/removeListener.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/removeStyle.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/select.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/setAttr.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/setInputValue.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/setStyle.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/toFragment.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/transclude.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/triggerEvent.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/undelegate.js","webpack://metaphorjs-ui/../metaphorjs/src/func/dom/whenAttached.js","webpack://metaphorjs-ui/../metaphorjs/src/lib/Config.js","webpack://metaphorjs-ui/../metaphorjs/src/lib/DomEvent.js","webpack://metaphorjs-ui/../metaphorjs/src/lib/EventBuffer.js","webpack://metaphorjs-ui/../metaphorjs/src/lib/EventHandler.js","webpack://metaphorjs-ui/../metaphorjs/src/lib/Expression.js","webpack://metaphorjs-ui/../metaphorjs/src/lib/History.js","webpack://metaphorjs-ui/../metaphorjs/src/lib/Input.js","webpack://metaphorjs-ui/../metaphorjs/src/lib/MutationObserver.js","webpack://metaphorjs-ui/../metaphorjs/src/lib/State.js","webpack://metaphorjs-ui/../metaphorjs/src/lib/Stylesheet.js","webpack://metaphorjs-ui/../metaphorjs/src/lib/Text.js","webpack://metaphorjs-ui/../metaphorjs/src/lib/UrlParam.js","webpack://metaphorjs-ui/../metaphorjs/src/plugin/ListAnimated.js","webpack://metaphorjs-ui/../metaphorjs/src/plugin/ListBuffered.js","webpack://metaphorjs-ui/../metaphorjs/src/plugin/ListPullNext.js","webpack://metaphorjs-ui/../metaphorjs/src/plugin/SrcDeferred.js","webpack://metaphorjs-ui/../metaphorjs/src/plugin/SrcSize.js","webpack://metaphorjs-ui/../metaphorjs/src/var/dom/htmlTags.js","webpack://metaphorjs-ui/../../../../../private/tmp/wp-prebuilt-1656071342820.js","webpack://metaphorjs-ui/webpack/bootstrap","webpack://metaphorjs-ui/webpack/runtime/define property getters","webpack://metaphorjs-ui/webpack/runtime/global","webpack://metaphorjs-ui/webpack/runtime/hasOwnProperty shorthand","webpack://metaphorjs-ui/webpack/runtime/make namespace object","webpack://metaphorjs-ui/../../../../../private/tmp/wp-1656071342820.js"],"sourcesContent":["\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nMetaphorJs.animate = MetaphorJs.animate || {};","\nrequire(\"./__init.js\");\nrequire(\"./getDuration.js\");\nrequire(\"./isCssSupported.js\");\nrequire(\"./easing.js\");\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\nrequire(\"metaphorjs/src/func/dom/data.js\");\nrequire(\"metaphorjs/src/func/dom/addClass.js\");\nrequire(\"metaphorjs/src/func/dom/removeClass.js\");\n\nconst isArray                 = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    isThenable              = require(\"metaphorjs-shared/src/func/isThenable.js\"),\n    extend                  = require(\"metaphorjs-shared/src/func/extend.js\"),\n    isString                = require(\"metaphorjs-shared/src/func/isString.js\"),\n    isFunction              = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    isPlainObject           = require(\"metaphorjs-shared/src/func/isPlainObject.js\"),\n    raf                     = require(\"../func/raf.js\"),\n    MetaphorJs              = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.animate.animate = function(){\n\n    var types           = {\n            \"show\":     [\"mjs-show\"],\n            \"hide\":     [\"mjs-hide\"],\n            \"enter\":    [\"mjs-enter\"],\n            \"leave\":    [\"mjs-leave\"],\n            \"move\":     [\"mjs-move\"]\n        },\n\n        animId          = 0,\n        dataParam       = \"mjsAnimationQueue\",\n\n        callTimeout     = function(fn, startTime, duration) {\n            var tick = function(){\n                var time = (new Date).getTime();\n                if (time - startTime >= duration) {\n                    fn();\n                }\n                else {\n                    raf(tick);\n                }\n            };\n            raf(tick);\n        },\n\n\n        nextInQueue     = function(el) {\n            var queue = MetaphorJs.dom.data(el, dataParam),\n                next;\n            if (queue.length) {\n                next = queue[0];\n                animationStage(next.el, next.stages, 0, next.start, next.deferred, false, next.id, next.step);\n            }\n            else {\n                MetaphorJs.dom.data(el, dataParam, null);\n            }\n        },\n\n        animationStage  = function animationStage(el, stages, position, startCallback,\n                                                  deferred, first, id, stepCallback) {\n\n            var stopped   = function() {\n                var q = MetaphorJs.dom.data(el, dataParam);\n                if (!q || !q.length || q[0].id != id) {\n                    deferred.reject(el);\n                    return true;\n                }\n                return false;\n            };\n\n            var finishStage = function() {\n\n                if (stopped()) {\n                    return;\n                }\n\n                var thisPosition = position;\n\n                position++;\n\n                if (position === stages.length) {\n                    deferred.resolve(el);\n                    MetaphorJs.dom.data(el, dataParam).shift();\n                    nextInQueue(el);\n                }\n                else {\n                    MetaphorJs.dom.data(el, dataParam)[0].position = position;\n                    animationStage(el, stages, position, null, deferred, false, id, stepCallback);\n                }\n\n                MetaphorJs.dom.removeClass(el, stages[thisPosition]);\n                MetaphorJs.dom.removeClass(el, stages[thisPosition] + \"-active\");\n            };\n\n            var setStage = function() {\n\n                if (!stopped()) {\n\n                    MetaphorJs.dom.addClass(el, stages[position] + \"-active\");\n\n                    MetaphorJs.lib.Promise.resolve(stepCallback && stepCallback(el, position, \"active\"))\n                        .done(function(){\n                            if (!stopped()) {\n\n                                var duration = MetaphorJs.animate.getDuration(el);\n\n                                if (duration) {\n                                    callTimeout(finishStage, (new Date).getTime(), duration);\n                                }\n                                else {\n                                    raf(finishStage);\n                                }\n                            }\n                        });\n                }\n\n            };\n\n            var start = function(){\n\n                if (!stopped()) {\n                    MetaphorJs.dom.addClass(el, stages[position]);\n\n                    MetaphorJs.lib.Promise.waterfall([\n                            stepCallback && stepCallback(el, position, \"start\"),\n                            function(){\n                                return startCallback ? startCallback(el) : null;\n                            }\n                        ])\n                        .done(function(){\n                            !stopped() && raf(setStage);\n                        });\n                }\n            };\n\n            first ? raf(start) : start();\n        },\n\n\n        jsAnimation = function(el, animation, deferred, startCallback, stepCallback) {\n\n            var duration    = animation.duration || 500,\n                timingFn    = animation.timing || \"linear\",\n                from        = animation.from,\n                to          = animation.to,\n                draw        = animation.draw;\n                \n            timingFn = typeof timingFn === \"string\" ? \n                            MetaphorJs.animate.easing[timingFn] :\n                            timingFn;\n\n            if (!timingFn) {\n                throw new Error(\"Missing easing function \" + animation.timing);\n            }\n\n            typeof from === \"function\" && (from = from(el));\n            typeof to === \"function\" && (to = to(el));\n\n            var calc = animation.calc || function(from, to, frac) {\n                return from + ((to - from) * frac);\n            };\n            \n            var apply = function(progress) {\n\n                var res;\n\n                if (isPlainObject(to)) {\n                    res = {};\n                    for (var k in to) {\n                        res[k] = calc(from[k], to[k], progress, k);\n                    }\n                }\n                else {\n                    res = calc(from, to, progress);\n                }\n\n                draw(el, res);\n                stepCallback && stepCallback(el, res);\n            };\n\n            var step = function() {\n                // timeFraction goes from 0 to 1\n                var time = (new Date).getTime();\n                var timeFraction = (time - start) / duration;\n                if (timeFraction > 1) timeFraction = 1;\n    \n                // calculate the current animation state\n                var progress = timingFn(timeFraction);\n    \n                apply(progress); // draw it\n    \n                if (timeFraction < 1) {\n                    raf(step);\n                }\n                else {\n                    deferred.resolve(el);\n                }\n            };\n            \n            var start = (new Date).getTime();\n            startCallback && startCallback(el);\n            step(start);\n        };\n\n\n    /**\n     * @function MetaphorJs.animate.animate\n     * @param {HTMLElement} el Element being animated\n     * @param {string|function|[]|object} animation {\n     *  'string' - registered animation name,<br>\n     *  'function' - fn(el, callback) - your own animation<br>\n     *  'array' - array or stages (class names)<br>\n     *  'array' - [{before}, {after}] - jquery animation<br>\n     *  'object' - {stages, fn, before, after, options, context, duration, start}\n     * }\n     * @param {function} startCallback call this function before animation begins\n     * @param {function} stepCallback call this function between stages\n     * @returns {MetaphorJs.lib.Promise}\n     */\n    var animate = function animate(el, animation, startCallback, stepCallback) {\n\n        var deferred    = new MetaphorJs.lib.Promise,\n            queue       = MetaphorJs.dom.data(el, dataParam) || [],\n            id          = ++animId,\n            stages,\n            jsFn,\n            before, after,\n            options, context,\n            duration;\n\n        if (animation) {\n\n            if (isString(animation)) {\n                stages = types[animation];\n            }\n            else if (isFunction(animation)) {\n                jsFn = animation;\n            }\n            else if (isArray(animation)) {\n                if (isString(animation[0])) {\n                    stages = animation;\n                }\n                else {\n                    before = animation[0];\n                    after = animation[1];\n                }\n            }\n            else if (isPlainObject(animation)) {\n                stages      = animation.stages;\n                jsFn        = animation.fn;\n                before      = animation.before;\n                after       = animation.after;\n                options     = animation.options ? extend({}, animation.options) : {};\n                context     = animation.context || null;\n                duration    = animation.duration || null;\n                startCallback   = startCallback || options.start;\n            }\n\n            if (MetaphorJs.animate.isCssSupported() && stages) {\n\n                queue.push({\n                    el: el,\n                    stages: stages,\n                    start: startCallback,\n                    step: stepCallback,\n                    deferred: deferred,\n                    position: 0,\n                    id: id\n                });\n                MetaphorJs.dom.data(el, dataParam, queue);\n\n                if (queue.length === 1) {\n                    animationStage(el, stages, 0, startCallback, deferred, true, id, stepCallback);\n                }\n\n                return deferred;\n            }\n            else if (animation.draw) {\n                jsAnimation(el, animation, deferred, startCallback, stepCallback);\n                return deferred;\n            }\n            else {\n\n                options = options || {};\n\n                startCallback && (options.start = function(){\n                    startCallback(el);\n                });\n\n                options.complete = function() {\n                    deferred.resolve(el);\n                };\n\n                duration && (options.duration = duration);\n\n                if (jsFn && isFunction(jsFn)) {\n                    if (before) {\n                        extend(el.style, before, true, false);\n                    }\n                    startCallback && startCallback(el);\n                    MetaphorJs.dom.data(el, dataParam, jsFn.call(context, el, function(){\n                        deferred.resolve(el);\n                    }));\n                    return deferred;\n                }\n                else if (window.jQuery) {\n\n                    var j = $(el);\n                    before && j.css(before);\n                    MetaphorJs.dom.data(el, dataParam, \"stop\");\n\n                    if (jsFn && isString(jsFn)) {\n                        j[jsFn](options);\n                        return deferred;\n                    }\n                    else if (after) {\n                        j.animate(after, options);\n                        return deferred;\n                    }\n                }\n            }\n        }\n\n        // no animation happened\n\n        if (startCallback) {\n            var promise = startCallback(el);\n            if (isThenable(promise)) {\n                promise.done(function(){\n                    deferred.resolve(el);\n                });\n            }\n            else {\n                deferred.resolve(el);\n            }\n        }\n        else {\n            deferred.resolve(el);\n        }\n\n        return deferred;\n    };\n\n    /**\n     * @function MetaphorJs.animate.animate.addAnimationType\n     * @param {string} name \n     * @param {array} stages \n     */\n    animate.addAnimationType     = function(name, stages) {\n        types[name] = stages;\n    };\n\n    return animate;\n}();","require(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n//https://gist.github.com/gre/1650294\nmodule.exports = MetaphorJs.animate.easing = {\n    // no easing, no acceleration\n    linear: function (t) { return t },\n    // accelerating from zero velocity\n    easeInQuad: function (t) { return t*t },\n    // decelerating to zero velocity\n    easeOutQuad: function (t) { return t*(2-t) },\n    // acceleration until halfway, then deceleration\n    easeInOutQuad: function (t) { return t<.5 ? 2*t*t : -1+(4-2*t)*t },\n    // accelerating from zero velocity \n    easeInCubic: function (t) { return t*t*t },\n    // decelerating to zero velocity \n    easeOutCubic: function (t) { return (--t)*t*t+1 },\n    // acceleration until halfway, then deceleration \n    easeInOutCubic: function (t) { return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1 },\n    // accelerating from zero velocity \n    easeInQuart: function (t) { return t*t*t*t },\n    // decelerating to zero velocity \n    easeOutQuart: function (t) { return 1-(--t)*t*t*t },\n    // acceleration until halfway, then deceleration\n    easeInOutQuart: function (t) { return t<.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t },\n    // accelerating from zero velocity\n    easeInQuint: function (t) { return t*t*t*t*t },\n    // decelerating to zero velocity\n    easeOutQuint: function (t) { return 1+(--t)*t*t*t*t },\n    // acceleration until halfway, then deceleration \n    easeInOutQuint: function (t) { return t<.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t }\n}","\nrequire(\"./__init.js\");\nrequire(\"./getPrefixes.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.animate.getDuration = function(){\n\n    var parseTime       = function(str) {\n            if (!str) {\n                return 0;\n            }\n            var time = parseFloat(str);\n            if (str.indexOf(\"ms\") === -1) {\n                time *= 1000;\n            }\n            return time;\n        },\n\n        getMaxTimeFromPair = function(max, dur, delay) {\n\n            var i, sum, len = dur.length;\n\n            for (i = 0; i < len; i++) {\n                sum = parseTime(dur[i]) + parseTime(delay[i]);\n                max = Math.max(sum, max);\n            }\n\n            return max;\n        },\n\n        pfx                 = false,\n        animationDuration   = null,\n        animationDelay      = null,\n        transitionDuration  = null,\n        transitionDelay     = null;\n\n\n    /**\n     * Get duration in milliseconds from html \n     * element based on current computed style\n     * @function MetaphorJs.animate.getDuration\n     * @param {HTMLElement} el\n     * @returns {number}\n     */\n    return function(el) {\n\n        if (pfx === false) {\n            pfx = MetaphorJs.animate.getPrefixes();\n            animationDuration = pfx ? pfx.animationDuration : null;\n            animationDelay = pfx ? pfx.animationDelay : null;\n            transitionDuration = pfx ? pfx.transitionDuration : null;\n            transitionDelay = pfx ? pfx.transitionDelay : null;\n        }\n\n        if (!pfx) {\n            return 0;\n        }\n\n        var style       = window.getComputedStyle ? window.getComputedStyle(el, null) : el.style,\n            duration    = 0,\n            animDur     = (style[animationDuration] || '').split(','),\n            animDelay   = (style[animationDelay] || '').split(','),\n            transDur    = (style[transitionDuration] || '').split(','),\n            transDelay  = (style[transitionDelay] || '').split(',');\n\n        duration    = Math.max(duration, getMaxTimeFromPair(duration, animDur, animDelay));\n        duration    = Math.max(duration, getMaxTimeFromPair(duration, transDur, transDelay));\n\n        return duration;\n    };\n\n}();\n\n","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.animate.getPrefixes = function(){\n\n    var domPrefixes         = ['Moz', 'Webkit', 'ms', 'O', 'Khtml'],\n        animationDelay      = \"animationDelay\",\n        animationDuration   = \"animationDuration\",\n        transitionDelay     = \"transitionDelay\",\n        transitionDuration  = \"transitionDuration\",\n        transform           = \"transform\",\n        transitionend       = null,\n        prefixes            = null,\n\n        probed              = false,\n\n        detectCssPrefixes   = function() {\n\n            var el = window.document.createElement(\"div\"),\n                animation = false,\n                pfx,\n                i, len;\n\n            if (el.style && el.style['animationName'] !== undefined) {\n                animation = true;\n            }\n            else {\n                for(i = 0, len = domPrefixes.length; i < len; i++) {\n                    pfx = domPrefixes[i];\n                    if (el.style && el.style[ pfx + 'AnimationName' ] !== undefined) {\n                        animation           = true;\n                        animationDelay      = pfx + \"AnimationDelay\";\n                        animationDuration   = pfx + \"AnimationDuration\";\n                        transitionDelay     = pfx + \"TransitionDelay\";\n                        transitionDuration  = pfx + \"TransitionDuration\";\n                        transform           = pfx + \"Transform\";\n                        break;\n                    }\n                }\n            }\n\n            if (animation) {\n                if('ontransitionend' in window) {\n                    // Chrome/Saf (+ Mobile Saf)/Android\n                    transitionend = 'transitionend';\n                }\n                else if('onwebkittransitionend' in window) {\n                    // Chrome/Saf (+ Mobile Saf)/Android\n                    transitionend = 'webkitTransitionEnd';\n                }\n            }\n\n            return animation;\n        };\n\n\n    /**\n     * Get css prefixes used in current browser\n     * @function MetaphorJs.animate.getPrefixes\n     * @returns {object} {\n     *  @type {string} animationDelay\n     *  @type {string} animationDuration\n     *  @type {string} transitionDelay\n     *  @type {string} transitionDuration\n     *  @type {string} transform\n     *  @type {string} transitionend\n     * }\n     */\n    return function() {\n\n        if (!probed) {\n            if (detectCssPrefixes()) {\n                prefixes = {\n                    animationDelay: animationDelay,\n                    animationDuration: animationDuration,\n                    transitionDelay: transitionDelay,\n                    transitionDuration: transitionDuration,\n                    transform: transform,\n                    transitionend: transitionend\n                };\n            }\n            else {\n                prefixes = {};\n            }\n\n            probed = true;\n        }\n\n\n        return prefixes;\n    };\n}();","\nrequire(\"./__init.js\");\nrequire(\"./getPrefixes.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Is css animation supported in current browser\n * @function MetaphorJs.animate.isCssSupported\n * @returns {bool}\n */\nmodule.exports = MetaphorJs.animate.isCssSupported = (function(){\n\n    var cssAnimations = null;\n\n    return function() {\n        if (cssAnimations === null) {\n            cssAnimations   = !!MetaphorJs.animate.getPrefixes();\n        }\n        return cssAnimations;\n    };\n}());","\nrequire(\"./__init.js\");\nrequire(\"metaphorjs/src/func/dom/data.js\");\nrequire(\"metaphorjs/src/func/dom/removeClass.js\");\n\nconst isFunction = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Stop ongoing animation for given element\n * @function MetaphorJs.animate.stop\n * @param {HTMLElement} el\n */\nmodule.exports = MetaphorJs.animate.stop = function(el) {\n\n    var queue = MetaphorJs.dom.data(el, \"mjsAnimationQueue\"),\n        current,\n        position,\n        stages;\n\n    if (isArray(queue) && queue.length) {\n        current = queue[0];\n\n        if (current) {\n            if (current.stages) {\n                position = current.position;\n                stages = current.stages;\n                MetaphorJs.dom.removeClass(el, stages[position]);\n                MetaphorJs.dom.removeClass(el, stages[position] + \"-active\");\n            }\n            if (current.deferred) {\n                current.deferred.reject(current.el);\n            }\n        }\n    }\n    else if (isFunction(queue)) {\n        queue(el);\n    }\n    else if (queue === \"stop\") {\n        $(el).stop(true, true);\n    }\n\n    MetaphorJs.dom.data(el, \"mjsAnimationQueue\", null);\n};\n","\nconst async = require(\"metaphorjs-shared/src/func/async.js\");\n\nmodule.exports = function() {\n\n    var raf,\n        cancel;\n\n    if (typeof window !== \"undefined\") {\n        var w   = window;\n        raf     = w.requestAnimationFrame ||\n                    w.webkitRequestAnimationFrame ||\n                    w.mozRequestAnimationFrame;\n        cancel  = w.cancelAnimationFrame ||\n                    w.webkitCancelAnimationFrame ||\n                    w.mozCancelAnimationFrame ||\n                    w.webkitCancelRequestAnimationFrame;\n\n        if (raf) {\n            return function(fn, context, args) {\n                var id = raf(context || args ? function(){\n                    fn.apply(context, args || []);\n                } : fn);\n                return function() {\n                    cancel(id);\n                };\n            };\n        }\n    }\n\n    return function(fn, context, args){\n        var id = async(fn, context, args, 0);\n        return function(){\n            clearTimeout(id);\n        };\n    };\n\n}();","require(\"metaphorjs-namespace/src/lib/Namespace.js\");\n\nconst isFunction  = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    isString    = require(\"metaphorjs-shared/src/func/isString.js\"),\n    isArray     = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    toArray     = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    extend      = require(\"metaphorjs-shared/src/func/extend.js\"),\n    emptyFn     = require(\"metaphorjs-shared/src/func/emptyFn.js\"),\n    instantiate = require(\"metaphorjs-shared/src/func/instantiate.js\"),\n    intercept   = require(\"metaphorjs-shared/src/func/intercept.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = function(){\n\n\n    var proto   = \"prototype\",\n        constr  = \"$constructor\",\n\n        $constr = function $constr() {\n            var self = this;\n            if (self.$super && self.$super !== emptyFn) {\n                self.$super.apply(self, arguments);\n            }\n        },\n\n        collectMixinEvents = function(events, pConstr) {\n            var pp;\n            while (pConstr) {\n                pp = pConstr[proto];\n                if (pp.$mixinEvents) {\n                    events = events.concat(pp.$mixinEvents);\n                }\n                pConstr = pConstr.$parent;\n            }\n            return events;\n        },\n\n        wrapPrototypeMethod = function wrapPrototypeMethod(parent, k, fn) {\n\n            var $super = parent[proto][k] ||\n                        (k === constr ? parent : emptyFn) ||\n                        emptyFn;\n\n            return function() {\n                var ret,\n                    self    = this,\n                    prev    = self.$super;\n\n                if (self.$destroyed) {\n                    self.$super = null;\n                    return null;\n                }\n\n                self.$super     = $super;\n                ret             = fn.apply(self, arguments);\n                self.$super     = prev;\n\n                return ret;\n            };\n        },\n\n        preparePrototype = function preparePrototype(prototype, cls, parent, onlyWrap, mixEvents) {\n            var k, ck, pk, pp = parent[proto],\n                i, l, name;\n\n            for (k in cls) {\n                if (cls.hasOwnProperty(k)) {\n                    \n                    pk = pp[k];\n                    ck = cls[k];\n\n                    prototype[k] = isFunction(ck) && (!pk || isFunction(pk)) ?\n                                    wrapPrototypeMethod(parent, k, ck) :\n                                    ck;\n                }\n            }\n\n            if (onlyWrap) {\n                return;\n            }\n\n            prototype.$plugins      = null;\n            prototype.$pluginMap    = null;\n\n            if (mixEvents) {\n                for (i = 0, l = mixEvents.length; i < l; i++) {\n                    name = mixEvents[i];\n                    if (pp[name]) {\n                        if (typeof pp[name] === 'function') {\n                            throw new Error(\"Cannot override method \" + \n                                            name + \n                                            \" with mixin event\");\n                        }\n                        prototype[name] = pp[name].slice();\n                    }\n                    else {\n                        prototype[name] = [];\n                    }\n                }\n            }\n        },\n        \n        mixinToPrototype = function(prototype, mixin, events) {\n            \n            var k;\n\n            for (k in mixin) {\n                if (mixin.hasOwnProperty(k)) {\n                    if (events.indexOf(k) !== -1) {\n                        prototype[k].push(mixin[k]);\n                    }\n                    else if (!prototype[k]) {\n                        prototype[k] = mixin[k];\n                    }\n                }\n            }\n        };\n\n\n    /**\n     * Instantiate class system with namespace.\n     * @group api\n     * @function\n     * @param {MetaphorJs.lib.Namespace} ns {\n     *  Provide your own namespace or a new private ns will be \n     *  constructed automatically. \n     *  @optional\n     * }\n     * @returns {object} Returns cls() function/object. \n     */\n    var classManagerFactory = function(ns) {\n\n        if (!ns) {\n            ns = new MetaphorJs.lib.Namespace;\n        }\n\n        var createConstructor = function(className) {\n\n            return function() {\n\n                var self    = this,\n                    before  = [],\n                    after   = [],\n                    args    = arguments,\n                    newArgs,\n                    i, l,\n                    plugins, plugin,\n                    pmap,\n                    plCls;\n\n                if (!self) {\n                    throw new Error(\"Must instantiate via new: \" + className);\n                }\n\n                self.$plugins   = [];\n\n                newArgs = self[constr].apply(self, arguments);\n\n                if (newArgs && isArray(newArgs)) {\n                    args = newArgs;\n                }\n\n                plugins = self.$plugins;\n                pmap    = self.$pluginMap = {};\n\n                if (self.$beforeInit) \n                    for (i = -1, l = self.$beforeInit.length; ++i < l;\n                         before.push([self.$beforeInit[i], self])) {}\n\n                if (self.$afterInit)\n                    for (i = -1, l = self.$afterInit.length; ++i < l;\n                         after.push([self.$afterInit[i], self])) {}\n\n                if (plugins && plugins.length) {\n\n                    for (i = 0, l = plugins.length; i < l; i++) {\n\n                        plugin = plugins[i];\n\n                        if (isString(plugin)) {\n                            plCls = plugin;\n                            plugin = ns ? ns.get(plugin) : null;\n                            if (!plugin) {\n                                throw plCls + \" not found\";\n                            }\n                        }\n \n                        plugin = new plugin(self, args);\n                        pmap[plugin.$class] = plugin;\n\n                        if (plugin.$beforeHostInit) {\n                            before.push([plugin.$beforeHostInit, plugin]);\n                        }\n\n                        plugins[i] = plugin;\n                    }\n                }\n\n                for (i = -1, l = before.length; ++i < l;\n                     before[i][0].apply(before[i][1], args)){}\n\n                if (self.$init) {\n                    self.$init.apply(self, args);\n                }\n\n                // we look for $afterHostInit in a separate loop\n                // for plugins can be added inside $beforeHostInit\n                // or in $init\n                if (plugins && plugins.length) {\n                    for (i = 0, l = plugins.length; i < l; i++) {\n                        plugin = plugins[i];\n                        if (plugin.$afterHostInit) {\n                            after.push([plugin.$afterHostInit, plugin]);\n                        }\n                    }\n                }\n\n                for (i = -1, l = after.length; ++i < l;\n                     after[i][0].apply(after[i][1], args)){}\n            };\n        };\n\n\n        /**\n         * All classes defined with <code>cls</code> extend this class.\n         * Basically,<code>cls({});</code> is the same as \n         * <code>BaseClass.$extend({})</code>.\n         * @group api\n         * @class MetaphorJs.cls.BaseClass\n         */\n        var BaseClass = function() {\n\n        };\n\n        extend(BaseClass.prototype, {\n\n            /**\n             * Class name\n             * @property {string} \n             */\n            $class: null,\n            $extends: null,\n\n            /**\n             * List of plugin names or constructors before class \n             * is initialised, list of plugin instances after initialisation\n             * @property {array} \n             */\n            $plugins: null,\n            $pluginMap: null,\n            $mixins: null,\n            $mixinEvents: [\"$beforeInit\", \"$afterInit\",\n                            \"$beforeDestroy\", \"$afterDestroy\"],\n\n            $destroyed: false,\n            $destroying: false,\n\n            $constructor: emptyFn,\n            $init: emptyFn,\n            $beforeInit: [],\n            $afterInit: [],\n            $beforeDestroy: [],\n            $afterDestroy: [],\n\n            /**\n             * Call mixins for a specified mixin event\n             * @param {string} eventName \n             */\n            $callMixins: function(eventName) {\n                var self = this,\n                    fns = self[eventName],\n                    i, l,\n                    args = toArray(arguments);\n\n                args.shift();\n\n                for (i = 0, l = fns.length; i < l; i++) {\n                    fns[i].apply(self, args);\n                }\n            },\n\n            /**\n             * Get this instance's class name\n             * @method\n             * @returns {string}\n             */\n            $getClass: function() {\n                return this.$class;\n            },\n\n            /**\n             * Is this object instance of <code>cls</code>\n             * @param {string} cls\n             * @returns {boolean}\n             */\n            $is: function(cls) {\n                return isInstanceOf(this, cls);\n            },\n\n            /**\n             * Get parent class name\n             * @method\n             * @returns {string | null}\n             */\n            $getParentClass: function() {\n                return this.$extends;\n            },\n\n            /**\n             * Intercept method\n             * @method\n             * @param {string} method Intercepted method name\n             * @param {function} fn function to call before or after intercepted method\n             * @param {object} newContext optional interceptor's \"this\" object\n             * @param {string} when optional, when to call interceptor \n             *                         before | after | instead; default \"before\"\n             * @param {bool} replaceValue optional, return interceptor's return value \n             *                  or original method's; default false\n             * @returns {function} original method\n             */\n            $intercept: function(method, fn, newContext, when, replaceValue) {\n                var self = this,\n                    orig = self[method];\n                self[method] = intercept(orig || emptyFn, fn, newContext || self, \n                                            self, when, replaceValue);\n                return orig || emptyFn;\n            },\n\n            /**\n             * Implement new methods or properties on instance\n             * @method\n             * @param {object} methods\n             */\n            $implement: function(methods) {\n                var $self = this.constructor;\n                if ($self && $self.$parent) {\n                    preparePrototype(this, methods, $self.$parent, true);\n                }\n            },\n\n            /**\n             * Add a plugin to class instance\n             * @param {string|function} plugin \n             */\n            $addPlugin: function(plugin) {\n\n                var plCls, \n                    self = this,\n                    pmap = self.$pluginMap;\n\n                if (isString(plugin)) {\n                    plCls = plugin;\n                    plugin = ns ? ns.get(plugin) : null;\n                    if (!plugin) {\n                        throw plCls + \" not found\";\n                    }\n                }\n                else {\n                    plCls = plugin.$class;\n                }\n\n                if (pmap[plCls]) {\n                    throw plCls + \" already initialized on this instance\";\n                }\n\n                plugin = new plugin(self);\n                pmap[plCls] = plugin;\n                self.$plugins.push(plugin);\n            },\n\n            /**\n             * Does this instance have a plugin\n             * @method\n             * @param cls\n             * @returns {boolean}\n             */\n            $hasPlugin: function(cls) {\n                return cls ? !!this.$pluginMap[cls] : false;\n            },\n\n            /**\n             * Get plugin instance\n             * @method\n             * @param {string} cls Plugin class name\n             * @returns {object|null}\n             */\n            $getPlugin: function(cls) {\n                return cls ? this.$pluginMap[cls] || null : null;\n            },\n\n            /**\n             * Get a bound to this object function\n             * @method\n             * @param {function} fn\n             * @returns {Function}\n             */\n            $bind: function(fn) {\n                var self = this;\n                return function() {\n                    if (!self.$isDestroyed()) {\n                        return fn.apply(self, arguments);\n                    }\n                };\n            },\n\n            /**\n             * Is this object destroyed\n             * @method\n             * @return {boolean}\n             */\n            $isDestroyed: function() {\n                return this.$destroying || this.$destroyed;\n            },\n\n            /**\n             * Destroy this instance. Also destroys plugins and\n             * calls all beforeDestroy and afterDestroy handlers.\n             * Also calls onDestroy.<br>\n             * Safe to call multiple times.\n             * @method\n             */\n            $destroy: function() {\n\n                var self    = this,\n                    before  = self.$beforeDestroy,\n                    after   = self.$afterDestroy,\n                    plugins = self.$plugins,\n                    i, l, res;\n\n                if (self.$destroying || self.$destroyed) {\n                    return;\n                }\n\n                self.$destroying = true;\n\n                for (i = -1, l = before.length; ++i < l;\n                     before[i].apply(self, arguments)){}\n\n                for (i = 0, l = plugins.length; i < l; i++) {\n                    if (plugins[i].$beforeHostDestroy) {\n                        plugins[i].$beforeHostDestroy.call(plugins[i], arguments);\n                    }\n                }\n\n                res = self.onDestroy.apply(self, arguments);\n\n                for (i = -1, l = after.length; ++i < l;\n                     after[i].apply(self, arguments)){}\n\n                for (i = 0, l = plugins.length; i < l; i++) {\n                    plugins[i].$destroy.apply(plugins[i], arguments);\n                }\n\n                if (res !== false) {\n                    for (i in self) {\n                        if (self.hasOwnProperty(i)) {\n                            self[i] = null;\n                        }\n                    }\n                }\n\n                self.$destroying = false;\n                self.$destroyed = true;\n            },\n\n            /**\n             * Overridable method. Put your destructor here\n             * @method\n             */\n            onDestroy: function(){}\n        });\n\n        BaseClass.$self = BaseClass;\n\n        /**\n         * Create an instance of current class. Same as <code>cls.factory(name)</code>\n         * @method\n         * @static\n         * @code var myObj = My.Class.$instantiate(arg1, arg2, ...);\n         * @returns {object} class instance\n         */\n        BaseClass.$instantiate = function() {\n\n            var cls = this,\n                args = arguments,\n                cnt = args.length;\n\n            // lets make it ugly, but without creating temprorary classes and leaks.\n            // and fallback to normal instantiation.\n\n            switch (cnt) {\n                case 0:\n                    return new cls;\n                case 1:\n                    return new cls(args[0]);\n                case 2:\n                    return new cls(args[0], args[1]);\n                case 3:\n                    return new cls(args[0], args[1], args[2]);\n                case 4:\n                    return new cls(args[0], args[1], args[2], args[3]);\n                default:\n                    return instantiate(cls, args);\n            }\n        };\n\n        /**\n         * Override class methods (on prototype level, not on instance level)\n         * @method\n         * @static\n         * @param {object} methods\n         */\n        BaseClass.$override = function(methods) {\n            var $self = this.$self,\n                $parent = this.$parent;\n\n            if ($self && $parent) {\n                preparePrototype($self.prototype, methods, $parent);\n            }\n        };\n\n        /**\n         * Create new class extending current one\n         * @static\n         * @method\n         * @param {object} definition\n         * @param {object} statics\n         * @returns {function}\n         */\n        BaseClass.$extend = function(definition, statics) {\n            return defineClass(definition, statics, this);\n        };\n\n        /**\n         * Destroy class (not the instance)\n         * @method\n         * @static\n         */\n        BaseClass.$destroy = function() {\n            var self = this,\n                k;\n\n            for (k in self) {\n                self[k] = null;\n            }\n        };\n        /**\n         * @end-class\n         */\n\n\n        /**\n         * Constructed class system. Also this is a function, same as \n         * <code>cls.define</code>\n         * @group api\n         * @object cls\n         */\n\n        /**\n         * @property {function} define {\n         *  @param {object} definition {\n         *      @type {string} $class optional class name\n         *      @type {string} $extends optional parent class\n         *      @type {array} $mixins optional list of mixins\n         *      @type {function} $constructor optional low-level constructor\n         *      @type {function} $init optional constructor\n         *      @type {function} onDestroy your own destroy function\n         *  }\n         *  @param {object} statics any statis properties or methods\n         * }\n         * @code var Name = cls({$class: \"Name\"});\n         */\n        var defineClass = function defineClass(definition, statics, $extends) {\n\n            definition          = definition || {};\n            \n            var name            = definition.$class,\n                parentClass     = $extends || definition.$extends,\n                mixins          = definition.$mixins,\n                mixEvents       = definition.$mixinEvents || [],\n                alias           = definition.$alias,\n                pConstructor,\n                allMixEvents,\n                i, l, k, prototype, c, mixin;\n\n            if (parentClass) {\n                if (isString(parentClass)) {\n                    pConstructor = ns.get(parentClass);\n                }\n                else {\n                    pConstructor = parentClass;\n                    parentClass = pConstructor.$class || \"\";\n                }\n            }\n            else {\n                pConstructor = BaseClass;\n                parentClass = \"\";\n            }\n\n            if (parentClass && !pConstructor) {\n                throw parentClass + \" not found\";\n            }\n\n            definition.$class   = name;\n            definition.$extends = parentClass;\n            delete definition.$mixins;\n            delete definition.$mixinEvents;\n\n            allMixEvents        = collectMixinEvents(mixEvents, pConstructor);\n            prototype           = Object.create(pConstructor[proto]);\n            definition[constr]  = definition[constr] || $constr;\n\n            preparePrototype(prototype, definition, pConstructor, false, allMixEvents);\n\n            if (mixins) {\n                for (i = 0, l = mixins.length; i < l; i++) {\n                    mixin = mixins[i];\n                    if (isString(mixin)) {\n                        if (!ns) {\n                            throw new Error(\"Mixin \" + mixin + \" not found\");\n                        }\n                        mixin = ns.get(mixin, true);\n                    }\n                    mixinToPrototype(prototype, mixin, allMixEvents);\n                }\n            }\n\n            c = createConstructor(name);\n            prototype.constructor = c;\n            prototype.$self = c;\n            prototype.$mixinEvents = mixEvents;\n            c[proto] = prototype;\n\n            for (k in BaseClass) {\n                if (k !== proto && BaseClass.hasOwnProperty(k)) {\n                    c[k] = BaseClass[k];\n                }\n            }\n\n            for (k in pConstructor) {\n                if (k !== proto && pConstructor.hasOwnProperty(k)) {\n                    c[k] = pConstructor[k];\n                }\n            }\n\n            if (statics) {\n                for (k in statics) {\n                    if (k !== proto && statics.hasOwnProperty(k)) {\n                        c[k] = statics[k];\n                    }\n                }\n            }\n\n            c.$parent   = pConstructor;\n            c.$self     = c;\n\n            if (ns) {\n                if (name) {\n                    ns.register(name, c);\n                }\n                if (alias) {\n                    ns.register(alias, c);\n                }\n            }\n\n            return c;\n        };\n\n\n\n\n        /**\n         * Instantiate class. Pass constructor parameters after \"name\"\n         * @property {function} factory {\n         * @code cls.factory(\"My.Class.Name\", arg1, arg2, ...);\n         * @param {string} name Full name of the class\n         * @returns {object} class instance\n         * }\n         */\n        var factory = function(name) {\n\n            var cls     = ns ? ns.get(name) : null,\n                args    = toArray(arguments).slice(1);\n\n            if (!cls) {\n                throw name + \" not found\";\n            }\n\n            return cls.$instantiate.apply(cls, args);\n        };\n\n\n\n        /**\n         * Is given object instance of class\n         * @property {function} isInstanceOf {\n         * @code cls.instanceOf(myObj, \"My.Class\");\n         * @code cls.instanceOf(myObj, My.Class);\n         * @param {object} cmp\n         * @param {string|object} name\n         * @returns {boolean}\n         * }\n         */\n        var isInstanceOf = function(cmp, name) {\n            var _cls    = isString(name) && ns ? ns.get(name) : name;\n            return _cls ? cmp instanceof _cls : false;\n        };\n\n\n\n        /**\n         * Is one class subclass of another class\n         * @property {function} isSubclassOf {\n         * @code cls.isSubclassOf(\"My.Subclass\", \"My.Class\");\n         * @code cls.isSubclassOf(myObj, \"My.Class\");\n         * @code cls.isSubclassOf(\"My.Subclass\", My.Class);\n         * @code cls.isSubclassOf(myObj, My.Class);\n         * @param {string|object} childClass\n         * @param {string|object} parentClass\n         * @return {boolean}\n         * }\n         */\n        var isSubclassOf = function(childClass, parentClass) {\n\n            var p   = childClass,\n                g   = ns ? ns.get : function(){};\n\n            if (!isString(parentClass)) {\n                parentClass  = parentClass.prototype.$class;\n            }\n\n            if (isString(childClass)) {\n                p   = g(childClass);\n            }\n\n            while (p && p.prototype) {\n\n                if (p.prototype.$class === parentClass) {\n                    return true;\n                }\n\n                p = p.$parent;\n            }\n\n            return false;\n        };\n\n\n        /**\n         * Reference to the managerFactory\n         * @property {function} classManagerFactory\n         */\n        defineClass.classManagerFactory = classManagerFactory;\n        defineClass.factory = factory;\n        defineClass.isSubclassOf = isSubclassOf;\n        defineClass.isInstanceOf = isInstanceOf;\n        defineClass.define = defineClass;\n\n        /**\n         * @property {function} Namespace Namespace constructor\n         */\n        defineClass.Namespace = MetaphorJs.lib.Namespace;\n\n        /**\n         * @property {class} BaseClass\n         */\n        defineClass.BaseClass = BaseClass;\n\n        /**\n         * @property {object} ns Namespace instance\n         */\n        defineClass.ns = ns;\n\n        /**\n         * @property {function} $destroy Destroy class system and namespace\n         */\n        defineClass.$destroy = function() {\n            BaseClass.$destroy();\n            BaseClass = null;\n            if (ns) {\n                ns.$destroy();\n                ns = null;\n            }\n        };\n\n        return defineClass;\n    };\n\n    return classManagerFactory;\n}();\n","const classManagerFactory = require(\"./classManagerFactory.js\"),\n    ns = require(\"metaphorjs-namespace/src/var/ns.js\");\n\nmodule.exports = classManagerFactory(ns);\n","const MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nMetaphorJs.dialog = MetaphorJs.dialog || {pointer: {}, position: {}};","\nrequire(\"../__init.js\");\nrequire(\"../mixin/Dialog.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dialog.Container = MetaphorJs.app.Container.$extend({\n    $mixins: [MetaphorJs.mixin.Dialog]\n});\n","\nconst cls             = require(\"metaphorjs-class/src/cls.js\"),\n    extend          = require(\"metaphorjs-shared/src/func/extend.js\"),\n    nextUid         = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    bind            = require(\"metaphorjs-shared/src/func/bind.js\"),\n    isArray         = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    isString        = require(\"metaphorjs-shared/src/func/isString.js\"),\n    isFunction      = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    isNumber        = require(\"metaphorjs-shared/src/func/isNumber.js\"),\n    isBool          = require(\"metaphorjs-shared/src/func/isBool.js\"),\n    ucfirst         = require(\"metaphorjs-shared/src/func/ucfirst.js\"),\n    raf             = require(\"metaphorjs-animate/src/func/raf.js\"),\n    async           = require(\"metaphorjs-shared/src/func/async.js\"),\n    error           = require(\"metaphorjs-shared/src/func/error.js\"),\n    MetaphorJs      = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nrequire(\"../__init.js\");\nrequire(\"metaphorjs/src/lib/Expression.js\");\nrequire(\"metaphorjs/src/func/dom/addClass.js\");\nrequire(\"metaphorjs/src/func/dom/hasClass.js\");\nrequire(\"metaphorjs/src/func/dom/removeClass.js\");\nrequire(\"metaphorjs/src/func/dom/setStyle.js\");\nrequire(\"metaphorjs/src/func/dom/getAttr.js\");\nrequire(\"metaphorjs/src/func/dom/setAttr.js\");\nrequire(\"metaphorjs/src/func/dom/removeAttr.js\");\nrequire(\"metaphorjs/src/func/dom/addListener.js\");\nrequire(\"metaphorjs/src/func/dom/removeListener.js\");\nrequire(\"metaphorjs/src/func/dom/normalizeEvent.js\");\nrequire(\"metaphorjs/src/func/dom/isVisible.js\");\nrequire(\"metaphorjs/src/func/dom/isAttached.js\");\nrequire(\"metaphorjs/src/func/dom/whenAttached.js\");\nrequire(\"metaphorjs/src/func/dom/select.js\");\nrequire(\"metaphorjs/src/func/dom/is.js\");\nrequire(\"metaphorjs/src/func/dom/getOuterWidth.js\");\nrequire(\"metaphorjs/src/func/dom/getOuterHeight.js\");\nrequire(\"metaphorjs/src/func/dom/delegate.js\");\nrequire(\"metaphorjs/src/func/dom/undelegate.js\");\nrequire(\"metaphorjs/src/func/dom/data.js\");\n\nrequire(\"metaphorjs-animate/src/animate/animate.js\");\nrequire(\"metaphorjs-animate/src/animate/stop.js\");\n\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");\n\nrequire(\"./position/Abstract.js\");\nrequire(\"./position/Target.js\");\nrequire(\"./position/Mouse.js\");\nrequire(\"./position/Window.js\");\nrequire(\"./position/Custom.js\");\nrequire(\"./position/None.js\");\nrequire(\"./position/Draggable.js\");\nrequire(\"./pointer/Abstract.js\");\nrequire(\"./pointer/Html.js\");\nrequire(\"./Overlay.js\");\nrequire(\"./Manager.js\");\n\n\nmodule.exports = MetaphorJs.dialog.Dialog = (function(){\n\n    var manager = new MetaphorJs.dialog.Manager;\n\n    var defaultEventProcessor = function(dlg, e, type, returnMode){\n        if (type === \"show\" || !returnMode) {\n            e.preventDefault();\n            e.stopPropagation();\n            return false;\n        }\n    };\n\n    var getEventConfig = function(e, action, dlgEl) {\n\n        var type    = e.type,\n            trg     = e.target,\n            cfg     = null,\n            data;\n\n        while (trg && trg !== dlgEl) {\n\n            data    = MetaphorJs.dom.getAttr(trg, \"data-\" + action + \"-\" + type);\n\n            if (data) {\n                cfg = MetaphorJs.lib.Expression.parse(data)({});\n                break;\n            }\n\n            trg     = trg.parentNode;\n        }\n\n        return cfg;\n    };\n\n    /*\n     * Shorthands\n     */\n\n    var fixShorthand = function(options, level1, level2, type) {\n        var value   = options[level1],\n            yes     = false;\n\n        if (value === undefined) {\n            return;\n        }\n\n        switch (type) {\n            case \"string\": {\n                yes     = isString(value);\n                break;\n            }\n            case \"function\": {\n                yes     = isFunction(value);\n                break;\n            }\n            case \"number\": {\n                yes     = isNumber(value) || value == parseInt(value);\n                break;\n            }\n            case \"dom\": {\n                yes     = value && (value.tagName || value.nodeName) ? true : false;\n                break;\n            }\n            case \"jquery\": {\n                yes     = value && value.jquery ? true : false;\n                if (yes) {\n                    value = value.get(0);\n                }\n                break;\n            }\n            case \"boolean\": {\n                if (value === true || value === false) {\n                    yes = true;\n                }\n                break;\n            }\n            default: {\n                if (type === true && value === true) {\n                    yes = true;\n                }\n                if (type === false && value === false) {\n                    yes = true;\n                }\n            }\n        }\n        if (yes) {\n            options[level1] = {};\n            options[level1][level2] = value;\n        }\n    };\n\n    var fixShorthands   = function(options) {\n\n        if (!options) {\n            return {};\n        }\n\n        fixShorthand(options, \"content\", \"value\", \"string\");\n        fixShorthand(options, \"content\", \"value\", \"boolean\");\n        fixShorthand(options, \"content\", \"fn\", \"function\");\n        fixShorthand(options, \"remote\", \"url\", \"string\");\n        fixShorthand(options, \"cls\", \"dialog\", \"string\");\n        fixShorthand(options, \"render\", \"tpl\", \"string\");\n        fixShorthand(options, \"render\", \"fn\", \"function\");\n        fixShorthand(options, \"render\", \"el\", \"dom\");\n        fixShorthand(options, \"render\", \"el\", \"jquery\");\n        fixShorthand(options, \"show\", \"events\", false);\n        fixShorthand(options, \"show\", \"events\", \"string\");\n        fixShorthand(options, \"hide\", \"events\", false);\n        fixShorthand(options, \"hide\", \"events\", \"string\");\n        fixShorthand(options, \"toggle\", \"events\", false);\n        fixShorthand(options, \"toggle\", \"events\", \"string\");\n        fixShorthand(options, \"position\", \"type\", \"string\");\n        fixShorthand(options, \"position\", \"type\", false);\n        fixShorthand(options, \"position\", \"get\", \"function\");\n        fixShorthand(options, \"overlay\", \"enabled\", \"boolean\");\n        fixShorthand(options, \"pointer\", \"position\", \"string\");\n        fixShorthand(options, \"pointer\", \"size\", \"number\");\n\n        return options;\n    };\n\n\n    /**\n     * @object MetaphorJs.dialog.Dialog.defaults\n     */\n    var defaults    = {\n\n        /**\n         * Target element(s) which trigger dialog's show and hide.<br>\n         * If {HTMLElement}: will be used as a single target,<br>\n         * if selector: will be used as dynamic target.<br>\n         * Dynamic targets work like this:<br>\n         * you provide delegates: {someElem: {click: someClass}} -- see \"show\" function<br>\n         * when show() is called, target will be determined from the event using\n         * the selector.\n         * @property {string|Element} target\n         */\n        target:         null,\n\n        /**\n         * One or more group names.\n         * @property {string|array} group\n         */\n        group:          null,\n\n        /**\n         * If dialog is modal, overlay will be forcefully enabled.\n         * @property {bool} modal\n         */\n        modal:\t\t\tfalse,\n\n        /**\n         * Use link's href attribute as remote.url or as render.el\n         * @property {bool} useHref\n         */\n        useHref:        false,\n\n\n        /**\n         * If neither content value nor remote url are provided,\n         * plugin will try to read target's attribute values: 'tooltip', 'title' and 'alt'.\n         * (unless attr is specified).<br>\n         * <em>shorthand</em>: string -> content.value<br>\n         * <em>shorthand</em>: false -> content.value<br>\n         * <em>shorthand</em>: function -> content.fn<br>\n         * @object content\n         */\n        content: {\n\n            /**\n             * Dialog's text content. Has priority before readContent/loadContent.\n             * If set to false, no content will be automatically set whether via fn() or attributes.\n             * @property {string|boolean} value\n             */\n            value: \t\t\t'',\n\n            /**\n             * Must return content value\n             * @property {function} fn\n             * @param {HTMLElement} target\n             * @param {MetaphorJs.dialog.Dialog} dialog\n             * @returns {string}\n             */\n            fn:\t\t\t\tnull,\n\n            /**\n             * This function receives new content and returns string value (processed content).\n             * @property {function} prepare\n             * @param {MetaphorJs.dialog.Dialog} dialog\n             * @param {string} mode\n             *      empty string - content has come from content.value or setContent()<br>\n             *      'attribute' - content has been read from target attributes<br>\n             *      'remote' - data returned by fetch request\n             *      @default '' | 'attribute' | 'remote'\n             *\n             * @param {string} content\n             * @returns {string}\n             */\n            prepare:\t\tnull,\n\n            /**\n             * Get content from this attribute (belongs to target)\n             * @property {string} attr\n             */\n            attr:           null\n\n            /**\n             * @end-object\n             */\n        },\n\n\n        /**\n         * All these options are passed to fetch().\n         * You can provide more options in this section\n         * but 'success' will be overriden (use content.prepare for data processing).<br>\n         * <em>shorthand</em>: string -> remote.url\n         * @object remote\n         */\n        remote: {\n\n            /**\n             * Url to load content from.\n             * @property {string} url\n             */\n            url: \t\t\tnull,\n\n            /**\n             * Use Metaphor.remote.fetch library\n             * @property {boolean} useMetaphor\n             */\n            useMetaphor:    false\n\n            /*\n             * Pass this data along with xhr.\n             * @property {object} data\n             *\n            data: \t\t\tnull,\n\n            /*\n             * @property {string} dataType\n             *\n            dataType: \t\t'text',\n\n            /*\n             * @property {string} method\n             *\n            method: \t\t'GET'*/\n\n            /**\n             * @end-object\n             */\n        },\n\n        /**\n         * Classes to apply to the dialog.\n         * <em>shorthand</em>: string -> cls.dialog\n         * @object cls\n         */\n        cls: {\n            /**\n             * Base class.\n             * @property {string} dialog\n             */\n            dialog:         null,\n            /**\n             * Only applied when dialog is visible.\n             * @property {string} visible\n             */\n            visible:        null,\n            /**\n             * Only applied when dialog is hidden.\n             * @property {string} hidden\n             */\n            hidden:         null,\n            /**\n             * Only applied when dialog is fetching remote data.\n             * @property {string} loading\n             */\n            loading:        null\n\n            /**\n             * @end-object\n             */\n        },\n\n        /**\n         * <p>Selector is used when dialog has inner structure and you\n         * want to change its content.</p>\n         * <pre><code class=\"language-javascript\">\n         * {\n         *      render: {\n         *          tpl: '&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt;'\n         *      },\n         *      selector: {\n         *          content: '.content'\n         *      }\n         * }\n         * </code></pre>\n         * <p>If no selector provided, setContent will replace all inner html.\n         * Another thing relates to structurally complex content:</p>\n         *\n         * <pre><code class=\"language-javascript\">\n         * setContent({title: \"...\", body: \"...\"});\n         * selector: {\n         *      title:  \".title\",\n         *      body:   \".body\"\n         * }\n         * </code></pre>\n         * @object selector\n         */\n        selector:           {\n            /**\n             * Dialog's content selector.\n             * @property {string} content\n             */\n            content:        null\n\n            /**\n             * @end-object\n             */\n        },\n\n        /**\n         * Object {buttonId: selector}\n         * @property {object|null} buttons\n         */\n        buttons: null,\n\n\n        /**\n         * <p><em>shorthand</em>: string -> render.tpl<br>\n         * <em>shorthand</em>: function -> render.fn<br>\n         * <em>shorthand</em>: dom element -> render.el<br>\n         * @object render\n         */\n        render: {\n            /**\n             * Dialog's template \n             * @property {string} tpl\n             */\n            tpl: \t\t\t'<div></div>',\n\n            /**\n             * Call this function to get dialog's template.\n             * @property {function} fn\n             * @param {MetaphorJs.dialog.Dialog} dialog\n             * @returns {string|Element}\n             */\n            fn: \t\t\tnull,\n\n            /**\n             * Selector or existing element instead of template.\n             * @property {string|Element} el\n             */\n            el: \t\t\tnull,\n\n            /**\n             * Apply this zIndex.\n             * @property {number} zIndex\n             */\n            zIndex:\t\t\tnull,\n\n            /**\n             * false - render immediately, true - wait for the first event.\n             * @property {bool} lazy\n             */\n            lazy: \t\t\ttrue,\n\n            /**\n             * Object to pass to elem.css()\n             * @property {object} style\n             */\n            style:          null,\n\n            /**\n             * If set, the element will be appended to specified container.<br>\n             * If set to false, element will not be appended anywhere (works with \"el\").\n             * @property {string|Element|bool} appendTo\n             */\n            appendTo:\t\tnull,\n\n            /**\n             * Dialog's id attribute.\n             * @property {string} id\n             */\n            id:\t\t\t\tnull,\n\n            /**\n             * If set to true, element's show() and hide() will never be called. Use\n             * \"visible\" and \"hidden\" classes instead.\n             * @property {boolean} keepVisible\n             */\n            keepVisible:    false,\n\n            /**\n             * When destroying dialog's elem, keep it in DOM.\n             * Useful when you return it in fn() on every show()\n             * and have lifetime = 0.\n             * @property {boolean} keepInDOM\n             */\n            keepInDOM:      false,\n\n            /**\n             * Number of ms for the rendered object to live\n             * after its been hidden. 0 to destroy elem immediately.\n             * @property {number} lifetime\n             */\n            lifetime:       null\n\n            /**\n             * @end-object\n             */\n        },\n\n        /**\n         * Event actions.\n         * @object events\n         */\n        events: {\n\n            /**\n             * @object show\n             */\n            show: {\n\n                /**\n                 * You can also add any event you use to show/hide dialog \n                 * (mouseup, mousedown, etc)\n                 * @object * \n                 */\n                \"*\": {\n\n                    /**\n                     * @property {boolean} preventDefault\n                     */\n                    preventDefault: false,\n\n                    /**\n                     * @property {boolean} stopPropagation\n                     */\n                    stopPropagation: false,\n\n                    /**\n                     * @property {boolean} returnValue\n                     */\n                    returnValue: null,\n\n                    /**\n                     * @property {function} process\n                     * @param {Dialog} dialog\n                     * @param {Event} event\n                     * @param {string} type show|hide\n                     * @param {string} returnMode\n                     */\n                    process: defaultEventProcessor\n\n                    /**\n                     * @end-object\n                     */\n                }\n\n                /**\n                 * @end-object\n                 */\n            },\n\n            /**\n             * @object hide\n             */\n            hide: {\n\n                /**\n                 * You can also add any event you use to show/hide dialog.\n                 * @object *\n                 */\n                \"*\": {\n\n                    /**\n                     * @property {boolean} preventDefault\n                     */\n                    preventDefault: false,\n\n                    /**\n                     * @property {boolean} stopPropagation\n                     */\n                    stopPropagation: false,\n\n                    /**\n                     * @property {boolean} returnValue\n                     */\n                    returnValue: null,\n\n                    /**\n                     * Must return \"returnValue\" which will be in its turn\n                     * returned from event handler. If you provide this function\n                     * preventDefault and stopPropagation options are ignored.\n                     * @property {function}\n                     * @param {Dialog} dialog\n                     * @param {Event} event\n                     * @param {string} type show|hide\n                     * @param {string} returnMode\n                     */\n                    process: defaultEventProcessor\n\n                    /**\n                     * @end-object\n                     */\n                }\n\n                /**\n                 * @end-object\n                 */\n            }\n\n            /**\n             * @end-object\n             */\n        },\n\n        /**\n         * <p><em>shorthand</em>: false -> show.events<br>\n         * <em>shorthand</em>: string -> show.events._target</p>\n         * @object show\n         */\n        show: {\n            /**\n             * Delay dialog's appearance. Milliseconds.\n             * @property {number} delay\n             */\n            delay: \t\t\tnull,\n\n            /**\n             * True to hide all other tooltips.\n             * If \"group\" specified, will hide only\n             * those dialogs that belong to that group.\n             * @property {bool} single\n             */\n            single:\t\t\tfalse,\n\n            /**\n             * Works for show, hide and toggle\n             * <pre><code class=\"language-javascript\">\n             * events: false // disable all\n             *\n             * events: eventName || [eventName, eventName, ...]\n             * // same as events: {\"_target\": ...}\n             *\n             * events: {\n             *  \"body\":         eventName || [eventName, eventName, ...],\n             *  \"_self\":        same, // dialog itself\n             *  \"_target\":      same, // target element\n             *  \"_document\":    same,\n             *  \"_window\":      same,\n             *  \"_html\":        same,\n             *  \"_overlay\":     same, // overlay element (works with hiding)\n             *  \">.selector\":   same // selector inside dialog\n             * }\n             *\n             * events: {\n             *  \"(body|_self|_target|...)\": {\n             *      eventName: \".selector\"\n             *  }\n             *  // $(\"body|_self|_target|...\").delegate(\".selector\", eventName)\n             *  // this one is for dynamic targets\n             * }\n             * </code></pre>\n             * @property {string|bool|object} events\n             */\n            events:\t\t\tnull,\n\n            /**\n             * <p>true -- [\"mjs-show\"] or [\"mjs-hide\"]<br>\n             * string -- class name -> [class]<br>\n             * array -- [{properties before}, {properties after}]<br>\n             * array -- [class, class]<br>\n             * object --\n             * .fn -- string: \"fadeIn\", \"fadeOut\", etc. (optional) requires jQuery<br>\n             * .fn -- function(Element, completeCallback)\n             * .stages -- [class, class] (optional)\n             * .before -- {} apply css properties before animation (optional)\n             * .after -- {} animate these properties (optional) requires jQuery\n             * .options - {} jQuery's .animate() options\n             * .context -- fn's this object\n             * .duration -- used when .fn is string\n             * .skipDisplayChange -- do not set style.display = \"\" on start\n             * function(){}<br>\n             * function must return any of the above:</p>\n             * <pre><code class=\"language-javascript\">\n             * animate: function(dlg, e) {\n             *      return {\n             *          before: {\n             *             width: '200px'\n             *          },\n             *          after: {\n             *              width: '400px'\n             *          },\n             *          options: {\n             *             step: function() {\n             *               dlg.reposition();\n             *             }\n             *          }\n             *      };\n             * }\n             * </code></pre>\n             * @property {bool|string|array|function} animate\n             */\n            animate:\t\tfalse,\n\n            /**\n             * Ignore {show: {single: true}} on other dialogs.\n             * @property {bool} ignoreHideAll\n             */\n            ignoreHideAll:\tfalse,\n\n            /**\n             * true - automatically set focus on input fields on buttons;\n             * string - selector\n             * @property {bool|string} focus\n             */\n            focus:          false,\n\n            /**\n             * Prevent scrolling on given element\n             * true = \"body\"\n             * @property {bool|string|Element} preventScroll\n             */\n            preventScroll:  false,\n\n            /**\n             * When showing, set css display to this value\n             * @property {string} display\n             */\n            display: \"block\"\n\n            /**\n             * @end-object\n             */\n        },\n\n\n        /**\n         * <p><em>shorthand</em>: false -> hide.events<br>\n         * <em>shorthand</em>: string -> hide.events._target</p>\n         * @object hide\n         */\n        hide: {\n            /**\n             * Milliseconds. Delay hiding for this amount of time.\n             * @property {number} delay\n             */\n            delay:\t\t\tnull,\n\n            /**\n             * Milliseconds. Dialog will be shown no longer than for that time.\n             * @property {number} timeout\n             */\n            timeout: \t\tnull,\n\n            /**\n             * See show.events\n             * @property {string|bool|object} events\n             */\n            events: \t\tnull,\n\n            /**\n             * Destroy dialog after hide.\n             * @property {bool} destroy\n             */\n            destroy:        false,\n\n            /**\n             * Remove element from DOM after hide\n             * @property {bool} remove\n             */\n            remove:         false,\n\n            /**\n             * See show.animate\n             * @property {bool|string|array|function} animate\n             */\n            animate:\t\tfalse,\n\n            /**\n             * true: hide anyway even if showing is delayed,<br>\n             * false: ignore hide events until tooltip is shown.\n             * @property {bool} cancelShowDelay\n             */\n            cancelShowDelay:true\n\n            /**\n             * @end-object\n             */\n        },\n\n        /**\n         * This option is required when you want to show and hide on the same event.<br>\n         * <em>shorthand</em>: false -> toggle.events<br>\n         * <em>shorthand</em>: string -> toggle.events._target\n         * @object toggle\n         */\n        toggle: {\n            /**\n             * See show.events\n             * @property {string|bool|object} events\n             */\n            events: \t\tnull\n\n            /**\n             * @end-object\n             */\n        },\n\n        /**\n         * <p><em>shorthand</em>: false -> position.type<br>\n         * <em>shorthand</em>: string -> position.type<br>\n         * <em>shorthand</em>: function -> position.get\n         * @object position\n         */\n        position: {\n\n            /**\n             * false -- do not apply position<br>\n             * function(api) - must return one of the following:<br>\n             * \"auto\" - detect position automatically<br>\n             *\n             * <b>relative to target:</b><br>\n             * t | r | b | l -- simple positions aligned by center<br>\n             * tr | rt | rb | br | bl | lb | lt | tl -- aligned by side<br>\n             * trc | brc | blc | tlc -- corner positions<br>\n             *\n             * <b>relative to mouse:</b><br>\n             * m -- works only with get(). get() function will be called on mousemove<br>\n             * mt | mr | mb | ml -- following the mouse, aligned by center<br>\n             * mrt | mrb | mlb | mlt -- following the mouse, corner positions<br>\n             *\n             * <b>window positions:</b><br>\n             * wc | wt | wr | wb | wl<br>\n             * wrt | wrb | wlt | wlb\n             *\n             * Defaults to 't'\n             * @property {bool|string} type\n             */\n            type:\t\t\t't',\n\n            /**\n             * @property {string} preferredType\n             */\n            preferredType:  null,\n\n            /**\n             * Add this offset to dialog's x position\n             * @property {number} offsetX\n             */\n            offsetX: \t\t0,\n\n            /**\n             * Add this offset to dialog's y position\n             * @property {number} offsetY\n             */\n            offsetY:\t\t0,\n\n            /**\n             * Follow the mouse only by this axis;\n             * second coordinate will be relative to target\n             * @property {string} axis\n             */\n            axis: \t\t\tnull,\n\n            /**\n             * Overrides position.type<br>\n             * If this function is provided, offsets are not applied.\n             * @property {function} get\n             * @param {MetaphorJs.dialog.Dialog} dialog\n             * @param {Event} event\n             * @returns {object} {\n             *      @type {number} x If object contains only one coordinate - x or y -\n             *                       the other one will not be updated.\n             *      @type {number} y\n             *      @type {number} top If object does not contain x and y, it will be applied\n             *                          as is.\n             *      @type {number} right\n             *      @type {number} bottom\n             *      @type {number} left\n             * }\n             */\n            get:\t\t\tnull,\n\n            /**\n             * Prevent from rendering off the screen.<br>\n             * Set to maximum distance between tooltip and window edge.\n             * @property {number|bool} screenX\n             */\n            screenX:\t\tfalse,\n\n            /**\n             * Prevent from rendering off the screen.<br>\n             * Set to maximum distance between tooltip and window edge.\n             * @property {number|bool} screenY\n             */\n            screenY:\t\tfalse,\n\n            /**\n             * Calculate position relative to this element (defaults to window)\n             * @property {string|Element} base\n             */\n            base:           null,\n\n            /**\n             * Monitor window/selector/element scroll and reposition on scroll.\n             * @property {bool|string|Element} scroll\n             */\n            scroll:         false,\n\n            /**\n             * Monitor window resize and reposition on resize\n             * @property {bool} resize\n             */\n            resize:         true\n\n            /**\n             * @end-object\n             */\n        },\n\n        /**\n         * Pointer will only work if size > 0 or el is not null<br>\n         * <em>shorthand</em>: string -> pointer.position<br>\n         * <em>shorthand</em>: number -> pointer.size\n         * @object pointer\n         */\n        pointer: {\n\n            /**\n             * t / r / b / l<br>\n             * tr / lt / lb / br / bl / lb / lt<br>\n             * null - opposite to dialog's position\n             * @property {string} position\n             */\n            position: \t\tnull,\n\n            /**\n             * t / r / b / l<br>\n             * null - opposite to primary position\n             * @property {string} direction\n             */\n            direction: \t\tnull,\n\n            /**\n             * Number of pixels (triangle's height)\n             * @property {number} size\n             */\n            size: \t\t\t0,\n\n            /**\n             * Number of pixels (triangle's width), by default equals to size.\n             * @property {number} width\n             */\n            width:\t\t\tnull,\n\n            /**\n             * '#xxxxxx'\n             * @property {string} color\n             */\n            color: \t\t\tnull,\n\n            /**\n             * Shift pointer's position by this number of pixels.\n             * Shift direction will depend on position:<br>\n             * t / tl / b / bl - right shift<br>\n             * tr / br - left shift<br>\n             * r / l / rt / lt - top shift<br>\n             * rb / lb - bottom shift\n             * @property {number} offset\n             */\n            offset: \t\t0,\n\n            /**\n             * Number of pixels.\n             * @property {number} border\n             */\n            border:\t\t\t0,\n\n            /**\n             * '#xxxxxx'\n             * @property {string} borderColor\n             */\n            borderColor:\tnull,\n\n            /**\n             * Custom pointer.<br>\n             * If you provide custom pointer el,\n             * border, direction and color will not be applied.<br>\n             * pointer.cls will be applied.\n             * @property {string|Element} el\n             */\n            el:             null,\n\n            /**\n             * Apply this class to pointer.\n             * @property {string} cls\n             */\n            cls:            null,\n\n            /**\n             * Apply this class to pointerBorder element.\n             * @property {string} borderCls\n             */\n            borderCls:      null\n\n            /**\n             * @end-object\n             */\n        },\n\n        /**\n         * <p><em>shorthand</em>: boolean -> overlay.enabled<br></p>\n         * @object overlay\n         */\n        overlay:\t\t\t{\n\n            /**\n             * Enable overlay.\n             * @property {bool} enabled\n             */\n            enabled:\t\tfalse,\n\n            /**\n             * @property {string} color\n             */\n            color:\t\t\t'#000',\n\n            /**\n             * @property {number} opacity\n             */\n            opacity:\t\t.5,\n\n            /**\n             * @property {string} cls\n             */\n            cls:\t\t\tnull,\n\n            /**\n             * Same animation rules as in show.animate.\n             * @property {bool} animateShow\n             */\n            animateShow:\tfalse,\n\n            /**\n             * Same animation rules as in show.animate.\n             * @property {bool} animateHide\n             */\n            animateHide:\tfalse\n\n            /**\n             * @end-object\n             */\n        },\n\n        /**\n         * Callbacks are case insensitive.<br>\n         * You can use camel case if you like.\n         * @object callback\n         */\n        callback: {\n\n            /**\n             * 'this' object for all callbacks, including render.fn, position.get, etc.\n             * @property {object} context\n             */\n            context:\t\t\tnull,\n\n            /**\n             * When content has changed.\n             * @property {function} contentChange\n             * @param {MetaphorJs.dialog.Dialog} dialog\n             * @param {string} content\n             */\n            \"content-change\": \tnull,\n\n            /**\n             * Before dialog appeared.<br>\n             * Return false to cancel showing.\n             * @property {function} beforeShow\n             * @param {MetaphorJs.dialog.Dialog} dialog\n             * @param {Event} event\n             */\n            \"before-show\": \t\tnull,\n\n            /**\n             * Immediately after dialog appeared.\n             * @property {function} show\n             * @param {MetaphorJs.dialog.Dialog} dialog\n             * @param {Event} event\n             */\n            show: \t\t\t\tnull,\n\n            /**\n             * Before dialog disappears.<br>\n             * Return false to cancel hiding.\n             * @property {function} beforeHide\n             * @param {MetaphorJs.dialog.Dialog} dialog\n             * @param {Event} event\n             */\n            \"before-hide\": \t\tnull,\n\n            /**\n             * Immediately after dialog has been hidden.\n             * @property {function} hide\n             * @param {MetaphorJs.dialog.Dialog} dialog\n             * @param {Event} event\n             */\n            hide: \t\t\t\tnull,\n\n            /**\n             * After dialog has been rendered.\n             * @property {function} render\n             * @param {MetaphorJs.dialog.Dialog} dialog\n             */\n            render: \t\t\tnull,\n\n            /**\n             * After dialog's html element has been removed.\n             * @property {function} lifetime\n             * @param {MetaphorJs.dialog.Dialog} dialog\n             */\n            lifetime:           null,\n\n            /**\n             * Called when dynamic target changes (on hide it always changes to null).\n             * Also called from setTarget().\n             * @property {function} targetChange\n             * @param {MetaphorJs.dialog.Dialog} dialog\n             * @param {HTMLElement} newTarget\n             * @param {Element|null} prevTarget\n             */\n            \"target-change\":       null,\n\n            /**\n             * One handler for all configured buttons. Called on click, enter and space.\n             * @property {function} button\n             * @param {MetaphorJs.dialog.Dialog} dialog\n             * @param {string} buttonId\n             * @param {Event} event\n             */\n            button:             null\n\n            /**\n             * @end-object\n             */\n        }\n\n        /**\n         * @end-object\n         */\n    };\n\n\n\n\n    /**\n     * @class MetaphorJs.dialog.Dialog\n     * @mixes MetaphorJs.mixin.Observable\n     */\n    var Dialog = cls({\n\n        $mixins:            [MetaphorJs.mixin.Observable],\n\n        id:                 null,\n        node:               null,\n        overlay:            null,\n        pointer:            null,\n        cfg:                null,\n        position:           null,\n\n        target:             null,\n        dynamicTarget:      false,\n        dynamicTargetEl:    null,\n\n        visible:            false,\n        enabled:            true,\n        frozen:             false,\n        rendered:           false,\n\n        bindSelfOnRender:   false,\n\n        hideTimeout:        null,\n        hideDelay:          null,\n        showDelay:          null,\n        destroyDelay:       null,\n\n        images:             0,\n\n        positionGetType:    null,\n        positionClass:      null,\n        positionAttempt:    0,\n\n        $constructor: function() {\n\n            this.$$events = {\n                \"before-show\": {\n                    returnResult: false\n                },\n                \"before-hide\": {\n                    returnResult: false\n                }\n            };\n\n            this.$super.apply(this, arguments);\n\n        },\n\n        /**\n         * @method\n         * @constructor\n         * @param {object} cfg See MetaphorJs.dialog.Dialog.defaults\n         */\n        $init: function(cfg) {\n\n            cfg = cfg || {};\n            var preset  = cfg.preset,\n                self    = this;\n\n            cfg.preset  = null;\n            cfg         = extend({}, defaults,\n                                fixShorthands(Dialog.defaults),\n                                fixShorthands(Dialog[preset]),\n                                fixShorthands(cfg),\n                                    true, true);\n\n            self.cfg    = cfg;\n            self.id     = nextUid();\n\n            self.onPreventScrollDelegate = bind(self.onPreventScroll, self);\n            self.onButtonClickDelegate = bind(self.onButtonClick, self);\n            self.onButtonKeyupDelegate = bind(self.onButtonKeyup, self);\n            self.showDelegate = bind(self.show, self);\n            self.hideDelegate = bind(self.hide, self);\n            self.toggleDelegate = bind(self.toggle, self);\n            self.onImageLoadDelegate = bind(self.onImageLoad, self);\n\n            manager.register(self);\n\n            if (cfg.modal) {\n                cfg.overlay.enabled = true;\n            }\n            self.overlay    = new MetaphorJs.dialog.Overlay(self);\n\n            var pointerCls = ucfirst(cfg.pointer.$class || \"Html\");\n            self.pointer    = cls.factory(\n                                \"MetaphorJs.dialog.pointer.\" + pointerCls, \n                                self, cfg.pointer);\n\n            if (isFunction(cfg.position.type)) {\n                self.positionGetType = cfg.position.type;\n            }\n\n            self.setTarget(cfg.target);\n\n            if (cfg.target && cfg.useHref) {\n                var href = MetaphorJs.dom.getAttr(self.getTarget(), \"href\");\n                if (href.substr(0, 1) === \"#\") {\n                    cfg.render.el = href;\n                }\n                else {\n                    cfg.remote.url = href;\n                }\n            }\n\n            if (!cfg.render.lazy) {\n                self.render();\n            }\n\n            self.trigger(\"init\", self);\n            self.setHandlers(\"bind\");\n        },\n\n\n        /* **** General api **** */\n\n\n        /**\n         * @method\n         * @returns {HTMLElement}\n         */\n        getElem: function() {\n            return this.node;\n        },\n\n        /**\n         * @method\n         * @returns {string}\n         */\n        getInstanceId: function() {\n            return this.id;\n        },\n\n        /**\n         * Get dialog's config.\n         * @method\n         * \n         * @return {object}\n         */\n        getCfg: function() {\n            return this.cfg;\n        },\n\n        /**\n         * Get dialog's pointer object\n         * @method\n         * @returns {MetaphorJs.dialog.pointer.*}\n         */\n        getPointer: function() {\n            return this.pointer;\n        },\n\n\n        /**\n         * Get dialog's overlay object\n         * @method\n         * @returns {MetaphorJs.dialog.Overlay}\n         */\n        getOverlay: function() {\n            return this.overlay;\n        },\n\n\n        /**\n         * @method\n         * \n         * @return {boolean}\n         */\n        isEnabled: function() {\n            return this.enabled;\n        },\n\n        /**\n         * @method\n         * \n         * @return {boolean}\n         */\n        isVisible: function() {\n            return this.visible;\n        },\n\n        /**\n         * @method\n         * \n         * @returns {boolean}\n         */\n        isHideAllIgnored: function() {\n            return this.cfg.show.ignoreHideAll;\n        },\n\n        /**\n         * @method\n         * \n         * @return {boolean}\n         */\n        isFrozen: function() {\n            return this.frozen;\n        },\n\n        /**\n         * @method\n         * @returns {boolean}\n         */\n        isRendered: function() {\n            return this.rendered;\n        },\n\n        /**\n         * Enable dialog (enabled by default)\n         * @method\n         * \n         */\n        enable: function() {\n            this.enabled = true;\n        },\n\n        /**\n         * Disable dialog\n         * \n         * @method\n         */\n        disable: function() {\n            this.hide();\n            this.enabled = false;\n        },\n\n        /**\n         * The difference between freeze and disable is that\n         * disable always hides dialog and freeze makes current\n         * state permanent (if it was shown, it will stay shown\n         * until unfreeze() is called).\n         * \n         * @method\n         */\n        freeze: function() {\n            this.frozen   = true;\n        },\n\n        /**\n         * Unfreeze dialog\n         * @method\n         * \n         */\n        unfreeze: function() {\n            this.frozen   = false;\n        },\n\n        /**\n         * Get groups.\n         * @method\n         * \n         * @return {[]}\n         */\n        getGroup: function() {\n            var cfg = this.cfg;\n            if (!cfg.group) {\n                return [\"\"];\n            }\n            else {\n                return isString(cfg.group) ?\n                       [cfg.group] : cfg.group;\n            }\n        },\n\n        /**\n         * Show/hide\n         * @method\n         * \n         * @param {Event} e Optional\n         * @param {bool} immediately Optional\n         */\n        toggle: function(e, immediately) {\n\n            var self = this;\n\n            // if switching between dynamic targets\n            // we need not to hide tooltip\n            if (e && e.stopPropagation && self.dynamicTarget) {\n\n                if (self.visible && self.isDynamicTargetChanged(e)) {\n                    return self.show(e);\n                }\n            }\n\n            return self[self.visible ? 'hide' : 'show'](e, immediately);\n        },\n\n\n        /* **** Events **** */\n\n        resetHandlers: function(fn, context) {\n\n            var self = this;\n            self.setHandlers(\"unbind\");\n            self.bindSelfOnRender = false;\n\n            if (fn) {\n                fn.call(context, self, self.getCfg());\n            }\n\n            self.setHandlers(\"bind\");\n        },\n\n        setHandlers: function(mode, only) {\n\n            var self    = this,\n                cfg     = self.cfg,\n                fns     = [\"show\", \"hide\", \"toggle\"],\n                lfn     = mode === \"bind\" ? MetaphorJs.dom.addListener : \n                                            MetaphorJs.dom.removeListener,\n                dfn     = mode === \"bind\" ? MetaphorJs.dom.delegate :\n                                            MetaphorJs.dom.undelegate,\n                fn,\n                fnCfg,\n                selector,\n                e, i, len,\n                evs, el,\n                j, jl;\n\n            while (fn = fns.shift()) {\n\n                fnCfg   = cfg[fn].events;\n\n                if (fnCfg === false) {\n                    continue;\n                }\n\n                if (isString(fnCfg) || isArray(fnCfg)) {\n                    if (self.dynamicTarget) {\n                        var tmp     = {};\n                        tmp[fnCfg]  = cfg.target;\n                        fnCfg       = {\n                            \"_html\": tmp\n                        }\n                    }\n                    else {\n                        fnCfg   = {\"_target\": fnCfg};\n                    }\n                }\n\n                for (selector in fnCfg) {\n\n                    if (only) {\n                        if (only === '_self') {\n                            if (selector !== '_self' &&\n                                selector !== \"_overlay\" &&\n                                selector.substr(0,1) !== '>') {\n                                continue;\n                            }\n                        }\n                        else if (selector !== only) {\n                            continue;\n                        }\n                    }\n\n                    if ((selector === '_self' ||\n                            selector === '_overlay' ||\n                            selector.substr(0,1) === '>')\n                        && !self.node) {\n\n                        self.bindSelfOnRender = true;\n                        continue;\n                    }\n\n                    evs         = fnCfg[selector];\n\n                    if (!evs) {\n                        continue;\n                    }\n\n                    switch (selector) {\n                        case \"_target\":\n                            el  = [self.getTarget()];\n                            break;\n\n                        case \"_self\":\n                            el  = [self.node];\n                            break;\n\n                        case \"_window\":\n                            el  = [window];\n                            break;\n\n                        case \"_document\":\n                            el  = [window.document];\n                            break;\n\n                        case \"_html\":\n                            el  = [window.document.documentElement];\n                            break;\n\n                        case \"_overlay\":\n                            el  = [self.overlay.getElem()];\n                            break;\n\n                        default:\n                            el  = selector.substr(0,1) === '>' ?\n                                    MetaphorJs.dom.select(selector.substr(1), self.node) :\n                                    MetaphorJs.dom.select(selector);\n\n                    }\n\n                    if (!el || !el.length) {\n                        continue;\n                    }\n\n                    if (isString(evs)) {\n                        evs     = [evs];\n                    }\n\n                    if (isArray(evs)) {\n                        for (i = 0, len = evs.length; i < len; i++) {\n                            for (j = -1, jl = el.length; ++j < jl; lfn(el[j], evs[i], self[fn+\"Delegate\"])){}\n                        }\n                    }\n                    else {\n                        for (e in evs) {\n                            for (j = -1, jl = el.length; ++j < jl; dfn(el[j], evs[e], e, self[fn+\"Delegate\"])){}\n                        }\n                    }\n                }\n            }\n        },\n\n\n\n\n        onPreventScroll: function(e) {\n            MetaphorJs.dom.normalizeEvent(e).preventDefault();\n        },\n\n        onButtonClick: function(e) {\n\n            var target  = MetaphorJs.dom.normalizeEvent(e).target,\n                btnId   = MetaphorJs.dom.data(target, \"metaphorjsTooltip-button-id\");\n\n            if (btnId) {\n                this.trigger(\"button\", this, btnId, e);\n            }\n        },\n\n        onButtonKeyup: function(e) {\n            if (e.keyCode === 13 || e.keyCode === 32) {\n                var target  = e.target,\n                    btnId   = MetaphorJs.dom.data(target, \"metaphorjsTooltip-button-id\");\n\n                if (btnId) {\n                    this.trigger(\"button\", this, btnId, MetaphorJs.dom.normalizeEvent(e));\n                }\n            }\n        },\n\n        getEventConfig: function(e, action) {\n\n            var self    = this,\n                ecfg    = getEventConfig(e, action, self.node),\n                cfg     = self.cfg;\n\n            if (!ecfg && cfg.events[action]) {\n                ecfg   = cfg.events[action][e.type] || cfg.events[action]['*'];\n            }\n\n            return ecfg;\n        },\n\n\n        /* **** Show **** */\n\n        /**\n         * Show dialog\n         * @method\n         * \n         * @param {Event} e Optional. True to skip delay.\n         * @param {bool} immediately Optional\n         */\n        show: function(e, immediately) {\n\n            // if called as an event handler, we do not return api\n            var self        = this,\n                cfg         = self.cfg,\n                returnValue\t= null,\n                scfg        = cfg.show,\n                returnMode  = null;\n\n            if (e) {\n                e = MetaphorJs.dom.normalizeEvent(e);\n            }\n\n            // if tooltip is disabled, we do not stop propagation and do not return false.s\n            if (!self.isEnabled()) {\n                returnMode = \"disabled\";\n            }\n\n            // if tooltip is already shown\n            // and hide timeout was set.\n            // we need to restart timer\n            if (!returnMode && self.visible && self.hideTimeout) {\n\n                window.clearTimeout(self.hideTimeout);\n                self.hideTimeout = async(self.hide, self, null, cfg.hide.timeout);\n\n                returnMode = \"hidetimeout\";\n            }\n\n            // if tooltip was delayed to hide\n            // we cancel it.\n            if (!returnMode && self.hideDelay) {\n\n                window.clearTimeout(self.hideDelay);\n                self.hideDelay     = null;\n                self.visible       = true;\n\n                returnMode = \"hidedelay\";\n            }\n\n\n            // various checks: tooltip should be enabled,\n            // should not be already shown, it should\n            // have some content, or empty content is allowed.\n            // also if beforeShow() returns false, we can't proceed\n            // if tooltip was frozen, we do not show or hide\n            if (!returnMode && self.frozen) {\n                returnMode = \"frozen\";\n            }\n\n            // cancel delayed destroy\n            // so that we don't have to re-render dialog\n            if (self.destroyDelay) {\n                window.clearTimeout(self.destroyDelay);\n                self.destroyDelay = null;\n            }\n\n\n            var dtChanged   = false;\n\n            // if we have a dynamicTarget\n            if (e && self.dynamicTarget) {\n                dtChanged = self.changeDynamicTarget(e);\n            }\n\n            if (self.visible) {\n                if (!dtChanged) {\n                    returnMode = returnMode || \"visible\";\n                }\n                else {\n                    self.reposition(e);\n                    returnMode = \"reposition\";\n                }\n            }\n\n            if (!returnMode || dtChanged) {\n                // if tooltip is not rendered yet we render it\n                if (!self.node) {\n                    self.render();\n                }\n                else if (dtChanged) {\n                    self.changeDynamicContent();\n                }\n            }\n\n\n            // if beforeShow callback returns false we stop.\n            if (!returnMode && self.trigger('before-show', self, e) === false) {\n                returnMode = \"beforeshow\";\n            }\n\n            var ecfg;\n\n            if (e && (ecfg = self.getEventConfig(e, \"show\"))) {\n\n                if (ecfg.process) {\n                    returnValue\t= ecfg.process(self, e, \"show\", returnMode);\n                }\n                else {\n                    ecfg.stopPropagation && e.stopPropagation();\n                    ecfg.preventDefault && e.preventDefault();\n                    returnValue = ecfg.returnValue;\n                }\n            }\n\n            if (returnMode) {\n                return returnValue;\n            }\n\n            // first, we stop all current animations\n            MetaphorJs.animate.stop(self.node);\n\n            // as of this moment we mark dialog as visible so that hide() were able\n            // to work. also, all next steps should check for this state\n            // in case if tooltip case hidden back during the process\n            self.visible = true;\n\n            if (scfg.single) {\n                manager.hideAll(self);\n            }\n\n            self.toggleTitleAttribute(false);\n\n            if (scfg.delay && !immediately) {\n                self.showDelay = async(self.showAfterDelay, self, [e], scfg.delay);\n            }\n            else {\n                self.showAfterDelay(e, immediately);\n            }\n\n            return returnValue;\n        },\n\n\n        showAfterDelay: function(e, immediately) {\n\n            var self = this,\n                cfg = self.cfg;\n\n            self.showDelay = null;\n\n            // if tooltip was already hidden, we can't proceed\n            if (!self.visible) {\n                return;\n            }\n\n            self.trigger('show-after-delay', self, e);\n\n            if (cfg.hide.remove) {\n                self.appendElem();\n            }\n\n            self.reposition(e);\n\n            if (cfg.show.preventScroll) {\n                var ps = cfg.show.preventScroll,\n                    i, l;\n                if (ps === true) {\n                    ps = \"body\";\n                }\n                ps = MetaphorJs.dom.select(ps);\n                for (i = -1, l = ps.length; ++i < l;\n                    MetaphorJs.dom.addListener(ps[i], \"mousewheel\", self.onPreventScrollDelegate) &&\n                    MetaphorJs.dom.addListener(ps[i], \"touchmove\", self.onPreventScrollDelegate)\n                ){}\n            }\n\n            self.overlay.show();\n\n            if (cfg.show.animate && !immediately) {\n                self.animate(\"show\").done(function() {\n                    self.showAfterAnimation(e);\n                });\n            }\n            else {\n                raf(function(){\n                    self.showAfterAnimation(e);\n                });\n            }\n        },\n\n        showAfterAnimation: function(e) {\n\n            var self = this,\n                cfg = self.cfg,\n                node = self.node;\n\n            // if tooltip was already hidden, we can't proceed\n            if (!self.visible) {\n                return;\n            }\n\n            // now we can finally show the dialog (if it wasn't shown already\n            // during the animation\n            MetaphorJs.dom.removeClass(node, cfg.cls.hidden);\n            MetaphorJs.dom.addClass(node, cfg.cls.visible);\n\n            if (!cfg.render.keepVisible) {\n                node.style.display = cfg.show.display || \"block\";\n            }\n\n\n            // if it has to be shown only for a limited amount of time,\n            // we set timeout.\n            if (cfg.hide.timeout) {\n                self.hideTimeout = async(self.hide, self, null, cfg.hide.timeout);\n            }\n\n            if (cfg.show.focus) {\n                async(self.setFocus, self, null, 20);\n            }\n\n            self.trigger('show', self, e);\n        },\n\n\n\n\n\n        /* **** Hide **** */\n\n\n        /**\n         * Hide dialog\n         * @method\n         * \n         * @param {Event} e Optional.\n         * @param {bool} immediately Optional. True to skip delay.\n         * @param {bool} cancelShowDelay Optional. If showing already started but was delayed -\n         * cancel that delay.\n         */\n        hide: function(e, immediately, cancelShowDelay) {\n\n            var self            = this,\n                returnValue\t    = null,\n                returnMode      = null,\n                cfg             = self.cfg;\n\n            self.hideTimeout    = null;\n\n            // if the timer was set to hide the tooltip\n            // but then we needed to close tooltip immediately\n            if (!self.visible && self.hideDelay && immediately) {\n                window.clearTimeout(self.hideDelay);\n                self.hideDelay     = null;\n                self.visible       = true;\n            }\n\n            // various checks\n            if (!self.node || !self.visible || !self.isEnabled()) {\n                returnMode = !self.node ? \"noelem\" : (!self.visible ? \"hidden\" : \"disabled\");\n            }\n\n            // if tooltip is still waiting to be shown after delay timeout,\n            // we cancel this timeout and return.\n            if (self.showDelay && !returnMode) {\n\n                if (cfg.hide.cancelShowDelay || cancelShowDelay) {\n                    window.clearTimeout(self.showDelay);\n                    self.showDelay     = null;\n                    self.visible       = false;\n\n                    returnMode = \"cancel\";\n                }\n                else {\n                    returnMode = \"delay\";\n                }\n            }\n\n            // if tooltip was frozen, we do not show or hide\n            if (self.frozen && !returnMode) {\n                returnMode = \"frozen\";\n            }\n\n            // lets see what the callback will tell us\n            if (!returnMode && self.trigger('before-hide', self, e) === false) {\n                returnMode = \"beforehide\";\n            }\n\n            var ecfg;\n            if (e && e.stopPropagation && (ecfg = self.getEventConfig(e, \"hide\"))) {\n\n                if (ecfg.process) {\n                    returnValue = ecfg.process(self, e, \"hide\", returnMode);\n                }\n                else {\n                    if (ecfg.stopPropagation) e.stopPropagation();\n                    if (ecfg.preventDefault) e.preventDefault();\n                    returnValue = ecfg.returnValue;\n                }\n            }\n\n            if (returnMode) {\n                return returnValue;\n            }\n\n            // now we can stop all current animations\n            MetaphorJs.animate.stop(self.node);\n\n            // and change the state\n            self.visible = false;\n\n            //self.toggleTitleAttribute(true);\n\n            if (self.dynamicTarget) {\n                self.resetDynamicTarget();\n            }\n\n            if (cfg.hide.delay && !immediately) {\n                self.hideDelay = async(self.hideAfterDelay, self, [e], cfg.hide.delay);\n            }\n            else {\n                self.hideAfterDelay(e, immediately);\n            }\n\n            return returnValue;\n        },\n\n\n        hideAfterDelay: function(e, immediately) {\n\n            var self = this,\n                cfg = self.cfg;\n\n            self.hideDelay = null;\n\n            if (self.visible) {\n                return;\n            }\n\n            self.trigger('hide-after-delay', self, e);\n\n\n            if (cfg.show.preventScroll) {\n                var ps = cfg.show.preventScroll,\n                    i, l;\n                if (ps === true) {\n                    ps = \"body\";\n                }\n                ps = MetaphorJs.dom.select(ps);\n                for (i = -1, l = ps.length; ++i < l;\n                    MetaphorJs.dom.removeListener(ps[i], \"mousewheel\", self.onPreventScrollDelegate) &&\n                    MetaphorJs.dom.removeListener(ps[i], \"touchmove\", self.onPreventScrollDelegate)\n                ){}\n            }\n\n            self.overlay.hide();\n\n            if (cfg.hide.animate && !immediately) {\n                self.animate(\"hide\").done(function() {\n                    self.hideAfterAnimation(e);\n                });\n            }\n            else {\n                raf(function(){\n                    self.hideAfterAnimation(e);\n                });\n            }\n        },\n\n        hideAfterAnimation: function(e) {\n\n            var self = this,\n                cfg = self.cfg,\n                node = self.node;\n\n            // we need to check if the tooltip was returned to visible state\n            // while hiding animation\n            if (self.visible) {\n                return;\n            }\n\n            MetaphorJs.dom.removeClass(node, cfg.cls.visible);\n            MetaphorJs.dom.addClass(node, cfg.cls.hidden);\n\n            if (!cfg.render.keepVisible) {\n                node.style.display = \"none\";\n            }\n\n            self.trigger('hide', self, e);\n\n            var lt = cfg.render.lifetime;\n\n            if (lt !== null) {\n                if (lt === 0) {\n                    self.destroyElem();\n                }\n                else {\n                    self.destroyDelay = async(self.destroyElem, self, null, lt);\n                }\n            }\n\n            if (node && cfg.hide.destroy) {\n                raf(function(){\n                    MetaphorJs.dom.data(node, cfg.instanceName, null);\n                    self.$destroy();\n                });\n            }\n            else if (node && cfg.hide.remove) {\n                raf(function(){\n                    self.removeElem();\n                });\n            }\n        },\n\n\n\n        /* **** Render **** */\n\n\n\n\n        render: function() {\n\n            var self = this,\n                cfg = self.cfg,\n                elem;\n\n            // if already rendered, we return\n            if (self.node) {\n                return;\n            }\n\n\n            var rnd\t    = cfg.render,\n                cls     = cfg.cls;\n\n\n            // custom rendering function\n            if (rnd.fn) {\n                var res = rnd.fn.call(self.$$callbackContext, self);\n                rnd[isString(res) ? 'tpl' : 'el'] = res;\n            }\n\n\n            if (rnd.el) {\n                if (isString(rnd.el)) {\n                    elem = MetaphorJs.dom.select(rnd.el).shift();\n                    rnd.keepInDOM = true;\n                }\n                else {\n                    elem = rnd.el;\n                }\n            }\n            else {\n                var tmp = window.document.createElement(\"div\");\n                tmp.innerHTML = rnd.tpl;\n                elem = tmp.firstChild;\n            }\n\n\n            if (!elem) {\n                elem = window.document.createElement(\"div\");\n            }\n\n            self.node = elem;\n\n            if (rnd.id) {\n                MetaphorJs.dom.setAttr(elem, 'id', rnd.id);\n            }\n\n            if (!cfg.render.keepVisible) {\n                elem.style.display = \"none\";\n            }\n\n            MetaphorJs.dom.addClass(elem, cls.dialog);\n            MetaphorJs.dom.addClass(elem, cls.hidden);\n\n            if (rnd.style) {\n                MetaphorJs.dom.setStyle(elem, rnd.style);\n            }\n\n\n            self.overlay.render();\n\n\n            if (!cfg.hide.remove) {\n                self.appendElem();\n            }\n            else {\n                if (elem.parentNode) {\n                    elem.parentNode.removeChild(elem);\n                }\n            }\n\n            if (rnd.zIndex) {\n                MetaphorJs.dom.setStyle(elem, {zIndex: rnd.zIndex});\n            }\n\n            var cnt = cfg.content;\n\n            if (cnt.value !== false) {\n                if (cnt.value) {\n                    self.setContent(cnt.value);\n                }\n                else {\n                    if (cnt.fn) {\n                        self.setContent(cnt.fn.call(self.$$callbackContext, self));\n                    }\n                    else {\n                        self[cfg.remote.url ? 'loadContent' : 'readContent']();\n                    }\n                }\n            }\n\n            self.pointer.render();\n            self.pointer.append();\n\n            if (cfg.buttons) {\n                var btnId, btn;\n                for (btnId in cfg.buttons) {\n                    btn = MetaphorJs.dom.select(cfg.buttons[btnId], elem).shift();\n                    if (btn) {\n                        MetaphorJs.dom.data(btn, \"metaphorjsTooltip-button-id\", btnId);\n                        MetaphorJs.dom.addListener(btn, \"click\", self.onButtonClickDelegate);\n                        MetaphorJs.dom.addListener(btn, \"keyup\", self.onButtonKeyupDelegate);\n                    }\n                }\n            }\n\n            if (self.bindSelfOnRender) {\n                self.setHandlers('bind', '_self');\n                self.bindSelfOnRender = false;\n            }\n\n            self.rendered = true;\n\n            self.trigger('render', self);\n        },\n\n\n\n\n\n\n\n\n        /* **** Position **** */\n\n        setPositionType: function(type) {\n            var self    = this,\n                positionCls     = self.getPositionClass(type);\n\n            self.cfg.position.type = type;\n\n            if (self.positionClass !== positionCls || !self.position) {\n                if (self.position) {\n                    self.position.$destroy();\n                    self.position = null;\n                }\n                if (positionCls) {\n                    self.position = cls.factory(positionCls, self);\n                }\n            }\n            else {\n                self.position.type = type;\n            }\n\n            if (self.isVisible()) {\n                self.reposition();\n            }\n        },\n\n        getPosition: function(e) {\n\n            var self = this,\n                cfgPos = self.cfg.position;\n\n            if (!self.position) {\n\n                if (!self.positionGetType && cfgPos.type !== \"custom\") {\n                    if (isFunction(cfgPos.get) && cfgPos.type !== \"m\") {\n                        cfgPos.type = \"custom\";\n                    }\n                }\n\n                var type    = self.positionGetType ?\n                                self.positionGetType.call(self.$$callbackContext, self, e) :\n                                cfgPos.type,\n                    positionCls = self.getPositionClass(type);\n\n                cfgPos.type     = type;\n\n                if (positionCls === false) {\n                    return;\n                }\n\n                if (self.positionClass !== positionCls) {\n                    self.position   = cls.factory(positionCls, self);\n                }\n                else {\n                    self.position.type = type;\n                }\n            }\n\n            return self.position;\n        },\n\n        getPositionClass: function(type) {\n\n            if (!type) {\n                return false;\n            }\n\n            if (isFunction(type) || type === \"custom\") {\n                return \"MetaphorJs.dialog.position.Custom\";\n            }\n            else if (type === \"draggable\") {\n                return \"MetaphorJs.dialog.position.Draggable\";\n            }\n            else if (type === \"none\") {\n                return \"MetaphorJs.dialog.position.None\";\n            }\n\n            var fc = type.substr(0, 1);\n\n            if (!fc) {\n                return false;\n            }\n            else if (fc === \"w\") {\n                return \"MetaphorJs.dialog.position.Window\";\n            }\n            else if (fc === \"m\") {\n                return \"MetaphorJs.dialog.position.Mouse\";\n            }\n            else {\n                return \"MetaphorJs.dialog.position.Target\";\n            }\n        },\n\n\n        /**\n         * Usually called internally from show().\n         * @method\n         * \n         * @param {Event} e Optional.\n         */\n        reposition: function(e) {\n            var self = this;\n\n            if (self.repositioning) {\n                return;\n            }\n\n            if (self.node && !MetaphorJs.dom.isAttached(self.node)) {\n                MetaphorJs.dom.whenAttached(self.node).done(function(){\n                    self.reposition(e);\n                });\n                return;\n            }\n\n            self.repositioning = true;\n\n            e && (e = MetaphorJs.dom.normalizeEvent(e));\n\n            self.getPosition(e);\n            self.trigger(\"before-reposition\", self, e);\n            self.getPosition(e);\n            self.trigger(\"reposition\", self, e);\n\n            self.repositioning = false;\n        },\n\n\n\n        /* **** Target **** */\n\n        /**\n         * Get dialog's target.\n         * @method\n         * \n         * @return {HTMLElement}\n         */\n        getTarget: function() {\n            return this.dynamicTarget ? this.dynamicTargetEl : this.target;\n        },\n\n\n        /**\n         * Set new dialog's target.\n         * @method\n         * \n         * @param {string|Element} newTarget Selector or dom node\n         */\n        setTarget: function(newTarget) {\n\n            if (!newTarget) {\n                return;\n            }\n\n            var self    = this,\n                change  = false,\n                prev    = self.target;\n\n            if (self.target) {\n                self.setHandlers('unbind', '_target');\n                change = true;\n            }\n            else if (self.dynamicTarget) {\n                change = true;\n            }\n\n            var isStr = isString(newTarget);\n\n            if (isStr && newTarget.substr(0,1) !== \"#\") {\n                self.dynamicTarget = true;\n                self.target        = null;\n            }\n            else {\n                if (isStr) {\n                    newTarget       = MetaphorJs.dom.select(newTarget).shift();\n                }\n                self.dynamicTarget = false;\n                self.target        = newTarget;\n            }\n\n            if (change) {\n                self.setHandlers('bind', '_target');\n                self.trigger(\"target-change\", self, newTarget, prev);\n            }\n        },\n\n\n        resetDynamicTarget: function() {\n            var self = this,\n                curr = self.dynamicTargetEl;\n            if (curr) {\n                self.setHandlers(\"unbind\", \"_target\");\n                self.trigger(\"target-change\", self, null, curr);\n            }\n        },\n\n        isDynamicTargetChanged: function(e) {\n\n            var self    = this,\n                cfg     = self.cfg,\n                dt\t    = cfg.target,\n                t\t    = e.target,\n                curr    = self.dynamicTargetEl;\n\n            while (t && !MetaphorJs.dom.is(t, dt)) {\n                t   = t.parentNode;\n            }\n\n            if (!t) {\n                return false;\n            }\n\n            return !curr || curr !== t;\n        },\n\n        changeDynamicTarget: function(e) {\n\n            var self    = this,\n                cfg     = self.cfg,\n                dt\t    = cfg.target,\n                t\t    = e.target,\n                curr    = self.dynamicTargetEl;\n\n            while (t && !MetaphorJs.dom.is(t, dt)) {\n                t   = t.parentNode;\n            }\n\n            if (!t) {\n                return false;\n            }\n\n            if (!curr || curr !== t) {\n\n                if (curr) {\n                    self.setHandlers(\"unbind\", \"_target\");\n                }\n\n                self.dynamicTargetEl = t;\n\n                self.setHandlers(\"bind\", \"_target\");\n                self.trigger(\"target-change\", self, t, curr);\n                return true;\n            }\n            else {\n                return false;\n            }\n        },\n\n\n\n\n\n\n\n\n\n        /* **** Content **** */\n\n        /**\n         * @method\n         * \n         * @return {HTMLElement}\n         */\n        getContentElem: function() {\n            var self = this,\n                node = self.node;\n\n            if (!node) {\n                return null;\n            }\n\n            if (self.cfg.selector.content) {\n                var el = MetaphorJs.dom.select(self.cfg.selector.content, node).shift();\n                return el || node;\n            }\n            else {\n                return node;\n            }\n        },\n\n\n        /**\n         * Set new content.\n         * @method\n         * \n         * @param {string|object} content {\n             *      See \"selector\" option\n             *      @required\n         * }\n         * @param {string} mode \"\", \"attribute\", \"remote\" -- optional (used internally). See\n         * content.prepare option.\n         */\n        setContent: function(content, mode) {\n\n            mode = mode || '';\n\n            var self    = this,\n                node    = self.node,\n                cfg     = self.cfg,\n                pnt     = self.pointer;\n\n            if (!node) {\n                cfg.content.value = content;\n                return self;\n            }\n\n            if (cfg.content.prepare) {\n                content = cfg.content.prepare.call(self.$$callbackContext, self, mode, content);\n            }\n\n            var contentElem = self.getContentElem(),\n                fixPointer  = self.rendered && !cfg.selector.content && pnt,\n                pntEl       = fixPointer && pnt.getElem();\n\n            if (fixPointer && pntEl) {\n                try {\n                    node.removeChild(pntEl);\n                }\n                catch (thrownError) {\n                    error(thrownError);\n                }\n            }\n\n            if (!isString(content)) {\n                for (var i in content) {\n                    var sel     = cfg.selector[i];\n                    if (sel) {\n                        var cel = MetaphorJs.dom.select(sel, contentElem).shift();\n                        if (cel) {\n                            cel.innerHTML = content[i];\n                        }\n                    }\n                }\n            }\n            else {\n                contentElem.innerHTML = content;\n            }\n\n            // if there a pointer, and this is not initial content set,\n            // and there is no selector for content\n            // we must restore pointer after dialog's inner html\n            // has been replaced with new content\n            if (fixPointer && pntEl) {\n                try {\n                    node.appendChild(pntEl);\n                }\n                catch (thrownError) {\n                    error(thrownError);\n                }\n            }\n\n            var imgs = MetaphorJs.dom.select(\"img\", contentElem),\n                l;\n\n            self.images = imgs.length;\n\n            for (i = -1, l = imgs.length; ++i < l; \n                MetaphorJs.dom.addListener(imgs[i], \"load\", self.onImageLoadDelegate)){}\n\n            self.trigger('content-change', self, content, mode);\n            self.onContentChange();\n        },\n\n        /**\n         * Force dialog to re-read content from attributes.\n         * @method\n         * \n         */\n        readContent: function() {\n\n            var self        = this,\n                cfg         = self.cfg,\n                el \t\t\t= self.getTarget(),\n                content;\n\n            if (el) {\n                if (typeof cfg.content.attr === \"string\") {\n                    content = MetaphorJs.dom.getAttr(el, cfg.content.attr);\n                }\n                else {\n                    content = MetaphorJs.dom.getAttr(el, 'tooltip') ||\n                            MetaphorJs.dom.getAttr(el, 'title') ||\n                            MetaphorJs.dom.getAttr(el, 'alt');\n                }\n            }\n\n            if (content) {\n                self.setContent(content, 'attribute');\n            }\n        },\n\n        /**\n         * Load remote content.\n         * @method\n         * @param {object} options Merged with cfg.remote\n         */\n        loadContent: function(options) {\n\n            const self = this,\n                    cfg = self.cfg;\n\n            MetaphorJs.dom.addClass(self.node, cfg.cls.loading);\n            var opt = extend({}, cfg.remote, options, true, true);\n\n            self.trigger('before-fetch', self, opt);\n\n            if (opt.useMetaphor) {\n                if (!MetaphorJs.remote || !MetaphorJs.remote.fetch) {\n                    console.error(\"MetaphorJs.remote.fetch is not available in this build\");\n                }\n                delete opt.useMetaphor;\n                return MetaphorJs.remote.fetch(opt).done(self.onRemoteLoad, self);\n            }\n\n            return fetch(opt).then(r => r.text()).then((resp) => self.onRemoteLoad(resp));\n        },\n\n        onRemoteLoad: function(data) {\n            var self = this;\n            MetaphorJs.dom.removeClass(self.node, self.cfg.cls.loading);\n            self.setContent(data, 'remote');\n        },\n\n        onImageLoad: function() {\n            this.images--;\n            this.onContentChange();\n        },\n\n        onContentChange: function() {\n            if (this.visible) {\n                this.reposition();\n            }\n        },\n\n        changeDynamicContent: function() {\n            var self = this,\n                cfg = self.cfg;\n            if (cfg.content.fn) {\n                self.setContent(cfg.content.fn.call(self.$$callbackContext, self));\n            }\n            else if (cfg.content.attr) {\n                self.readContent();\n            }\n        },\n\n        toggleTitleAttribute: function(state) {\n\n            var self = this,\n                trg = self.getTarget(),\n                title;\n\n            if (trg) {\n                if (state === false) {\n                    if (trg.hasAttribute(\"title\")) {\n                        MetaphorJs.dom.setAttr(trg, \"tooltip\", MetaphorJs.dom.getAttr(trg, \"title\"));\n                        MetaphorJs.dom.removeAttr(trg, 'title');\n                    }\n                }\n                else if (title = MetaphorJs.dom.getAttr(trg, \"tooltip\")) {\n                    MetaphorJs.dom.setAttr(trg, \"title\", title);\n                }\n            }\n        },\n\n        /* **** Dimension **** */\n\n\n        getDialogSize: function() {\n\n            var self    = this;\n\n            if (!self.rendered) {\n                self.render();\n            }\n\n            var cfg     = self.cfg,\n                node    = self.node,\n                hidden  = cfg.cls.hidden ? MetaphorJs.dom.hasClass(node, cfg.cls.hidden) : \n                                            !MetaphorJs.dom.isVisible(node),\n                size,\n                left    = node.style.left;\n\n            if (hidden) {\n                MetaphorJs.dom.setStyle(node, {left: \"-1000px\"});\n                node.style.display = cfg.show.display;\n            }\n\n            size    = {\n                width:      MetaphorJs.dom.getOuterWidth(node),\n                height:     MetaphorJs.dom.getOuterHeight(node)\n            };\n\n            if (hidden) {\n                MetaphorJs.dom.setStyle(node, {left: left});\n                node.style.display = \"none\";\n            }\n\n            return size;\n        },\n\n        getTargetSize: function() {\n\n            var self    = this,\n                target  = self.getTarget();\n\n            if (!target) {\n                return null;\n            }\n\n            return {\n                width:      MetaphorJs.dom.getOuterWidth(target),\n                height:     MetaphorJs.dom.getOuterHeight(target)\n            };\n        },\n\n\n        /* **** Misc **** */\n\n\n        /**\n         * Set focus based on focus setting.\n         * @method\n         */\n        setFocus: function() {\n\n            var self    = this,\n                cfg     = self.cfg,\n                af      = cfg.show.focus,\n                node    = self.node,\n                i,\n                input;\n\n            if (af === true) {\n                input   = MetaphorJs.dom.select(\"input\", node).concat(\n                            MetaphorJs.dom.select(\"textarea\", node));\n                if (input.length > 0) {\n                    input[0].focus();\n                }\n                else if (cfg.buttons) {\n                    for (i in cfg.buttons) {\n                        var btn = MetaphorJs.dom.select(cfg.buttons[i], node).shift();\n                        btn && btn.focus();\n                        break;\n                    }\n                }\n            }\n            else {\n                var el = MetaphorJs.dom.select(af, node).shift();\n                el && el.focus();\n            }\n        },\n\n        getScrollEl: function(cfgScroll) {\n            if (cfgScroll === true || cfgScroll === false) {\n                return window;\n            }\n            else if (typeof cfgScroll === \"string\") {\n                return MetaphorJs.dom.select(cfgScroll).shift();\n            }\n            else {\n                return cfgScroll;\n            }\n        },\n\n\n        animate: function(section, e) {\n\n            var self = this,\n                cfg = self.cfg,\n                node = self.node,\n                a,\n                skipDisplay;\n\n            a \t= cfg[section].animate;\n\n            if (isFunction(a)) {\n                a   = a(self, e);\n            }\n\n            skipDisplay = a.skipDisplayChange || false;\n\n            if (isBool(a)) {\n                a = section;\n            }\n            else if (isString(a)) {\n                a = [a];\n            }\n\n            return MetaphorJs.animate.animate(node, a, function(){\n                if (section === \"show\" && !skipDisplay) {\n                    return new MetaphorJs.lib.Promise(function(resolve, reject){\n                        raf(function(){ \n                            node.style.display = cfg.show.display || \"block\";\n                            resolve();\n                        });\n                    });\n                }\n            }, false);\n        },\n\n        removeElem: function() {\n\n            var self = this,\n                node = self.node;\n\n            self.overlay.remove();\n\n            if (node && node.parentNode) {\n                raf(function(){\n                    if (!self.visible) {\n                        node.parentNode.removeChild(node);\n                    }\n                });\n            }\n        },\n\n        appendElem: function() {\n\n\n\n            var self    = this,\n                cfg     = self.cfg,\n                body    = window.document.body,\n                rnd\t    = cfg.render,\n                to      = rnd.appendTo || body;\n\n            self.overlay.append();\n\n            if (self.node && cfg.render.appendTo !== false) {\n                to.appendChild(self.node);\n                self.trigger(\"attached\", self, to);\n            }\n            else if (self.node && MetaphorJs.dom.isAttached(self.node)) {\n                self.trigger(\"attached\", self, self.node.parentNode);\n            }\n        },\n\n\n        /* **** Destroy **** */\n\n        destroyElem: function() {\n\n            var self = this,\n                node = self.node;\n\n            self.setHandlers(\"unbind\", \"_self\");\n            self.bindSelfOnRender = true;\n\n            self.pointer.remove();\n            self.overlay.remove();\n\n            if (node) {\n                if (!self.cfg.render.keepInDOM) {\n                    node.parentNode && node.parentNode.removeChild(node);\n                }\n                self.node = null;\n            }\n\n            self.trigger(\"lifetime\", self);\n        },\n\n        onDestroy: function() {\n\n            var self = this;\n\n            self.setHandlers(\"unbind\");\n\n            self.trigger(\"destroy\", self);\n            self.destroyElem();\n\n            self.overlay && self.overlay.$destroy();\n            self.pointer && self.pointer.$destroy();\n            self.position && self.position.$destroy();\n        }\n\n    }, {\n        defaults: null\n    });\n\n\n\n    return Dialog;\n\n}());","require(\"../__init.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dialog.Manager = cls({\n\n    all: null,\n    groups: null,\n\n    $init: function() {\n        this.all = {};\n        this.groups = {};\n    },\n\n    register: function(dialog) {\n\n        var id      = dialog.getInstanceId(),\n            grps    = dialog.getGroup(),\n            self    = this,\n            all     = self.all,\n            groups  = self.groups,\n            i, len,\n            g;\n\n        all[id]     = dialog;\n\n        for (i = 0, len = grps.length; i < len; i++) {\n            g   = grps[i];\n            if (!groups[g]) {\n                groups[g]   = {};\n            }\n            groups[g][id] = true;\n        }\n\n        dialog.on(\"destroy\", this.unregister, this);\n    },\n\n    unregister: function(dialog) {\n\n        var id  = dialog.getInstanceId();\n        delete this.all[id];\n    },\n\n    hideAll: function(dialog) {\n\n        var id      = dialog.getInstanceId(),\n            grps    = dialog.getGroup(),\n            self    = this,\n            all     = self.all,\n            groups  = self.groups,\n            i, len, gid,\n            ds, did;\n\n        for (i = 0, len = grps.length; i < len; i++) {\n            gid     = grps[i];\n            ds      = groups[gid];\n            for (did in ds) {\n                if (!all[did]) {\n                    delete ds[did];\n                }\n                else if (did != id && !all[did].isHideAllIgnored()) {\n                    all[did].hide(null, true, true);\n                }\n            }\n        }\n    }\n\n});","\nrequire(\"../__init.js\");\nrequire(\"metaphorjs/src/func/dom/setStyle.js\");\nrequire(\"metaphorjs/src/func/dom/addListener.js\");\nrequire(\"metaphorjs/src/func/dom/normalizeEvent.js\");\nrequire(\"metaphorjs-animate/src/animate/animate.js\");\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    raf = require(\"metaphorjs-animate/src/func/raf.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    isFunction = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    isString = require(\"metaphorjs-shared/src/func/isString.js\"),\n    isBool = require(\"metaphorjs-shared/src/func/isBool.js\");\n\nmodule.exports = MetaphorJs.dialog.Overlay = cls({\n\n    dialog:         null,\n    enabled:\t\tfalse,\n    color:\t\t\t'#000',\n    opacity:\t\t.5,\n    cls:\t\t\tnull,\n    animateShow:\tfalse,\n    animateHide:\tfalse,\n\n    $mixins:        [MetaphorJs.mixin.Observable],\n\n    $init: function(dialog) {\n\n        var self = this;\n\n        self.dialog = dialog;\n        self.onClickDelegate = bind(self.onClick, self);\n        extend(self, dialog.getCfg().overlay, true, false);\n\n        self.$$observable.createEvent(\"click\", false);\n\n        if (self.enabled) {\n            self.enabled = false;\n            self.enable();\n        }\n    },\n\n    getElem: function() {\n        var self = this;\n        if (self.enabled && !self.node) {\n            self.render();\n        }\n        return self.node;\n    },\n\n    enable: function() {\n        var self = this;\n        if (!self.enabled) {\n            self.enabled = true;\n        }\n    },\n\n    disable: function() {\n        var self = this;\n        if (self.enabled) {\n            self.remove();\n            self.enabled = false;\n        }\n    },\n\n    show: function(e) {\n        var self = this;\n\n        if (!self.enabled) {\n            return;\n        }\n\n        if (self.animateShow) {\n            self.animate(\"show\", e);\n        }\n        else {\n            self.node.style.display = \"block\";\n        }\n    },\n\n    hide: function(e) {\n        var self = this;\n        if (self.node) {\n            if (self.animateHide) {\n                self.animate(\"hide\", e);\n            }\n            else {\n                self.node.style.display = \"none\";\n            }\n        }\n    },\n\n    render: function() {\n\n        var self = this;\n\n        if (!self.enabled) {\n            return;\n        }\n\n        var node = window.document.createElement(\"div\"),\n            cfg = self.dialog.getCfg(),\n            style = {\n                display:            \"none\",\n                position: \t\t\t\"fixed\",\n                left:\t\t\t\t0,\n                top:\t\t\t\t0,\n                right:              0,\n                bottom:             0\n            };\n\n        if (self.opacity !== false) {\n            style.opacity = self.opacity;\n        }\n        if (self.color !== false) {\n            style.backgroundColor = self.color;\n        }\n\n        MetaphorJs.dom.setStyle(node, style);\n        MetaphorJs.dom.addListener(node, \"click\", self.onClickDelegate);\n\n        if (cfg.render.zIndex) {\n            MetaphorJs.dom.setStyle(node, \"zIndex\", cfg.render.zIndex);\n        }\n        if (self.cls) {\n            MetaphorJs.dom.addClass(node, self.cls);\n        }\n\n        self.node = node;\n    },\n\n    remove: function() {\n        var self = this,\n            node = self.node;\n\n        if (node) {\n            raf(function() {\n                //if (!dialog.isVisible() && node.parentNode) {\n                if (node.parentNode) {\n                    node.parentNode.removeChild(node);\n                }\n            });\n        }\n    },\n\n    append: function() {\n        var self = this,\n            cfg = self.dialog.getCfg(),\n            to = cfg.render.appendTo || window.document.body;\n\n        if (!self.enabled || self.$destroyed) {\n            return;\n        }\n\n        if (!self.node) {\n            self.render();\n        }\n\n        to.appendChild(self.node);\n    },\n\n    animate: function(type, e) {\n        var self = this,\n            node = self.node,\n            a;\n\n        a = type == \"show\" ? self.animateShow : self.animateHide;\n\n        if (isFunction(a)) {\n            a   = a(self, e);\n        }\n\n        if (isBool(a)) {\n            a = type;\n        }\n        else if (isString(a)) {\n            a = [a];\n        }\n\n        return MetaphorJs.animate.animate(node, a, function(){\n            if (type == \"show\") {\n                return new MetaphorJs.lib.Promise(function(resolve, reject){\n                    raf(function(){\n                        node.style.display = \"\";\n                        resolve();\n                    });\n                });\n            }\n        }, false);\n    },\n\n    onClick: function(e) {\n\n        var self = this;\n\n        var res = self.trigger(\"click\", self.dialog, self, e);\n\n        if (res === false) {\n            return null;\n        }\n\n        if (self.modal) {\n            e = MetaphorJs.dom.normalizeEvent(e);\n            e.preventDefault();\n            e.stopPropagation();\n            return false;\n        }\n        return null;\n    },\n\n    onDestroy: function() {\n        var self = this;\n        self.remove();\n    }\n});","require(\"../../__init.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dialog.pointer.Abstract = cls({\n\n    enabled: null,\n    node: null,\n    correctX: 0,\n    correctY: 0,\n\n    $init: function(dialog, cfg) {\n\n        var self = this;\n\n        extend(self, cfg, true, false);\n\n        self.origCfg    = cfg;\n        self.dialog     = dialog;\n        self.opposite   = {t: \"b\", r: \"l\", b: \"t\", l: \"r\"};\n        self.names      = {t: 'top', r: 'right', b: 'bottom', l: 'left'};\n        self.sides      = {t: ['l','r'], r: ['t','b'], b: ['r','l'], l: ['b','t']};\n\n        if (self.enabled !== false && cfg.size) {\n            self.enabled = true;\n        }\n        else {\n            self.enabled = false;\n        }\n    },\n\n    enable: function() {\n        var self = this;\n        if (!self.enabled) {\n            self.enabled = true;\n            self.render();\n            if (self.dialog.isVisible()) {\n                self.dialog.reposition();\n            }\n        }\n    },\n\n    disable: function() {\n        var self = this;\n        if (self.enabled) {\n            self.remove();\n            self.enabled = false;\n            if (self.dialog.isVisible()) {\n                self.dialog.reposition();\n            }\n        }\n    },\n\n    getElem: function() {\n        return this.node;\n    },\n\n    getSize: function() {\n        return this.enabled ? this.size : 0;\n    },\n\n    setCorrectionOffset: function(x, y) {\n        this.correctX = x;\n        this.correctY = y;\n    },\n\n    getCorrectionValue: function(type, value, position) {\n\n        if (!value) {\n            return 0;\n        }\n\n        var self    = this,\n            pri     = position.substr(0,1),\n            sec     = position.substr(1,1),\n            tsize   = self.dialog.getDialogSize(),\n            width   = self.width,\n            sprop   = pri == \"t\" || pri == \"b\" ? \"width\" : \"height\",\n            min,\n            max;\n\n        switch (sec) {\n            case \"\":\n                max = (tsize[sprop] / 2) - (width / 2);\n                min = -max;\n                break;\n            case \"l\":\n                min = 0;\n                max = tsize[sprop] - (width / 2);\n                break;\n            case \"r\":\n                min = -(tsize[sprop] - (width / 2));\n                max = 0;\n                break;\n        }\n\n        value = value < 0 ? Math.max(min, value) : Math.min(max, value);\n\n        if ((pri == \"t\" || pri == \"b\") && type == \"x\") {\n            return value;\n        }\n        if ((pri == \"l\" || pri == \"r\") && type == \"y\") {\n            return value;\n        }\n\n        return 0;\n    },\n\n    getDialogPositionOffset: function(position) {\n        var self    = this,\n            pp      = (self.detectPointerPosition(position) || \"\").substr(0,1),\n            dp      = self.dialog.getPosition().getPrimaryPosition(position),\n            ofs     = {x: 0, y: 0};\n\n        if (!self.enabled) {\n            return ofs;\n        }\n\n        if (pp == self.opposite[dp]) {\n            ofs[pp == \"t\" || pp == \"b\" ? \"y\" : \"x\"] =\n                pp == \"b\" || pp == \"r\" ? -self.size : self.size;\n        }\n\n        return ofs;\n    },\n\n    detectPointerPosition: function(dialogPosition) {\n\n        var self = this,\n            pri, sec, thr;\n\n        if (self.position && !dialogPosition) {\n            if (isFunction(self.position)) {\n                return self.position.call(self.dialog.$$callbackContext, self.dialog, self.origCfg);\n            }\n            return self.position;\n        }\n\n        pri = self.dialog.getPosition().getPrimaryPosition(dialogPosition) || \"\";\n        sec = self.dialog.getPosition().getSecondaryPosition(dialogPosition) || \"\";\n        thr = sec ? sec.substr(1, 1) : null;\n\n        if (!pri) {\n            return null;\n        }\n\n        var position = self.opposite[pri] || \"\";\n\n        if (sec) {\n            sec = sec.substr(0, 1);\n            if (thr === \"c\") {\n                position += self.opposite[sec];\n            }\n            else {\n                position += sec;\n            }\n        }\n\n        return position;\n    },\n\n    detectPointerDirection: function(position) {\n\n        var self = this;\n\n        if (self.direction) {\n            if (isFunction(self.direction)) {\n                return self.direction.call(self.dialog.$$callbackContext, self.dialog, position, self.origCfg);\n            }\n            return self.direction;\n        }\n        return position;\n    },\n\n    update: function(){\n        var self = this;\n        self.remove();\n        self.render();\n        self.append();\n        if (self.dialog.isVisible()) {\n            self.dialog.reposition();\n        }\n    },\n\n\n\n    setType: function(position, direction) {\n        var self = this;\n        self.position = position;\n        self.direction = direction;\n        self.update();\n        self.reposition();\n    },\n\n\n    render: function() {},\n\n    onDestroy: function() {\n        var self = this;\n        self.remove();\n    },\n\n    reposition: function() {\n\n    },\n\n    append: function() {\n\n        var self = this;\n        if (!self.enabled) {\n            return;\n        }\n        if (!self.node) {\n            self.render();\n        }\n        if (!self.node) {\n            return;\n        }\n\n        self.reposition();\n\n        var parent = self.dialog.getElem();\n        if (parent) {\n            parent.appendChild(self.node);\n        }\n    },\n\n    remove: function(){\n\n        var self = this,\n            node = self.node;\n\n        if (node) {\n\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n\n            self.node = null;\n        }\n    }\n});","require(\"../../__init.js\");\nrequire(\"metaphorjs/src/func/dom/setStyle.js\");\nrequire(\"metaphorjs/src/func/dom/addClass.js\");\nrequire(\"metaphorjs-animate/src/animate/getPrefixes.js\");\nrequire(\"./Abstract.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    ucfirst = require(\"metaphorjs-shared/src/func/ucfirst.js\");\n\nmodule.exports = MetaphorJs.dialog.pointer.Html = (function(){\n\n    var ie6             = null,\n        defaultProps    = {\n            backgroundColor: 'transparent',\n            width: \t\t\t'0px',\n            height: \t\t'0px',\n            position: \t\t'absolute',\n            fontSize: \t    '0px', // ie6\n            lineHeight:     '0px' // ie6\n        };\n\n    return MetaphorJs.dialog.pointer.Abstract.$extend({\n\n        node: null,\n        sub: null,\n\n        $init: function(dialog, cfg) {\n\n            if (ie6 === null) {\n                ie6 = window.document.all && !window.XMLHttpRequest\n            }\n\n            var self = this;\n\n            self.$super(dialog, cfg);\n\n            self.width = self.width || self.size * 2;\n\n            if (self.inner) {\n                self.enabled = true;\n            }\n        },\n\n\n\n        createInner: function() {\n            var self        = this,\n                newcfg \t\t= extend({}, self.origCfg);\n\n            newcfg.size \t= self.size - (self.border * 2);\n            newcfg.width\t= self.width - (self.border * 4);\n\n            newcfg.border = 0;\n            newcfg.borderColor = null;\n            newcfg.borderCls = null;\n            newcfg.offset = 0;\n            newcfg.inner = self.border;\n\n            self.sub = new MetaphorJs.dialog.pointer.Html(self.dialog, newcfg);\n        },\n\n\n        getBorders: function(position, direction, color) {\n\n            var self        = this,\n                borders \t= {},\n                pri \t\t= position.substr(0,1),\n                dpri        = direction.substr(0,1),\n                dsec        = direction.substr(1),\n                style       = ie6 ? \"dotted\" : \"solid\",\n                names       = self.names,\n                sides       = self.sides,\n                opposite    = self.opposite;\n\n            // in ie6 \"solid\" wouldn't make transparency :(\n\n            // this is always height : border which is opposite to direction\n            borders['border'+ucfirst(names[opposite[pri]])] = self.size + \"px solid \"+color;\n            // border which is similar to direction is always 0\n            borders['border'+ucfirst(names[pri])] = \"0 \"+style+\" transparent\";\n\n            if (!dsec) {\n                // if pointer's direction matches pointer primary position (p: l|lt|lb, d: l)\n                // then we set both side borders to a half of the width;\n                var side = Math.floor(self.width / 2);\n                borders['border' + ucfirst(names[sides[dpri][0]])] = side + \"px \"+style+\" transparent\";\n                borders['border' + ucfirst(names[sides[dpri][1]])] = side + \"px \"+style+\" transparent\";\n            }\n            else {\n                // if pointer's direction doesn't match with primary position (p: l|lt|lb, d: t|b)\n                // we set the border opposite to direction to the full width;\n                borders['border'+ucfirst(names[dsec])] = \"0 solid transparent\";\n                borders['border'+ucfirst(names[opposite[dsec]])] = self.width + \"px \"+style+\" transparent\";\n            }\n\n            return borders;\n        },\n\n        getOffsets: function(position, direction) {\n\n            var self    = this,\n                offsets = {},\n                names   = self.names,\n                opposite= self.opposite,\n                pri\t\t= position.substr(0,1),\n                auto \t= (pri == 't' || pri == 'b') ? \"r\" : \"b\";\n\n            offsets[names[pri]] = self.inner ? 'auto' : -self.size+\"px\";\n            offsets[names[auto]] = \"auto\";\n\n            if (!self.inner) {\n\n                var margin;\n\n                switch (position) {\n                    case 't': case 'r': case 'b': case 'l':\n                        if (direction != position) {\n                            if (direction == 'l' || direction == 't') {\n                                margin = self.offset;\n                            }\n                            else {\n                                margin = -self.width + self.offset;\n                            }\n                        }\n                        else {\n                            margin = -self.width/2 + self.offset;\n                        }\n                        break;\n\n                    case 'bl': case 'tl': case 'lt': case 'rt':\n                        margin = self.offset;\n                        break;\n\n                    default:\n                        margin = -self.width - self.offset;\n                        break;\n                }\n\n                offsets['margin' + ucfirst(names[opposite[auto]])] = margin + \"px\";\n\n                var positionOffset;\n\n                switch (position) {\n                    case 't': case 'r': case 'b': case 'l':\n                        positionOffset = '50%';\n                        break;\n\n                    case 'tr': case 'rb': case 'br': case 'lb':\n                        positionOffset = '100%';\n                        break;\n\n                    default:\n                        positionOffset = 0;\n                        break;\n                }\n\n                offsets[names[opposite[auto]]]  = positionOffset;\n\n                var pfxs = MetaphorJs.animate.getPrefixes(),\n                    transformPfx = pfxs.transform,\n                    transform = \"\",\n                    cx = self.correctX,\n                    cy = self.correctY;\n\n                if (transformPfx) {\n\n                    if (cx) {\n                        transform += \" translateX(\" + self.getCorrectionValue(\"x\", cx, position) + \"px)\";\n                    }\n                    if (cy) {\n                        transform += \" translateY(\" + self.getCorrectionValue(\"y\", cy, position) + \"px)\";\n                    }\n\n                    offsets[transformPfx] = transform;\n                }\n            }\n            else {\n\n                var innerOffset,\n                    dpri    = direction.substr(0, 1),\n                    dsec    = direction.substr(1);\n\n                if (dsec) {\n                    if (dsec == 'l' || dsec == 't') {\n                        innerOffset = self.inner + 'px';\n                    }\n                    else {\n                        innerOffset = -self.width - self.inner + 'px';\n                    }\n                }\n                else {\n                    innerOffset = Math.floor(-self.width / 2) + 'px';\n                }\n\n                offsets[names[opposite[auto]]]  = innerOffset;\n                offsets[names[opposite[dpri]]] = -(self.size + (self.inner * 2)) + 'px';\n            }\n\n\n            return offsets;\n        },\n\n        render: function() {\n\n            var self = this;\n\n            if (!self.enabled) {\n                return;\n            }\n\n            if (self.node) {\n                return;\n            }\n\n            var position    = self.detectPointerPosition();\n            if (!position) {\n                return;\n            }\n\n            if (self.border && !self.sub) {\n                self.createInner();\n            }\n\n            self.node   = window.document.createElement('div');\n            var cmt     = window.document.createComment(\" \");\n\n            self.node.appendChild(cmt);\n\n            MetaphorJs.dom.setStyle(self.node, defaultProps);\n            MetaphorJs.dom.addClass(self.node, self.borderCls || self.cls);\n\n            if (self.sub) {\n                self.sub.render();\n                self.node.appendChild(self.sub.getElem());\n            }\n        },\n\n        reposition: function() {\n\n            var self        = this,\n                position    = self.detectPointerPosition(),\n                direction   = self.detectPointerDirection(position);\n\n            if (!self.node) {\n                return;\n            }\n\n            MetaphorJs.dom.setStyle(self.node, \n                self.getBorders(position, direction, self.borderColor || self.color));\n            MetaphorJs.dom.setStyle(self.node, \n                self.getOffsets(position, direction));\n\n            if (self.sub) {\n                self.sub.reposition();\n            }\n        },\n\n        update: function() {\n            var self = this;\n            if (self.sub) {\n                self.sub.$destroy();\n                self.sub = null;\n            }\n            self.remove();\n            self.node = null;\n            self.render();\n            self.append();\n\n            if (self.dialog.isVisible()) {\n                self.dialog.reposition();\n            }\n        },\n\n        onDestroy: function() {\n\n            var self = this;\n\n            if (self.sub) {\n                self.sub.$destroy();\n                self.sub = null;\n            }\n\n            self.$super();\n        },\n\n        remove: function() {\n\n            var self = this;\n\n            if (self.sub) {\n                self.sub.remove();\n            }\n\n            self.$super();\n        }\n    });\n}());\n\n","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/func/dom/setStyle.js\");\nrequire(\"metaphorjs/src/func/dom/select.js\");\nrequire(\"metaphorjs/src/func/dom/normalizeEvent.js\");\nrequire(\"metaphorjs/src/func/dom/addListener.js\");\nrequire(\"metaphorjs/src/func/dom/removeListener.js\");\nrequire(\"metaphorjs/src/func/dom/getScrollTop.js\");\nrequire(\"metaphorjs/src/func/dom/getScrollLeft.js\");\nrequire(\"metaphorjs/src/func/dom/getOuterWidth.js\");\nrequire(\"metaphorjs/src/func/dom/getOuterHeight.js\");\nrequire(\"metaphorjs/src/func/dom/getWidth.js\");\nrequire(\"metaphorjs/src/func/dom/getHeight.js\");\nrequire(\"metaphorjs/src/func/dom/isAttached.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dialog.position.Abstract = cls({\n\n    dialog: null,\n    positionBase: null,\n    correct: \"solid\",\n\n    $init: function(dialog) {\n        var self = this;\n        self.dialog = dialog;\n        extend(self, dialog.getCfg().position, true, false);\n\n        self.onWindowResizeDelegate = bind(self.onWindowResize, self);\n        self.onWindowScrollDelegate = bind(self.onWindowScroll, self);\n\n        if (self.type === \"auto\") {\n            self.type = null;\n        }\n\n        var pt = self.preferredType || self.type;\n        if (typeof pt === \"string\") {\n            var pts = self.getAllPositions(),\n                inx;\n            if ((inx = pts.indexOf(pt)) !== -1) {\n                pts.splice(inx, 1);\n                pts.unshift(pt);\n            }\n            self.preferredType = pts;\n            !self.type && (self.type = pts[0]);\n        }\n        else if (!pt) {\n            self.preferredType = self.getAllPositions();\n            !self.type && (self.type = self.preferredType[0]);\n        }\n        else {\n            !self.type && (self.type = self.preferredType[0]);\n        }\n\n        dialog.on(\"reposition\", self.onReposition, self);\n        dialog.on(\"show-after-delay\", self.onShowAfterDelay, self);\n        dialog.on(\"hide-after-delay\", self.onHideAfterDelay, self);\n\n        if (dialog.isVisible()) {\n            self.onShowAfterDelay();\n        }\n\n    },\n\n\n    getPositionBase: function() {\n\n        var self = this,\n            dlg = self.dialog;\n\n        if (self.positionBase) {\n            return self.positionBase;\n        }\n        var b;\n        if (b = dlg.getCfg().position.base) {\n            if (typeof b === \"string\") {\n                self.positionBase = MetaphorJs.dom.select(b).shift();\n            }\n            else {\n                self.positionBase = b;\n            }\n            return self.positionBase;\n        }\n        return null;\n    },\n\n    getBoundary: function() {\n\n        var self    = this,\n            base    = self.getPositionBase(),\n            sx      = self.screenX || 0,\n            sy      = self.screenY || 0,\n            w, h,\n            st, sl,\n            ofs;\n\n        if (base) {\n            ofs = MetaphorJs.dom.getOffset(base);\n            w = MetaphorJs.dom.getOuterWidth(base);\n            h = MetaphorJs.dom.getOuterHeight(base);\n            return {\n                x: ofs.left + sx,\n                y: ofs.top + sy,\n                x1: ofs.left + w - sx,\n                y1: ofs.top + h - sy,\n                w: w,\n                h: h\n            };\n        }\n        else {\n            w = MetaphorJs.dom.getWidth(window);\n            h = MetaphorJs.dom.getHeight(window);\n            st = MetaphorJs.dom.getScrollTop(window);\n            sl = MetaphorJs.dom.getScrollLeft(window);\n            return {\n                x: sl + sx,\n                y: st + sy,\n                x1: sl + w - sx,\n                y1: st + h - sy,\n                w: w,\n                h: h\n            };\n        }\n    },\n\n\n    getPrimaryPosition: function(pos) {\n        return false;\n    },\n    getSecondaryPosition: function(pos) {\n        return false;\n    },\n\n    getAllPositions: function() {\n        return [];\n    },\n\n    correctPosition: function(e) {\n\n        var self        = this,\n            pri         = self.getPrimaryPosition(),\n            strategy    = self.correct;\n\n        if (!pri || !strategy) {\n            return;\n        }\n\n        var dlg         = self.dialog,\n            boundary    = self.getBoundary(),\n            size        = dlg.getDialogSize(),\n            pts         = self.preferredType,\n            pt          = pts[0],\n            i, l;\n\n        if (strategy && strategy !== \"none\") {\n            if (strategy && strategy != \"solid\") {\n                if (self.type != pt && self.checkIfFits(e, pt, boundary, size, false)) {\n                    self.changeType(pt);\n                    return self.fitToBoundary(self.getCoords(e), boundary, size);\n                }\n\n                if (self.checkIfFits(e, self.type, boundary, size, false)) {\n                    return self.fitToBoundary(self.getCoords(e), boundary, size);\n                }\n            }\n            if (strategy && strategy != \"position-only\") {\n                for (i = 0, l = pts.length; i < l; i++) {\n                    if (self.checkIfFits(e, pts[i], boundary, size, true)) {\n                        self.changeType(pts[i]);\n                        return self.getCoords(e);\n                    }\n                }\n            }\n        }\n\n        return self.getCoords(e);\n    },\n\n    checkIfFits: function(e, position, boundary, size, fully) {\n\n        var self    = this,\n            coords  = self.getCoords(e, position, true);\n\n        // leave only basic positions here\n        if (!fully && self.getSecondaryPosition(position)) {\n            return false;\n        }\n\n        if (fully) {\n            return !(coords.x < boundary.x ||\n                     coords.y < boundary.y ||\n                     coords.x + size.width > boundary.x1 ||\n                     coords.y + size.height > boundary.y1);\n        }\n        else {\n            var pri = self.getPrimaryPosition(position);\n            switch (pri) {\n                case \"t\":\n                    return coords.y >= boundary.y;\n                case \"r\":\n                    return coords.x + size.width <= boundary.x1;\n                case \"b\":\n                    return coords.y + size.height <= boundary.y1;\n                case \"l\":\n                    return coords.x >= boundary.x;\n            }\n        }\n    },\n\n    fitToBoundary: function(coords, boundary, size) {\n\n        var self = this,\n            base = self.getPositionBase(),\n            x = base ? 0 : boundary.x,\n            y = base ? 0 : boundary.y,\n            x1 = base ? boundary.w : boundary.x1,\n            y1 = base ? boundary.h : boundary.y1,\n            xDiff = 0,\n            yDiff = 0,\n            pointer = self.dialog.getPointer();\n\n        if (coords.x < x) {\n            xDiff = coords.x - x;\n            coords.x = x;\n        }\n        if (coords.y < y) {\n            yDiff = coords.y - y;\n            coords.y = y;\n        }\n        if (coords.x + size.width > x1) {\n            xDiff = (coords.x + size.width) - x1;\n            coords.x -= xDiff;\n        }\n        if (coords.y + size.height > y1) {\n            yDiff = (coords.y + size.height) - y1;\n            coords.y -= yDiff;\n        }\n\n        pointer.setCorrectionOffset(xDiff, yDiff);\n        pointer.reposition();\n\n        return coords;\n    },\n\n    changeType: function(type) {\n        var self = this,\n            dlg = self.dialog,\n            pointer = dlg.getPointer();\n\n        self.type = type;\n        pointer.setType(null, null);\n    },\n\n    onReposition: function(dlg, e) {\n\n        var self    = this,\n            coords;\n\n        // cannot calculate and apply position\n        if (!dlg.node || !MetaphorJs.dom.isAttached(dlg.node)) {\n            return;\n        }\n\n        if (self.screenX !== false || self.screenY !== false) {\n            coords  = self.correctPosition(e);\n        }\n        else {\n            coords  = self.getCoords(e);\n        }\n\n        self.apply(coords);\n    },\n\n    getCoords: function(e){\n        return {\n            x: 0,\n            y: 0\n        }\n    },\n\n    apply: function(coords) {\n\n        if (!coords) {\n            return;\n        }\n\n        if (isNaN(coords.x) || isNaN(coords.y)) {\n            return;\n        }\n\n        var self    = this,\n            dlg     = self.dialog,\n            axis    = dlg.getCfg().position.axis,\n            pos     = {};\n\n        axis != \"y\" && (pos.left = coords.x + \"px\");\n        axis != \"x\" && (pos.top = coords.y + \"px\");\n\n        MetaphorJs.dom.setStyle(dlg.getElem(), pos);\n    },\n\n    onWindowResize: function(e) {\n        this.dialog.reposition(MetaphorJs.dom.normalizeEvent(e));\n    },\n\n    onWindowScroll: function(e) {\n        this.dialog.reposition(MetaphorJs.dom.normalizeEvent(e));\n    },\n\n    onShowAfterDelay: function() {\n        var self = this;\n\n        if (self.resize || self.screenX || self.screenY) {\n            MetaphorJs.dom.addListener(window, \"resize\", self.onWindowResizeDelegate);\n        }\n\n        if (self.scroll || self.screenX || self.screenY) {\n            MetaphorJs.dom.addListener(self.dialog.getScrollEl(self.scroll), \"scroll\", self.onWindowScrollDelegate);\n        }\n    },\n\n    onHideAfterDelay: function() {\n\n        var self = this;\n\n        if (self.resize || self.screenX || self.screenY) {\n            MetaphorJs.dom.removeListener(window, \"resize\", self.onWindowResizeDelegate);\n        }\n\n        if (self.scroll || self.screenX || self.screenY) {\n            MetaphorJs.dom.removeListener(self.dialog.getScrollEl(self.scroll), \"scroll\", self.onWindowScrollDelegate);\n        }\n    },\n\n    onDestroy: function() {\n\n        var self = this,\n            dlg = self.dialog;\n\n        MetaphorJs.dom.removeListener(window, \"resize\", self.onWindowResizeDelegate);\n        MetaphorJs.dom.removeListener(dlg.getScrollEl(self.scroll), \"scroll\", self.onWindowScrollDelegate);\n\n        dlg.un(\"reposition\", self.onReposition, self);\n        dlg.un(\"show-after-delay\", self.onShowAfterDelay, self);\n        dlg.un(\"hide-after-delay\", self.onHideAfterDelay, self);\n\n        if (dlg.isVisible()) {\n            self.onHideAfterDelay();\n        }\n    }\n\n\n\n});\n\n","\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nrequire(\"../../__init.js\");\nrequire(\"./Abstract.js\");\n\nmodule.exports = MetaphorJs.dialog.position.Custom = \n                    MetaphorJs.dialog.position.Abstract.$extend({\n\n    getCoords: function(e) {\n        var dlg = this.dialog;\n        return this.get.call(dlg.$$callbackContext || this, dlg, e);\n    }\n});\n\n","\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nrequire(\"../../__init.js\");\nrequire(\"./Abstract.js\");\nrequire(\"metaphorjs/src/func/dom/getOffset.js\");\n\nmodule.exports = MetaphorJs.dialog.position.Draggable = \n                    MetaphorJs.dialog.position.Abstract.$extend({\n\n\n    getCoords: function(e) {\n        var dlg = this.dialog;\n        if (this.get) {\n            return this.get.call(dlg.$$callbackContext, dlg, e);\n        }\n        else {\n            // if node is not yet visible,\n            // we try to extract position from style\n            if (!MetaphorJs.dom.isVisible(dlg.getElem())) {\n                var elem = dlg.getElem(),\n                    left = elem.style.left,\n                    top = elem.style.top;\n\n                if (left && top) {\n                    return {\n                        x: parseInt(left),\n                        y: parseInt(top)\n                    }\n                }\n            }\n            \n            // otherwise get element offset\n            var ofs = MetaphorJs.dom.getOffset(dlg.getElem());\n            return {\n                x: ofs.left,\n                y: ofs.top\n            }\n        }\n    },\n\n    correctPosition: function(e) {\n        var self        = this,\n            dlg         = self.dialog,\n            boundary    = self.getBoundary(),\n            size        = dlg.getDialogSize();\n\n        if (!self.checkIfFits(e, self.type, boundary, size, true)) {\n            return self.fitToBoundary(self.getCoords(e), boundary, size);\n        }\n\n        return self.getCoords(e);\n    }\n});\n\n","\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\");\n\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/func/dom/normalizeEvent.js\");\nrequire(\"metaphorjs/src/func/dom/addListener.js\");\nrequire(\"metaphorjs/src/func/dom/removeListener.js\");\nrequire(\"metaphorjs/src/func/dom/getOffset.js\");\nrequire(\"./Target.js\");\n\n\nmodule.exports = MetaphorJs.dialog.position.Mouse = MetaphorJs.dialog.position.Target.$extend({\n\n    correct: \"position\",\n\n    $init: function(dialog) {\n\n        var self = this;\n\n        self.onMouseMoveDelegate = bind(self.onMouseMove, self);\n        self.$super(dialog);\n    },\n\n    getCoords: function(e, type, absolute) {\n\n        if (!e) {\n            return null;\n        }\n\n        var self    = this,\n            origType= type || self.type,\n            dlg     = self.dialog,\n            cfg     = dlg.getCfg(),\n            size    = dlg.getDialogSize(),\n            base    = self.getPositionBase(),\n            pos     = {},\n            type    = (type || self.type).substr(1),\n            offsetX = cfg.position.offsetX,\n            offsetY = cfg.position.offsetY,\n            axis    = cfg.position.axis,\n            pntOfs  = dlg.getPointer().getDialogPositionOffset(origType),\n            absOfs  = {x: 0, y: 0};\n\n        if (!absolute && base) {\n            var baseOfs = MetaphorJs.dom.getOffset(base);\n            absOfs.x = baseOfs.left;\n            absOfs.y = baseOfs.top;\n        }\n\n        switch (type) {\n            case \"\": {\n                pos     = self.get.call(dlg.$$callbackContext, dlg, e, type, absolute);\n                break;\n            }\n            case \"c\": {\n                pos.y   = e.pageY - absOfs.y - (size.height / 2);\n                pos.x   = e.pageX - absOfs.x - (size.width / 2);\n                break;\n            }\n            case \"t\": {\n                pos.y   = e.pageY - absOfs.y - size.height - offsetY;\n                pos.x   = e.pageX - absOfs.x - (size.width / 2);\n                break;\n            }\n            case \"r\": {\n                pos.y   = e.pageY - absOfs.y - (size.height / 2);\n                pos.x   = e.pageX - absOfs.x + offsetX;\n                break;\n            }\n            case \"b\": {\n                pos.y   = e.pageY - absOfs.y + offsetY;\n                pos.x   = e.pageX - absOfs.x - (size.width / 2);\n                break;\n            }\n            case \"l\": {\n                pos.y   = e.pageY - absOfs.y - (size.height / 2);\n                pos.x   = e.pageX - absOfs.x - size.width - offsetX;\n                break;\n            }\n            case \"rt\": {\n                pos.y   = e.pageY - absOfs.y - size.height - offsetY;\n                pos.x   = e.pageX - absOfs.x + offsetX;\n                break;\n            }\n            case \"rb\": {\n                pos.y   = e.pageY - absOfs.y + offsetY;\n                pos.x   = e.pageX - absOfs.x + offsetX;\n                break;\n            }\n            case \"lt\": {\n                pos.y   = e.pageY - absOfs.y - size.height - offsetY;\n                pos.x   = e.pageX - absOfs.x - size.width - offsetX;\n                break;\n            }\n            case \"lb\": {\n                pos.y   = e.pageY - absOfs.y + offsetY;\n                pos.x   = e.pageX - absOfs.x - size.width - offsetX;\n                break;\n            }\n        }\n\n        if (pntOfs) {\n            pos.x += pntOfs.x;\n            pos.y += pntOfs.y;\n        }\n\n        if (axis) {\n            var tp = self.$super(e, type);\n            if (tp) {\n                if (axis == \"x\") {\n                    pos.y = tp.y;\n                }\n                else {\n                    pos.x = tp.x;\n                }\n            }\n        }\n\n        return pos;\n    },\n\n    onShowAfterDelay: function() {\n        var self = this;\n        self.$super();\n        MetaphorJs.dom.addListener(window.document.documentElement, \"mousemove\", self.onMouseMoveDelegate);\n    },\n\n    onHideAfterDelay: function() {\n        var self = this;\n        self.$super();\n        MetaphorJs.dom.removeListener(window.document.documentElement, \"mousemove\", self.onMouseMoveDelegate);\n    },\n\n    onMouseMove: function(e) {\n        this.dialog.reposition(MetaphorJs.dom.normalizeEvent(e));\n    },\n\n    getPrimaryPosition: function(pos) {\n        return (pos || this.type).substr(1, 1);\n    },\n\n    getSecondaryPosition: function(pos) {\n        return (pos || this.type).substr(2);\n    },\n\n    getAllPositions: function() {\n        return [\"mt\", \"mr\", \"mb\", \"ml\", \"mrt\", \"mrb\", \"mlb\", \"mlt\"];\n    }\n});\n\n","\nrequire(\"../../__init.js\");\nrequire(\"./Abstract.js\");\nrequire(\"metaphorjs/src/func/dom/getOffset.js\");\nrequire(\"metaphorjs/src/func/dom/removeStyle.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dialog.position.None = \n                    MetaphorJs.dialog.position.Abstract.$extend({\n\n    $init: function(dialog) {\n\n        this.$super(dialog);\n        MetaphorJs.dom.removeStyle(dialog.getElem(), \"left\");\n        MetaphorJs.dom.removeStyle(dialog.getElem(), \"top\");\n    },\n\n    getCoords: function(e) {\n        var dlg = this.dialog,\n            ofs = MetaphorJs.dom.getOffset(dlg.getElem());\n        return {\n            x: ofs.left,\n            y: ofs.top\n        };\n    },\n\n    apply: function() {\n\n    },\n\n    correctPosition: function(e) {\n        return this.getCoords(e);\n    }\n});","\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nrequire(\"metaphorjs/src/func/dom/getOffset.js\");\nrequire(\"metaphorjs/src/func/dom/getPosition.js\");\nrequire(\"./Abstract.js\");\n\nmodule.exports = MetaphorJs.dialog.position.Target = \n                MetaphorJs.dialog.position.Abstract.$extend({\n\n    getCoords: function(e, type, absolute) {\n\n        var self    = this,\n            dlg     = self.dialog,\n            cfg     = dlg.getCfg(),\n            target  = dlg.getTarget();\n\n        if (!target) {\n            return null;\n        }\n\n        type    = type || self.type;\n\n        var pBase   = self.getPositionBase(),\n            size    = dlg.getDialogSize(),\n            offset  = pBase && !absolute ?\n                        MetaphorJs.dom.getPosition(target, pBase) :\n                        MetaphorJs.dom.getOffset(target),\n            tsize   = dlg.getTargetSize(),\n            pos     = {},\n            pri     = type.substr(0, 1),\n            sec     = type.substr(1),\n            offsetX = cfg.position.offsetX,\n            offsetY = cfg.position.offsetY,\n            pntOfs  = dlg.pointer.getDialogPositionOffset(type);\n\n        switch (pri) {\n            case \"t\": {\n                pos.y   = offset.top - size.height - offsetY;\n                break;\n            }\n            case \"r\": {\n                pos.x   = offset.left + tsize.width + offsetX;\n                break;\n            }\n            case \"b\": {\n                pos.y   = offset.top + tsize.height + offsetY;\n                break;\n            }\n            case \"l\": {\n                pos.x   = offset.left - size.width - offsetX;\n                break;\n            }\n        }\n\n        switch (sec) {\n            case \"t\": {\n                pos.y   = offset.top + offsetY;\n                break;\n            }\n            case \"r\": {\n                pos.x   = offset.left + tsize.width - size.width - offsetX;\n                break;\n            }\n            case \"b\": {\n                pos.y   = offset.top + tsize.height - size.height - offsetY;\n                break;\n            }\n            case \"l\": {\n                pos.x   = offset.left + offsetX;\n                break;\n            }\n            case \"rc\": {\n                pos.x   = offset.left + tsize.width + offsetX;\n                break;\n            }\n            case \"lc\": {\n                pos.x   = offset.left - size.width - offsetX;\n                break;\n            }\n            case \"\": {\n                switch (pri) {\n                    case \"t\":\n                    case \"b\": {\n                        pos.x   = offset.left + (tsize.width / 2) -\n                                    (size.width / 2);\n                        break;\n                    }\n                    case \"r\":\n                    case \"l\": {\n                        pos.y   = offset.top + (tsize.height / 2) -\n                                    (size.height / 2);\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n\n        if (pntOfs) {\n            pos.x += pntOfs.x;\n            pos.y += pntOfs.y;\n        }\n\n        return pos;\n    },\n\n    getPrimaryPosition: function(pos) {\n        return (pos || this.type || \"\").substr(0, 1);\n    },\n\n    getSecondaryPosition: function(pos) {\n        return (pos || this.type || \"\").substr(1);\n    },\n\n    getAllPositions: function() {\n        return [\"t\", \"r\", \"b\", \"l\", \"tl\", \"tr\", \"rt\", \"rb\",\n                \"br\", \"bl\", \"lb\", \"lt\", \"tlc\", \"trc\", \"brc\", \"blc\"];\n    }\n\n});\n\n","\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/func/dom/getScrollTop.js\");\nrequire(\"metaphorjs/src/func/dom/getScrollLeft.js\");\nrequire(\"metaphorjs/src/func/dom/getOuterWidth.js\");\nrequire(\"metaphorjs/src/func/dom/getOuterHeight.js\");\nrequire(\"./Abstract.js\");\n\nmodule.exports = MetaphorJs.dialog.position.Window = MetaphorJs.dialog.position.Abstract.$extend({\n\n    getCoords: function(e, type) {\n\n        var self    = this,\n            dlg     = self.dialog,\n            pBase   = self.getPositionBase() || window,\n            size    = dlg.getDialogSize(),\n            pos     = {},\n            type    = (type || self.type).substr(1),\n            offsetX = self.offsetX,\n            offsetY = self.offsetY,\n            st      = MetaphorJs.dom.getScrollTop(pBase),\n            sl      = MetaphorJs.dom.getScrollLeft(pBase),\n            ww      = MetaphorJs.dom.getOuterWidth(pBase),\n            wh      = MetaphorJs.dom.getOuterHeight(pBase);\n\n        switch (type) {\n            case \"c\": {\n                pos.y   = (wh / 2) - (size.height / 2) + st + offsetY;\n                pos.x   = (ww / 2) - (size.width / 2) + sl + offsetX;\n                break;\n            }\n            case \"t\": {\n                pos.y   = st + offsetY;\n                pos.x   = (ww / 2) - (size.width / 2) + sl + offsetX;\n                break;\n            }\n            case \"r\": {\n                pos.y   = (wh / 2) - (size.height / 2) + st - offsetY;\n                pos.x   = ww - size.width + sl - offsetX;\n                break;\n            }\n            case \"b\": {\n                pos.y   = wh - size.height + st - offsetY;\n                pos.x   = (ww / 2) - (size.width / 2) + sl + offsetX;\n                break;\n            }\n            case \"l\": {\n                pos.y   = (wh / 2) - (size.height / 2) + st + offsetY;\n                pos.x   = sl + offsetX;\n                break;\n            }\n            case \"rt\": {\n                pos.y   = st + offsetY;\n                pos.x   = ww - size.width + sl - offsetX;\n                break;\n            }\n            case \"rb\": {\n                pos.y   = wh - size.height + st - offsetY;\n                pos.x   = ww - size.width + sl - offsetX;\n                break;\n            }\n            case \"lt\": {\n                pos.y   = st + offsetY;\n                pos.x   = sl + offsetX;\n                break;\n            }\n            case \"lb\": {\n                pos.y   = wh - size.height + st - offsetY;\n                pos.x   = sl + offsetX;\n                break;\n            }\n        }\n\n        return pos;\n    },\n\n    getPrimaryPosition: function(type) {\n        return (type || this.type).substr(1, 1);\n    },\n\n    getSecondaryPosition: function(type) {\n        return (type || this.type).substr(2);\n    },\n\n\n    getAllPositions: function() {\n        return [\"wt\", \"wr\", \"wb\", \"wl\", \"wrt\", \"wrb\", \"wlb\", \"wlt\", \"wc\"];\n    },\n\n    correctPosition: function(e) {\n        return this.getCoords(e);\n    }\n\n});\n\n","\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"../dialog/Dialog.js\");\nrequire(\"metaphorjs/src/func/dom/getParentDocument.js\");\n\nconst Directive = require(\"metaphorjs/src/app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    isThenable = require(\"metaphorjs-shared/src/func/isThenable.js\"),\n    ns = require(\"metaphorjs-namespace/src/var/ns.js\");\n\nDirective.registerAttribute(\"dropdown\", 1100,\n    Directive.$extend({\n        $class: \"MetaphorJs.app.Directive.attr.Dropdown\",\n        id: \"dropdown\",\n\n        _autoOnChange: false,\n        _dialog: null,\n        _contentNode: null,\n        _hostCmp: null,\n        _contentCmp: null,\n\n        _asyncInit: true,\n\n        initConfig: function() {\n            this.$super();\n            MetaphorJs.app.Directive.attr.Dropdown.initConfig(this.config);\n        },\n\n        initDirective: function() {\n\n            var self = this,\n                config = self.config,\n                state = self.state,\n                ref = config.get(\"ref\"),\n                cmpid = config.get(\"cmp\"),\n                selector = config.get(\"selector\"),\n                doc = MetaphorJs.dom.getParentDocument(self.node),\n                cmp;\n\n            if (self.component) {\n                if (ref) {\n                    cmp = self.component.getRefCmp(ref) || \n                            self.component.getRefCmpPromise(ref);\n                }\n                else if (cmpid) {\n                    if (typeof cmpid === \"string\") {\n                        if (state.$app) {\n                            cmp = state.$app.getCmp(cmpid) ||\n                                    state.$app.onAvailable(cmpid);\n                        }\n                    }\n                    else {\n                        cmp = cmpid;\n                    }\n                }\n                else if (selector) {\n                    self._contentNode = doc.querySelector(selector);    \n                }\n\n                if (cmp) {\n                    if (isThenable(cmp)) {\n                        cmp.done(function(component) {\n                            self._contentCmp = component;\n                            self._contentNode = component.getRefEl(\"main\");\n                        });\n                        cmp.done(self._initDialog, self);\n                    }\n                    else {\n                        self._contentCmp = cmp;\n                        self._contentNode = cmp.getRefEl(\"main\");\n                        self._initDialog();\n                    }\n                }\n            }\n            else {\n                self._contentNode = doc.getElementById(ref);\n                self._initDialog();\n            }\n\n            self.$super();\n        },\n\n        initChange: function(){\n            // skip setting onChange listener\n        },\n\n        _initDialog: function() {\n            var self = this;\n            if (!self._dialog) {\n                var cls = ns.get(self.config.get(\"dialog\")),\n                    cfg = self._getDialogConfig();\n                self._dialog = new cls(cfg);\n                self.$$observable.relayEvent(self._dialog, \"*\");\n                self._dialog.on(\"*\", self.state.$check, self.state);\n            }\n\n            return this._dialog;\n        },\n\n        _getDialogConfig: function() {\n            var self = this,\n                config = self.config,\n                cfgCfg = config.get(\"config\"),\n                on = config.get(\"on\"),\n                un = config.get(\"un\"),\n                appendTo = config.get(\"appendTo\"),\n                position = config.get(\"position\"),\n                animate = config.get(\"animate\"),\n                opposite = {\n                    \"click\": \"click\",\n                    \"mouseover\": \"mouseout\"\n                };\n\n            if (appendTo && typeof appendTo === \"string\") {\n                appendTo = window.document.querySelector(appendTo);\n            }\n\n            var defCfg = {\n                preset: config.get(\"preset\") || null,\n                target: self.node,\n                content: false,\n                render: {\n                    el: self._contentNode,\n                    keepInDOM: true,\n                    appendTo: appendTo || false\n                },\n                position: position || false\n            };\n\n            if (on === \"click\") {\n                extend(defCfg, {\n                    events: {\n                        show: {\n                            \"click\": {\n                                stopPropagation: true,\n                                preventDefault: true\n                            }\n                        },\n                        hide: {\n                            click: {\n                                stopPropagation: false,\n                                preventDefault: false\n                            }\n                        }\n                    },\n                    toggle: {\n                        events: {\n                            _target: on\n                        }\n                    },\n                    hide: {\n                        animate: animate,\n                        events: {\n                            _html: \"click\"\n                        }\n                    },\n                    show: {\n                        animate: animate\n                    }\n                });\n            }\n            else if (on === \"mouseover\") {\n                extend(defCfg, {\n                    show: {\n                        animate: animate,\n                        events: {\n                            _target: on,\n                            _self: on\n                        }\n                    },\n                    hide: {\n                        animate: animate,\n                        events: {\n                            _target: un || opposite[on]\n                        }\n                    }\n                });\n            }\n\n            var cfg = extend({}, cfgCfg, defCfg, true, true);\n            return cfg;\n        },\n\n        onDestroy: function() {\n            if (this._dialog) {\n                this._dialog.$destroy();\n            }\n            this.$super();\n        }\n    },\n    \n    {\n        initConfig: function(config) {\n            var s = MetaphorJs.lib.Config.MODE_STATIC;\n            config.disableProperty(\"value\");\n            config.setDefaultMode(\"ref\", s);\n            config.setDefaultMode(\"selector\", s);\n            config.setDefaultMode(\"cmp\", s);\n            config.setDefaultMode(\"dialog\", s);\n            config.setDefaultMode(\"on\", s);\n            config.setDefaultMode(\"un\", s);\n            config.setDefaultMode(\"appendTo\", s);\n            config.setDefaultMode(\"position\", s);\n            config.setDefaultMode(\"preset\", s);\n            config.setType(\"animate\", \"bool\", s);\n            config.setDefaultValue(\"dialog\", \"MetaphorJs.dialog.Dialog\");\n            config.setDefaultValue(\"on\", \"click\");\n        }\n    })\n\n);\n","\nrequire(\"../__init.js\");\nrequire(\"metaphorjs/src/lib/DomEvent.js\");\nrequire(\"../dialog/Dialog.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\");\n\n\nmodule.exports = MetaphorJs.mixin.Dialog = {\n    dialog: null,\n    dialogPreset: null,\n    dialogCfg: null,\n\n    _hidden: true,\n    autoRender: true,\n\n    target: null,\n    isTooltip: false,\n\n    $beforeInit: function(cfg) {\n\n        var self = this;\n\n        self.autoRender = true;\n\n        if ((!cfg || !cfg.node) && \n            !self.template && \n            (!cfg || !cfg.template)) {\n            self.node = window.document.createElement(\"div\");\n        }\n\n        self.$intercept(\n            \"_onRenderingFinished\", \n            self._onDialogRenderingFinished, \n            self,\n            \"after\"\n        );\n    },\n\n    $beforeDestroy: function() {\n        if (this.dialog) {\n            this.dialog.$destroy();\n        }\n    },\n\n    getDialogCfg: function() {\n\n        var self    = this;\n\n        return extend({}, self.dialogCfg, {\n            preset: self.dialogPreset,\n            render: {\n                el: self.getRefEl(\"main\"),\n                keepInDOM: true,\n                appendTo: false,\n                lazy: false\n            }\n        }, true, true);\n    },\n\n    getDialog: function() {\n        return this.dialog;\n    },\n\n\n\n    _onDialogRenderingFinished: function() {\n        var self = this, i, l, items = self.items;\n\n        if (items) {\n            // insert all placeholders, but\n            // attach only resolved items\n            for (i = -1, l = items.length; ++i < l;){\n                self._putItemInPlace(items[i]);\n            }\n        }\n\n        this._createDialog();  \n    },\n\n    _createDialog: function() {\n        var self    = this;\n        self.dialog = new MetaphorJs.dialog.Dialog(self.getDialogCfg());\n        self.dialog.on(\"show\", self.onDialogShow, self);\n        self.dialog.on(\"hide\", self.onDialogHide, self);\n        self.dialog.on(\"before-show\", self.onBeforeDialogShow, self);\n        self.dialog.on(\"before-hide\", self.onBeforeDialogHide, self);\n        self.dialog.on(\"destroy\", self.onDialogDestroy, self);\n        self.dialog.on(\"attached\", self.onDialogAttached, self);\n\n        if (!self._hidden) {\n            self.show();\n        }\n    },\n\n    show: function(e) {\n        if (e && !(e instanceof MetaphorJs.lib.DomEvent)) {\n            e = null;\n        }\n\n        if (this.dialog) {\n            this.dialog.show(e);\n        }\n        else this._hidden = false;\n    },\n\n    hide: function(e) {\n        if (e && !(e instanceof MetaphorJs.lib.DomEvent)) {\n            e = null;\n        }\n\n        if (this.dialog) {\n            this.dialog.hide(e);\n        }\n        else this._hidden = true;\n    },\n\n\n    onDialogAttached: function() {\n        if (!this._attached) {\n            this.render(this.node.parentNode);\n        }\n    },\n\n    onBeforeDialogShow: function() {\n        var self = this;\n        if (!self._rendered) {\n            self.render();\n        }\n        else if (!self._attached && self.renderTo) {\n            self.attach(self.renderTo, self.renderBefore);\n        }\n\n        self._hidden = false;\n    },\n\n    onDialogShow: function() {\n        var self = this;\n        self.trigger(\"show\", self);\n    },\n\n    onBeforeDialogHide: function() {},\n\n    onDialogHide: function() {\n        var self = this;\n        if (!self.$destroyed) {\n            self._hidden = true;\n            self.trigger(\"hide\", self);\n        }\n    },\n\n    onDialogDestroy: function() {\n        var self    = this;\n\n        if (!self.$destroying) {\n            self.dialog = null;\n            self.$destroy();\n        }\n    }\n\n}","const MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nMetaphorJs.model = MetaphorJs.model || {};","\nrequire(\"metaphorjs/src/app/StoreRenderer.js\");\nrequire(\"metaphorjs/src/directive/attr/each.js\");\nrequire(\"../../model/Store.js\");\n\nconst Directive = require(\"metaphorjs/src/app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nDirective.getDirective(\"attr\", \"each\")\n    .registerType(MetaphorJs.model.Store, MetaphorJs.app.StoreRenderer);\n\n","\nconst extend  = require(\"metaphorjs-shared/src/func/extend.js\"),\n    cls = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    isString = require(\"metaphorjs-shared/src/func/isString.js\"),\n    isFunction = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    isThenable = require(\"metaphorjs-shared/src/func/isThenable.js\");\n\nrequire(\"../__init.js\");\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");\n\n\nmodule.exports = MetaphorJs.model.Model = function(){\n\n    let instances   = {},\n        cache       = {};\n\n    /**\n     * @class MetaphorJs.model.Model\n     */\n    return cls({\n\n        $mixins:        [MetaphorJs.mixin.Observable],\n\n        type:           null,\n        fields:         null,\n        record:         null,\n        store:          null,\n        plain:          false,\n\n        lastFetchedResponse: null,\n\n\n\n        /**\n         * @constructor\n         * @method $init\n         * @param {object} cfg {\n         *      Properties \n         *      <code>json,id,url,fn,data,success,extra,root,data,\n         *              processRequest,validate,resolve</code> are valid \n         *      on the top level and inside all create/load/save/delete/controller\n         *      groups.<br> Use string or function instead of object as shortcut\n         *      for load.url/save.url/load.fn/save.fn etc.\n         * \n         *      @type {string} type Record class\n         *      @type {object} fields {\n         *          Fields conf\n         *          @type {object|string} *name* {\n         *              Field name: conf\n         *              @type {string} type {\n         *                  int|bool|boolean|double|float|date\n         *              }\n         *              @type {function} parseFn {\n         *                  Parse date field\n         *                  @param {string} value\n         *                  @param {string} format Format from this config\n         *              }\n         *              @type {function} formatFn {\n         *                  Prepare date field for sending\n         *                  @param {*} value\n         *                  @param {string} format Format from this config\n         *              }\n         *              @type {string} format Date format {\n         *                  If format == \"timestamp\", <code>date = parseInt(value) * 1000</code>\n         *              }\n         *              @type {function} restore {\n         *                  Custom value processor (on receiving). Another way is to override\n         *                  <code>onRestoreField(rec, name, value)</code> method\n         *                  @param {object} rec Record from response\n         *                  @param {*} value Data value\n         *                  @param {string} name Field name\n         *                  @returns {*}\n         *              }\n         *              @type {function} store {\n         *                  Custom value processor (on sending). Another way is to override\n         *                  <code>onStoreField(rec, value, name)</code> method.\n         *                  @param {object} rec \n         *                  @param {*} value\n         *                  @param {string} name\n         *                  @returns {string}\n         *              }\n         *          }\n         *      }\n         *      \n         *      @type {bool} json Send data as json string in the request body.\n         *      @type {string} url Api endpoint.\n         *                      In url you can use <code>:name</code> placeholders,\n         *                      they will be taken from payload.\n         *      @type {function} fn Optional function that performs request.\n         *                       It accepts payload and returns Promise which\n         *                          is then resolved with response. \n         *      @type {string} id Id field. Where to take record id from or \n         *                      put record id to (when sending).\n         *      @type {string|function} success Success field or function\n         *                     that takes response and returns boolean. \n         *                     If resulted in false, request fails. Leave\n         *                     undefined to skip this check.\n         *      @type {object} data Main data payload.\n         *      @type {object} extra Extra params object. Adds data to payload, \n         *                          overrides data fields.\n         *      @type {string} root Records root. In \"load\" requests this is\n         *                          the field to take records from,\n         *                          in other requests (if defined) this will be the field\n         *                          to put payload into.\n         *      @type {object} remote Various fetch settings\n         *      @type {function} processRequest {\n         *          Custom request processor.\n         *          @param {MetaphorJs.lib.Promise} returnPromise The promise \n         *                          that is returned from load()/save() etc. \n         *                          You can take control of this promise if needed.\n         *          @param {int|string|null} id Record id (if applicable)\n         *          @param {object|string|null} data Payload\n         *      }\n         *      @type {function} validate {\n         *          Validate request\n         *          @param {int|string|null} id Record id (if applicable)\n         *          @param {object|string|null} data Payload\n         *          @returns {boolean} Return false to cancel the request and \n         *                              reject promise.\n         *      }\n         *      @type {function} resolve {\n         *          Custom request resolver\n         *          @param {int|string|null} id Record id (if applicable)\n         *          @param {object|string|null} data Payload\n         *          @returns {MetaphorJs.lib.Promise|*} If returned Promise, \n         *              this promise will be returned from the function making\n         *              the request. If returned something else, \n         *              will return a new Promise resolved with this value. \n         *              If returned nothing, will continue making the request\n         *              as usual.\n         *      }\n         * \n         *      @type {object} record {\n         *          @type {string|object} create New record config\n         *          @type {string|object} load Load one record config\n         *          @type {string|object} save Save one record config\n         *          @type {string|object} delete Delete one record config\n         *          @type {object} extend {\n         *              Use properties of this object to extend every\n         *              received record. If you don't want to create\n         *              a whole record class but want to add a few \n         *              methods to a record object.\n         *          }\n         *      }\n         *      @type {object} store {\n         *          @type {string} total Total count of records field\n         *          @type {string} start Start field: pagination offset\n         *          @type {string} limit Limit field: pagination per page\n         *          @type {string|object} load Load multiple records\n         *          @type {string|object} save Save multiple records\n         *          @type {string|object} delete Delete multiple records\n         *      }\n         * \n         *      @type {object} controller {\n         *          @type {object} *name* {\n         *              Controller config (<code>id,root,data,success</code> etc).<br>\n         *              Called via <code>model.runController(\"name\")</code>\n         *          }\n         *      }\n         * }\n         * @code src-docs/snippets/model.js\n         * @code src-docs/snippets/controller.js\n         */\n        $init: function(cfg) {\n\n            let defaults    = {\n                    record: {\n                        load:       null,\n                        save:       null,\n                        \"delete\":   null,\n                        id:         null,\n                        data:       null,\n                        success:    null,\n                        extra:      {}\n                    },\n\n                    store: {\n                        load:       null,\n                        save:       null,\n                        \"delete\":   null,\n                        id:         null,\n                        data:       null,\n                        total:      null,\n                        start:      null,\n                        limit:      null,\n                        success:    null,\n                        extra:      {}\n                    }\n                };\n\n\n            if (!this.fields) {\n                this.fields = {};\n            }\n\n            extend(this, defaults, false, true);\n            extend(this, cfg, true, true);\n\n            this.plain = !this.type;\n        },\n\n        /**\n         * Do records within this model have type (config's \"type\" property) \n         * or are they plain objects\n         * @method\n         * @returns {bool}\n         */\n        isPlain: function() {\n            return this.plain;\n        },\n\n        /**\n         * Get config property related to specific record action \n         * (create/save/load/delete).If there is no such config,\n         * it will check a higher level config: <br>\n         * config.record.load.url or config.record.url or\n         * config.url\n         * @method\n         * @param {string} type create|load|save|delete\n         * @param {string} prop\n         * @returns {*}\n         * @code model.getRecordProp(\"load\", \"url\");\n         */\n        getRecordProp: function(type, prop) {\n            return this.getProp(\"record\", type, prop);\n        },\n\n        /**\n         * Set record config property. See getRecordProp and constructor's config.\n         * @method\n         * @param {string} prop\n         * @param {string|int|bool} value\n         */\n        setRecordProp: function(prop, value) {\n            this.record[prop] = value;\n        },\n\n        /**\n         * Get config property related to specific store action \n         * (save/load/delete). If there is no such config,\n         * it will check a higher level config: <br>\n         * config.store.load.url or config.store.url or\n         * config.url\n         * @method\n         * @param {string} type load|save|delete\n         * @param {string} prop\n         * @returns {*}\n         */\n        getStoreProp: function(type, prop) {\n            return this.getProp(\"store\", type, prop);\n        },\n\n        /**\n         * Set store config property. See getStoreProp and constructor's config.\n         * @method\n         * @param {string} prop\n         * @param {string|int|bool} value\n         */\n        setStoreProp: function(prop, value) {\n            this.store[prop] = value;\n        },\n\n\n        /**\n         * Get config property related to specific action \n         * (save/load/delete). If there is no such config,\n         * it will check a higher level config: <br>\n         * config.:what:.:type:.:prop: or config.:what:.:prop: or\n         * config.:prop:\n         * @method\n         * @param {string} what record|store\n         * @param {string} type create|load|save|delete\n         * @param {string} prop\n         * @returns {*}\n         */\n        getProp: function(what, type, prop) {\n            let profile = this[what];\n            return (profile[type] && profile[type][prop]) || profile[prop] || this[prop] || null;\n        },\n\n        /**\n         * Set config property. \n         * @method\n         * @param {string} prop\n         * @param {string|int|bool} value\n         */\n        setProp: function(prop, value) {\n            return this[prop] = value;\n        },\n\n        _prepareRequestUrl: function(url, data) {\n\n            url = url.replace(/:([a-z0-9_\\-]+)/gi, function(match, name){\n\n                let value = data[name];\n\n                if (value != undefined) {\n                    delete data[name];\n                    return value;\n                }\n                else {\n                    return match;\n                }\n\n            });\n\n            if (/:([a-z0-9_\\-]+)/.test(url)) {\n                return null;\n            }\n\n            return url;\n        },\n\n        _makeRequest: function(what, type, id, data) {\n\n            const profile     = this[what],\n                  idProp      = this.getProp(what, type, \"id\"),\n                  dataProp    = this.getProp(what, type, \"root\"),\n                  url         = this.getProp(what, type, \"url\"),\n                  isJson      = this.getProp(what, type, \"json\"),\n                  remoteCfg     = {};\n\n            let res;\n            let cfg = !isString(profile[type]) && !isFunction(profile[type]) ?\n                            extend({}, profile[type]) :\n                            profile[type];\n\n            if (!cfg) {\n                if (url) {\n                    cfg     = { url };\n                }\n                else {\n                    throw what + \".\" + type + \" not defined\";\n                }\n            }\n            else if (isString(cfg)) {\n                cfg = { url: cfg };\n            }\n            else if (isFunction(cfg)) {\n                cfg = { fn: cfg };\n            }\n\n            if (!cfg.url) {\n                if (!url && !cfg.fn) {\n                    throw what + \".\" + type + \" url not defined\";\n                }\n                url && (cfg.url = url);\n            }\n\n            remoteCfg.url = cfg.url;\n\n            if (cfg.remote) {\n                extend(remoteCfg, cfg.remote, true, false);\n            }\n\n            if (cfg.validate) {\n                res = cfg.validate.call(this, id, data);\n                if (res === false) {\n                    return MetaphorJs.lib.Promise.reject(res);\n                }\n            }\n\n            if (cfg.resolve) {\n                res = cfg.resolve.call(this, id, data);\n                if (res && isThenable(res)){\n                    return res;\n                }\n                else if (res) {\n                    return MetaphorJs.lib.Promise.resolve(res);\n                }\n            }\n\n            remoteCfg.data        = extend(\n                {},\n                cfg.data,\n                this.extra,\n                profile.extra,\n                profile[type] ? profile[type].extra : null,\n                remoteCfg.data,\n                data,\n                true,\n                true\n            );\n\n            if (cfg.fn) {\n                const df = what === \"controller\" ?\n                            cfg.fn(id, remoteCfg.data) :\n                            cfg.fn(remoteCfg.data),\n                      promise = new MetaphorJs.lib.Promise;\n\n                df.then(response => {\n                    if (what === \"record\") {\n                        this._processRecordResponse(type, response, promise);\n                    }\n                    else if (what === \"store\") {\n                        this._processStoreResponse(type, response, promise);\n                    }\n                    else if (what === \"controller\") {\n                        this._processControllerResponse(type, response, promise);\n                    }\n                });\n\n                return promise;\n            }\n            else if (!MetaphorJs.remote || !MetaphorJs.remote.fetch) {\n                console.error(\"MetaphorJs.remote.fetch is not available in this build\");\n            }\n\n            if (id && idProp) {\n                remoteCfg.data[idProp] = id;\n            }\n\n            if (data && dataProp && type !== \"load\") {\n                remoteCfg.data[dataProp] = data;\n            }\n\n            remoteCfg.url = this._prepareRequestUrl(remoteCfg.url, remoteCfg.data);\n\n            if (!remoteCfg.url) {\n                return MetaphorJs.lib.Promise.reject();\n            }\n\n            if (!remoteCfg.method) {\n                if (what !== \"controller\") {\n                    remoteCfg.method = type === \"load\" ? \"GET\" : \"POST\";\n                }\n                else {\n                    remoteCfg.method = \"GET\";\n                }\n            }\n\n            if (isJson && remoteCfg.data && remoteCfg.method !== 'GET') { // && cfg.type != 'GET') {\n                remoteCfg.contentType = \"text/plain\";\n                remoteCfg.data        = JSON.stringify(remoteCfg.data);\n            }\n\n            remoteCfg.context = this;\n\n            let returnPromise;\n\n            if (what === \"record\") {\n                remoteCfg.processResponse = (response, deferred) => {\n                    this.lastFetchedResponse = response;\n                    this._processRecordResponse(type, response, deferred);\n                };\n                returnPromise = this._processRecordRequest(\n                                    MetaphorJs.remote.fetch(remoteCfg), type, id, data);\n            }\n            else if (what === \"store\") {\n                remoteCfg.processResponse = (response, deferred) => {\n                    this.lastFetchedResponse = response;\n                    this._processStoreResponse(type, response, deferred);\n                };\n                returnPromise = this._processStoreRequest(\n                                    MetaphorJs.remote.fetch(remoteCfg), type, id, data);\n            }\n            else if (what === \"controller\") {\n                remoteCfg.processResponse = (response, deferred) => {\n                    this.lastFetchedResponse = response;\n                    this._processControllerResponse(type, response, deferred);\n                };\n                returnPromise = this._processControllerRequest(\n                                    MetaphorJs.remote.fetch(remoteCfg), type, id, data);\n            }\n\n            if (cfg.processRequest) {\n                cfg.processRequest.call(this, returnPromise, id, data);\n            }\n\n            return returnPromise;\n        },\n\n        _processRecordRequest: function(promise, type, id, data) {\n            return promise;\n        },\n\n        _processRecordResponse: function(type, response, df) {\n            let idProp      = this.getRecordProp(type, \"id\"),\n                dataProp    = this.getRecordProp(type, \"root\"),\n                data        = dataProp ? response[dataProp] : response,\n                id          = (data && data[idProp]) || response[idProp];\n\n            if (!this._getSuccess(\"record\", type, response)) {\n                df.reject(response);\n            }\n            else {\n                data = this.normalizeRecord(data);\n                data = this.extendPlainRecord(data);\n                df.resolve({ id, data });\n            }\n        },\n\n        _processStoreRequest: function(promise, type, id, data) {\n            return promise;\n        },\n\n        _processStoreResponse: function(type, response, df) {\n            const   dataProp    = this.getStoreProp(type, \"root\"),\n                    totalProp   = this.getStoreProp(type, \"total\"),\n                    data        = dataProp ? response[dataProp] : response,\n                    total       = totalProp ? response[totalProp] : null;\n\n            if (!this._getSuccess(\"store\", type, response)) {\n                df.reject(response);\n            }\n            else {\n                df.resolve({ data, total });\n            }\n        },\n\n        _processControllerRequest: function(promise, type, id, data) {\n            return promise;\n        },\n\n        _processControllerResponse: function(type, response, df) {\n            if (!this._getSuccess(\"controller\", type, response)) {\n                df.reject(response);\n            }\n            else {\n                df.resolve(response);\n            }\n        },\n\n        _getSuccess: function(what, type, response) {\n            const sucProp = this.getProp(what, type, \"success\");\n\n            if (typeof sucProp === \"function\") {\n                return sucProp(response);\n            }\n\n            if (sucProp && response[sucProp] != undefined) {\n                return response[sucProp];\n            }\n            else {\n                return true;\n            }\n        },\n\n        runController: function(name, id, data) {\n            return this._makeRequest(\"controller\", name, id, data);\n        },\n\n\n        /**\n         * @method\n         * @param {string|number} id Record id\n         * @returns {MetaphorJs.lib.Promise}\n         */\n        loadRecord: function(id) {\n            return this._makeRequest(\"record\", \"load\", id);\n        },\n\n        /**\n         * Send a create or save request with record data\n         * @method\n         * @param {MetaphorJs.model.Record} rec\n         * @param {array|null} keys\n         * @param {object|null} extra\n         * @returns {MetaphorJs.lib.Promise}\n         */\n        saveRecord: function(rec, keys, extra) {\n            return this._makeRequest(\n                \"record\",\n                rec.getId() ? \"save\" : \"create\",\n                rec.getId(),\n                extend({}, rec.storeData(rec.getData(keys)), extra)\n            );\n        },\n\n        /**\n         * Make a record/delete request.\n         * @method\n         * @param {MetaphorJs.model.Record} rec\n         * @returns {MetaphorJs.lib.Promise}\n         */\n        deleteRecord: function(rec) {\n            return this._makeRequest(\"record\", \"delete\", rec.getId());\n        },\n\n        /**\n         * Load store records\n         * @method\n         * @param {MetaphorJs.model.Store} store\n         * @param {object} params\n         * @returns {MetaphorJs.lib.Promise}\n         */\n        loadStore: function(store, params) {\n            return this._makeRequest(\"store\", \"load\", null, params);\n        },\n\n        /**\n         * Send store records back to server for saving\n         * @method\n         * @param {MetaphorJs.model.Store} store\n         * @param {object} recordData\n         * @returns {MetaphorJs.lib.Promise}\n         */\n        saveStore: function(store, recordData) {\n            return this._makeRequest(\"store\", \"save\", null, recordData);\n        },\n\n        /**\n         * Delete store records\n         * @method\n         * @param {MetaphorJs.model.Store} store\n         * @param {array} ids\n         * @returns {MetaphorJs.lib.Promise}\n         */\n        deleteRecords: function(store, ids) {\n            return this._makeRequest(\"store\", \"delete\", ids);\n        },\n\n\n\n        /**\n         * Takes plain object and extends with properties\n         * defined in model.record.extend\n         * @method\n         * @returns {object}\n         */\n        extendPlainRecord: function(rec) {\n            const ext     = this.getRecordProp(null, \"extend\");\n            rec = ext ? extend(rec, ext, false, false) : rec;\n            rec.$$model = this;\n            return rec;\n        },\n\n        /**\n         * Normalize record data response\n         * @param {object} data \n         */\n        normalizeRecord: function(data) {\n            return data;\n        },\n\n        /**\n         * Get field configs\n         * @method\n         * @returns {object}\n         */\n        getFields: function() {\n            return this.fields;\n        },\n\n        /**\n         * Extract record id from a record\n         * @method\n         * @param {object} rec\n         * @returns {*|null}\n         */\n        getRecordId: function(rec) {\n            const idProp = this.getRecordProp(\"load\", \"id\");\n            return rec ? (rec.getId ? rec.getId() : rec[idProp]) || null : null;\n        },\n\n        /**\n         * Convert field's value from database state to app state\n         * @method\n         * @param {MetaphorJs.model.Record} rec\n         * @param {string} name\n         * @param {string|int|bool|Date} value\n         * @returns {*}\n         */\n        restoreField: function(rec, name, value) {\n\n            const f  = this.fields[name];\n\n            if (f) {\n                const type = isString(f) ? f : f.type;\n\n                switch (type) {\n                    case \"int\": {\n                        value   = parseInt(value);\n                        break;\n                    }\n                    case \"bool\":\n                    case \"boolean\": {\n                        if (isString(value)) {\n                            value   = value.toLowerCase();\n                            value   = !(value === \"off\" || value === \"no\" || value === \"0\" ||\n                                        value == \"false\" || value == \"null\");\n                        }\n                        else {\n                            value = value ? true : false;\n                        }\n                        break;\n                    }\n                    case \"double\":\n                    case \"float\": {\n                        value   = parseFloat(value);\n                        break;\n                    }\n                    case \"date\": {\n                        if (f['parseFn']) {\n                            value   = f['parseFn'](value, f.format);\n                        }\n                        else if (Date['parse']) {\n                            value   = Date['parse'](value, f.format);\n                        }\n                        else {\n                            if (f.format === \"timestamp\") {\n                                value   = parseInt(value) * 1000;\n                            }\n                            value   = new Date(value);\n                        }\n                        break;\n                    }\n                }\n\n                if (f.restore) {\n                    value   = f.restore.call(rec, value, name);\n                }\n            }\n\n            return this.onRestoreField(rec, name, value);\n        },\n\n        /**\n         * Override this method to have your own value processor\n         * @method\n         * @access protected\n         * @param {MetaphorJs.model.Record} rec\n         * @param {string} name\n         * @param {string|int|bool} value\n         * @returns {string|int|bool|Date}\n         */\n        onRestoreField: function(rec, name, value) {\n            return value;\n        },\n\n        /**\n         * Convert field's value from app state to database state\n         * @method\n         * @param {MetaphorJs.model.Record} rec\n         * @param {string} name\n         * @param {string|int|bool|Date} value\n         * @returns {*}\n         */\n        storeField: function(rec, name, value) {\n\n            const f = this.fields[name];\n\n            if (f) {\n                const type = isString(f) ? f : f.type;\n\n                switch (type) {\n                    case \"bool\":\n                    case \"boolean\": {\n                        value   = value ? \"1\" : \"0\";\n                        break;\n                    }\n                    case \"date\": {\n                        if (f['formatFn']) {\n                            value   = f['formatFn'](value, f.format);\n                        }\n                        else if (Date.format) {\n                            value   = Date.format(value, f.format);\n                        }\n                        else {\n                            if (f.format === \"timestamp\") {\n                                value   = value.getTime() / 1000;\n                            }\n                            else {\n                                value   = value['format'] ? value['format'](f.format) : value.toString();\n                            }\n                        }\n                        break;\n                    }\n                    default: {\n                        value   = value.toString();\n                    }\n                }\n\n                if (f.store) {\n                    value   = f.store.call(rec, value, name);\n                }\n            }\n\n            return this.onStoreField(rec, name, value);\n\n        },\n\n        /**\n         * Override this method to have your own value processor\n         * @method\n         * @access protected\n         * @param {MetaphorJs.model.Record} rec\n         * @param {string} name\n         * @param {string|int|bool} value\n         * @returns {string|int}\n         */\n        onStoreField: function(rec, name, value) {\n            return value;\n        }\n\n\n    }, {\n\n        /**\n         * @static\n         * @method\n         * @param {string} model Model class name\n         * @param {object} cfg Model config\n         * @returns {object}\n         */\n        create: function(model, cfg) {\n\n            if (model === \"MetaphorJs.model.Model\") {\n                return cls.factory(model, cfg);\n            }\n            else {\n                if (cfg) {\n                    return cls.factory(model, cfg);\n                }\n                else {\n                    if (instances[model]) {\n                        return instances[model];\n                    }\n                    else {\n                        return instances[model] = cls.factory(model);\n                    }\n                }\n            }\n        },\n\n        /**\n         * @static\n         * @method\n         * @param {MetaphorJs.model.Record} rec\n         */\n        addToCache: function(rec) {\n\n            const   id      = rec.getId(),\n                    cname   = rec.$getClass();\n\n            if (!(rec instanceof MetaphorJs.model.Record) && cname) {\n                if (!cache[cname]) {\n                    cache[cname] = {};\n                }\n                cache[cname][id] = rec;\n            }\n        },\n\n        /**\n         * @static\n         * @method\n         * @param {string} type Class name\n         * @param {string|int|bool} id\n         */\n        getFromCache: function(type, id) {\n\n            if (cache[type] && cache[type][id]) {\n                return cache[type][id];\n            }\n            else {\n                return null;\n            }\n        },\n\n        /**\n         * @static\n         * @method\n         * @param {string} type Class name\n         * @param {string|int|bool} id\n         */\n        removeFromCache: function(type, id) {\n            if (cache[type] && cache[type][id]) {\n                delete cache[type][id];\n            }\n        }\n    });\n}();\n","\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    extend  = require(\"metaphorjs-shared/src/func/extend.js\"),\n    isString = require(\"metaphorjs-shared/src/func/isString.js\");\n\nrequire(\"../__init.js\");\nrequire(\"./Model.js\");\nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");\n\n/**\n * @class MetaphorJs.model.Record\n * @mixes MetaphorJs.mixin.Observable\n */\nmodule.exports = MetaphorJs.model.Record = cls({\n\n    /**\n     * @event dirty-change {\n     *  Record become changed on unchanged\n     *  @param {MetaphorJs.model.Record} rec\n     *  @param {boolean} dirty\n     * }\n     */\n    /**\n     * @event change {\n     *  General record change event\n     *  @param {MetaphorJs.model.Record} rec \n     *  @param {string} key\n     *  @param {*} value \n     *  @param {*} prevValue\n     * }\n     */\n    /**\n     * @event change-_key_ {\n     *  Specific key change event\n     *  @param {MetaphorJs.model.Record} rec \n     *  @param {string} key\n     *  @param {*} value \n     *  @param {*} prevValue\n     * }\n     */\n    /**\n     * @event before-load {\n     *  @param {MetaphorJs.model.Record}\n     * }\n     */\n    /**\n     * @event load {\n     *  @param {MetaphorJs.model.Record}\n     * }\n     */\n    /**\n     * @event failed-load {\n     *  @param {MetaphorJs.model.Record}\n     * }\n     */\n    /**\n     * @event before-save {\n     *  @param {MetaphorJs.model.Record}\n     * }\n     */\n    /**\n     * @event save {\n     *  @param {MetaphorJs.model.Record}\n     * }\n     */\n    /**\n     * @event failed-save {\n     *  @param {MetaphorJs.model.Record}\n     * }\n     */\n    /**\n     * @event before-delete {\n     *  @param {MetaphorJs.model.Record}\n     * }\n     */\n    /**\n     * @event delete {\n     *  @param {MetaphorJs.model.Record}\n     * }\n     */\n    /**\n     * @event failed-delete {\n     *  @param {MetaphorJs.model.Record}\n     * }\n     */\n    /**\n     * @event reset {\n     *  @param {MetaphorJs.model.Record}\n     * }\n     */\n\n\n    $mixins: [MetaphorJs.mixin.Observable],\n\n    id:             null,\n    data:           null,\n    orig:           null,\n    modified:       null,\n    loaded:         false,\n    loading:        false,\n    dirty:          false,\n    model:          null,\n    standalone:     true,\n    stores:         null,\n    importUponSave: false,\n    importUponCreate: false,\n\n    /**\n     * @constructor\n     * @method $init\n     * @param {*} id\n     * @param {object} cfg {\n     *  @type {string|MetaphorJs.model.Model} model\n     *  @type {boolean} autoLoad {\n     *      Load record automatically when constructed\n     *      @default true\n     *  }\n     *  @type {boolean} importUponSave {\n     *      Import new data from response on save request\n     *      @default false\n     *  }\n     *  @type {boolean} importUponCreate {\n     *      Import new data from response on create request\n     *      @default false\n     *  }\n     * }\n     */\n\n    /**\n     * @constructor\n     * @method $init\n     * @param {object} cfg\n     */\n\n    /**\n     * @constructor\n     * @method $init\n     * @param {string|int|null} id\n     * @param {object} data\n     * @param {object} cfg\n     */\n    $init: function(id, data, cfg) {\n\n        let args    = arguments.length;\n\n        if (args === 1) {\n            cfg     = id;\n            id      = null;\n            data    = null;\n        }\n        else if (args === 2) {\n            cfg     = data;\n            data    = null;\n        }\n\n        this.data       = {};\n        this.orig       = {};\n        this.stores     = [];\n        this.modified   = {};\n        cfg             = cfg || {};\n        this.$super(cfg);\n\n        if (isString(this.model)) {\n            this.model  = MetaphorJs.model.Model.create(this.model);\n        }\n        else if (!(this.model instanceof MetaphorJs.model.Model)) {\n            this.model  = new MetaphorJs.model.Model(this.model);\n        }\n\n        this.id     = id;\n\n        if (data) {\n            this.importData(data);\n        }\n        else if(cfg.autoLoad !== false && id) {\n            this.load();\n        }\n\n        if (this.$getClass() !== \"MetaphorJs.model.Record\") {\n            MetaphorJs.model.Model.addToCache(this);\n        }\n    },\n\n    /**\n     * Is record finished loading from server\n     * @method\n     * @returns {bool}\n     */\n    isLoaded: function() {\n        return this.loaded;\n    },\n\n    /**\n     * Is record still loading from server\n     * @method\n     * @returns {bool}\n     */\n    isLoading: function() {\n        return this.loading;\n    },\n\n    /**\n     * Is this record was created separately from a store\n     * @method\n     * @returns {bool}\n     */\n    isStandalone: function() {\n        return this.standalone;\n    },\n\n    /**\n     * Does this record have changes\n     * @method\n     * @returns {bool}\n     */\n    isDirty: function() {\n        return this.dirty;\n    },\n\n    /**\n     * @method\n     * @returns {MetaphorJs.model.Model}\n     */\n    getModel: function() {\n        return this.model;\n    },\n\n    /**\n     * Make this record belong to a store\n     * @method\n     * @param {MetaphorJs.model.Store} store\n     */\n    attachStore: function(store) {\n        let sid = store.getId();\n\n        if (this.stores.indexOf(sid) == -1) {\n            this.stores.push(sid);\n        }\n    },\n\n    /**\n     * Remove attachment to a store. If record is not standalone,\n     * it will be destroyed.\n     * @method\n     * @param {MetaphorJs.model.Store} store\n     */\n    detachStore: function(store) {\n        var sid     = store.getId(),\n            inx;\n\n        if (!this.$destroyed && (inx = this.stores.indexOf(sid)) != -1) {\n            this.stores.splice(inx, 1);\n\n            if (this.stores.length == 0 && !this.standalone) {\n                this.$destroy();\n            }\n        }\n    },\n\n    /**\n     * Mark this record as having changes\n     * @method\n     * @param {bool} dirty\n     */\n    setDirty: function(dirty) {\n        if (this.dirty != dirty) {\n            this.dirty  = !!dirty;\n            this.trigger(\"dirty-change\", this, dirty);\n        }\n    },\n\n    /**\n     * Import record data. Resets record to a unchanged state\n     * @method\n     * @param {object} data\n     */\n    importData: function(data) {\n\n        let processed   = {},\n            name;\n\n        if (data) {\n            for (name in data) {\n                processed[name] = this.model.restoreField(this, name, data[name]);\n            }\n\n            this.data   = processed;\n        }\n\n        this.orig       = extend({}, this.data);\n        this.modified   = {};\n        this.loaded     = true;\n        this.setDirty(false);\n    },\n\n    /**\n     * Prepare data for sending to a server\n     * @method\n     * @access protected\n     * @param {object} data\n     * @returns {object}\n     */\n    storeData: function(data) {\n\n        let processed   = {},\n            name;\n\n        for (name in data) {\n            processed[name] = this.model.storeField(this, name, data[name]);\n        }\n\n        return processed;\n    },\n\n\n    /**\n     * Get record id\n     * @method\n     * @returns {*}\n     */\n    getId: function() {\n        return this.id;\n    },\n\n    /**\n     * Get record data. Returns a new object with all data keys \n     * or only the ones specified and without keys starting with $.\n     * @method\n     * @param {[]|null|string} keys\n     * @returns {object}\n     */\n    getData: function(keys) {\n\n        let data = {},\n            i;\n\n        if (keys) {\n            let len;\n\n            keys = isString(keys) ? [keys] : keys;\n\n            for (i = 0, len = keys.length; i < len; i++) {\n                data[keys[i]] = this.data[keys[i]];\n            }\n            return data;\n        }\n        else {\n            let sdata = this.data;\n\n            for (i in sdata) {\n                if (i.substr(0, 1) === \"$\") {\n                    continue;\n                }\n                data[i] = sdata[i];\n            }\n\n            return data;\n        }\n    },\n\n    /**\n     * Get changed properties\n     * @method\n     * @returns {object}\n     */\n    getChanged: function() {\n        return extend({}, this.modified);\n    },\n\n    /**\n     * Is the field changed\n     * @method\n     * @param {string} key\n     * @returns {bool}\n     */\n    isChanged: function(key) {\n        return this.modified[key] || false;\n    },\n\n    /**\n     * Get specific data key\n     * @method\n     * @param {string} key\n     * @returns {*}\n     */\n    get: function(key) {\n        return this.data[key];\n    },\n\n    /**\n     * Set record id\n     * @method\n     * @param {*} id\n     */\n    setId: function(id) {\n        if (!this.id && id) {\n            this.id = id;\n        }\n    },\n\n    /**\n     * Set data field\n     * @method\n     * @param {string} key\n     * @param {*} value\n     */\n    set: function(key, value) {\n\n        let prev = this.data[key];\n\n        value           = this.model.restoreField(this, key, value);\n        this.data[key]  = value;\n\n        if (prev != value) {\n            this.modified[key]  = true;\n            this.setDirty(true);\n            this.trigger(\"change\", this, key, value, prev);\n            this.trigger(\"change-\"+key, this, key, value, prev);\n        }\n    },\n\n    /**\n     * Revert record to the last saved state\n     * @method\n     */\n    revert: function() {\n        if (this.dirty) {\n            this.data       = extend({}, this.orig);\n            this.modified   = {};\n            this.setDirty(false);\n        }\n    },\n\n    /**\n     * Load record from the server\n     * @method\n     * @returns {MetaphorJs.lib.Promise}\n     */\n    load: function() {\n        this.loading = true;\n        this.trigger(\"before-load\", this);\n        return this.model.loadRecord(this.id)\n            .always(() => {\n                this.loading = false;\n            })\n            .done((response) => {\n                this.setId(response.id);\n                this.importData(response.data);\n                this.trigger(\"load\", this);\n            })\n            .fail(() => {\n                this.trigger(\"failed-load\", this);\n            });\n    },\n\n    /**\n     * Send data back to server \n     * @method\n     * @param {array|null|string} keys Only send these keys\n     * @param {object|null} extra Send this data along with record data\n     * @returns {MetaphorJs.lib.Promise}\n     */\n    save: function(keys, extra) {\n        this.trigger(\"before-save\", this);\n\n        let create  = !this.getId(),\n            imprt   = create ? this.importUponCreate : this.importUponSave;\n\n        return this.model.saveRecord(this, keys, extra)\n            .done((response) => {\n                if (response.id) {\n                    this.setId(response.id);\n                }\n                if (imprt) {\n                    this.importData(response.data);\n                }\n                this.trigger(\"save\", this);\n            })\n            .fail(() => this.trigger(\"failed-save\", this));\n    },\n\n    /**\n     * Send delete request\n     * @method\n     * @returns {MetaphorJs.lib.Promise}\n     */\n    \"delete\": function() {\n        this.trigger(\"before-delete\", this);\n        return this.model.deleteRecord(this)\n            .done(() => {\n                this.trigger(\"delete\", this);\n                this.$destroy();\n            }).\n            fail(() => {\n                this.trigger(\"failed-delete\", this);\n            });\n    },\n\n\n    /**\n     * Set record back to unloaded state\n     * @method\n     */\n    reset: function() {\n\n        this.id         = null;\n        this.data       = {};\n        this.orig       = {};\n        this.modified   = {};\n        this.loaded     = false;\n        this.dirty      = false;\n\n        this.trigger(\"reset\", this);\n    },\n\n\n\n    onDestroy: function() {\n        MetaphorJs.model.Model.removeFromCache(this.$getClass(), this.id);\n        this.$super();\n    }\n\n});\n\n","\nconst extend  = require(\"metaphorjs-shared/src/func/extend.js\"),\n    emptyFn = require(\"metaphorjs-shared/src/func/emptyFn.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    cls = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    isString = require(\"metaphorjs-shared/src/func/isString.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    filterArray = require(\"metaphorjs-shared/src/func/filterArray.js\"),\n    sortArray = require(\"metaphorjs-shared/src/func/sortArray.js\");\n    \nrequire(\"../__init.js\");\nrequire(\"./Model.js\");\nrequire(\"./Record.js\");    \nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");\n\nmodule.exports = MetaphorJs.model.Store = function(){\n\n    const allStores   = {};\n\n    /**\n     * @class MetaphorJs.model.Store\n     * @mixes MetaphorJs.mixin.Observable\n     */\n    return cls({\n\n        /**\n         * @event update {\n         *  Store contents got updated\n         *  @param {MetaphorJs.model.Store} store\n         *  @param {MetaphorJs.model.Record|object} rec\n         * }\n         */\n        /**\n         * @event before-load {\n         *  Before store sends a get request to the server\n         *  @param {MetaphorJs.model.Store} store\n         *  @returns {boolean} return false to cancel laoding\n         * }\n         */\n        /**\n         * @event load {\n         *  After store finished loading and updating its contents\n         *  @param {MetaphorJs.model.Store} store\n         * }\n         */\n        /**\n         * @event loading-end {\n         *  After store finished loading but before updating.<br>\n         *  This event does not respect <code>silent</code> option. \n         *  The purpose of this event is to let you \n         *  display loading indicator or something like that.\n         *  @param {MetaphorJs.model.Store} store\n         * }\n         */\n        /**\n         * @event loading-start {\n         *  The store requested the server.<br>\n         *  This event does not respect <code>silent</code> option. \n         *  The purpose of this event is to let you \n         *  display loading indicator or something like that.\n         *  @param {MetaphorJs.model.Store} store\n         * }\n         */\n        /**\n         * @event failed-load {\n         *  There was an error while loading\n         *  @param {MetaphorJs.model.Store} store\n         *  @param {string|Error} reason\n         * }\n         */\n        /**\n         * @event before-save {\n         *  Before sending \"save\" request\n         *  @param {MetaphorJs.model.Store} store\n         *  @param {array} recs\n         *  @returns {boolean} return false to cancel saving\n         * }\n         */\n        /**\n         * @event save {\n         *  Records have been saved\n         *  @param {MetaphorJs.model.Store} store\n         * }\n         */\n        /**\n         * @event failed-save {\n         *  There was an error while saving\n         *  @param {MetaphorJs.model.Store} store\n         *  @param {string|Error} reason\n         * }\n         */\n        /**\n         * @event before-delete {\n         *  Before sending \"delete\" request\n         *  @param {MetaphorJs.model.Store} store\n         *  @param {array} ids \n         *  @returns {boolean} return false to cancel deletion\n         * }\n         */\n        /**\n         * @event delete {\n         *  Records have been deleted\n         *  @param {MetaphorJs.model.Store} store\n         *  @param {array} ids \n         * }\n         */\n        /**\n         * @event failed-delete {\n         *  There was an error while deleting\n         *  @param {MetaphorJs.model.Store} store\n         *  @param {array} ids \n         * }\n         */\n        /**\n         * @event add {\n         *  Some records were added to the store\n         *  @param {MetaphorJs.model.Store} store\n         *  @param {array} recs \n         * }\n         */\n        /**\n         * @event remove {\n         *  Record got removed from the store\n         *  @param {MetaphorJs.model.Store} store\n         *  @param {MetaphorJs.model.Record|object} rec\n         *  @param {string|int} id \n         * }\n         */\n        /**\n         * @event replace {\n         *  A record was replaced\n         *  @param {MetaphorJs.model.Store} store\n         *  @param {MetaphorJs.model.Record|object} old\n         *  @param {MetaphorJs.model.Record|object} rec\n         * }\n         */\n        /**\n         * @event clear {\n         *  The store has been cleared\n         *  @param {MetaphorJs.model.Store} store\n         *  @param {array} recs\n         * }\n         */\n\n            $mixins:        [MetaphorJs.mixin.Observable],\n\n            id:             null,\n            autoLoad:       false,\n            clearOnLoad:    true,\n            model:          null,\n\n            extraParams:    null,\n            loaded:         false,\n            loading:        false,\n            local:          false,\n\n            items:          null,\n            current:        null,\n            itemMap:        null,\n            currentMap:     null,\n\n            length:         0,\n            currentLength:  0,\n            maxLength:      0,\n            totalLength:    0,\n\n            start:          0,\n            pageSize:       null,\n            pages:          null,\n            filtered:       false,\n            sorted:         false,\n            filterBy:       null,\n            filterOpt:      null,\n            sortBy:         null,\n            sortDir:        null,\n            publicStore:    false,\n\n            idProp:         null,\n            loadingPromise: null,\n\n            /**\n             * @constructor\n             * @method $init\n             * @param {object} options {\n             *  @type {string} url Api endpoint url if not defined in model\n             *  @type {boolean} local {\n             *      This store does not load data from remote server\n             *      @default false\n             *  }\n             *  @type {int} pageSize Number of records per page\n             *  @type {boolean} autoLoad {\n             *      @default false\n             *  }\n             *  @type {boolean} clearOnLoad {\n             *      On load, remove everything already added \n             *      @default true\n             *  }\n             *  @type {string|object|MetaphorJs.model.Model} model\n             *  @type {object} extraParams {\n             *      Extra params to add to every request\n             *  }\n             *  @type {MetaphorJs.model.Store} sourceStore {\n             *      Keep in sync with another store\n             *  }\n             * }\n             * @param {array} initialData Array of records\n             */\n\n            /**\n             * @constructor\n             * @method $init\n             * @param {string} url\n             * @param {object} options\n             * @param {array} initialData\n             */\n            $init:     function(url, options, initialData) {\n\n                this.items          = [];\n                this.current        = [];\n                this.itemMap        = {};\n                this.currentMap     = {};\n                this.loaded         = false;\n                this.extraParams    = this.extraParams || {};\n\n                if (url && !isString(url)) {\n                    initialData = options;\n                    options     = url;\n                    url         = null;\n                }\n\n                options         = options || {};\n\n                if (url) {\n                    options.url = url;\n                }\n\n                this.$super(options);\n                extend(this, options, true, false);\n\n                this.id         = this.id || nextUid();\n                this.filtered   = !!this.filterBy;\n                \n                if (this.publicStore) {\n                    allStores[this.id]  = this;\n                }\n\n                this.initModel(options);\n\n                this.$$observable.createEvent(\"beforeload\", false);\n\n                if (!this.local && this.autoLoad) {\n                    this.load();\n                }\n                else if (initialData) {\n                    if (isArray(initialData)) {\n                        this._loadArray(initialData);\n                    }\n                    else {\n                        this._fetchData(initialData);\n                    }\n                }\n\n                if (this.local) {\n                    this.loaded     = true;\n                }\n\n                if (this.sourceStore) {\n                    this.initSourceStore(this.sourceStore, \"on\");\n                }\n            },\n\n            /**\n             * Change store's model\n             * @param {MetaphorJs.model.Model} model \n             */\n            setModel: function(model) {\n                this.model = model;\n                this.initModel({});\n            },\n\n            initModel: function(options) {\n\n                if (isString(this.model)) {\n                    this.model  = MetaphorJs.model.Model.create(this.model);\n                }\n                else if (!(this.model instanceof MetaphorJs.model.Model)) {\n                    this.model  = new MetaphorJs.model.Model(this.model);\n                }\n\n                if (options.url) {\n                    this.model.store.load = options.url;\n                }\n\n                this.idProp = this.model.getStoreProp(\"load\", \"id\");\n            },\n\n\n            initSourceStore: function(sourceStore, mode) {\n                sourceStore[mode](\"update\", this.onSourceStoreUpdate, this);\n            },\n\n            onSourceStoreUpdate: function() {\n\n                this.$$observable.suspendAllEvents();\n\n                this.clear();\n                this.addMany(this.sourceStore.toArray());\n\n                this.$$observable.resumeAllEvents();\n                this.trigger(\"update\", this);\n            },\n\n            /**\n             * Get store id\n             * @method\n             * @returns {string}\n             */\n            getId: function() {\n                return this.id;\n            },\n\n            /**\n             * Is this store finished loading data\n             * @method\n             * @returns {bool}\n             */\n            isLoaded: function() {\n                return this.loaded;\n            },\n\n            /**\n             * Is this store local (does not load remote data)\n             * @method\n             * @returns {bool}\n             */\n            isLocal: function() {\n                return this.local;\n            },\n\n            /**\n             * Make this store local or remote\n             * @method\n             * @param {bool} state\n             */\n            setLocal: function(state) {\n                this.local  = !!state;\n            },\n\n            /**\n             * Is this store currently loading\n             * @method\n             * @returns {bool}\n             */\n            isLoading: function() {\n                return this.loading;\n            },\n\n            /**\n             * Does this store have a filter applied\n             * @method\n             * @returns {bool}\n             */\n            isFiltered: function() {\n                return this.filtered;\n            },\n\n            /**\n             * Does this store have a sorter applied\n             * @method\n             * @returns {bool}\n             */\n            isSorted: function() {\n                return this.sorted;\n            },\n\n            /**\n             * Get number of records in this store\n             * @method\n             * @param {boolean} unfiltered\n             * @returns {number}\n             */\n            getLength: function(unfiltered) {\n                return unfiltered ? this.length : this.currentLength;\n            },\n\n            /**\n             * Get number of records on the server\n             * @method\n             * @returns {number}\n             */\n            getTotalLength: function() {\n                return this.totalLength || this.currentLength;\n            },\n\n            /**\n             * Is this store currently empty\n             * @method\n             * @param {boolean} unfiltered\n             * @returns {boolean}\n             */\n            isEmpty: function(unfiltered) {\n                return unfiltered ? this.length === 0 : this.currentLength === 0;\n            },\n\n            /**\n             * Get number of pages (based on pageSize setting)\n             * @method\n             * @returns {number}\n             */\n            getPagesCount: function() {\n                if (this.pageSize !== null) {\n                    return parseInt(this.totalLength / this.pageSize);\n                }\n                else {\n                    return 1;\n                }\n            },\n\n            /**\n             * Set extra param. It will be sent along with every request\n             * @method\n             * @param {string} k\n             * @param {string|int|null} v\n             */\n            setParam: function(k, v) {\n                if (v === null) {\n                    delete this.extraParams[k];\n                }\n                else {\n                    this.extraParams[k] = v;\n                }\n            },\n\n            /**\n             * Get extra param\n             * @method\n             * @param {string} k\n             * @returns {*}\n             */\n            getParam: function(k) {\n                return this.extraParams[k];\n            },\n\n            /**\n             * Get all extra params (in a new object)\n             * @method\n             * @returns {object}\n             */\n            getParams: function() {\n                return extend({}, this.extraParams);\n            },\n\n            /**\n             * Clear all extra params\n             * @method\n             */\n            clearParams: function() {\n                this.extraParams = {};\n            },\n\n            /**\n             * Set remote record offset\n             * @method\n             * @param {number} val\n             */\n            setStart: function(val) {\n                this.start = val;\n            },\n\n            /**\n             * Set page size\n             * @method\n             * @param {number} val\n             */\n            setPageSize: function(val) {\n                this.pageSize = val;\n            },\n\n            /**\n             * Get unprocessed response data\n             * @method\n             * @returns {object}\n             */\n            getFetchedData: function() {\n                return this.fetchedData;\n            },\n\n            /**\n             * Does this store have records marked as dirty\n             * @method\n             * @param {boolean} unfiltered If filter is appied this flag will \n             *  make this method ignore the filter\n             * @returns {bool}\n             */\n            hasDirty: function(unfiltered) {\n                if (this.model.isPlain()) {\n                    return false;\n                }\n                let ret = false;\n                this.each(function(rec){\n                    if (rec.isDirty()) {\n                        ret = true;\n                        return false;\n                    }\n                    return true;\n                }, null, unfiltered);\n                return ret;\n            },\n\n            /**\n             * Get list of records marked as dirty\n             * @method\n             * @param {boolean} unfiltered If filter is appied this flag will \n             *  make this method ignore the filter\n             * @returns {array}\n             */\n            getDirty: function(unfiltered) {\n                let recs    = [];\n                if (this.model.isPlain()) {\n                    return recs;\n                }\n                this.each(function(rec){\n                    if (rec.isDirty()) {\n                        recs.push(rec);\n                    }\n                }, null, unfiltered);\n                return recs;\n            },\n\n            /**\n             * Get current model\n             * @method\n             * @returns {MetaphorJs.model.Model}\n             */\n            getModel: function() {\n                return this.model;\n            },\n\n\n            /**\n             * Get list of records (affected by store filter)\n             * @method\n             * @returns {array}\n             */\n            toArray: function() {\n                return this.current.slice();\n            },\n\n\n\n            /**\n             * @ignore\n             * initialize store with data from remote sever\n             * @method\n             * @param {object} data\n             */\n            _fetchData: function(data, options) {\n\n                options = options || {};\n\n                if (!options.silent && this.trigger(\"before-load\", this) === false) {\n                    return;\n                }\n\n                this.fetchedData = data;\n\n                this.model._processStoreResponse(\"load\", data, {\n                    resolve: (response) => {\n                        this._onModelLoadSuccess(response, options);\n                    },\n                    reject: (reason) => {\n                        this._onModelLoadFail(reason, options);\n                    }\n                });\n            },\n\n            /**\n             * @ignore\n             * initialize store with local data\n             * @param {[]} recs\n             * @param {{}} options\n             */\n            _loadArray: function(recs, options) {\n\n                options = options || {};\n\n                if (!options.silent && this.trigger(\"before-load\", this) === false) {\n                    return;\n                }\n\n                if (isArray(recs)) {\n                    this._load(recs, options);\n                    this.totalLength = this.length;\n                }\n            },\n\n\n\n            /**\n             * @ignore\n             * load records no matter where they came from\n             * @param {[]} recs\n             * @param {{}} options\n             */\n            _load: function(recs, options) {\n\n                const prepend = options.prepend;\n\n                options = options || {};\n                recs = recs || [];\n\n                if (prepend) {\n                    this.insertMany(0, recs, true, true)\n                }\n                else {\n                    this.addMany(recs, true, true);\n                }\n\n                this.loaded     = true;\n                this.loading    = false;\n\n                this.trigger(\"loading-end\", this);\n                this.onLoad();\n\n                if (!options.skipUpdate) {\n                    this.update();\n                }\n\n                if (!options.silent) {\n                    this.trigger(\"load\", this);\n                }\n            },\n\n            /**\n             * (Re)load store. \n             * @method\n             * @param {object} params {\n             *  Add these params to load request\n             *  @optional\n             * }\n             * @param {object} options {\n             *  @type {boolean} silent {\n             *      Do not trigger events\n             *      @default false\n             *  }\n             *  @type {boolean} noopOnEmpty {\n             *      Stop doing anything as soon as we know the data is empty\n             *      (do not clear and update)\n             *      @default false\n             *  }\n             *  @type {boolean} prepend {\n             *      Insert loaded data in front of old ones (and do not clear)\n             *      @default false\n             *  }\n             *  @type {boolean} append {\n             *      Insert loaded data after existing records (and do not clear)\n             *      @default false\n             *  }\n             *  @type {boolean} skipUpdate {\n             *      Skip updating store - re-filter, re-map\n             *      @default false\n             *  }\n             * }\n             * @returns {MetaphorJs.lib.Promise}\n             */\n            load: function(params, options) {\n\n                const ms      = this.model.store,\n                      sp      = ms.start,\n                      lp      = ms.limit,\n                      ps      = this.pageSize;\n\n                if (this.loadingPromise && this.loadingPromise.abort) {\n                    this.loadingPromise.abort();\n                }\n\n                options     = options || {};\n\n                if (this.local) {\n                    return null;\n                }\n\n                params      = extend({}, this.extraParams, params || {});\n\n                if (ps !== null && !params[sp] && !params[lp]) {\n                    if (sp) {\n                        params[sp]    = this.start;\n                    }\n                    if (lp) {\n                        params[lp]    = ps;\n                    }\n                }\n\n                if (!options.silent && this.trigger(\"before-load\", this) === false) {\n                    return null;\n                }\n\n                this.loading = true;\n\n                this.trigger(\"loading-start\", this);\n\n                return this.loadingPromise = this.model.loadStore(this, params)\n                    .done((response) => {\n                        if (this.$destroyed) {\n                            return;\n                        }\n                        this.loadingPromise = null;\n                        this.fetchedData = this.model.lastFetchedResponse;\n                        this._onModelLoadSuccess(response, options);\n                    })\n                    .fail((reason) => {\n                        if (this.$destroyed) {\n                            return;\n                        }\n                        this.loadingPromise = null;\n                        this.fetchedData = this.model.lastFetchedResponse;\n                        this._onModelLoadFail(reason, options);\n                    });\n            },\n\n            _onModelLoadSuccess: function(response, options) {\n\n                options = options || {};\n\n                if (options.noopOnEmpty && !response.data.length) {\n                    return;\n                }\n\n                if ((!options.prepend && !options.append) && \n                    this.clearOnLoad && \n                    this.length > 0) {\n                        this.clear(true);\n                }\n\n                if (response.total !== null && response.total !== undefined) { \n                    this.totalLength = parseInt(response.total);\n                }\n                this._load(response.data, options);\n            },\n\n            _onModelLoadFail: function(reason, options) {\n                this.onFailedLoad();\n                if (!options.silent) {\n                    this.trigger(\"failed-load\", this, reason);\n                }\n            },\n\n            /**\n             * Override this method to catch successful loads\n             * @method\n             */\n            onLoad: emptyFn,\n\n            /**\n             * Override this method to catch failed loads\n             * @method\n             */\n            onFailedLoad: emptyFn,\n\n            /**\n             * Save all dirty records\n             * @method\n             * @param {boolean} silent {\n             *  Do not trigger events\n             *  @default false\n             * }\n             * @returns {MetaphorJs.lib.Promise}\n             */\n            save: function(silent) {\n\n                let recs    = {},\n                    cnt     = 0;\n\n                if (this.local) {\n                    return null;\n                }\n\n                if (this.model.isPlain()) {\n                    throw new Error(\"Cannot save plain store\");\n                }\n\n                this.each(rec => {\n                    if (rec.isDirty()) {\n                        recs[rec.getId()] = rec.storeData(rec.getData());\n                        cnt++;\n                    }\n                });\n\n                if (!cnt) {\n                    return null;\n                }\n\n                if (!silent && this.trigger(\"before-save\", this, recs) === false) {\n                    return null;\n                }\n\n                return this.model\n                    .saveStore(this, recs)\n                    .done(response => this._onModelSaveSuccess(response, silent))\n                    .fail(reason => this._onModelSaveFail(reason, silent));\n            },\n\n            _onModelSaveSuccess: function(response, silent) {\n\n                let i, len,\n                    id, rec,\n                    data = response.data;\n\n                if (data && data.length) {\n                    for (i = 0, len = data.length; i < len; i++) {\n\n                        id      = this.getRecordId(data[i]);\n                        rec     = this.getById(id);\n\n                        if (rec) {\n                            rec.importData(data[i]);\n                        }\n                    }\n                }\n\n                this.onSave();\n                if (!silent) {\n                    this.trigger(\"save\", this);\n                }\n            },\n\n            _onModelSaveFail: function(reason, silent) {\n                this.onFailedSave(reason);\n                if (!silent) {\n                    this.trigger(\"failed-save\", this, reason);\n                }\n            },\n\n            /**\n             * Override this method to catch successful saves\n             * @method\n             */\n            onSave: emptyFn,\n\n            /**\n             * Override this method to catch failed saves\n             * @method\n             */\n            onFailedSave: emptyFn,\n\n\n            /**\n             * Delete record by id (send delete request)\n             * @method\n             * @param {int|string|array} ids Record id(s)\n             * @param {boolean} silent {\n             *  Do not trigger events\n             *  @default false\n             * }\n             * @param {boolean} skipUpdate {\n             *  Skip updating store (re-filter, re-map)\n             *  @default false\n             * }\n             * @returns {MetaphorJs.lib.Promise}\n             */\n            deleteById: function(ids, silent, skipUpdate) {\n\n                let i, len, rec;\n\n                if (this.local) {\n                    return null;\n                }\n\n                if (!ids || (isArray(ids) && !ids.length)) {\n                    throw new Error(\"Record id required\");\n                }\n\n                if (!isArray(ids)) {\n                    ids = [ids];\n                }\n\n                for (i = 0, len = ids.length; i < len; i++){\n                    rec = this.getById(ids[i]);\n                    this.remove(rec, silent, skipUpdate);\n                    if (rec instanceof MetaphorJs.model.Record) {\n                        rec.$destroy();\n                    }\n                }\n\n                if (!silent && this.trigger(\"before-delete\", this, ids) === false) {\n                    return null;\n                }\n\n                return this.model.deleteRecords(this, ids)\n                    .done(() => {\n                        this.totalLength -= ids.length;\n                        this.onDelete();\n                        if (!silent) {\n                            this.trigger(\"delete\", this, ids);\n                        }\n                    })\n                    .fail(() => {\n                        this.onFailedDelete();\n                        if (!silent) {\n                            this.trigger(\"failed-delete\", this, ids);\n                        }\n                    });\n            },\n\n            /**\n             * Override this method to catch successful deletes\n             * @method\n             */\n            onDelete: emptyFn,\n\n            /**\n             * Override this method to catch failed deletes\n             * @method\n             */\n            onFailedDelete: emptyFn,\n\n            /**\n             * Delete record at index\n             * @method\n             * @param {number} inx Position at which to delete record\n             * @param {boolean} silent\n             * @param {boolean} skipUpdate\n             * @returns {MetaphorJs.lib.Promise}\n             */\n            deleteAt: function(inx, silent, skipUpdate) {\n                const rec = this.getAt(inx);\n\n                if (!rec) {\n                    throw new Error(\"Record not found at \" + inx);\n                }\n                return this[\"delete\"](rec, silent, skipUpdate);\n            },\n\n            /**\n             * Delete record\n             * @method\n             * @param {MetaphorJs.model.Record} rec\n             * @param {boolean} silent\n             * @param {boolean} skipUpdate\n             * @returns {MetaphorJs.lib.Promise}\n             */\n            \"delete\": function(rec, silent, skipUpdate) {\n                return this.deleteById(this.getRecordId(rec), silent, skipUpdate);\n            },\n\n            /**\n             * Delete multiple records\n             * @method\n             * @param {MetaphorJs.model.Record[]} recs\n             * @param {boolean} silent\n             * @param {boolean} skipUpdate\n             * @returns {MetaphorJs.lib.Promise}\n             */\n            deleteRecords: function(recs, silent, skipUpdate) {\n                const ids = [];\n                let i, len;\n\n                for (i = 0, len = recs.length; i < len; i++) {\n                    ids.push(this.getRecordId(recs[i]));\n                }\n\n                return this.deleteById(ids, silent, skipUpdate);\n            },\n\n\n            /**\n             * Load store if not loaded or call provided callback\n             * @method\n             * @param {object} options See load()\n             * @returns {MetaphorJs.lib.Promise}\n             */\n            loadOr: function(options) {\n\n                if (!this.local && !this.isLoading() && !this.isLoaded()) {\n                    return this.load(null, options);\n                }\n\n                return MetaphorJs.lib.Promise.resolve(this);\n            },\n\n            /**\n             * Load previous page and prepend before current records\n             * @method\n             * @param {object} options {\n             *      See load(). append,prepend and noopOnEmpty will be set to\n             *      false, true and true.\n             * }\n             * @returns {MetaphorJs.lib.Promise}\n             */\n            addPrevPage: function(options) {\n\n                options = options || {};\n                options.append = false;\n                options.prepend = true;\n                options.noopOnEmpty = true;\n\n                return this.loadPrevPage(options);\n            },\n\n            /**\n             * Load next page and append after current records\n             * @method\n             * @param {object} options {\n             *      See load(). append,prepend and noopOnEmpty will be set to\n             *      true, false and true.\n             * }\n             * @returns {MetaphorJs.lib.Promise}\n             */\n            addNextPage: function(options) {\n                options = options || {};\n                options.append = true;\n                options.prepend = false;\n                options.noopOnEmpty = true;\n\n                if (!this.local && (!this.totalLength || this.length < this.totalLength)) {\n                    return this.load({\n                        start:      this.length,\n                        limit:      this.pageSize\n                    }, options);\n                }\n                else {\n                    return MetaphorJs.lib.Promise.resolve();\n                }\n            },\n\n            /**\n             * Load next page and replace current records with records from \n             * the next page\n             * @method\n             * @param {object} options See load()\n             * @returns {MetaphorJs.lib.Promise}\n             */\n            loadNextPage: function(options) {\n\n                if (!this.totalLength || \n                    this.local ||\n                    this.length < this.totalLength) {\n\n                    this.start += this.pageSize;\n                    if (!this.local) {\n                        return this.load(null, options);\n                    }\n                    else {\n                        this.update();\n                    }\n                }\n                \n                return MetaphorJs.lib.Promise.resolve();\n            },\n\n            /**\n             * Load prev page and replace current records with records from \n             * the prev page\n             * @method\n             * @param {object} options See load()\n             * @returns {MetaphorJs.lib.Promise}\n             */\n            loadPrevPage: function(options) {\n\n                if (this.start > 0) {\n                    this.start -= this.pageSize;\n                    if (this.start < 0) {\n                        this.start = 0;\n                    }\n                    if (!this.local) {\n                        return this.load(null, options);\n                    }\n                    else {\n                        this.update();\n                    }\n                }\n\n                return MetaphorJs.lib.Promise.resolve();\n            },\n\n            /**\n             * Load a page and replace current records with records from \n             * the page\n             * @method\n             * @param {int} start Records offset\n             * @param {object} options See load()\n             * @returns {MetaphorJs.lib.Promise}\n             */\n            loadPage: function(start, options) {\n\n                this.start = parseInt(start, 10);\n                if (this.start < 0) {\n                    this.start = 0;\n                }\n                if (!this.local) {\n                    return this.load(null, options);\n                }\n                else {\n                    this.update();\n                }\n                return MetaphorJs.lib.Promise.resolve();\n            },\n\n\n            /**\n             * Extract id from a record\n             * @method\n             * @param {MetaphorJs.model.Record|object} rec\n             * @returns {int|string|null}\n             */\n            getRecordId: function(rec) {\n                if (!rec) {\n                    return null;\n                }\n                else if (rec instanceof MetaphorJs.model.Record) {\n                    return rec.getId();\n                }\n                else if (this.model) {\n                    return this.model.getRecordId(rec) || rec[this.idProp] || null;\n                }\n                else {\n                    return rec[this.idProp] || null;\n                }\n            },\n\n            /**\n             * Get record data as plain object\n             * @method\n             * @param {MetaphorJs.model.Record|object} rec\n             * @returns {object}\n             */\n            getRecordData: function(rec) {\n                return this.model.isPlain() ? rec : rec.data;\n            },\n\n            /**\n             * @ignore\n             * @method\n             * @access protected\n             * @param {MetaphorJs.model.Record|Object} item\n             * @returns MetaphorJs.model.Record|Object\n             */\n            processRawDataItem: function(item) {\n\n                if (item instanceof MetaphorJs.model.Record) {\n                    return item;\n                }\n\n                if (this.model.isPlain()) {\n                    return this.model.extendPlainRecord(\n                        this.model.normalizeRecord(item)\n                    );\n                }\n                else {\n\n                    const type    = this.model.type,\n                        id      = this.getRecordId(item);\n                    let r;\n\n                    if (id) {\n                        r       = MetaphorJs.model.Model.getFromCache(type, id);\n                    }\n\n                    if (!r) {\n                        r       = cls.factory(type, id, item, {\n                                    model:      this.model,\n                                    standalone: false\n                        });\n                    }\n\n                    return r;\n                }\n            },\n\n            /**\n             * @ignore\n             * @method\n             * @param {string} mode on|un\n             * @param {MetaphorJs.model.Record} rec\n             * @returns {MetaphorJs.model.Record}\n             */\n            bindRecord: function(mode, rec) {\n                rec[mode](\"change\", this.onRecordChange, this);\n                rec[mode](\"destroy\", this.onRecordDestroy, this);\n                rec[mode](\"dirty-change\", this.onRecordDirtyChange, this);\n                return rec;\n            },\n\n            /**\n             * @ignore\n             * @method\n             * @access protected\n             * @param {MetaphorJs.model.Record|Object} rec\n             */\n            onRecordDirtyChange: function(rec) {\n                this.trigger(\"update\", this, rec);\n            },\n\n            /**\n             * @ignore\n             * @method\n             * @access protected\n             * @param {MetaphorJs.model.Record|Object} rec\n             * @param {string} k\n             * @param {string|int|bool} v\n             * @param {string|int|bool} prev\n             */\n            onRecordChange: function(rec, k, v, prev) {\n                this.trigger(\"update\", this, rec);\n            },\n\n            /**\n             * @ignore\n             * @method\n             * @access protected\n             * @param {MetaphorJs.model.Record|Object} rec\n             */\n            onRecordDestroy: function(rec) {\n                this.remove(rec);\n            },\n\n\n\n\n\n            /**\n             * Remove and return first record\n             * @method\n             * @param {boolean} silent Do not trigger events\n             * @param {boolean} skipUpdate Do not run store updates\n             * @param {boolean} unfiltered Execute on unfiltered set of records\n             * @returns {MetaphorJs.model.Record|Object|null}\n             */\n            shift: function(silent, skipUpdate, unfiltered) {\n                return this.removeAt(0, 1, silent, skipUpdate, unfiltered);\n            },\n\n            /**\n             * Insert record at the beginning. Works with unfiltered data\n             * @method\n             * @param {object|MetaphorJs.model.Record} rec\n             * @param {boolean} silent Do not trigger events\n             * @param {boolean} skipUpdate Do not run store updates\n             * @returns {MetaphorJs.model.Record|object}\n             */\n            unshift: function(rec, silent, skipUpdate) {\n                return this.insert(0, rec, silent, skipUpdate);\n            },\n\n            /**\n             * Remove and return last record\n             * @method\n             * @param {boolean} silent Do not trigger events\n             * @param {boolean} skipUpdate Do not run store updates\n             * @param {boolean} unfiltered Execute on unfiltered set of records\n             * @returns {MetaphorJs.model.Record|object|null}\n             */\n            pop: function(silent, skipUpdate, unfiltered) {\n                return this.removeAt(this.length - 1, 1, silent, skipUpdate, unfiltered);\n            },\n\n            /**\n             * Add many records to the store. Works with unfiltered data\n             * @method\n             * @param {MetaphorJs.model.Record[]|object[]} recs\n             * @param {boolean} silent Do not trigger events\n             * @param {boolean} skipUpdate Do not run store updates\n             */\n            addMany: function(recs, silent, skipUpdate) {\n                let i, l, start = this.length;\n\n                for (i = 0, l = recs.length; i < l; i++) {\n                    this.insert(start + i, recs[i], true, true);\n                }\n\n                if (!skipUpdate) {\n                    this.update();\n                }\n\n                if (l > 0 && !silent) {\n                    this.trigger(\"add\", recs);\n                }\n            },\n\n            /**\n             * Add one record to the store. Works with unfiltered data\n             * @method\n             * @param {MetaphorJs.model.Record|object} rec\n             * @param {boolean} silent Do not trigger events\n             * @param {boolean} skipUpdate Do not run store updates\n             */\n            add: function(rec, silent, skipUpdate) {\n                return this.insert(this.length, rec, silent, skipUpdate);\n            },\n\n            /**\n             * Override this method to catch when records are added\n             * @method \n             * @param {int} index\n             * @param {MetaphorJs.model.Record|object} rec\n             */\n            onAdd: emptyFn,\n\n            /**\n             * Remove records from specific position\n             * @method\n             * @param {number} index {\n             *  Starting index \n             *  @required\n             * }\n             * @param {number} length {\n             *  Number of records to remove\n             *  @default 1\n             * }\n             * @param {boolean} silent Do not trigger events\n             * @param {boolean} skipUpdate Do not run store updates\n             * @param {boolean} unfiltered Execute on unfiltered set of records\n             * @returns {MetaphorJs.model.Record|object|undefined}\n             */\n            removeAt: function(index, length, silent, skipUpdate, unfiltered) {\n\n                let i       = 0,\n                    l       = this.length;\n\n                if (l === 0) {\n                    return;\n                }\n\n                if (index === null) {\n                    //index   = 0; ??\n                    return;\n                }\n                while (index < 0) {\n                    index   = l + index;\n                }\n\n                if (length == null) {\n                    length = 1;\n                }\n\n                if (!unfiltered) {\n                    index   = this.items.indexOf(this.current[index]);\n                }\n\n                while (index < this.length && index >= 0 && i < length) {\n\n                    this.length--;\n                    const rec     = this.items[index];\n                    this.items.splice(index, 1);\n\n                    const id      = this.getRecordId(rec);\n\n                    if (id !== undefined){\n                        delete this.itemMap[id];\n                        delete this.currentMap[id];\n                    }\n\n                    this.onRemove(rec, id);\n\n                    if (!skipUpdate) {\n                        this.update();\n                    }\n\n                    if (!silent) {\n                        this.trigger('remove', rec, id);\n                    }\n\n                    if (rec instanceof MetaphorJs.model.Record) {\n                        this.bindRecord(\"un\", rec);\n                        rec.detachStore(this);\n\n                        if (length === 1) {\n                            return rec.$destroyed ? undefined : rec;\n                        }\n                    }\n                    else {\n                        if (length === 1) {\n                            return rec;\n                        }\n                    }\n\n                    i++;\n                }\n\n                return undefined;\n            },\n\n            /**\n             * Remove records between start and end indexes\n             * @method\n             * @param {int} start Start index\n             * @param {int} end End index\n             * @param {boolean} silent Do not trigger events\n             * @param {boolean} skipUpdate Do not run store updates\n             * @param {boolean} unfiltered Execute on unfiltered set of records\n             * @returns {MetaphorJs.model.Record|object|undefined}\n             */\n            removeRange: function(start, end, silent, skipUpdate, unfiltered) {\n                const l = this.length;\n\n                if (l === 0) {\n                    return;\n                }\n\n                if (start == null && end == null) {\n                    return this.clear(silent);\n                }\n\n                if (start == null) {\n                    start   = 0;\n                }\n                while (start < 0) {\n                    start   = l + start;\n                }\n                if (end == null) {\n                    end     = l - 1;\n                }\n                while (end < 0) {\n                    end     = l + start;\n                }\n\n                return this.removeAt(start, (end - start) + 1, silent, skipUpdate, unfiltered);\n            },\n\n            /**\n             * Override this method to catch all record removals\n             * @method\n             * @param {MetaphorJs.model.Record|object} rec\n             * @param {int|string|null} id\n             */\n            onRemove: emptyFn,\n\n            /**\n             * Insert multiple records at specific index. (Works with unfiltered set)\n             * @method\n             * @param {int} index {\n             *  @required\n             * }\n             * @param {array} recs\n             * @param {boolean} silent Do not trigger events\n             * @param {boolean} skipUpdate Do not run store updates\n             */\n            insertMany: function(index, recs, silent, skipUpdate) {\n                let i, l;\n                for (i = 0, l = recs.length; i < l; i++) {\n                    this.insert(index + i, recs[i], true, true);\n                }\n                if (l > 0 && !skipUpdate) {\n                    this.update();\n                }\n                if (l > 0 && !silent) {\n                    this.trigger(\"add\", recs);\n                }\n            },\n\n            /**\n             * Insert record at specific index. (Works with unfiltered set)\n             * @method\n             * @param {number} index {\n             *  @required\n             * }\n             * @param {MetaphorJs.model.Record|object} rec\n             * @param {boolean} silent Do not trigger events\n             * @param {boolean} skipUpdate Do not run store updates\n             * @returns {MetaphorJs.model.Record|object}\n             */\n            insert: function(index, rec, silent, skipUpdate) {\n\n                let id,\n                    last = false;\n\n                rec     = this.processRawDataItem(rec);\n                id      = this.getRecordId(rec);\n\n                if(this.itemMap[id]){\n                    this.$$observable.suspendAllEvents();\n                    this.removeId(id);\n                    this.$$observable.resumeAllEvents();\n                }\n\n                if(index >= this.length){\n                    this.items.push(rec);\n                    last = true;\n                }\n                else {\n                    this.items.splice(index, 0, rec);\n                }\n\n                this.length++;\n\n                if (this.maxLength && this.length > this.maxLength) {\n                    if (last) {\n                        this.pop(silent, true);\n                    }\n                    else {\n                        this.shift(silent, true);\n                    }\n                }\n\n                if(id !== undefined){\n                    this.itemMap[id] = rec;\n                }\n\n                if (rec instanceof MetaphorJs.model.Record) {\n                    rec.attachStore(this);\n                    this.bindRecord(\"on\", rec);\n                }\n\n                this.onAdd(index, rec);\n\n                if (!skipUpdate) {\n                    this.update();\n                }\n\n                if (!silent) {\n                    this.trigger('add', [rec]);\n                }\n\n                return rec;\n            },\n\n            /**\n             * Replace one record with another\n             * @method\n             * @param {MetaphorJs.model.Record|object} old Old record\n             * @param {MetaphorJs.model.Record|object} rec New record\n             * @param {boolean} silent Do not trigger events\n             * @param {boolean} skipUpdate Do not run store updates\n             * @returns {MetaphorJs.model.Record|object} new record\n             */\n            replace: function(old, rec, silent, skipUpdate) {\n\n                const index   = this.items.indexOf(old);\n\n                this.removeAt(index, 1, true, true, true);\n                this.insert(index, rec, true, true);\n\n                if (!skipUpdate) {\n                    this.update();\n                }\n\n                this.onReplace(old, rec);\n\n                if (!silent) {\n                    this.trigger('replace', old, rec);\n                }\n\n                return rec;\n            },\n\n\n            /**\n             * Replace record with given id by another record\n             * @method\n             * @param {int|string} id Old record id\n             * @param {MetaphorJs.model.Record|object} rec New record\n             * @param {boolean} silent Do not trigger events\n             * @param {boolean} skipUpdate Do not run store updates\n             * @returns {MetaphorJs.model.Record|object} new record\n             */\n            replaceId: function(id, rec, silent, skipUpdate) {\n                const index = this.indexOfId(id);\n                return this.replace(this.getAt(index), rec, silent, skipUpdate);\n            },\n\n            /**\n             * Override this method to catch all record replacements\n             * @method\n             * @param {MetaphorJs.model.Record|object} old Old record\n             * @param {MetaphorJs.model.Record|object} rec New record\n             */\n            onReplace: emptyFn,\n\n            /**\n             * Remove record from the store\n             * @method\n             * @param {MetaphorJs.model.Record|object} rec\n             * @param {boolean} silent Do not trigger events\n             * @param {boolean} skipUpdate Do not run store updates\n             * @returns {MetaphorJs.model.Record|object|null}\n             */\n            remove: function(rec, silent, skipUpdate) {\n                const inx = this.indexOf(rec, true);\n                if (inx !== -1) {\n                    return this.removeAt(inx, 1, silent, skipUpdate, true);\n                }\n                return null;\n            },\n\n            /**\n             * Remove record from the store by record id\n             * @method\n             * @param {string|int} id Record id\n             * @param {boolean} silent Do not trigger events\n             * @param {boolean} skipUpdate Do not run store updates\n             * @returns {MetaphorJs.model.Record|object|null}\n             */\n            removeId: function(id, silent, skipUpdate) {\n                const inx = this.indexOfId(id, true);\n                if (inx !== -1) {\n                    return this.removeAt(inx, 1, silent, skipUpdate, true);\n                }\n            },\n\n\n\n            /**\n             * Does this store contains record\n             * @method\n             * @param {MetaphorJs.model.Record|object} rec\n             * @param {boolean} unfiltered Check unfiltered set\n             * @returns {boolean}\n             */\n            contains: function(rec, unfiltered) {\n                return this.indexOf(rec, unfiltered) !== -1;\n            },\n\n            /**\n             * Does this store contains a record with given id\n             * @method\n             * @param {string|int} id Record id\n             * @param {boolean} unfiltered Check in unfiltered set\n             * @returns {boolean}\n             */\n            containsId: function(id, unfiltered) {\n                if (unfiltered) {\n                    return this.itemMap[id] !== undefined;\n                }\n                else {\n                    return this.currentMap[id] !== undefined;\n                }\n            },\n\n            /**\n             * Remove all records from the store\n             * @method\n             * @param {boolean} silent Do not trigger events\n             */\n            clear: function(silent) {\n\n                const recs = this.getRange();\n\n                this._reset();\n                this.onClear();\n\n                if (!silent) {\n                    this.trigger('update', this);\n                    this.trigger('clear', this, recs);\n                }\n            },\n\n            /**\n             * Override this method to catch when the store is being cleared\n             * @method\n             */\n            onClear: emptyFn,\n\n            /**\n             * Same as clear but it doesn't trigger any events. \n             * This is what clear() calls internally\n             * @method\n             */\n            reset: function() {\n                this._reset();\n                this.start = 0;\n            },\n\n            _reset: function(keepRecords) {\n                let i, len, rec;\n\n                if (!keepRecords) {\n                    for (i = 0, len = this.items.length; i < len; i++) {\n                        rec = this.items[i];\n                        if (rec instanceof MetaphorJs.model.Record) {\n                            this.bindRecord(\"un\", rec);\n                            rec.detachStore(this);\n                        }\n                    }\n                }\n\n                this.length         = 0;\n                this.currentLength  = 0;\n                this.totalLength    = 0;\n                this.items          = [];\n                this.current        = [];\n                this.itemMap        = {};\n                this.currentMap     = {};\n                this.loaded         = this.local;\n            },\n\n\n            /**\n             * Get record at given index\n             * @method\n             * @param {int} index\n             * @param {boolean} unfiltered Get from unfiltered set\n             * @returns {MetaphorJs.model.Record|object|null}\n             */\n            getAt: function(index, unfiltered) {\n                return unfiltered ?\n                       (this.items[index] || undefined) :\n                       (this.current[index] || undefined);\n            },\n\n            /**\n             * Get record by id\n             * @method\n             * @param {string|int} id Record id\n             * @param {boolean} unfiltered Get from unfiltered set\n             * @returns {MetaphorJs.model.Record|object|null}\n             */\n            getById: function(id, unfiltered) {\n                return unfiltered ?\n                       (this.itemMap[id] || undefined) :\n                       (this.currentMap[id] || undefined);\n            },\n\n            /**\n             * Get index of record\n             * @method\n             * @param {MetaphorJs.model.Record|object} rec\n             * @param {boolean} unfiltered Lookup in unfiltered set\n             * @returns {int} returns -1 if not found\n             */\n            indexOf: function(rec, unfiltered) {\n                return unfiltered ?\n                       this.items.indexOf(rec) :\n                       this.current.indexOf(rec);\n            },\n\n            /**\n             * Get index of record by given record id\n             * @method\n             * @param {string|int} id Record id\n             * @param {boolean} unfiltered Lookup in unfiltered set\n             * @returns {int} returns -1 if not found\n             */\n            indexOfId: function(id, unfiltered) {\n                return this.indexOf(this.getById(id, unfiltered), unfiltered);\n            },\n\n            /**\n             * Interate over store records\n             * @method\n             * @param {function} fn {\n             *      @param {MetaphorJs.model.Record|object} rec\n             *      @param {number} index\n             *      @param {number} length\n             *      @returns {boolean|null} return false to stop\n             * }\n             * @param {object} context fn's context\n             * @param {boolean} unfiltered Iterate over unfiltered set\n             */\n            each: function(fn, context, unfiltered) {\n                const items = unfiltered ?\n                            this.items.slice() :\n                            this.current.slice();\n                let i, len;\n\n                for(i = 0, len = items.length; i < len; i++){\n                    if(fn.call(context, items[i], i, len) === false){\n                        break;\n                    }\n                }\n            },\n\n            /**\n             * Map store\n             * @param {function} fn \n             * @param {object} context \n             * @param {boolean} unfiltered \n             * @returns []\n             */\n            map: function(fn, context, unfiltered) {\n                const ret = [];\n                this.each(rec => ret.push(fn.call(context, rec)), null, unfiltered);\n                return ret;\n            },\n\n            /**\n             * Iterate over store records\n             * @method\n             * @param {function} fn {\n             *      @param {string|number} id Record id\n             *      @param {number} index Record position in set\n             *      @param {number} length Set length\n             *      @returns {boolean|null} return false to stop\n             * }\n             * @param {object} context fn's context\n             * @param {boolean} unfiltered Iterate over unfiltered set\n             */\n            eachId: function(fn, context, unfiltered) {\n                this.each(\n                    (rec, i, len) => \n                        fn.call(context, this.getRecordId(rec), i, len), \n                    null, \n                    unfiltered\n                );\n            },\n\n            /**\n             * Collect values of given field\n             * @method\n             * @param {string} f Field name\n             * @param {boolean} unfiltered Collect from unfiltered set\n             * @returns {array}\n             */\n            collect: function(f, unfiltered) {\n\n                const rt      = !this.model.isPlain();\n\n                return this.map(\n                            rec => rt ? rec.get(f) : rec[f], \n                            null, \n                            unfiltered\n                        )\n                        .filter(r => r !== undefined)\n            },\n\n            /**\n             * Get first record\n             * @method\n             * @param {boolean} unfiltered Get from unfiltered set\n             * @returns {MetaphorJs.model.Record|object|null}\n             */\n            first : function(unfiltered){\n                return unfiltered ? this.items[0] : \n                                    this.current[0];\n            },\n\n            /**\n             * Get last record\n             * @method\n             * @param {boolean} unfiltered Get from unfiltered set\n             * @returns {MetaphorJs.model.Record|object|null}\n             */\n            last : function(unfiltered){\n                return unfiltered ? this.items[this.length-1] : \n                                    this.current[this.current-1];\n            },\n\n            /**\n             * Get a slice of records list\n             * @method\n             * @param {number} start {\n             *  Start index\n             *  @default 0\n             * }\n             * @param {number} end {\n             *  End index\n             *  @default length-1\n             * }\n             * @param {boolean} unfiltered Get from unfiltered set\n             * @returns {MetaphorJs.model.Record[]|object[]}\n             */\n            getRange : function(start, end, unfiltered){\n                const items   = unfiltered ? this.items : this.current,\n                      r       = [];\n                let   i;\n\n                if(items.length < 1){\n                    return r;\n                }\n\n                start   = start || 0;\n                end     = Math.min(end == undefined ? this.length-1 : end, this.length-1);\n\n                if(start <= end){\n                    for(i = start; i <= end; i++) {\n                        r.push(items[i]);\n                    }\n                }else{\n                    for(i = start; i >= end; i--) {\n                        r.push(items[i]);\n                    }\n                }\n                return r;\n            },\n\n            /**\n             * Find and return record matching custom filter\n             * @method\n             * @param {function} fn {\n             *      @param {MetaphorJs.model.Record|object} rec\n             *      @param {string|int} id\n             *      @returns {boolean} Return true to accept record\n             * }\n             * @param {object} context fn's context\n             * @param {number} start { @default 0 }\n             * @param {boolean} unfiltered Look in unfiltered set\n             * @returns {MetaphorJs.model.Record|object|null}\n             */\n            findBy: function(fn, context, start, unfiltered) {\n                const inx = this.findIndexBy(fn, context, start, unfiltered);\n                return inx === -1 ? undefined : this.getAt(inx, unfiltered);\n            },\n\n            /**\n             * Find index of a record matching custom filter\n             * @method\n             * @param {function} fn {\n             *      @param {MetaphorJs.model.Record|object} rec\n             *      @param {string|int} id\n             *      @returns {boolean} return true to accept record\n             * }\n             * @param {object} context fn's context\n             * @param {number} start { @default 0 }\n             * @param {boolean} unfiltered Look in unfiltered set\n             * @returns {int} returns -1 if not found\n             */\n            findIndexBy : function(fn, context, start, unfiltered) {\n\n                const it  = unfiltered ? this.items : this.current;\n                let i, len;\n\n                for(i = (start||0), len = it.length; i < len; i++) {\n                    if(fn.call(context, it[i], this.getRecordId(it[i]))){\n                        return i;\n                    }\n                }\n\n                return -1;\n            },\n\n            /**\n             * Find record by its field value\n             * @method\n             * @param {string} property Record's field name\n             * @param {string|int|bool} value Value to compare to\n             * @param {bool} exact Make a strict comparison\n             * @param {boolean} unfiltered Look in unfiltered set\n             * @returns {MetaphorJs.model.Record|object|null}\n             * @code store.find(\"name\", \"Jane\");\n             */\n            find: function(property, value, exact, unfiltered) {\n\n                const rt    = !this.model.isPlain();\n                const inx   = this.findIndexBy(rec => {\n\n                    const v = rt ? rec.get(property) : rec[property];\n\n                    if (exact) {\n                        return v === value;\n                    }\n                    else {\n                        return v == value;\n                    }\n\n                }, this, 0, unfiltered);\n\n                return inx !== -1 ? this.getAt(inx, unfiltered) : null;\n            },\n\n            /**\n             * Find record by its field value.<br>\n             * Same as <code>find()</code> but with exact=true\n             * @method\n             * @param {string} property Record's field name\n             * @param {string|int|bool} value Value to compare to\n             * @param {boolean} unfiltered Look in unfiltered set\n             * @returns {MetaphorJs.model.Record|object|null}\n             */\n            findExact: function(property, value, unfiltered) {\n                return this.find(property, value, true, unfiltered);\n            },\n\n            /**\n             * Find record by a set of fields\n             * @method\n             * @param {object} props A set of field:value pairs to match record against.\n             * All fields must match for the record to be accepted.\n             * @param {boolean} unfiltered Look in unfiltered set\n             * @returns {MetaphorJs.model.Record|object|null}\n             */\n            findBySet: function(props, unfiltered) {\n\n                let found   = null,\n                    match,\n                    i;\n\n                this.each(function(rec){\n\n                    match   = true;\n\n                    for (i in props) {\n                        if (props[i] != rec[i]) {\n                            match   = false;\n                            break;\n                        }\n                    }\n\n                    if (match) {\n                        found   = rec;\n                        return false;\n                    }\n\n                    return true;\n                }, null, unfiltered);\n\n                return found;\n            },\n\n\n\n\n            /**\n             * Re-apply filter and sorting. \n             * Call this function if you used <code>skipUpdate</code> before.\n             * @method\n             */\n            update: function() {\n\n                const filtered    = this.filtered,\n                      sorted      = this.sorted,\n                      isPlain     = this.model.isPlain();\n\n                if (this.local) {\n                    this.totalLength = this.length = this.items.length;\n                }\n\n                this.currentLength  = this.length;\n                this.currentMap     = this.itemMap;\n                this.current        = this.items;\n\n                if (filtered) {\n\n                    const by              = this.filterBy,\n                          opt             = this.filterOpt;\n                    let current, map;\n\n                    this.current        = current = [];\n                    this.currentMap     = map = {};\n\n                    this.each((rec) => {\n                        if (filterArray.compare(isPlain ? rec : rec.data, by, opt)) {\n                            current.push(rec);\n                            map[this.getRecordId(rec)] = rec;\n                        }\n                    }, null, true);\n\n                    this.currentLength  = this.current.length;\n                }\n\n                if (this.local && this.pageSize) {\n                    this.current = this.current.slice(this.start, this.start + this.pageSize);\n                    this.currentLength  = this.current.length;\n                }\n\n                if (sorted) {\n                    const sortBy        = this.sortBy,\n                        rt              = !this.model.isPlain(),\n                        getterFn        = function(item) {\n                            return rt ? item.get(sortBy) : item[sortBy];\n                        };\n\n                    this.current        = sortArray(\n                        this.current, \n                        isFunction(sortBy) ? {fn: sortBy} : getterFn, \n                        this.sortDir\n                    );\n                }\n\n                this.trigger(\"update\", this);\n            },\n\n\n            /**\n             * Filter store using a custom filter. This will change store contents\n             * and length and you might have to use <code>unfiltered</code> flag\n             * in some of the methods later. \n             * @method\n             * @param {object|string|regexp|function|boolean} by\n             * @param {string|boolean} opt\n             * @code metaphorjs-shared/src-docs/examples/filterArray.js\n             */\n            filter: function(by, opt) {\n\n                this.filtered       = true;\n                this.filterBy       = by;\n                this.filterOpt      = opt;\n\n                this.update();\n            },\n\n            /**\n             * Clear filter\n             * @method\n             */\n            clearFilter: function() {\n\n                if (!this.filtered) {\n                    return;\n                }\n\n                this.filterBy = null;\n                this.filterOpt = null;\n\n                this.update();\n            },\n\n            /**\n             * Sort array\n             * @method\n             * @param {string|function} by {\n             *  Either a field name to sort by, or a function \n             *  @param {MetaphorJs.model.Record|object} a\n             *  @param {MetaphorJs.model.Record|object} b \n             *  @returns {int} -1|0|1\n             * }\n             * @param {string} dir asc|desc\n             */\n            sort: function(by, dir) {\n                this.sorted = true;\n                this.sortBy = by;\n                this.sortDir = dir;\n                this.update();\n            },\n\n            /**\n             * Clear sorting\n             * @method\n             */\n            clearSorting: function() {\n                this.sorted = false;\n                this.sortBy = null;\n                this.sortDir = null;\n                this.update();\n            },\n\n\n            onDestroy: function() {\n\n                delete allStores[this.id];\n\n                if (this.sourceStore) {\n                    this.initSourceStore(this.sourceStore, \"un\");\n                }\n\n                this.clear();\n                this.trigger(\"destroy\", this);\n                this.$super();\n            }\n\n        },\n\n        {\n            /**\n             * Find store\n             * @static\n             * @method\n             * @param {string} id\n             * @returns MetaphorJs.model.Store|null\n             */\n            lookupStore: function(id) {\n                return allStores[id] || null;\n            },\n\n            /**\n             * Iterate over registered stores\n             * @static\n             * @method\n             * @param {function} fn {\n             *  @param {MetaphorJs.model.Store} store\n             *  @returns {boolean} return false to stop\n             * }\n             * @param {object} fnScope\n             */\n            eachStore: function(fn, fnScope) {\n\n                let id;\n\n                for (id in allStores) {\n                    if (fn.call(fnScope, allStores[id]) === false) {\n                        break;\n                    }\n                }\n            }\n        }\n    );\n}();","require(\"metaphorjs-shared/src/lib/Cache\");\nconst isObject = require(\"metaphorjs-shared/src/func/isObject\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs\");\n\n/**\n * @class MetaphorJs.lib.Namespace\n * @code src-docs/examples/main.js\n */\n\n/**\n * Construct namespace\n * @constructor\n * @param {object} root {\n *  Namespace root object. Everything you register\n *  will be assigned as property of root object at some level.\n *  The parameter is optional. Pass your own object or window or global\n *  to have direct access to its properties. \n *  @optional\n * }\n */\nmodule.exports = MetaphorJs.lib.Namespace = function(root) {\n\n    root        = root || {};\n\n    var self    = this,\n        cache   = new MetaphorJs.lib.Cache(false);\n\n    var parseNs     = function(ns) {\n\n        var tmp     = ns.split(\".\"),\n            i,\n            last    = tmp.pop(),\n            parent  = tmp.join(\".\"),\n            len     = tmp.length,\n            name,\n            current = root;\n\n        if (cache[parent]) {\n            return [cache[parent], last, ns];\n        }\n\n        if (len > 0) {\n            for (i = 0; i < len; i++) {\n\n                name    = tmp[i];\n\n                if (current[name] === undefined) {\n                    current[name]   = {};\n                }\n\n                current = current[name];\n            }\n        }\n\n        return [current, last, ns];\n    };\n\n    /**\n     * Get namespace/cache object. \n     * @method\n     * @param {string} objName Object name to get link to. Use the same name\n     * as you used then registered or added the object.\n     * @param {bool} cacheOnly Only get cached value. \n     * Return undefined if there is no cached value.\n     * @returns {*}\n     */\n    var get       = function(objName, cacheOnly) {\n\n        var ex = cache.get(objName);\n        if (ex !== undefined || cacheOnly) {\n            return ex;\n        }\n\n        var tmp     = objName.split(\".\"),\n            i,\n            len     = tmp.length,\n            name,\n            current = root;\n\n        for (i = 0; i < len; i++) {\n\n            name    = tmp[i];\n\n            if (current[name] === undefined) {\n                return undefined;\n            }\n\n            current = current[name];\n        }\n\n        if (current) {\n            cache.add(objName, current);\n        }\n\n        return current;\n    };\n\n    /**\n     * Register item in namespace and cache. Given <code>root</code> is your\n     * root object, registering <code>register(\"My.Value\", 1)</code> will \n     * result in <code>root.My.Value === 1</code>.\n     * @method\n     * @param {string} objName Object name to register\n     * @param {*} value\n     * @returns {*} value\n     */\n    var register    = function(objName, value) {\n\n        var parse   = parseNs(objName),\n            parent  = parse[0],\n            name    = parse[1];\n\n        if (isObject(parent) && parent[name] === undefined) {\n            parent[name]        = value;\n            cache.add(parse[2], value);\n        }\n\n        return value;\n    };\n\n    /**\n     * Check if given object name exists in namespace.\n     * @method\n     * @param {string} objName\n     * @returns {boolean}\n     */\n    var exists      = function(objName) {\n        return get(ns, true) !== undefined;\n    };\n\n    /**\n     * Add item only to cache. This method will not add anything\n     * to the root object. The <code>get</code> method will still return\n     * value of this object.\n     * @method\n     * @param {string} objName\n     * @param {*} value\n     * @returns {*} value\n     */\n    var add = function(objName, value) {\n        return cache.add(objName, value);\n    };\n\n    /**\n     * Remove item from cache. Leaves namespace object unchanged.\n     * @method\n     * @param {string} objName\n     * @returns {*} removed value\n     */\n    var remove = function(objName) {\n        return cache.remove(objName);\n    };\n\n    /**\n     * Make alias in the cache.\n     * @method\n     * @param {string} from\n     * @param {string} to\n     * @returns {*} value\n     */\n    var makeAlias = function(from, to) {\n\n        var value = cache.get(from);\n\n        if (value !== undefined) {\n            cache.add(to, value);\n        }\n\n        return value;\n    };\n\n    /**\n     * Destroy namespace and all classes in it\n     * @method $destroy\n     */\n    var destroy     = function() {\n\n        var self = this,\n            k;\n\n        cache.eachEntry(function(entry){\n            if (entry && entry.$destroy) {\n                entry.$destroy();\n            }\n        });\n\n        cache.$destroy();\n        cache = null;\n\n        for (k in self) {\n            self[k] = null;\n        }\n    };\n\n    self.register   = register;\n    self.exists     = exists;\n    self.get        = get;\n    self.add        = add;\n    self.remove     = remove;\n    self.makeAlias  = makeAlias;\n    self.$destroy    = destroy;\n};\n","require(\"../lib/Namespace\");\nconst MetaphorJs = require('metaphorjs-shared/src/MetaphorJs');\n\n/**\n * Already constructed private namespace \n * with <code>MetaphorJs</code> object and its alias <code>mjs</code> \n * registered at top level.\n * @var ns \n */\nmodule.exports = (function(){\n    var ns = new MetaphorJs.lib.Namespace;\n    ns.register(\"MetaphorJs\", MetaphorJs);\n    ns.register(\"mjs\", MetaphorJs);\n    return ns;\n}());\n","\nconst extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n    \nrequire(\"./ObservableEvent.js\");\n\nmodule.exports = MetaphorJs.lib.Observable = (function(){\n\n/**\n * @description A javascript event system implementing multiple patterns: \n * observable, collector and pipe.\n * @description Observable:\n * @code src-docs/examples/observable.js\n *\n * @description Collector:\n * @code src-docs/examples/collector.js\n * \n * @description Pipe:\n * @code src-docs/examples/pipe.js\n *\n * @class MetaphorJs.lib.Observable\n * @author Ivan Kuindzhi\n */\nvar Observable = function() {\n\n    this.events = {};\n\n};\n\n\nextend(Observable.prototype, {\n\n\n    /**\n     * @method createEvent\n     * @param {string} name {\n     *      Event name\n     *      @required\n     * }\n     * @param {object|string|bool} options {\n     *  Options object or returnResult value. All options are optional.\n     * \n     *  @type {string|bool} returnResult {\n     *   false -- return first 'false' result and stop calling listeners after that<br>\n     *   true -- return first 'true' result and stop calling listeners after that<br>\n     *   \"all\" -- return all results as array<br>\n     *   \"concat\" -- merge all results into one array (each result must be array)<br>\n     *   \"merge\" -- merge all results into one object (each result much be object)<br>\n     *   \"pipe\" -- pass return value of previous listener to the next listener.\n     *             Only first trigger parameter is being replaced with return value,\n     *             others stay as is.<br>\n     *   \"first\" -- return result of the first handler (next listener will not be called)<br>\n     *   \"nonempty\" -- return first nonempty result<br>\n     *   \"last\" -- return result of the last handler (all listeners will be called)<br>\n     *  }\n     *  @type {bool} autoTrigger {\n     *      once triggered, all future subscribers will be automatically called\n     *      with last trigger params\n     *      @code src-docs/examples/autoTrigger.js\n     * }\n     *  @type {function} triggerFilter {\n     *      This function will be called each time event is triggered. \n     *      Return false to skip listener.\n     *       @code src-docs/examples/triggerFilter.js\n     *       @param {object} listener This object contains all information about the listener, including\n     *           all data you provided in options while subscribing to the event.\n     *       @param {[]} arguments\n     *       @return {bool}\n     *  }\n     *  @type {object} filterContext triggerFilter's context\n     *  @type {bool} expectPromises {   \n     *      Expect listeners to return Promises. If <code>returnResult</code> is set,\n     *      promises will be treated as return values unless <code>resolvePromises</code>\n     *      is set.\n     *  }\n     *  @type {bool} resolvePromises {\n     *      In pair with <code>expectPromises</code> and <code>returnResult</code>\n     *      this option makes trigger function wait for promises to resolve.\n     *      All or just one depends on returnResult mode. \"pipe\" mode \n     *      makes promises resolve consequentially passing resolved value\n     *      to the next promise.\n     *  }\n     * }\n     * @returns {MetaphorJs.lib.ObservableEvent}\n     */\n    createEvent: function(name, options) {\n        name = name.toLowerCase();\n        var events  = this.events;\n        if (!events[name]) {\n            events[name] = new MetaphorJs.lib.ObservableEvent(name, options);\n        }\n        return events[name];\n    },\n\n    /**\n    * @method\n    * @access public\n    * @param {string} name Event name\n    * @return {MetaphorJs.lib.ObservableEvent|undefined}\n    */\n    getEvent: function(name) {\n        name = name.toLowerCase();\n        return this.events[name];\n    },\n\n    /**\n    * Subscribe to an event or register collector function.\n    * @method\n    * @access public\n    * @param {string} name {\n    *       Event name. Use '*' to subscribe to all events.\n    *       @required\n    * }\n    * @param {function} fn {\n    *       Callback function\n    *       @required\n    * }\n    * @param {object} context \"this\" object for the callback function\n    * @param {object} options {\n    *       You can pass any key-value pairs in this object. All of them will be passed \n    *       to triggerFilter (if you're using one).\n    *       @type {bool} first {\n    *           True to prepend to the list of handlers\n    *           @default false\n    *       }\n    *       @type {number} limit {\n    *           Call handler this number of times; 0 for unlimited\n    *           @default 0\n    *       }\n    *       @type {number} start {\n    *           Start calling handler after this number of calls. Starts from 1\n    *           @default 1\n    *       }\n    *       @type {array} append Append parameters\n    *       @type {array} prepend Prepend parameters\n    *       @type {array} replaceArgs Replace parameters\n    *       @type {bool} allowDupes allow the same handler twice\n    *       @type {bool|int} async run event asynchronously. If event was\n    *                      created with <code>expectPromises: true</code>, \n    *                      this option is ignored.\n    * }\n    */\n    on: function(name, fn, context, options) {\n        name = name.toLowerCase();\n        var events  = this.events;\n        if (!events[name]) {\n            events[name] = new MetaphorJs.lib.ObservableEvent(name);\n        }\n        return events[name].on(fn, context, options);\n    },\n\n    /**\n    * Same as {@link class:Observable.on}, but options.limit is forcefully set to 1.\n    * @method\n    * @access public\n    */\n    once: function(name, fn, context, options) {\n        options     = options || {};\n        options.limit = 1;\n        return this.on(name, fn, context, options);\n    },\n\n    /**\n     * Subscribe to an event and return a promise that will be resolved\n     * with event payload\n     * @param {string} name Event name\n     * @return {Promise}\n     * @code src-docs/examples/promise.js\n     */\n    promise: function(name) {\n        return new Promise((resolve) => {\n            this.once(name, resolve, null, { limit: 1 });\n        });\n    },\n\n    /**\n    * Unsubscribe from an event\n    * @method\n    * @access public\n    * @param {string} name Event name\n    * @param {function} fn Event handler\n    * @param {object} context If you called on() with context you must \n    *                         call un() with the same context\n    */\n    un: function(name, fn, context) {\n        name = name.toLowerCase();\n        var events  = this.events;\n        if (!events[name]) {\n            return;\n        }\n        events[name].un(fn, context);\n    },\n\n    /**\n     * Relay all events of <code>eventSource</code> through this observable.\n     * @method\n     * @access public\n     * @code src-docs/examples/relay.js\n     * @param {object} eventSource\n     * @param {string} eventName\n     * @param {string} triggerName\n     * @param {string} triggerNamePfx prefix all relayed event names\n     */\n    relayEvent: function(eventSource, eventName, triggerName, triggerNamePfx) {\n        eventSource.on(eventName, this.trigger, this, {\n            prepend: eventName === \"*\" ? \n                        null: \n                        // use provided new event name or original name\n                        [triggerName || eventName],\n            replaceArgs: eventName === \"*\" && triggerNamePfx ? \n                            function(l, args) {\n                                args[0] = triggerNamePfx + args[0]\n                                return args;\n                            } : \n                            null\n        });\n    },\n\n    /**\n     * Stop relaying events of <code>eventSource</code>\n     * @method\n     * @access public\n     * @param {object} eventSource\n     * @param {string} eventName\n     */\n    unrelayEvent: function(eventSource, eventName) {\n        eventSource.un(eventName, this.trigger, this);\n    },\n\n    /**\n     * @method hasListener\n     * @access public\n     * @return bool\n     */\n\n    /**\n    * @method hasListener\n    * @access public\n    * @param {string} name Event name { @required }\n    * @return bool\n    */\n\n    /**\n    * @method\n    * @access public\n    * @param {string} name Event name { @required }\n    * @param {function} fn Callback function { @required }\n    * @param {object} context Function's \"this\" object\n    * @return bool\n    */\n    hasListener: function(name, fn, context) {\n        var events = this.events;\n\n        if (name) {\n            name = name.toLowerCase();\n            if (!events[name]) {\n                return false;\n            }\n            return events[name].hasListener(fn, context);\n        }\n        else {\n            for (name in events) {\n                if (events[name].hasListener()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    },\n\n    /**\n    * @method\n    * @access public\n    * @param {string} name Event name { @required }\n    * @return bool\n    */\n    hasEvent: function(name) {\n        return !!this.events[name];\n    },\n\n\n    /**\n    * Remove all listeners from all events\n    * @method removeAllListeners\n    * @access public\n    */\n\n    /**\n    * Remove all listeners from specific event\n    * @method\n    * @access public\n    * @param {string} name Event name { @required }\n    */\n    removeAllListeners: function(name) {\n        var events  = this.events;\n        if (name) {\n            if (!events[name]) {\n                return;\n            }\n            events[name].removeAllListeners();\n        }\n        else {\n            for (name in events) {\n                events[name].removeAllListeners();\n            }\n        }\n    },\n\n    /**\n    * Trigger an event -- call all listeners. Also triggers '*' event.\n    * @method\n    * @access public\n    * @param {string} name Event name { @required }\n    * @param {*} ... As many other params as needed\n    * @return mixed\n    */\n    trigger: function() {\n\n        var name = arguments[0],\n            events  = this.events,\n            e,\n            res = null;\n\n        name = name.toLowerCase();\n\n        if (events[name]) {\n            e = events[name];\n            res = e.trigger.apply(e, toArray(arguments).slice(1));\n        }\n\n        // trigger * event with current event name\n        // as first argument\n        if (e = events[\"*\"]) {\n            e.trigger.apply(e, arguments);\n        }\n        \n        return res;\n    },\n\n    /**\n    * Suspend an event. Suspended event will not call any listeners on trigger().\n    * @method\n    * @access public\n    * @param {string} name Event name\n    */\n    suspendEvent: function(name) {\n        name = name.toLowerCase();\n        var events  = this.events;\n        if (!events[name]) {\n            return;\n        }\n        events[name].suspend();\n    },\n\n    /**\n    * @method\n    * @access public\n    */\n    suspendAllEvents: function() {\n        var events  = this.events;\n        for (var name in events) {\n            events[name].suspend();\n        }\n    },\n\n    /**\n    * Resume suspended event.\n    * @method\n    * @access public\n    * @param {string} name Event name\n    */\n    resumeEvent: function(name) {\n        name = name.toLowerCase();\n        var events  = this.events;\n        if (!events[name]) {\n            return;\n        }\n        events[name].resume();\n    },\n\n    /**\n    * @method\n    * @access public\n    */\n    resumeAllEvents: function() {\n        var events  = this.events;\n        for (var name in events) {\n            events[name].resume();\n        }\n    },\n\n    /**\n     * @method\n     * @access public\n     * @param {string} name Event name\n     */\n    destroyEvent: function(name) {\n        var events  = this.events;\n        if (events[name]) {\n            events[name].removeAllListeners();\n            events[name].$destroy();\n            delete events[name];\n        }\n    },\n\n\n    /**\n    * Destroy observable\n    * @method\n    * @md-not-inheritable\n    * @access public\n    */\n    $destroy: function() {\n        var self    = this,\n            events  = self.events;\n\n        for (var i in events) {\n            self.destroyEvent(i);\n        }\n\n        for (i in self) {\n            self[i] = null;\n        }\n    }\n}, true, false);\n\n\nconst __createEvents = function(host, obs, events) {\n    for (var i in events) {\n        host.createEvent ?\n            host.createEvent(i, events[i]) :\n            obs.createEvent(i, events[i]);\n    }\n};\n\nconst __on = function(host, obs, event, fn, context) {\n    host.on ?\n        host.on(event, fn, context || host) :\n        obs.on(event, fn, context || host);\n};\n\nObservable['$initHost'] = function(host, hostCfg, observable)  {\n    var i;\n\n    if (host.$$events) {\n        __createEvents(host, observable, host.$$events);\n    }\n\n    if (hostCfg && hostCfg.callback) {\n        var ls = hostCfg.callback,\n            context = ls.context || ls.scope || ls.$context;\n\n        if (ls.$events)\n            __createEvents(host, observable, ls.$events);\n\n        ls.context = null;\n        ls.scope = null;\n\n        for (i in ls) {\n            if (ls[i]) {\n                __on(host, observable, i, ls[i], context);\n            }\n        }\n\n        hostCfg.callback = null;\n\n        if (context) {\n            host.$$callbackContext = context;\n        }\n    }\n};\n\nObservable['$initHostConfig'] = function(host, config, scope, node) {\n    var msl = MetaphorJs.lib.Config.MODE_LISTENER,\n        ctx;\n\n    config.setDefaultMode(\"callbackContext\", MetaphorJs.lib.Config.MODE_SINGLE);\n    config.eachProperty(function(name) {\n        if (name.substring(0,4) === 'on--') {\n            config.setMode(name, msl);\n            if (!ctx) {\n                if (scope.$app)\n                    ctx = config.get(\"callbackContext\") ||\n                            (node ? scope.$app.getParentCmp(node) : null) ||\n                            scope.$app ||\n                            scope;\n                else \n                    ctx = config.get(\"callbackContext\") || scope;\n            }\n            host.on(name.substring(4), config.get(name), ctx);\n        }\n    });\n};\n\n\nreturn Observable;\n}());","\nconst nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    async = require(\"metaphorjs-shared/src/func/async.js\"),\n    error = require(\"metaphorjs-shared/src/func/error.js\"),\n    isFunction = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nmodule.exports = MetaphorJs.lib.ObservableEvent = (function(){\n\n/**\n * This class is private - you can't create an event other than via Observable.\n * See {@link class:Observable} reference.\n * @class MetaphorJs.lib.ObservableEvent\n * @private\n */\nvar ObservableEvent = function(name, options) {\n\n    var self    = this;\n\n    self.name           = name;\n    self.listeners      = [];\n    self.map            = {};\n    self.hash           = nextUid();\n    self.uni            = '$$' + name + '_' + self.hash;\n    self.suspended      = false;\n    self.lid            = 0; // listener id\n    self.fid            = 0; // function id (same function can be different listeners)\n    //self.limit          = 0;\n    \n    if (typeof options === \"object\" && options !== null) {\n        extend(self, options, true, false);\n    }\n    else {\n        self.returnResult = options;\n    }\n\n    self.triggered      = 0;\n};\n\n\nextend(ObservableEvent.prototype, {\n\n    name: null,\n    listeners: null,\n    map: null,\n    hash: null,\n    uni: null,\n    suspended: false,\n    lid: null,\n    fid: null,\n    limit: 0,\n    triggered: 0,\n    returnResult: null,\n    autoTrigger: null,\n    lastTrigger: null,\n    triggerFilter: null,\n    filterContext: null,\n    expectPromises: false,\n    resolvePromises: false,\n\n    /**\n     * Get event name\n     * @method\n     * @returns {string}\n     */\n    getName: function() {\n        return this.name;\n    },\n\n    /**\n     * @method\n     */\n    $destroy: function() {\n        var self        = this,\n            k;\n\n        for (k in self) {\n            self[k] = null;\n        }\n    },\n\n    /**\n     * @method\n     * @param {function} fn Callback function { @required }\n     * @param {object} context Function's \"this\" object\n     * @param {object} options See {@link class:Observable.on}\n     */\n    on: function(fn, context, options) {\n\n        if (!fn) {\n            return null;\n        }\n\n        context     = context || null;\n        options     = options || {};\n\n        var self    = this,\n            uni     = self.uni,\n            lid     = ++self.lid,\n            fid     = fn[uni] || ++self.fid,\n            ctxUni  = uni + \"_\" + fid,\n            first   = options.first || false;\n\n        if (fn[uni] && (!context || context[ctxUni]) && !options.allowDupes) {\n            return null;\n        }\n        if (!fn[uni]) {\n            fn[uni]  = fid;\n        }\n        if (context && !context[ctxUni]) {\n            context[ctxUni] = true;\n        }\n\n        var e = {\n            fn:         fn,\n            context:    context,\n            id:         lid,\n            fid:        fid,\n            async:      false,\n            called:     0, // how many times the function was triggered\n            limit:      0, // how many times the function is allowed to trigger\n            start:      1, // from which attempt it is allowed to trigger the function\n            count:      0, // how many attempts to trigger the function was made\n            append:     null, // append parameters\n            prepend:    null, // prepend parameters\n            replaceArgs:null // replace parameters\n        };\n\n        extend(e, options, true, false);\n\n        if (e.async === true) {\n            e.async = 1;\n        }\n        if (options.once) {\n            e.limit = 1;\n        }\n\n        if (first) {\n            self.listeners.unshift(e);\n        }\n        else {\n            self.listeners.push(e);\n        }\n\n        self.map[lid] = e;\n\n        if (self.autoTrigger && self.lastTrigger && !self.suspended) {\n            var prevFilter = self.triggerFilter;\n            self.triggerFilter = function(l){\n                if (l.id === lid) {\n                    return prevFilter ? prevFilter(l) !== false : true;\n                }\n                return false;\n            };\n            self.trigger.apply(self, self.lastTrigger);\n            self.triggerFilter = prevFilter;\n        }\n\n        return lid;\n    },\n\n    /**\n     * @method\n     * @param {function} fn Callback function { @required }\n     * @param {object} context Function's \"this\" object\n     * @param {object} options See {@link class:Observable.on}\n     */\n    once: function(fn, context, options) {\n\n        options = options || {};\n        options.limit = 1;\n\n        return this.on(fn, context, options);\n    },\n\n    /**\n     * @method\n     * @param {function} fn Callback function { @required }\n     * @param {object} context Callback context\n     */\n    un: function(fn, context) {\n\n        var self        = this,\n            inx         = -1,\n            uni         = self.uni,\n            listeners   = self.listeners,\n            fid, lid;\n\n        if (fn == parseInt(fn)) {\n            lid = parseInt(fn);\n            if (!self.map[lid]) {\n                return false;\n            }\n            fid = self.map[lid].fid;\n        }\n        else {\n            fid = fn[uni];\n        }\n\n        if (!fid) {\n            return false;\n        }\n\n        var ctxUni  = uni + \"_\" + fid;\n        context     = context || null;\n\n        for (var i = 0, len = listeners.length; i < len; i++) {\n            if (listeners[i].fid === fid && \n                listeners[i].context === context) {\n                inx = i;\n                lid = listeners[i].id;\n                delete fn[uni];\n                if (context) {\n                    delete context[ctxUni];\n                }\n                break;\n            }\n        }\n\n        if (inx === -1) {\n            return false;\n        }\n\n        listeners.splice(inx, 1);\n        delete self.map[lid];\n        return true;\n    },\n\n    /**\n     * @method hasListener\n     * @return bool\n     */\n\n    /**\n     * @method\n     * @param {function} fn Callback function { @required }\n     * @param {object} context Callback context\n     * @return boolean\n     */\n    hasListener: function(fn, context) {\n\n        var self    = this,\n            listeners   = self.listeners,\n            fid;\n\n        if (fn) {\n\n            if (!isFunction(fn)) {\n                fid  = parseInt(fn);\n            }\n            else {\n                fid  = fn[self.uni];\n            }\n\n            if (!fid) {\n                return false;\n            }\n\n            var ctxUni  = self.uni + \"_\" + fid;\n\n            for (var i = 0, len = listeners.length; i < len; i++) {\n                if (listeners[i].fid === fid) {\n                    if (!context || context[ctxUni]) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n        else {\n            return listeners.length > 0;\n        }\n    },\n\n\n    /**\n     * @method\n     */\n    removeAllListeners: function() {\n        var self        = this,\n            listeners   = self.listeners,\n            uni         = self.uni,\n            i, len, ctxUni;\n\n        for (i = 0, len = listeners.length; i < len; i++) {\n            ctxUni = uni +\"_\"+ listeners[i].fn[uni];\n            delete listeners[i].fn[uni];\n            if (listeners[i].context) {\n                delete listeners[i].context[ctxUni];\n            }\n        }\n        self.listeners   = [];\n        self.map         = {};\n    },\n\n    /**\n     * @method\n     */\n    suspend: function() {\n        this.suspended = true;\n    },\n\n    /**\n     * @method\n     */\n    resume: function() {\n        this.suspended = false;\n    },\n\n\n    _prepareArgs: function(l, triggerArgs) {\n        var args, prepend, append, repl;\n\n        if (l.append || l.prepend) {\n            prepend = l.prepend;\n            append  = l.append;\n            args    = triggerArgs.slice();\n\n            if (prepend) {\n                if (typeof prepend === \"function\") {\n                    prepend = prepend(l, triggerArgs);\n                }\n                args    = prepend.concat(args);\n            }\n            if (append) {\n                if (typeof append === \"function\") {\n                    append = append(l, triggerArgs);\n                }\n                args    = args.concat(append);\n            }\n        }\n        else if (l.replaceArgs) {\n            repl = l.replaceArgs;\n            if (typeof repl === \"function\") {\n                repl = repl(l, triggerArgs);\n            }\n            args = [].concat(repl);\n        }\n        else {\n            args = triggerArgs;\n        }\n\n        return args;\n    },\n\n    /**\n     * @method\n     * @return {*}\n     */\n    trigger: function() {\n\n        var self            = this,\n            listeners       = self.listeners,\n            rr              = self.returnResult,\n            filter          = self.triggerFilter,\n            filterContext   = self.filterContext,\n            expectPromises  = self.expectPromises,\n            keepPromiseOrder= self.keepPromiseOrder,\n            results         = [],\n            origArgs        = toArray(arguments),\n            prevPromise,\n            resPromise,\n            args, \n            resolver;\n\n        if (self.suspended) {\n            return null;\n        }\n        if (self.limit > 0 && self.triggered >= self.limit) {\n            return null;\n        }\n        self.triggered++;\n\n        if (self.autoTrigger) {\n            self.lastTrigger = origArgs.slice();\n        }\n\n        // in pipe mode if there is no listeners,\n        // we just return piped value\n        if (listeners.length === 0) {\n            if (rr === \"pipe\") {\n                return origArgs[0];\n            }\n            return null;\n        }\n\n        var ret     = rr === \"all\" || rr === \"concat\" ?\n                        [] : \n                        (rr === \"merge\" ? {} : null),\n            q, l,\n            res;\n\n        if (rr === \"first\") {\n            q = [listeners[0]];\n        }\n        else {\n            // create a snapshot of listeners list\n            q = listeners.slice();\n        }\n\n        if (expectPromises && rr === \"last\") {\n            keepPromiseOrder = true;\n        }\n\n        // now if during triggering someone unsubscribes\n        // we won't skip any listener due to shifted\n        // index\n        while (l = q.shift()) {\n\n            // listener may already have unsubscribed\n            if (!l || !self.map[l.id]) {\n                continue;\n            }\n\n            args = self._prepareArgs(l, origArgs);\n\n            if (filter && filter.call(filterContext, l, args, self) === false) {\n                continue;\n            }\n\n            if (l.filter && l.filter.apply(l.filterContext || l.context, args) === false) {\n                continue;\n            }\n\n            l.count++;\n\n            if (l.count < l.start) {\n                continue;\n            }\n\n            if (l.async && !expectPromises) {\n                res = null;\n                async(l.fn, l.context, args, l.async);\n            }\n            else {\n                if (expectPromises) {\n                    resolver = function(l, rr, args){\n                        return function(value) {\n\n                            if (rr === \"pipe\") {\n                                args[0] = value;\n                                args = self._prepareArgs(l, args);\n                            }\n                            \n                            return l.fn.apply(l.context, args);\n                        }\n                    }(l, rr, origArgs.slice());\n\n                    if (prevPromise) {\n                        res = prevPromise.then(resolver);\n                    }\n                    else {\n                        res = l.fn.apply(l.context, args);\n                    }\n\n                    res.catch(error);\n                }\n                else {\n                    res = l.fn.apply(l.context, args);\n                }\n            }\n\n            l.called++;\n\n            if (l.called === l.limit) {\n                self.un(l.id);\n            }\n\n            // This rule is valid in all cases sync and async.\n            // It either returns first value or first promise.\n            if (rr === \"first\") {\n                return res;\n            }\n        \n            // Promise branch\n            if (expectPromises) {\n            \n                // we collect all results for further processing/resolving\n                results.push(res);\n\n                if ((rr === \"pipe\" || keepPromiseOrder) && res) {\n                    prevPromise = res;\n                }\n            }\n            else {\n                if (rr !== null) {\n                    if (rr === \"all\") {\n                        ret.push(res);\n                    }\n                    else if (rr === \"concat\" && res) {\n                        ret = ret.concat(res);\n                    }\n                    else if (rr === \"merge\") {\n                        extend(ret, res, true, false);\n                    }\n                    else if (rr === \"nonempty\" && res) {\n                        return res;\n                    }\n                    else if (rr === \"pipe\") {\n                        ret = res;\n                        origArgs[0] = res;\n                    }\n                    else if (rr === \"last\") {\n                        ret = res;\n                    }\n                    else if (rr === false && res === false) {\n                        return false;\n                    }\n                    else if (rr === true && res === true) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        if (expectPromises) {\n            if (rr === \"pipe\") {\n                return prevPromise;\n            }\n            resPromise = Promise.all(results);\n            if (self.resolvePromises && rr !== null && rr !== \"all\") {\n                resPromise = resPromise.then(function(values){\n                    var i, l = values.length, res;\n                    for(i = 0; i < l; i++) {\n                        res = values[i];\n                        if (rr === \"concat\" && res) {\n                            ret = ret.concat(res);\n                        }\n                        else if (rr === \"merge\") {\n                            extend(ret, res, true, false);\n                        }\n                        else if (rr === \"nonempty\" && res) {\n                            return res;\n                        }\n                        else if (rr === \"last\") {\n                            ret = res;\n                        }\n                        else if (rr === false && res === false) {\n                            return false;\n                        }\n                        else if (rr === true && res === true) {\n                            return true;\n                        }\n                    }\n                    return ret;\n                });\n            }\n            return resPromise;\n        }\n        else return ret;\n    }\n}, true, false);\n\nreturn ObservableEvent;\n}());","require(\"../lib/Observable.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @mixin MetaphorJs.mixin.Observable\n * @description Mixin adds observable features to the host object.\n *              It adds 'callback' option to the host config. See $beforeInit.\n *              Mixin is designed for MetaphorJs class system.\n * @code src-docs/examples/mixin.js\n */\nmodule.exports = MetaphorJs.mixin.Observable = {\n\n    /**\n     * @private\n     * @type {Observable}\n     * @description You can use this instance in your $init function\n     */\n    $$observable: null,\n\n    /**\n     * @private\n     * @type {object}\n     */\n    $$callbackContext: null,\n\n    /**\n     * @protected\n     * @type {object} {\n     *      Override this to define event properties. \n     *      Object's key is event name, value - either returnResult or \n     *      options object. See {@link class:MetaphorJs.lib.Observable.createEvent}\n     * }\n     */\n    $$events: null,\n\n    /**\n     * @method\n     * @private\n     * @param {object} cfg {\n     *      This is a config that was passed to the host object's constructor.\n     *      It is being passed to mixin's $beforeInit automatically.\n     *      @type {object} callback {\n     *          Here, except for 'context', '$context' and 'scope', \n     *          keys are event names and values are listeners. \n     *          @type {object} context All given listeners context\n     *          @type {object} scope The same\n     *      }\n     * }\n     */\n    $beforeInit: function(cfg) {\n        var self = this;\n        self.$$observable = new MetaphorJs.lib.Observable;\n        self.$initObservable(cfg);\n    },\n\n    /**\n     * @method\n     * @private\n     * @ignore\n     * @param {object} cfg\n     */\n    $initObservable: function(cfg) {\n        MetaphorJs.lib.Observable.$initHost(this, cfg, this.$$observable);\n    },\n\n    /**\n     * @method\n     * @see {@link class:Observable.on}\n     */\n    on: function() {\n        var o = this.$$observable;\n        return o ? o.on.apply(o, arguments) : null;\n    },\n\n    /**\n     * @method\n     * @see {@link class:Observable.un}\n     */\n    un: function() {\n        var o = this.$$observable;\n        return o ? o.un.apply(o, arguments) : null;\n    },\n\n    /**\n     * @method\n     * @see {@link class:Observable.once}\n     */\n    once: function() {\n        var o = this.$$observable;\n        return o ? o.once.apply(o, arguments) : null;\n    },\n\n    /**\n     * @method\n     * @see {@link class:Observable.trigger}\n     */\n    trigger: function() {\n        var o = this.$$observable;\n        return o ? o.trigger.apply(o, arguments) : null;\n    },\n\n    /**\n     * @method\n     * @private\n     * @ignore\n     */\n    $beforeDestroy: function() {\n        this.$$observable.trigger(\"before-destroy\", this);\n    },\n\n    /**\n     * @method\n     * @private\n     * @ignore\n     */\n    $afterDestroy: function() {\n        var self = this;\n        self.$$observable.trigger(\"destroy\", self);\n        self.$$observable.$destroy();\n        self.$$observable = null;\n    }\n};\n","\nconst isThenable = require(\"metaphorjs-shared/src/func/isThenable.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    isFunction = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    error = require(\"metaphorjs-shared/src/func/error.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\");\n\n\nmodule.exports = MetaphorJs.lib.Promise = function(){\n\n    var PENDING     = 0,\n        FULFILLED   = 1,\n        REJECTED    = 2,\n        CANCELLED   = 3,\n\n        queue       = [],\n        qRunning    = false,\n\n        nextTick    = typeof process !== \"undefined\" ?\n                        process.nextTick :\n                        function(fn) {\n                            setTimeout(fn, 0);\n                        },\n\n        // synchronous queue of asynchronous functions:\n        // callbacks must be called in \"platform stack\"\n        // which means setTimeout/nextTick;\n        // also, they must be called in a strict order.\n        nextInQueue = function() {\n            qRunning    = true;\n            var next    = queue.shift();\n            nextTick(function(){\n                next[0].apply(next[1], next[2]);\n                if (queue.length) {\n                    nextInQueue();\n                }\n                else {\n                    qRunning = false;\n                }\n            }, 0);\n        },\n\n        /**\n         * add to execution queue\n         * @function\n         * @param {Function} fn\n         * @param {Object} scope\n         * @param {[]} args\n         * @ignore\n         */\n        next        = function(fn, scope, args) {\n            args = args || [];\n            queue.push([fn, scope, args]);\n            if (!qRunning) {\n                nextInQueue();\n            }\n        },\n\n        /**\n         * returns function which receives value from previous promise\n         * and tries to resolve next promise with new value returned from given function(prev value)\n         * or reject on error.\n         * promise1.then(success, failure) -> promise2\n         * wrapper(success, promise2) -> fn\n         * fn(promise1 resolve value) -> new value\n         * promise2.resolve(new value)\n         *\n         * @function\n         * @param {Function} fn\n         * @param {Promise} promise\n         * @returns {Function}\n         * @ignore\n         */\n        resolveWrapper     = function(fn, promise) {\n            return function(value) {\n                try {\n                    promise.resolve(fn(value));\n                }\n                catch (thrownError) {\n                    promise.reject(thrownError);\n                }\n            };\n        };\n\n\n    /**\n     * @class MetaphorJs.lib.Promise\n     */\n\n    /**\n     * @constructor \n     * @method Promise\n     * @param {Function} fn {\n     *  @description Constructor accepts two parameters: resolve and reject functions.\n     *  @param {function} resolve {\n     *      @param {*} value\n     *  }\n     *  @param {function} reject {\n     *      @param {*} reason\n     *  }\n     * }\n     * @param {Object} context\n     * @returns {Promise}\n     */\n\n    /**\n     * @constructor \n     * @method Promise \n     * @param {Thenable} thenable\n     * @returns {Promise}\n     */\n\n    /**\n     * @constructor \n     * @method Promise \n     * @param {*} value Value to resolve promise with\n     * @returns {Promise}\n     */\n\n    /**\n     * @constructor \n     * @method Promise \n     * @returns {Promise}\n     */\n    var Promise = function(fn, context) {\n\n        if (fn instanceof Promise) {\n            return fn;\n        }\n\n        if (!(this instanceof Promise)) {\n            return new Promise(fn, context);\n        }\n\n        var self = this,\n            then;\n\n        self._fulfills   = [];\n        self._rejects    = [];\n        self._dones      = [];\n        self._fails      = [];\n\n        if (arguments.length > 0) {\n\n            if (then = isThenable(fn)) {\n                if (fn instanceof Promise) {\n                    fn.then(\n                        bind(self.resolve, self),\n                        bind(self.reject, self));\n                }\n                else {\n                    (new Promise(then, fn)).then(\n                        bind(self.resolve, self),\n                        bind(self.reject, self));\n                }\n            }\n            else if (isFunction(fn)) {\n                try {\n                    fn.call(context,\n                            bind(self.resolve, self),\n                            bind(self.reject, self));\n                }\n                catch (thrownError) {\n                    self.reject(thrownError);\n                }\n            }\n            else {\n                self.resolve(fn);\n            }\n        }\n    };\n\n    extend(Promise.prototype, {\n\n        _state: PENDING,\n\n        _fulfills: null,\n        _rejects: null,\n        _dones: null,\n        _fails: null,\n\n        _wait: 0,\n\n        _value: null,\n        _reason: null,\n\n        _triggered: false,\n\n        /**\n         * Is promise still pending (as opposed to resolved or rejected)\n         * @method\n         * @returns {boolean}\n         */\n        isPending: function() {\n            return this._state === PENDING;\n        },\n\n        /**\n         * Is the promise fulfilled. Same as isResolved()\n         * @method\n         * @returns {boolean}\n         */\n        isFulfilled: function() {\n            return this._state === FULFILLED;\n        },\n\n        /**\n         * Is the promise resolved. Same as isFulfilled()\n         * @method\n         * @returns {boolean}\n         */\n        isResolved: function() {\n            return this._state === FULFILLED;\n        },\n\n        /**\n         * Is the promise rejected\n         * @method\n         * @returns {boolean}\n         */\n        isRejected: function() {\n            return this._state === REJECTED;\n        },\n\n        /**\n         * Is the promise was destroyed before resolving or rejecting\n         * @method\n         * @returns {boolean}\n         */\n        isCancelled: function() {\n            return this._state === CANCELLED;\n        },\n\n        /**\n         * Did someone subscribed to this promise\n         * @method\n         * @returns {boolean}\n         */\n        hasListeners: function() {\n            var self = this,\n                ls  = [self._fulfills, self._rejects, self._dones, self._fails],\n                i, l;\n\n            for (i = 0, l = ls.length; i < l; i++) {\n                if (ls[i] && ls[i].length) {\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n        _cleanup: function() {\n            var self    = this;\n\n            self._fulfills = null;\n            self._rejects = null;\n            self._dones = null;\n            self._fails = null;\n        },\n\n        _processValue: function(value, cb, allowThenanle) {\n\n            var self    = this,\n                then;\n\n            if (self._state !== PENDING) {\n                return;\n            }\n\n            if (value === self) {\n                self._doReject(new TypeError(\"cannot resolve promise with itself\"));\n                return;\n            }\n\n            if (allowThenanle) {\n                try {\n                    if (then = isThenable(value)) {\n                        if (value instanceof Promise) {\n                            value.then(\n                                bind(self._processResolveValue, self),\n                                bind(self._processRejectReason, self)\n                            );\n                        }\n                        else {\n                            (new Promise(then, value)).then(\n                                bind(self._processResolveValue, self),\n                                bind(self._processRejectReason, self)\n                            );\n                        }\n                        return;\n                    }\n                }\n                catch (thrownError) {\n                    if (self._state === PENDING) {\n                        self._doReject(thrownError);\n                    }\n                    return;\n                }\n            }\n\n            cb.call(self, value);\n        },\n\n\n        _callResolveHandlers: function() {\n\n            var self    = this;\n\n            self._done();\n\n            var cbs  = self._fulfills,\n                cb;\n\n            while (cb = cbs.shift()) {\n                next(cb[0], cb[1], [self._value]);\n            }\n\n            self._cleanup();\n        },\n\n\n        _doResolve: function(value) {\n            var self    = this;\n\n            self._value = value;\n            self._state = FULFILLED;\n\n            if (self._wait === 0) {\n                self._callResolveHandlers();\n            }\n        },\n\n        _processResolveValue: function(value) {\n            this._processValue(value, this._doResolve, true);\n        },\n\n        /**\n         * Resolve the promise\n         * @method\n         * @param {*} value\n         */\n        resolve: function(value) {\n\n            var self    = this;\n\n            if (self._triggered) {\n                return self;\n            }\n\n            self._triggered = true;\n            self._processResolveValue(value);\n\n            return self;\n        },\n\n\n        _callRejectHandlers: function() {\n\n            var self    = this;\n\n            self._fail();\n\n            var cbs  = self._rejects,\n                cb;\n\n            while (cb = cbs.shift()) {\n                next(cb[0], cb[1], [self._reason]);\n            }\n\n            self._cleanup();\n        },\n\n        _doReject: function(reason) {\n\n            var self        = this;\n\n            self._state     = REJECTED;\n            self._reason    = reason;\n\n            if (self._wait === 0) {\n                self._callRejectHandlers();\n            }\n        },\n\n\n        _processRejectReason: function(reason) {\n            this._processValue(reason, this._doReject, false);\n        },\n\n        /**\n         * Reject the promise\n         * @method\n         * @param {*} reason\n         */\n        reject: function(reason) {\n\n            var self    = this;\n\n            if (self._triggered) {\n                return self;\n            }\n\n            self._triggered = true;\n\n            self._processRejectReason(reason);\n\n            return self;\n        },\n\n        /**\n         * @method\n         * @async\n         * @param {Function} resolve -- called when this promise is resolved; \n         *  returns new resolve value or promise\n         * @param {Function} reject -- called when this promise is rejected; \n         *  returns new reject reason\n         * @param {object} context -- resolve's and reject's functions \"this\" object\n         * @returns {Promise} new promise\n         */\n        then: function(resolve, reject, context) {\n\n            var self            = this,\n                promise         = new Promise,\n                state           = self._state;\n\n            if (context) {\n                if (resolve) {\n                    resolve = bind(resolve, context);\n                }\n                if (reject) {\n                    reject = bind(reject, context);\n                }\n            }\n\n            if (state === PENDING || self._wait !== 0) {\n\n                if (resolve && isFunction(resolve)) {\n                    self._fulfills.push([resolveWrapper(resolve, promise), null]);\n                }\n                else {\n                    self._fulfills.push([promise.resolve, promise])\n                }\n\n                if (reject && isFunction(reject)) {\n                    self._rejects.push([resolveWrapper(reject, promise), null]);\n                }\n                else {\n                    self._rejects.push([promise.reject, promise]);\n                }\n            }\n            else if (state === FULFILLED) {\n\n                if (resolve && isFunction(resolve)) {\n                    next(resolveWrapper(resolve, promise), null, [self._value]);\n                }\n                else {\n                    promise.resolve(self._value);\n                }\n            }\n            else if (state === REJECTED) {\n                if (reject && isFunction(reject)) {\n                    next(resolveWrapper(reject, promise), null, [self._reason]);\n                }\n                else {\n                    promise.reject(self._reason);\n                }\n            }\n\n            return promise;\n        },\n\n        /**\n         * Add reject listener.\n         * @method\n         * @async\n         * @param {Function} reject -- same as then(null, reject)\n         * @returns {Promise} new promise\n         */\n        \"catch\": function(reject) {\n            return this.then(null, reject);\n        },\n\n        _done: function() {\n\n            var self    = this,\n                cbs     = self._dones,\n                cb;\n\n            while (cb = cbs.shift()) {\n                try {\n                    cb[0].call(cb[1] || null, self._value);\n                }\n                catch (thrown) {\n                    error(thrown);\n                }\n            }\n        },\n\n        /**\n         * Add resolve listener\n         * @method\n         * @sync\n         * @param {Function} fn -- function to call when promise is resolved\n         * @param {Object} context -- function's \"this\" object\n         * @returns {Promise} same promise\n         */\n        done: function(fn, context) {\n            var self    = this,\n                state   = self._state;\n\n            if (state === FULFILLED && self._wait === 0) {\n                try {\n                    fn.call(context || null, self._value);\n                }\n                catch (thrown) {\n                    error(thrown);\n                }\n            }\n            else if (state === PENDING || self._wait > 0) {\n                self._dones.push([fn, context]);\n            }\n\n            return self;\n        },\n\n        _fail: function() {\n\n            var self    = this,\n                cbs     = self._fails,\n                cb;\n\n            while (cb = cbs.shift()) {\n                try {\n                    cb[0].call(cb[1] || null, self._reason);\n                }\n                catch (thrown) {\n                    error(thrown);\n                }\n            }\n        },\n\n        /**\n         * Add reject listener\n         * @method\n         * @sync\n         * @param {Function} fn -- function to call when promise is rejected.\n         * @param {Object} context -- function's \"this\" object\n         * @returns {Promise} same promise\n         */\n        fail: function(fn, context) {\n\n            var self    = this,\n                state   = self._state;\n\n            if (state === REJECTED && self._wait === 0) {\n                try {\n                    fn.call(context || null, self._reason);\n                }\n                catch (thrown) {\n                    error(thrown);\n                }\n            }\n            else if (state === PENDING || self._wait > 0) {\n                self._fails.push([fn, context]);\n            }\n\n            return self;\n        },\n\n        /**\n         * Add both resolve and reject listener\n         * @method\n         * @sync\n         * @param {Function} fn -- function to call when promise resolved or rejected\n         * @param {Object} context -- function's \"this\" object\n         * @return {Promise} same promise\n         */\n        always: function(fn, context) {\n            this.done(fn, context);\n            this.fail(fn, context);\n            return this;\n        },\n\n        /**\n         * Add both resolve and reject listener\n         * @method\n         * @sync\n         * @param {Function} fn -- function to call when promise resolved or rejected\n         * @param {Object} context -- function's \"this\" object\n         * @return {Promise} same promise\n         */\n        finally: function(fn, context) {\n            this.done(fn, context);\n            this.fail(fn, context);\n            return this;\n        },\n\n        /**\n         * Get a thenable object\n         * @method\n         * @returns {object} then: function, done: function, fail: function, always: function\n         */\n        promise: function() {\n            var self = this;\n            return {\n                then: bind(self.then, self),\n                done: bind(self.done, self),\n                fail: bind(self.fail, self),\n                always: bind(self.always, self),\n                \"catch\": bind(self['catch'], self)\n            };\n        },\n\n        /**\n         * Call resolve/reject handlers only after <code>value</code> \n         * promise is resolved. <br>\n         * <code>\n         * var p = new MetaphorJs.lib.Promise;\n         * var p2 = new MetaphorJs.lib.Promise;\n         * p.done(function(){console.log('ok')})\n         * p.after(p2); // add as many promises as needed\n         * p.resolve(); // nothing\n         * p2.resolve(); // 'ok' !\n         * </code>\n         * Keep in mind, that current promise will not be auto resolved. \n         * @method\n         * @param {*|Promise} value\n         * @returns {Promise} self\n         */\n        after: function(value) {\n\n            var self = this;\n\n            if (isThenable(value)) {\n\n                self._wait++;\n\n                var done = function() {\n                    self._wait--;\n                    if (self._wait === 0 && self._state !== PENDING && \n                                            self._state !== CANCELLED) {\n                        self._state === FULFILLED ?\n                            self._callResolveHandlers() :\n                            self._callRejectHandlers();\n                    }\n                };\n\n                if (isFunction(value.done)) {\n                    value.done(done);\n                }\n                else {\n                    value.then(done);\n                }\n            }\n\n            return self;\n        },\n\n        /**\n         * Cancel and destroy current promise. No resolve or reject \n         * callbacks will be called. isCancelled() will return true.\n         * @method\n         */\n        $destroy: function() {\n            this._cleanup();\n            this._state === PENDING && (this._state = CANCELLED);\n        }\n    }, true, false);\n\n\n    /**\n     * Call function <code>fn</code> with given args in given context\n     * and use its return value as resolve value for a new promise.\n     * Then return this promise.\n     * @static\n     * @method\n     * @param {function} fn\n     * @param {object} context\n     * @param {[]} args\n     * @returns {Promise}\n     */\n    Promise.fcall = function(fn, context, args) {\n        return Promise.resolve(fn.apply(context, args || []));\n    };\n\n    /**\n     * Create new promise and resolve it with given value\n     * @static\n     * @method\n     * @param {*} value\n     * @returns {Promise}\n     */\n    Promise.resolve = function(value) {\n        var p = new Promise;\n        p.resolve(value);\n        return p;\n    };\n\n\n    /**\n     * Create new promise and reject it with given reason\n     * @static\n     * @method\n     * @param {*} reason\n     * @returns {Promise}\n     */\n    Promise.reject = function(reason) {\n        var p = new Promise;\n        p.reject(reason);\n        return p;\n    };\n\n\n    /**\n     * Take a list of promises or values and once all promises are resolved,\n     * create a new promise and resolve it with a list of final values.<br>\n     * If one of the promises is rejected, it will reject the returned promise.\n     * @static\n     * @method\n     * @param {[]} promises -- array of promises or resolve values\n     * @returns {Promise}\n     */\n    Promise.all = function(promises) {\n\n        if (!promises.length) {\n            return Promise.resolve(null);\n        }\n\n        var p       = new Promise,\n            len     = promises.length,\n            values  = new Array(len),\n            cnt     = len,\n            i,\n            item,\n            done    = function(value, inx) {\n                values[inx] = value;\n                cnt--;\n\n                if (cnt === 0) {\n                    p.resolve(values);\n                }\n            };\n\n        for (i = 0; i < len; i++) {\n\n            (function(inx){\n                item = promises[i];\n\n                if (item instanceof Promise) {\n                    item.done(function(value){\n                        done(value, inx);\n                    })\n                        .fail(p.reject, p);\n                }\n                else if (isThenable(item) || isFunction(item)) {\n                    (new Promise(item))\n                        .done(function(value){\n                            done(value, inx);\n                        })\n                        .fail(p.reject, p);\n                }\n                else {\n                    done(item, inx);\n                }\n            })(i);\n        }\n\n        return p;\n    };\n\n    /**\n     * Same as <code>all()</code> but it treats arguments as list of values.\n     * @static\n     * @method\n     * @param {Promise|*} promise1\n     * @param {Promise|*} promise2\n     * @param {Promise|*} promiseN\n     * @returns {Promise}\n     */\n    Promise.when = function() {\n        return Promise.all(arguments);\n    };\n\n    /**\n     * Same as <code>all()</code> but the resulting promise\n     * will not be rejected if ones of the passed promises is rejected.\n     * @static\n     * @method\n     * @param {[]} promises -- array of promises or resolve values\n     * @returns {Promise}\n     */\n    Promise.allResolved = function(promises) {\n\n        if (!promises.length) {\n            return Promise.resolve(null);\n        }\n\n        var p       = new Promise,\n            len     = promises.length,\n            values  = [],\n            cnt     = len,\n            i,\n            item,\n            settle  = function(value) {\n                values.push(value);\n                proceed();\n            },\n            proceed = function() {\n                cnt--;\n                if (cnt === 0) {\n                    p.resolve(values);\n                }\n            };\n\n        for (i = 0; i < len; i++) {\n            item = promises[i];\n\n            if (item instanceof Promise) {\n                item.done(settle).fail(proceed);\n            }\n            else if (isThenable(item) || isFunction(item)) {\n                (new Promise(item)).done(settle).fail(proceed);\n            }\n            else {\n                settle(item);\n            }\n        }\n\n        return p;\n    };\n\n    /**\n     * Given the list of promises or values it will return a new promise\n     * and resolve it with the first resolved value.\n     * @static\n     * @method\n     * @param {[]} promises -- array of promises or resolve values\n     * @returns {Promise}\n     */\n    Promise.race = function(promises) {\n\n        if (!promises.length) {\n            return Promise.resolve(null);\n        }\n\n        var p   = new Promise,\n            len = promises.length,\n            i,\n            item;\n\n        for (i = 0; i < len; i++) {\n            item = promises[i];\n\n            if (item instanceof Promise) {\n                item.done(p.resolve, p).fail(p.reject, p);\n            }\n            else if (isThenable(item) || isFunction(item)) {\n                (new Promise(item)).done(p.resolve, p).fail(p.reject, p);\n            }\n            else {\n                p.resolve(item);\n            }\n\n            if (!p.isPending()) {\n                break;\n            }\n        }\n\n        return p;\n    };\n\n    /**\n     * Takes a list of async functions and executes \n     * them in given order consequentially\n     * @static\n     * @method\n     * @param {[]} functions -- array of promises or resolve values or functions\n     * @returns {Promise}\n     */\n    Promise.waterfall = function(functions) {\n\n        if (!functions.length) {\n            return Promise.resolve(null);\n        }\n\n        var first   = functions.shift(),\n            promise = isFunction(first) ? Promise.fcall(first) : Promise.resolve(fn),\n            fn;\n\n        while (fn = functions.shift()) {\n            if (isThenable(fn)) {\n                promise = promise.then(function(fn){\n                    return function(){\n                        return fn;\n                    };\n                }(fn));\n            }\n            else if (isFunction(fn)) {\n                promise = promise.then(fn);\n            }\n            else {\n                promise.resolve(fn);\n            }\n        }\n\n        return promise;\n    };\n\n    /**\n     * Works like Array.forEach but it expects passed function to \n     * return a Promise.\n     * @static\n     * @method \n     * @param {array} items \n     * @param {function} fn {\n     *  @param {*} value\n     *  @param {int} index\n     *  @returns {Promise|*}\n     * }\n     * @param {object} context \n     * @param {boolean} allResolved if true, the resulting promise\n     * will fail if one of the returned promises fails.\n     */\n    Promise.forEach = function(items, fn, context, allResolved) {\n\n        var left = items.slice(),\n            p = new Promise,\n            values = [],\n            i = 0;\n\n        var next = function() {\n\n            if (!left.length) {\n                p.resolve(values);\n                return;\n            }\n\n            var item = left.shift(),\n                index = i;\n\n            i++;\n\n            Promise.fcall(fn, context, [item, index])\n                .done(function(result){\n                    values.push(result);\n                    next();\n                })\n                .fail(function(reason){\n                    if (allResolved) {\n                        p.reject(reason);\n                    }\n                    else {\n                        values.push(null);\n                        next();\n                    }\n                });\n        };\n\n        next();\n\n        return p;\n    };\n\n    /**\n     * Returns a promise with additional <code>countdown</code>\n     * method. Call this method <code>cnt</code> times and\n     * the promise will get resolved.\n     * @static\n     * @method\n     * @param {int} cnt \n     * @returns {Promise}\n     */\n    Promise.counter = function(cnt) {\n\n        var promise     = new Promise;\n\n        promise.countdown = function() {\n            cnt--;\n            if (cnt === 0) {\n                promise.resolve();\n            }\n        };\n\n        return promise;\n    };\n\n    return Promise;\n}();\n\n","\n\nconst MetaphorJs = {\n    plugin: {},\n    mixin: {},\n    lib: {},\n    dom: {},\n    regexp: {},\n    browser: {},\n    app: {},\n    prebuilt: null\n};\n\n\nmodule.exports = MetaphorJs;","\nconst toString = require(\"../toString\");\n\nmodule.exports = (function() {\n\n    const types = {\n        '[object String]': 0,\n        '[object Number]': 1,\n        '[object Boolean]': 2,\n        '[object Object]': 3,\n        '[object Function]': 4,\n        '[object Array]': 5,\n        '[object RegExp]': 9,\n        '[object Date]': 10\n    };\n\n\n    /*\n     * 'string': 0,\n     * 'number': 1,\n     * 'boolean': 2,\n     * 'object': 3,\n     * 'function': 4,\n     * 'array': 5,\n     * 'null': 6,\n     * 'undefined': 7,\n     * 'NaN': 8,\n     * 'regexp': 9,\n     * 'date': 10,\n     * unknown: -1\n     * @param {*} value\n     * @returns {number}\n     */\n\n\n\n    return function _varType(val) {\n\n        if (!val) {\n            if (val === null) {\n                return 6;\n            }\n            if (val === undefined) {\n                return 7;\n            }\n        }\n\n        let num = types[toString.call(val)];\n\n        if (num === undefined) {\n            return -1;\n        }\n\n        if (num === 1 && isNaN(val)) {\n            return 8;\n        }\n\n        return num;\n    };\n\n})();","/**\n * Execute <code>fn</code> asynchronously\n * @function async\n * @param {Function} fn Function to execute\n * @param {Object} context Function's context (this)\n * @param {[]} args Arguments to pass to fn\n * @param {number} timeout Execute after timeout (number of ms)\n */\nmodule.exports = function async(fn, context, args, timeout) {\n    return setTimeout(() => fn.apply(context, args || []), timeout || 0);\n};","\n/**\n * Bind function to context (Function.bind wrapper)\n * @function bind\n * @param {function} fn\n * @param {*} context\n * @returns {function}\n */\nmodule.exports = function bind(fn, context){\n    return fn.bind(context);\n};","\nconst MetaphorJs = require(\"../../MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.browser.joinLocation = function(location, opt) {\n\n    var url = \"\";\n    opt = opt || {};\n\n    if (!opt.onlyPath) {\n        url += location.protocol + \"//\";\n\n        if (location.username && location.password) {\n            url += location.username + \":\" + location.password + \"@\";\n        }\n\n        url += location.hostname;\n\n        if (location.hostname && location.port) {\n            url += \":\" + location.port;\n        }\n    }\n\n    if (!opt.onlyHost) {\n        url += (location.pathname || \"/\");\n\n        if (location.search && location.search != \"?\") {\n            url += location.search;\n        }\n\n        if (location.hash && location.hash != \"#\") {\n            url += location.hash;\n        }\n    }\n\n    return url;\n};","\nrequire(\"../../var/regexp/location.js\");\n\nconst MetaphorJs = require(\"../../MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.browser.parseLocation = function(url) {\n\n    var matches = url.match(MetaphorJs.regexp.location) || [],\n        wl = (typeof window != \"undefined\" ? window.location : null) || {};\n\n    return {\n        protocol: matches[4] || wl.protocol || \"http:\",\n        hostname: matches[11] || wl.hostname || \"\",\n        host: ((matches[11] || \"\") + (matches[12] ? \":\" + matches[12] : \"\")) || wl.host || \"\",\n        username: matches[8] || wl.username || \"\",\n        password: matches[9] || wl.password || \"\",\n        port: parseInt(matches[12], 10) || wl.port || \"\",\n        href: url,\n        path: (matches[13] || \"/\") + (matches[16] || \"\"),\n        pathname: matches[13] || \"/\",\n        search: matches[16] || \"\",\n        hash: matches[17] && matches[17] != \"#\" ? matches[17] : \"\"\n    };\n};","\nconst isArray = require(\"./isArray.js\"),\n    isRegExp = require(\"./isRegExp.js\"),\n    isPlainObject = require(\"./isPlainObject.js\"),\n    isDate = require(\"./isDate.js\"),\n    isFunction = require(\"./isFunction.js\");\n\nmodule.exports = function copy(source, dest){\n\n    if (typeof window != \"undefined\" && source === window) {\n        throw new Error(\"Cannot copy window object\");\n    }\n    else if (typeof global != \"undefined\" && source === global) {\n        throw new Error(\"Cannot copy global object\");\n    }\n\n    if (!dest) {\n        dest = source;\n        if (source) {\n            if (isArray(source)) {\n                dest = copy(source, []);\n            } else if (isDate(source)) {\n                dest = new Date(source.getTime());\n            } else if (isRegExp(source)) {\n                dest = new RegExp(source.source);\n            } else if (isPlainObject(source)) {\n                dest = copy(source, {});\n            }\n        }\n    } else {\n        if (source === dest) {\n            throw new Error(\"Objects are identical\");\n        }\n        if (isArray(source)) {\n            dest.length = 0;\n            for ( var i = 0, l = source.length; i < l; i++) {\n                dest.push(copy(source[i]));\n            }\n        } else {\n            var key;\n            for (key in dest) {\n                delete dest[key];\n            }\n            for (key in source) {\n                if (source.hasOwnProperty(key)) {\n                    if (key.charAt(0) == '$' || isFunction(source[key])) {\n                        dest[key] = source[key];\n                    }\n                    else {\n                        dest[key] = copy(source[key]);\n                    }\n                }\n            }\n        }\n    }\n    return dest;\n};\n","\n\nmodule.exports = function emptyFn(){};","\nconst isArray = require(\"./isArray.js\"),\n    isDate = require(\"./isDate.js\"),\n    isRegExp = require(\"./isRegExp.js\"),\n    isWindow = require(\"./isWindow.js\"),\n    isFunction = require(\"./isFunction.js\");\n\n// from Angular\n\n/**\n * Performs various checks comparing two arguments. \n * Compared items can be of any type including\n * objects and arrays.\n * @function equals\n * @param {*} o1 \n * @param {*} o2 \n * @returns {boolean}\n */\nmodule.exports = function equals(o1, o2) {\n    if (o1 === o2) return true;\n    if (o1 === null || o2 === null) return false;\n    if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN\n    var t1 = typeof o1, t2 = typeof o2, length, key, keySet;\n    if (t1 === t2) {\n        if (t1 === 'object') {\n            if (isArray(o1)) {\n                if (!isArray(o2)) return false;\n                if ((length = o1.length) === o2.length) {\n                    for(key=0; key<length; key++) {\n                        if (!equals(o1[key], o2[key])) return false;\n                    }\n                    return true;\n                }\n            } else if (isDate(o1)) {\n                return isDate(o2) && o1.getTime() === o2.getTime();\n            } else if (isRegExp(o1) && isRegExp(o2)) {\n                return o1.toString() === o2.toString();\n            } else {\n                if (isWindow(o1) || isWindow(o2) || isArray(o2)) return false;\n                keySet = {};\n                for(key in o1) {\n                    if (key.charAt(0) === '$' || isFunction(o1[key])) {//&& typeof o1[key] == \"object\") {\n                        continue;\n                    }\n                    //if (isFunction(o1[key])) {\n                    //    continue;\n                    //}\n                    if (!equals(o1[key], o2[key])) {\n                        return false;\n                    }\n                    keySet[key] = true;\n                }\n                for(key in o2) {\n                    if (!keySet.hasOwnProperty(key) &&\n                        key.charAt(0) !== '$' &&\n                        o2[key] !== undefined &&\n                        !isFunction(o2[key])) return false;\n                }\n                return true;\n            }\n        }\n    }\n    return false;\n};\n","\n\n/**\n * Log thrown error to console (in debug mode) and \n * call all error listeners\n * @function error\n * @param {Error} e \n */\nmodule.exports = (function(){\n\n    var listeners = [];\n\n    var error = function error(e) {\n\n        var i, l;\n\n        for (i = 0, l = listeners.length; i < l; i++) {\n            listeners[i][0].call(listeners[i][1], e)\n        }\n\n        /*DEBUG-START*/\n        if (typeof console != \"undefined\" && console.error) {\n            console.error(e);\n        }\n        /*DEBUG-END*/\n    };\n\n    /**\n     * Subscribe to all errors\n     * @method on\n     * @param {function} fn \n     * @param {object} context \n     */\n    error.on = function(fn, context) {\n        error.un(fn, context);\n        listeners.push([fn, context]);\n    };\n\n    /**\n     * Unsubscribe from all errors\n     * @method un\n     * @param {function} fn \n     * @param {object} context \n     */\n    error.un = function(fn, context) {\n        var i, l;\n        for (i = 0, l = listeners.length; i < l; i++) {\n            if (listeners[i][0] === fn && listeners[i][1] === context) {\n                listeners.splice(i, 1);\n                break;\n            }\n        }\n    };\n\n    return error;\n}());\n\n","const toArray = require( \"./toArray\");\nconst isPlainObject = require( \"./isPlainObject\");\nconst isBool = require( \"./isBool\");\n\n/**\n * Copy properties = require( one object to another\n * @function extend\n * @param {Object} dst\n * @param {Object} src\n * @param {Object} src2 ... srcN\n * @param {boolean} override {\n *  Override already existing keys \n *  @default false\n * }\n * @param {boolean} deep {\n *  Do not copy objects by link, deep copy by value\n *  @default false\n * }\n * @returns {object}\n */\nmodule.exports = function extend() {\n\n    var override    = false,\n        deep        = false,\n        args        = toArray(arguments),\n        dst         = args.shift(),\n        src,\n        k,\n        value;\n\n    if (isBool(args[args.length - 1])) {\n        override    = args.pop();\n    }\n    if (isBool(args[args.length - 1])) {\n        deep        = override;\n        override    = args.pop();\n    }\n\n    if (override && !deep && typeof Object !== \"undefined\" && !!Object.assign) {\n        Object.assign.apply(Object, [dst].concat(args));\n        return dst;\n    }\n\n    while (args.length) {\n        \n        // src can be empty\n        src = args.shift();\n        \n        if (!src) {\n            continue;\n        }\n\n        for (k in src) {\n\n            if (src.hasOwnProperty(k) && (value = src[k]) !== undefined) {\n\n                if (deep) {\n                    if (dst[k] && isPlainObject(dst[k]) && isPlainObject(value)) {\n                        extend(dst[k], value, override, deep);\n                    }\n                    else {\n                        if (override === true || dst[k] == undefined) { // == checks for null and undefined\n                            if (isPlainObject(value)) {\n                                dst[k] = {};\n                                extend(dst[k], value, override, true);\n                            }\n                            else {\n                                dst[k] = value;\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (override === true || dst[k] == undefined) {\n                        dst[k] = value;\n                    }\n                }\n            }\n        }\n    }\n\n    return dst;\n};\n","\nconst isBool = require(\"./isBool.js\"),\n    isFunction = require(\"./isFunction.js\"),\n    isPrimitive = require(\"./isPrimitive.js\"),\n    isPlainObject = require(\"./isPlainObject.js\");\n\n\n/**\n * Filter array of various objects by object field\n * @function filterArray\n * @param {array} list Array to filter\n * @param {string|boolean|regexp} by \n * @param {string|boolean|null} opt true | false | \"strict\"\n * @code src-docs/examples/filterArray.js\n */\n\n/**\n * Filter array of various objects by object field\n * @function filterArray\n * @param {array} list Array to filter\n * @param {function} by {\n *  @param {*} value array[i]\n *  @returns {boolean}\n * }\n * @param {object} opt true | false | \"strict\"\n */\n\n/**\n * Filter array of various objects by object field\n * @function filterArray\n * @param {array} list Array to filter\n * @param {object} by \n * @param {object} opt true | false | \"strict\"\n */\nmodule.exports = function(){\n\n\n    var compareValues = function(value, to, opt) {\n\n            if (isFunction(to)) {\n                return to(value, opt);\n            }\n            else if (to === \"\" || to === undefined) {\n                return true;\n            }\n            else if (value === undefined) {\n                return false;\n            }\n            else if (isBool(value)) {\n                return value === to;\n            }\n            else if (to instanceof RegExp) {\n                return to.test(\"\" + value);\n            }\n            else if (opt === \"strict\") {\n                return \"\"+value === \"\"+to;\n            }\n            else if (opt === true || opt === null || opt === undefined) {\n                return (\"\"+value).toLowerCase().indexOf((\"\"+to).toLowerCase()) != -1;\n            }\n            else if (opt === false) {\n                return (\"\"+value).toLowerCase().indexOf((\"\"+to).toLowerCase()) == -1;\n            }\n            return false;\n        },\n\n        compare = function(value, by, opt) {\n\n            if (isFunction(by)) {\n                return by(value, opt);\n            }\n\n            if (isPrimitive(value)) {\n                if (by.$ === undefined) {\n                    return true;\n                }\n                else {\n                    return compareValues(value, by.$, opt);\n                }\n            }\n\n            var k, i;\n            for (k in by) {\n                if (k === '$') {\n                    for (i in value) {\n                        if (compareValues(value[i], by.$, opt)) {\n                            return true;\n                        }\n                    }\n                }\n                else {\n                    if (compareValues(value[k], by[k], opt)) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        };\n\n    var filterArray = function filterArray(a, by, opt) {\n\n        if (!isPlainObject(by) && !isFunction(by)) {\n            by = {$: by};\n        }\n\n        var ret = [],\n            i, l;\n\n        for (i = -1, l = a.length; ++i < l;) {\n            if (compare(a[i], by, opt)) {\n                ret.push(a[i]);\n            }\n        }\n\n        return ret;\n    };\n\n    filterArray.compare = compare;\n\n    return filterArray;\n\n}();","require(\"../lib/Cache.js\");\n\nconst MetaphorJs = require(\"../MetaphorJs.js\");\n\n/**\n * Get cached regular expression\n * @function getRegExp\n * @param {string} expr\n * @returns {RegExp}\n */\nmodule.exports = function getRegExp(expr) {\n    var g = MetaphorJs.lib.Cache.global(),\n        k = \"regex_\"+expr;\n    return g.get(k) || g.add(k, new RegExp(expr));\n};\n","\nconst isObject = require(\"./isObject.js\");\n\n/**\n * Instantite class when you have a list of arguments\n * and you can't just use .apply()\n * @function instantiate\n * @param {function} fn Class constructor\n * @param {array} args Constructor arguments\n * @returns {object}\n */\nmodule.exports = function instantiate(fn, args) {\n\n    var Temp = function(){},\n        inst, ret;\n\n    Temp.prototype  = fn.prototype;\n    inst            = new Temp;\n    ret             = fn.apply(inst, args);\n\n    // If an object has been returned then return it otherwise\n    // return the original instance.\n    // (consistent with behaviour of the new operator)\n    return isObject(ret) || ret === false ? ret : inst;\n};\n","/**\n * Function interceptor\n * @function intercept\n * @param {function} origFn Original function\n * @param {function} interceptor Function that should execute instead(ish)\n * @param {object|null} context Function's context\n * @param {object|null} origContext Original function's context\n * @param {string} when {\n *  before | after | instead\n *  @default before\n * }\n * @param {bool} replaceValue true to return interceptor's return value\n * instead of original\n * @returns {Function}\n */\nmodule.exports = function intercept(origFn, interceptor, context, origContext, when, replaceValue) {\n\n    when = when || \"before\";\n\n    return function() {\n\n        var intrRes,\n            origRes;\n\n        if (when == \"instead\") {\n            return interceptor.apply(context || origContext, arguments);\n        }\n        else if (when == \"before\") {\n            intrRes = interceptor.apply(context || origContext, arguments);\n            origRes = intrRes !== false ? origFn.apply(origContext || context, arguments) : null;\n        }\n        else {\n            origRes = origFn.apply(origContext || context, arguments);\n            intrRes = interceptor.apply(context || origContext, arguments);\n        }\n\n        return replaceValue ? intrRes : origRes;\n    };\n};","\nconst _varType = require(\"./_/_varType\");\n\n/**\n * Check if given value is array (not just array-like)\n * @function isArray\n * @param {*} value\n * @returns {boolean}\n */\nmodule.exports = function isArray(value) {\n    return typeof value === \"object\" && _varType(value) === 5;\n};","\n/**\n * Check if given value is a boolean value\n * @function isBool\n * @param {*} value \n * @returns {boolean}\n */\nmodule.exports = function isBool(value) {\n    return value === true || value === false;\n};","\nconst _varType = require(\"./_/_varType.js\");\n\n/**\n * Check if given value is a Date object\n * @function isDate\n * @param {*} value\n * @returns {boolean} \n */\nmodule.exports = function isDate(value) {\n    return _varType(value) === 10;\n};","\n/**\n * Check if given value is a function\n * @function isFunction\n * @param {*} value \n * @returns {boolean}\n */\nmodule.exports = function isFunction(value) {\n    return typeof value == 'function';\n};","\n/**\n * Check if given value is a null value\n * @function isNull\n * @param {*} value \n * @returns {boolean}\n */\nmodule.exports = function isNull(value) {\n    return value === null;\n};","\nconst _varType = require(\"./_/_varType.js\");\n\n/**\n * Check if given value is a number (not number-like)\n * @function isNumber\n * @param {*} value \n * @returns {boolean}\n */\nmodule.exports = function isNumber(value) {\n    return _varType(value) === 1;\n};","\nconst _varType = require( \"./_/_varType\");\n\n/**\n * Check if given value is an object (non-scalar)\n * @function isObject\n * @param {*} value \n * @returns {boolean}\n */\nmodule.exports = function isObject(value) {\n    if (value === null || typeof value != \"object\") {\n        return false;\n    }\n    var vt = _varType(value);\n    return vt > 2 || vt == -1;\n};","\nconst _varType = require( \"./_/_varType\");\n\n/**\n * Check if given value is plain object\n * @function isPlainObject\n * @param {*} value \n * @returns {boolean}\n */\nmodule.exports = function isPlainObject(value) {\n    // IE < 9 returns [object Object] = require( toString(htmlElement)\n    return typeof value == \"object\" &&\n           _varType(value) === 3 &&\n            !value.nodeType &&\n            value.constructor === Object;\n};","\nconst _varType = require(\"./_/_varType.js\");\n\n/**\n * Check if given value is a primitive (string, number, boolean)\n * @function isPrimitive\n * @param {*} value \n * @returns {boolean}\n */\nmodule.exports = function isPrimitive(value) {\n    var vt = _varType(value);\n    return vt < 3 && vt > -1;\n};","\nconst _varType = require(\"./_/_varType.js\");\n\n/**\n * Check if given value is regular expression\n * @function isRegExp\n * @param {*} value \n * @returns {boolean}\n */\nmodule.exports = function isRegExp(value) {\n    return _varType(value) === 9;\n};","\n/**\n * Check if given value is a string\n * @function isString\n * @param {*} value \n * @returns {boolean}\n */\nmodule.exports = function isString(value) {\n    return typeof value === \"string\" || value === \"\"+value;\n};","\nconst isFunction = require(\"./isFunction.js\");\n\n/**\n * Checks if given value is a thenable (a Promise)\n * @function isThenable\n * @param {*} any\n * @returns {boolean|function}\n */\nmodule.exports = function isThenable(any) {\n\n    // any.then must only be accessed once\n    // this is a promise/a+ requirement\n\n    if (!any) { //  || !any.then\n        return false;\n    }\n    \n    var t;\n\n    //if (!any || (!isObject(any) && !isFunction(any))) {\n    if (((t = typeof any) != \"object\" && t != \"function\")) {\n        return false;\n    }\n\n    var then = any.then;\n\n    return isFunction(then) ? then : false;\n};","\n/**\n * Check if given object is a window object\n * @function isWindow\n * @param {*} obj \n * @returns {boolean}\n */\nmodule.exports = function isWindow(obj) {\n    if (typeof window === \"undefined\") {\n        return false;\n    }\n    return obj === window ||\n           (obj && obj.document && obj.location && \n            obj.alert && obj.setInterval);\n};","\nconst equals = require(\"./equals.js\");\n\n/**\n * @function levenshteinDiff {\n *  @param {array} from\n *  @param {array} to\n *  @returns {object} {\n *      @type {number} changes\n *      @type {int} distance\n *      @type {array} prescription {\n *          List of instructions D(delete),R(replace),I(insert)\n *      }\n *  }\n * }\n */\nmodule.exports = function levenshteinDiff(from, to) {\n\n    var m = from.length,\n        n = to.length,\n        D = new Array(m + 1),\n        P = new Array(m + 1),\n        i, j, c,\n        route,\n        cost,\n        dist,\n        ops = 0;\n\n    if (m == n && m === 0) {\n        return {\n            changes: 0,\n            distance: 0,\n            prescription: []\n        };\n    }\n\n    for (i = 0; i <= m; i++) {\n        D[i]    = new Array(n + 1);\n        P[i]    = new Array(n + 1);\n        D[i][0] = i;\n        P[i][0] = 'D';\n    }\n    for (i = 0; i <= n; i++) {\n        D[0][i] = i;\n        P[0][i] = 'I';\n    }\n\n    for (i = 1; i <= m; i++) {\n        for (j = 1; j <= n; j++) {\n            cost = (!equals(from[i - 1], to[j - 1])) ? 1 : 0;\n\n            if(D[i][j - 1] < D[i - 1][j] && D[i][j - 1] < D[i - 1][j - 1] + cost) {\n                //Insert\n                D[i][j] = D[i][j - 1] + 1;\n                P[i][j] = 'I';\n            }\n            else if(D[i - 1][j] < D[i - 1][j - 1] + cost) {\n                //Delete\n                D[i][j] = D[i - 1][j] + 1;\n                P[i][j] = 'D';\n            }\n            else {\n                //Replace or noop\n                D[i][j] = D[i - 1][j - 1] + cost;\n                if (cost === 1) {\n                    P[i][j] = 'R';\n                }\n                else {\n                    P[i][j] = '-';\n                }\n            }\n        }\n    }\n\n    //Prescription\n    route = [];\n    i = m;\n    j = n;\n\n    do {\n        c = P[i][j];\n        route.push(c);\n        if (c !== '-') {\n            ops++;\n        }\n        if(c === 'R' || c === '-') {\n            i --;\n            j --;\n        }\n        else if(c === 'D') {\n            i --;\n        }\n        else {\n            j --;\n        }\n    } while((i !== 0) || (j !== 0));\n\n    dist = D[m][n];\n\n    return {\n        changes: ops / route.length,\n        distance: dist,\n        prescription: route.reverse()\n    };\n};\n","\n\n/**\n * @function levenshteinMove {\n *  @param {array} a1\n *  @param {array} a2 \n *  @param {array} prescription Prescription from levenshteinDiff\n *  @param {function} getKey {\n *      Function that tracks unique items of array\n *      @param {*} item \n *      @returns {string} item id\n *  }\n * }\n */\nmodule.exports = function levenshteinMove(a1, a2, prs, getKey) {\n\n    var newPrs = [],\n        i, l, k, action,\n        map1 = {},\n        prsi,\n        a2i,\n        index;\n\n    for (i = 0, l = a1.length; i < l; i++) {\n        k = getKey(a1[i], i);\n        if (k) {\n            map1[k] = i;\n        }\n    }\n\n    a2i = 0;\n    var used = {};\n\n    for (prsi = 0, l = prs.length; prsi < l; prsi++) {\n\n        action = prs[prsi];\n\n        if (action === 'D') {\n            continue;\n        }\n\n        k = getKey(a2[a2i], a2i);\n\n        if (k !== undefined && used[k] !== true && (index = map1[k]) !== undefined) {\n            newPrs.push(index);\n            used[k] = true;\n        }\n        else {\n            newPrs.push(action);\n        }\n        a2i++;\n    }\n\n    return newPrs;\n};","\nconst uid = ['0', '0', '0'];\n\n// from AngularJs\n/**\n * Generates new alphanumeric id with starting \n * length of 3 characters. IDs are consequential.\n * @function nextUid\n * @returns {string}\n */\nfunction nextUid() {\n    var index = uid.length;\n    var digit;\n\n    while(index) {\n        index--;\n        digit = uid[index].charCodeAt(0);\n        if (digit == 57 /*'9'*/) {\n            uid[index] = 'A';\n            return uid.join('');\n        }\n        if (digit == 90  /*'Z'*/) {\n            uid[index] = '0';\n        } else {\n            uid[index] = String.fromCharCode(digit + 1);\n            return uid.join('');\n        }\n    }\n    uid.unshift('0');\n    return uid.join('');\n};\n\nmodule.exports = nextUid;","\n/**\n * Function that returns false\n * @function returnFalse\n * @returns {boolean}\n */\nmodule.exports = function returnFalse() {\n    return false;\n};","\n/**\n * Function that returns true\n * @function returnTrue\n * @returns {boolean}\n */\nmodule.exports = function returnTrue() {\n    return true;\n};","\nconst isFunction = require(\"./isFunction.js\"),\n    isPlainObject = require(\"./isPlainObject.js\");\n\n/**\n * Sort array of various objects by some field\n * @function sortArray\n * @param {array} arr Array to sort\n * @param {function|string|object} by {\n *  Either a string: object field name to sort by<br>\n *  Or a function: takes array item and returns value by which to sort<br>\n *  Or an object:\n *  @type {function} fn {\n *      @param {*} itemA\n *      @param {*} itemB\n *      @returns {number} -1,0,1\n *  }\n *  @type {object|null} context fn's context\n * }\n * @param {string} dir \n * @returns {array}\n */\nmodule.exports = function sortArray(arr, by, dir) {\n\n    if (!dir) {\n        dir = \"asc\";\n    }\n\n    var ret = arr.slice(),\n        fn, ctx;\n\n    if (isPlainObject(by) && by.fn) {\n        fn = by.fn;\n        ctx = by.context;\n    }\n\n    ret.sort(function(a, b) {\n\n        if (fn) {\n            return fn.call(ctx, a, b);\n        }\n\n        var typeA   = typeof a,\n            typeB   = typeof b,\n            valueA  = a,\n            valueB  = b;\n\n        if (typeA != typeB) {\n            return 0;\n        }\n\n        if (typeA === \"object\") {\n            if (isFunction(by)) {\n                valueA = by(a);\n                valueB = by(b);\n            }\n            else {\n                valueA = a[by];\n                valueB = b[by];\n            }\n        }\n\n        if (typeof valueA === \"number\") {\n            return valueA - valueB;\n        }\n        else {\n            valueA = (\"\" + valueA).toLowerCase();\n            valueB = (\"\" + valueB).toLowerCase();\n\n            if (valueA === valueB) return 0;\n            return valueA > valueB ? 1 : -1;\n        }\n    });\n\n    return dir == \"desc\" ? ret.reverse() : ret;\n\n};","\n/**\n * Intellegently splits string into parts using a separator, \n * leaving untouched parts where separator is inside quotes.\n * @param {string} str\n * @param {string} separator\n * @param {bool} allowEmpty\n * @returns {array}\n */\nmodule.exports = function(str, separator, allowEmpty) {\n\n    var l       = str.length,\n        sl      = separator.length,\n        i       = 0,\n        prev    = 0,\n        inQDbl  = false,\n        inQSng  = false,\n        parts   = [],\n        esc     = \"\\\\\",\n        char;\n\n    if (!sl) {\n        return [str];\n    }\n\n    for (; i < l; i++) {\n\n        char = str.charAt(i);\n\n        if (char == esc) {\n            i++;\n            continue;\n        }\n\n        if (char == '\"') {\n            inQDbl = !inQDbl;\n            continue;\n        }\n        if (char == \"'\") {\n            inQSng = !inQSng;\n            continue;\n        }\n\n        if (!inQDbl && !inQSng) {\n            if ((sl == 1 && char == separator) ||\n                (sl > 1 && str.substring(i, i + sl) == separator)) {\n\n                if (str.substr(i - 1, sl) == separator ||\n                    str.substr(i + 1, sl) == separator) {\n\n                    if (!allowEmpty) {\n                        i += (sl - 1);\n                        continue;\n                    }\n                }\n\n                parts.push(str.substring(prev, i).replace(esc + separator, separator));\n                prev = i + sl;\n                i += (sl - 1);\n            }\n        }\n    }\n\n    parts.push(str.substring(prev).replace(esc + separator, separator));\n\n    return parts;\n};","\n\n/**\n * Transform anything into array\n * @function toArray\n * @param {*} list\n * @returns {array}\n */\nmodule.exports = function toArray(list) {\n    if (list && !list.length != undefined && list !== \"\"+list) {\n        for(var a = [], i =- 1, l = list.length>>>0; ++i !== l; a[i] = list[i]){}\n        return a;\n    }\n    else if (list) {\n        return [list];\n    }\n    else {\n        return [];\n    }\n};","\n/**\n * Converts given value to boolean. <br>\n * false: \"\", 0, false, undefined, null, \"false\", \"no\", \"0\"<br>\n * true: everything else\n * @function toBool\n * @param {*} val \n * @returns {boolean}\n */\nmodule.exports = function toBool(val) {\n    if (!val) { // real false, empty string, null, zero\n        return false;\n    }\n    if (typeof val === \"string\") {\n        val = val.toLowerCase();\n        if (val === \"false\" || val === \"no\" || val === '0') {\n            return false;\n        }\n    }\n    return true;\n};","\n\n/**\n * Convert dashes to camel case\n * @function toCamelCase\n * @param {string} str \n * @returns {string}\n */\nmodule.exports = function toCamelCase(str) {\n    return str.replace(/-./g, function(match) {\n        return match.charAt(1).toUpperCase();\n    });\n};\n\n","\n/**\n * Convert anything to string\n * @function toString\n * @param {*} value\n * @returns {string}\n */\nmodule.exports = Object.prototype.toString;","\n/**\n * Change first character to upper case\n * @function ucfirst\n * @param {string} str \n * @returns {string}\n */\nmodule.exports = function ucfirst(str) {\n    return str.substr(0, 1).toUpperCase() + str.substr(1);\n};","\nconst MetaphorJs = require( \"../MetaphorJs\");\n\nmodule.exports = MetaphorJs.lib.Cache = (function(){\n\n    let globalCache;\n\n    /**\n     * @class MetaphorJs.lib.Cache\n     */\n\n    /**\n     * @method\n     * @constructor\n     * @param {bool} cacheRewritable\n     */\n    var Cache = function(cacheRewritable) {\n\n        var storage = {},\n\n            finders = [];\n\n        if (arguments.length == 0) {\n            cacheRewritable = true;\n        }\n\n        return {\n\n            /**\n             * Add finder function. If cache doesn't have an entry\n             * with given name, it calls finder functions with this\n             * name as a parameter. If one of the functions\n             * returns anything else except undefined, it will\n             * store this value and return every time given name\n             * is requested.\n             * @param {function} fn {\n             *  @param {string} name\n             *  @param {Cache} cache\n             *  @returns {* | undefined}\n             * }\n             * @param {object} context\n             * @param {bool} prepend Put in front of other finders\n             */\n            addFinder: function(fn, context, prepend) {\n                finders[prepend? \"unshift\" : \"push\"]({fn: fn, context: context});\n            },\n\n            /**\n             * Add cache entry\n             * @method\n             * @param {string} name\n             * @param {*} value\n             * @param {bool} rewritable\n             * @returns {*} value\n             */\n            add: function(name, value, rewritable) {\n\n                if (storage[name] && storage[name].rewritable === false) {\n                    return storage[name];\n                }\n\n                storage[name] = {\n                    rewritable: typeof rewritable != \"undefined\" ? \n                                    rewritable : cacheRewritable,\n                    value: value\n                };\n\n                return value;\n            },\n\n            /**\n             * Get cache entry\n             * @method\n             * @param {string} name\n             * @param {*} defaultValue {\n             *  If value is not found, put this default value it its place\n             * }\n             * @returns {* | undefined}\n             */\n            get: function(name, defaultValue) {\n\n                if (!storage[name]) {\n                    if (finders.length) {\n\n                        var i, l, res,\n                            self = this;\n\n                        for (i = 0, l = finders.length; i < l; i++) {\n\n                            res = finders[i].fn.call(finders[i].context, name, self);\n\n                            if (res !== undefined) {\n                                return self.add(name, res, true);\n                            }\n                        }\n                    }\n\n                    if (defaultValue !== undefined) {\n                        return this.add(name, defaultValue);\n                    }\n\n                    return undefined; \n                }\n\n                return storage[name].value;\n            },\n\n            /**\n             * Remove cache entry\n             * @method\n             * @param {string} name\n             * @returns {*}\n             */\n            remove: function(name) {\n                var rec = storage[name];\n                if (rec && rec.rewritable === true) {\n                    delete storage[name];\n                }\n                return rec ? rec.value : undefined;\n            },\n\n            /**\n             * Check if cache entry exists\n             * @method\n             * @param {string} name\n             * @returns {boolean}\n             */\n            exists: function(name) {\n                return !!storage[name];\n            },\n\n            /**\n             * Walk cache entries\n             * @method\n             * @param {function} fn {\n             *  @param {*} value\n             *  @param {string} key\n             * }\n             * @param {object} context\n             */\n            eachEntry: function(fn, context) {\n                var k;\n                for (k in storage) {\n                    fn.call(context, storage[k].value, k);\n                }\n            },\n\n            /**\n             * Clear cache\n             * @method\n             */\n            clear: function() {\n                storage = {};\n            },\n\n            /**\n             * Clear and destroy cache\n             * @method\n             */\n            $destroy: function() {\n\n                var self = this;\n\n                if (self === globalCache) {\n                    globalCache = null;\n                }\n\n                storage = null;\n                cacheRewritable = null;\n\n                self.add = null;\n                self.get = null;\n                self.destroy = null;\n                self.exists = null;\n                self.remove = null;\n            }\n        };\n    };\n\n    /**\n     * Get global cache\n     * @method\n     * @static\n     * @returns {Cache}\n     */\n    Cache.global = function() {\n\n        if (!globalCache) {\n            globalCache = new Cache(true);\n        }\n\n        return globalCache;\n    };\n\n    return Cache;\n    \n}());\n\n","\nconst MetaphorJs = require(\"../MetaphorJs\");\nconst extend = require(\"../func/extend\");\nconst isArray = require(\"../func/isArray\");\n\nexport default MetaphorJs.lib.Color = (function () {\n\n\n    var processSet = function (args, prev) {\n\n        var val = [];\n\n        if (args.length > 1 ||\n            typeof args[0] === \"number\" ||\n            typeof args[0] === \"string\") {\n\n            var a1 = args[0],\n                a2 = args[1],\n                a3 = args[2],\n                a4 = args[3];\n\n            val = prev.slice();\n            a1 !== undefined && a1 !== null && (val[0] = a1);\n            a2 !== undefined && a2 !== null && (val[1] = a2);\n            a3 !== undefined && a3 !== null && (val[2] = a3);\n            a4 !== undefined && a4 !== null && (val[3] = a4);\n        }\n        else {\n            val = args[0];\n        }\n\n        val[0] = parseFloat(val[0] || 0);\n        val[1] = parseFloat(val[1] || 0);\n        val[2] = parseFloat(val[2] || 0);\n        val[3] = val[3] === 0 ? 0 : parseFloat(val[3] || 1);\n\n        return val;\n    },\n\n\n        set = function (inModel, outModel, args, prev) {\n\n            var val = processSet(args, prev);\n            return convert(inModel, outModel, val);\n        },\n\n        convert = function (from, to, val, doRound) {\n            var conv = from + \"2\" + to;\n            if (from !== to) {\n                if (conversion[conv]) {\n                    val = conversion[conv](val);\n                }\n                else if (conversion[from + \"2rgba\"] && conversion[\"rgba2\" + to]) {\n                    val = conversion[\"rgba2\" + to](\n                        conversion[from + \"2rgba\"](val)\n                    );\n                }\n                else {\n                    throw new Error(\"Cannot convert \" + from + \" to \" + to);\n                }\n            }\n\n            if (doRound) {\n                val = round(val);\n            }\n\n            return val;\n        },\n\n        round = function (input) {\n            var val = input.slice();\n            val[0] = Math.round(val[0] || 0);\n            val[1] = Math.round(val[1] || 0);\n            val[2] = Math.round(val[2] || 0);\n            return val;\n        },\n\n        hex2full = function (short) {\n            var r = short.substring(0, 1).toLowerCase(),\n                g = short.substring(1, 2).toLowerCase(),\n                b = short.substring(2, 3).toLowerCase();\n            return r + r + g + g + b + b;\n        },\n\n\n        conversion = {\n\n            rgba2hex: function (rgba) {\n                var r = Math.round(rgba[0]).toString(16),\n                    g = Math.round(rgba[1]).toString(16),\n                    b = Math.round(rgba[2]).toString(16);\n\n                r.length === 1 && (r = \"0\" + r);\n                g.length === 1 && (g = \"0\" + g);\n                b.length === 1 && (b = \"0\" + b);\n\n                return r + g + b;\n            },\n\n            hex2rgba: function (hex) {\n                var a = 1;\n                if (hex.length > 6) {\n                    a = parseInt(hex.substring(6, 8), 16);\n                    a = a / 255;\n                }\n                return [\n                    parseInt(hex.substring(0, 2), 16),\n                    parseInt(hex.substring(2, 4), 16),\n                    parseInt(hex.substring(4, 6), 16),\n                    a\n                ];\n            },\n\n            rgba2hsla: function (rgba) {\n                var r = rgba[0] / 255;\n                var g = rgba[1] / 255;\n                var b = rgba[2] / 255;\n                var min = Math.min(r, g, b);\n                var max = Math.max(r, g, b);\n                var delta = max - min;\n                var h;\n                var s;\n\n                if (max === min) {\n                    h = 0;\n                } else if (r === max) {\n                    h = (g - b) / delta;\n                } else if (g === max) {\n                    h = 2 + (b - r) / delta;\n                } else if (b === max) {\n                    h = 4 + (r - g) / delta;\n                }\n\n                h = Math.min(h * 60, 360);\n\n                if (h < 0) {\n                    h += 360;\n                }\n\n                var l = (min + max) / 2;\n\n                if (max === min) {\n                    s = 0;\n                } else if (l <= 0.5) {\n                    s = delta / (max + min);\n                } else {\n                    s = delta / (2 - max - min);\n                }\n\n                return [\n                    h,\n                    s * 100,\n                    l * 100,\n                    rgba.length > 3 ? rgba[3] : 1\n                ];\n            },\n\n            hsla2rgba: function (hsla) {\n                var h = hsla[0] / 360;\n                var s = (hsla[1] || 100) / 100;\n                var l = (hsla[2] || 100) / 100;\n                var a = hsla.length > 3 ? hsla[3] : 1;\n                var t2;\n                var t3;\n                var val;\n\n                if (s === 0) {\n                    val = l * 255;\n                    return [val, val, val, a];\n                }\n\n                if (l < 0.5) {\n                    t2 = l * (1 + s);\n                } else {\n                    t2 = l + s - l * s;\n                }\n\n                var t1 = 2 * l - t2;\n                var rgba = [0, 0, 0, a];\n\n                for (var i = 0; i < 3; i++) {\n                    t3 = h + 1 / 3 * -(i - 1);\n                    if (t3 < 0) {\n                        t3++;\n                    }\n\n                    if (t3 > 1) {\n                        t3--;\n                    }\n\n                    if (6 * t3 < 1) {\n                        val = t1 + (t2 - t1) * 6 * t3;\n                    } else if (2 * t3 < 1) {\n                        val = t2;\n                    } else if (3 * t3 < 2) {\n                        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n                    } else {\n                        val = t1;\n                    }\n\n                    rgba[i] = val * 255;\n                }\n\n                return rgba;\n            },\n\n            hsva2rgba: function (hsva) {\n                var h = hsva[0] / 60,\n                    s = hsva[1] / 100,\n                    v = hsva[2] / 100,\n                    a = hsva.length > 3 ? hsva[3] : 1,\n                    hi = Math.floor(h) % 6,\n\n                    f = h - Math.floor(h),\n                    p = 255 * v * (1 - s),\n                    q = 255 * v * (1 - (s * f)),\n                    t = 255 * v * (1 - (s * (1 - f)));\n\n                v *= 255;\n\n                switch (hi) {\n                    case 0:\n                        return [v, t, p, a];\n                    case 1:\n                        return [q, v, p, a];\n                    case 2:\n                        return [p, v, t, a];\n                    case 3:\n                        return [p, q, v, a];\n                    case 4:\n                        return [t, p, v, a];\n                    case 5:\n                        return [v, p, q, a];\n                }\n            },\n\n            rgba2hsva: function (rgba) {\n                var rdif,\n                    gdif,\n                    bdif,\n                    h,\n                    s,\n\n                    r = rgba[0] / 255,\n                    g = rgba[1] / 255,\n                    b = rgba[2] / 255,\n                    a = rgba.length > 3 ? rgba[3] : 1,\n                    v = Math.max(r, g, b),\n                    diff = v - Math.min(r, g, b);\n\n                var diffc = function (c) {\n                    return (v - c) / 6 / diff + 1 / 2;\n                };\n\n                if (diff === 0) {\n                    h = 0;\n                    s = 0;\n                } else {\n                    s = diff / v;\n                    rdif = diffc(r);\n                    gdif = diffc(g);\n                    bdif = diffc(b);\n\n                    if (r === v) {\n                        h = bdif - gdif;\n                    } else if (g === v) {\n                        h = (1 / 3) + rdif - bdif;\n                    } else if (b === v) {\n                        h = (2 / 3) + gdif - rdif;\n                    }\n\n                    if (h < 0) {\n                        h += 1;\n                    } else if (h > 1) {\n                        h -= 1;\n                    }\n                }\n\n                return [\n                    h * 360,\n                    s * 100,\n                    v * 100,\n                    a\n                ];\n            },\n\n            rgba2str: function (rgba) {\n                return color2str(\"rgba\", rgba);\n            },\n\n            hsla2str: function (hsla) {\n                return color2str(\"hsla\", hsla);\n            },\n\n            hsva2str: function (hsva) {\n                return color2str(\"hsva\", hsva);\n            },\n\n            str2rgba: function (str) {\n                return parseString(str);\n            },\n\n            str2hsla: function (str) {\n                return parseString(str);\n            },\n\n            str2hsva: function (str) {\n                return parseString(str);\n            }\n        },\n\n\n        color2str = function (model, color) {\n            var vals = round(color.slice()),\n                a = vals[3];\n            if (a > 0 && a < 1) {\n                vals[3] = a.toFixed(2);\n            }\n            return model + \"(\" + vals.join(',') + \")\";\n        },\n\n        parseString = function (str) {\n            var match = str.match(/[\\d, \\.]+/);\n            if (match) {\n                var parts = match[0].split(\",\");\n                parts[0] && (parts[0] = parseInt(parts[0]));\n                parts[1] && (parts[1] = parseInt(parts[1]));\n                parts[2] && (parts[2] = parseInt(parts[2]));\n                parts[3] && (parts[3] = parseFloat(parts[3]));\n                return parts;\n            }\n            return [0, 0, 0, 1];\n        };\n\n\n    /**\n     * @class MetaphorJs.lib.Color\n     * @constructor\n     * @param {string|MetaphorJs.lib.Color|array|null} color \n     * @param {string} model rgba|hsva\n     */\n    var Color = function (color, model) {\n\n        if (!model && color instanceof MetaphorJs.lib.Color) {\n            model = color.model;\n        }\n\n        this.model = model || \"rgba\";\n        this.color = [0, 0, 0, 1];\n\n        if (color) {\n            this.setColor(color);\n        }\n    };\n\n\n    extend(Color.prototype, {\n\n        model: null,\n        color: null,\n\n        /**\n         * Create object copy\n         * @returns {MetaphorJs.lib.Color}\n         */\n        copy: function () {\n            return new Color(this);\n        },\n\n        /**\n         * @method\n         * @param {string|MetaphorJs.lib.Color|array} color {\n         *  hex code, color object or rgba array\n         * }\n         */\n        setColor: function (color) {\n            if (!color) {\n                return;\n            }\n\n            var t = typeof color;\n\n            if (t === 'string') {\n                if (color.substring(0, 1) === \"#\") {\n                    color = color.substring(1);\n                }\n                color = color.toLowerCase();\n                if (color.length === 3) {\n                    this.setHEX(hex2full(color));\n                }\n                else if (color.indexOf(\"rgba\") !== -1) {\n                    this.setRGBA(parseString(color));\n                }\n                else if (color.indexOf(\"hsl\") !== -1) {\n                    this.setHSLA(parseString(color));\n                }\n                else if (color.indexOf(\"hsv\") !== -1) {\n                    this.setHSVA(parseString(color));\n                }\n                else if (color.length > 5) {\n                    this.setHEX(color);\n                }\n            }\n            else if (color instanceof MetaphorJs.lib.Color) {\n                if (this.model === \"rgba\") {\n                    this.setRGBA(color.getRGBA());\n                }\n                else if (this.model === \"hsva\") {\n                    this.setHSVA(color.getHSVA());\n                }\n            }\n            else if (isArray(color)) {\n                if (this.model === \"rgba\") {\n                    this.setRGBA(color);\n                }\n                else if (this.model === \"hsva\") {\n                    this.setHSVA(color);\n                }\n            }\n        },\n\n        /**\n         * @method\n         * @param {string} hex \n         */\n        setHEX: function (hex) {\n            var a = this.color[3];\n            this.color = convert(\"hex\", this.model, hex);\n            if (hex.length < 7) {\n                this.color[3] = a;\n            }\n        },\n\n        /**\n         * Set hsla\n         * @method setHSLA\n         * @param {int} h\n         * @param {int} s\n         * @param {int} l\n         * @param {float} a\n         */\n        /**\n         * Set hsla\n         * @method setHSLA\n         * @param {array} hsla \n         */\n        setHSLA: function () {\n            this.color = set(\"hsla\", this.model, arguments, this.getHSLA());\n        },\n\n\n        /**\n         * Set hsva\n         * @method setHSVA\n         * @param {int} h\n         * @param {int} s\n         * @param {int} v\n         * @param {float} a\n         */\n        /**\n         * Set hsla\n         * @method setHSVA\n         * @param {array} hsva \n         */\n        setHSVA: function () {\n            this.color = set(\"hsva\", this.model, arguments, this.getHSVA());\n        },\n\n        /**\n         * Set rgba\n         * @method setRGBA\n         * @param {int} r\n         * @param {int} g\n         * @param {int} b\n         * @param {float} a\n         */\n        /**\n         * Set hsla\n         * @method setRGBA\n         * @param {array} rgba \n         */\n        setRGBA: function () {\n            this.color = set(\"rgba\", this.model, arguments, this.getRGBA());\n        },\n\n        /**\n         * Set alpha channel\n         * @param {float} a \n         */\n        setAlpha: function (a) {\n            a = parseFloat(a);\n            a < 0 && (a = 0);\n            a > 1 && (a = 1);\n            this.color[3] = a;\n        },\n\n        /**\n         * Get color in given format\n         * @param {string} format hex|rgba|hsla|hsva|rgbastr|hslastr|hsvastr\n         * @param {boolean} floats \n         */\n        getAs: function (format, floats) {\n            switch (format) {\n                case \"hex\":\n                    return this.getHEX();\n                case \"rgba\":\n                    return this.getRGBA(floats);\n                case \"hsla\":\n                    return this.getHSLA(floats);\n                case \"hsva\":\n                    return this.getHSVA(floats);\n                case \"rgbastr\":\n                    return this.getRGBAString();\n                case \"hslastr\":\n                    return this.getHSLAString();\n                case \"hsvastr\":\n                    return this.getHSVAString();\n                default:\n                    return this.getHEX();\n            }\n        },\n\n\n        /**\n         * @method\n         * @returns {float}\n         */\n        getAlpha: function () {\n            return this.color[3];\n        },\n\n        /**\n         * @method\n         * @param {boolean} floats true to not round values to ints\n         * @returns {int}\n         */\n        getR: function (floats) {\n            return this.getRGBA(floats)[0];\n        },\n\n        /**\n         * @method\n         * @param {boolean} floats true to not round values to ints\n         * @returns {int}\n         */\n        getG: function (floats) {\n            return this.getRGBA(floats)[1];\n        },\n\n        /**\n         * @method\n         * @param {boolean} floats true to not round values to ints\n         * @returns {int}\n         */\n        getB: function (floats) {\n            return this.getRGBA(floats)[2];\n        },\n\n        /**\n         * @method\n         * @param {boolean} floats true to not round values to ints\n         * @returns {int}\n         */\n        getH: function (floats) {\n            return this.getHSVA(floats)[0];\n        },\n\n        /**\n         * @method\n         * @param {boolean} floats true to not round values to ints\n         * @returns {int}\n         */\n        getS: function (floats) {\n            return this.getHSVA(floats)[1];\n        },\n\n        /**\n         * @method\n         * @param {boolean} floats true to not round values to ints\n         * @returns {int}\n         */\n        getV: function (floats) {\n            return this.getHSVA(floats)[2];\n        },\n\n        /**\n         * @method\n         * @param {boolean} floats true to not round values to ints\n         * @returns {array}\n         */\n        getHSLA: function (floats) {\n            return convert(this.model, \"hsla\", this.color, !floats);\n        },\n\n        /**\n         * @method\n         * @param {boolean} floats true to not round values to ints\n         * @returns {array}\n         */\n        getRGBA: function (floats) {\n            return convert(this.model, \"rgba\", this.color, !floats);\n        },\n\n        /**\n         * @method\n         * @param {boolean} floats true to not round values to ints\n         * @returns {array}\n         */\n        getHSVA: function (floats) {\n            return convert(this.model, \"hsva\", this.color, !floats);\n        },\n\n        /**\n         * @method\n         * @returns {string}\n         */\n        getHEX: function () {\n            return convert(this.model, \"hex\", round(this.color));\n        },\n\n        /**\n         * @method\n         * @returns {string}\n         */\n        getRGBAString: function () {\n            return convert(\"rgba\", \"str\", convert(this.model, \"rgba\", this.color));\n        },\n\n        /**\n         * @method\n         * @returns {string}\n         */\n        getHSLAString: function () {\n            return convert(\"hsla\", \"str\", convert(this.model, \"hsla\", this.color));\n        },\n\n        /**\n         * @method\n         * @returns {string}\n         */\n        getHSVAString: function () {\n            return convert(\"hsva\", \"str\", convert(this.model, \"hsva\", this.color));\n        },\n\n        toString: function (format) {\n            return format ? this.getAs(format) : this.getHEX();\n        }\n    });\n\n    return Color;\n\n}());\n","\n\nconst isPlainObject = require(\"../func/isPlainObject.js\"),\n    isArray = require(\"../func/isArray.js\"),\n    extend = require(\"../func/extend.js\"),\n    MetaphorJs = require(\"../MetaphorJs.js\");\n\n/**\n * A storage of plural definitions\n * @class MetaphorJs.lib.LocalText\n */\nmodule.exports = MetaphorJs.lib.LocalText = function(){\n\n    var pluralDef       = function($number, $locale) {\n\n            if ($locale === \"pt_BR\") {\n                // temporary set a locale for brasilian\n                $locale = \"xbr\";\n            }\n\n            if ($locale.length > 3) {\n                $locale = $locale.substr(0, -$locale.lastIndexOf('_'));\n            }\n\n            switch($locale) {\n                case 'bo':\n                case 'dz':\n                case 'id':\n                case 'ja':\n                case 'jv':\n                case 'ka':\n                case 'km':\n                case 'kn':\n                case 'ko':\n                case 'ms':\n                case 'th':\n                case 'tr':\n                case 'vi':\n                case 'zh':\n                    return 0;\n\n                case 'af':\n                case 'az':\n                case 'bn':\n                case 'bg':\n                case 'ca':\n                case 'da':\n                case 'de':\n                case 'el':\n                case 'en':\n                case 'eo':\n                case 'es':\n                case 'et':\n                case 'eu':\n                case 'fa':\n                case 'fi':\n                case 'fo':\n                case 'fur':\n                case 'fy':\n                case 'gl':\n                case 'gu':\n                case 'ha':\n                case 'he':\n                case 'hu':\n                case 'is':\n                case 'it':\n                case 'ku':\n                case 'lb':\n                case 'ml':\n                case 'mn':\n                case 'mr':\n                case 'nah':\n                case 'nb':\n                case 'ne':\n                case 'nl':\n                case 'nn':\n                case 'no':\n                case 'om':\n                case 'or':\n                case 'pa':\n                case 'pap':\n                case 'ps':\n                case 'pt':\n                case 'so':\n                case 'sq':\n                case 'sv':\n                case 'sw':\n                case 'ta':\n                case 'te':\n                case 'tk':\n                case 'ur':\n                case 'zu':\n                    return ($number === 1) ? 0 : 1;\n\n                case 'am':\n                case 'bh':\n                case 'fil':\n                case 'fr':\n                case 'gun':\n                case 'hi':\n                case 'ln':\n                case 'mg':\n                case 'nso':\n                case 'xbr':\n                case 'ti':\n                case 'wa':\n                    return (($number === 0) || ($number === 1)) ? 0 : 1;\n\n                case 'be':\n                case 'bs':\n                case 'hr':\n                case 'ru':\n                case 'sr':\n                case 'uk':\n                    return (($number % 10 === 1) && ($number % 100 !== 11)) ?\n                           0 :\n                           ((($number % 10 >= 2) && ($number % 10 <= 4) &&\n                             (($number % 100 < 10) || ($number % 100 >= 20))) ? 1 : 2);\n\n                case 'cs':\n                case 'sk':\n                    return ($number === 1) ? 0 : ((($number >= 2) && ($number <= 4)) ? 1 : 2);\n\n                case 'ga':\n                    return ($number === 1) ? 0 : (($number === 2) ? 1 : 2);\n\n                case 'lt':\n                    return (($number % 10 === 1) && ($number % 100 !== 11)) ?\n                           0 :\n                           ((($number % 10 >= 2) &&\n                             (($number % 100 < 10) || ($number % 100 >= 20))) ? 1 : 2);\n\n                case 'sl':\n                    return ($number % 100 === 1) ?\n                           0 :\n                           (($number % 100 === 2) ?\n                                1 :\n                                ((($number % 100 === 3) || ($number % 100 === 4)) ? 2 : 3));\n\n                case 'mk':\n                    return ($number % 10 === 1) ? 0 : 1;\n\n                case 'mt':\n                    return ($number === 1) ?\n                           0 :\n                           ((($number === 0) || (($number % 100 > 1) && ($number % 100 < 11))) ?\n                                1 :\n                                ((($number % 100 > 10) && ($number % 100 < 20)) ? 2 : 3));\n\n                case 'lv':\n                    return ($number === 0) ? 0 : ((($number % 10 === 1) && ($number % 100 !== 11)) ? 1 : 2);\n\n                case 'pl':\n                    return ($number === 1) ?\n                           0 :\n                           ((($number % 10 >= 2) && ($number % 10 <= 4) &&\n                             (($number % 100 < 12) || ($number % 100 > 14))) ? 1 : 2);\n\n                case 'cy':\n                    return ($number === 1) ? 0 : (($number === 2) ? 1 : ((($number === 8) || ($number === 11)) ? 2 : 3));\n\n                case 'ro':\n                    return ($number === 1) ?\n                           0 :\n                           ((($number === 0) || (($number % 100 > 0) && ($number % 100 < 20))) ? 1 : 2);\n\n                case 'ar':\n                    return ($number === 0) ?\n                           0 :\n                           (($number === 1) ?\n                                1 :\n                                (($number === 2) ?\n                                    2 :\n                                    ((($number >= 3) && ($number <= 10)) ?\n                                        3 :\n                                        ((($number >= 11) && ($number <= 99)) ? 4 : 5))));\n\n                default:\n                    return 0;\n            }\n        };\n\n\n    /**\n     * @method LocalText\n     * @constructor\n     * @param {string} locale 2char locale id\n     */\n    var LocalText = function(locale) {\n\n        var self    = this;\n        self.store  = {};\n        if (locale) {\n            self.locale = locale;\n        }\n    };\n\n    extend(LocalText.prototype, {\n\n        store: null,\n        locale: \"en\",\n\n        /**\n         * @method\n         * @param {string} locale 2char locale id\n         */\n        setLocale: function(locale) {\n            this.locale = locale;\n        },\n\n        /**\n         * Set plural definition\n         * @method\n         * @param {string} key\n         * @param {array|object} value {\n         *  Array:<br>\n         *  0: Singular form<br>\n         *  1: LocalText form<br>\n         *  2: Second plural form<br>\n         *  3: Third plural form<br>\n         *  Object:<br>\n         *  <int>: Respective number<br>\n         *  \"one\": Singular form for 1<br>\n         *  \"negative\": Negative values form<br>\n         *  \"other\": All other\n         * }\n         */\n        set: function(key, value) {\n            var store = this.store;\n            if (store[key] === undefined) {\n                store[key] = value;\n            }\n        },\n\n        /**\n         * Load plural definitions\n         * @method\n         * @param {object} keys {\n         *  key: definition pairs; see set()\n         * }\n         */\n        load: function(keys) {\n            extend(this.store, keys, false, false);\n        },\n\n        /**\n         * Get definition. If key is not found, will return -- key --\n         * @method\n         * @param {string} key\n         * @returns {array|object|string}\n         */\n        get: function(key) {\n            var self = this;\n            return self.store[key] ||\n                   (self === globalText ? '-- ' + key + ' --' : globalText.get(key));\n        },\n\n        /**\n         * Get variant best suited for the number\n         * @method\n         * @param {string} key\n         * @param {int} number\n         * @returns {string}\n         */\n        plural: function(key, number) {\n            var self    = this,\n                strings = typeof key === \"string\" ? self.get(key): key,\n                def     = pluralDef(number, self.locale);\n\n            if (!isArray(strings)) {\n                if (isPlainObject(strings)) {\n                    if (strings[number]) {\n                        return strings[number];\n                    }\n                    if (number === 1 && strings.one !== undefined) {\n                        return strings.one;\n                    }\n                    else if (number < 0 && strings.negative !== undefined) {\n                        return strings.negative;\n                    }\n                    else {\n                        return strings.other;\n                    }\n                }\n                return strings;\n            }\n            else {\n                return strings[def];\n            }\n        },\n\n        /**\n         * Destroy definitions store\n         * @method\n         */\n        $destroy: function() {\n            this.store = null;\n        }\n\n    }, true, false);\n\n\n    var globalText  = new LocalText;\n\n    LocalText.global     = function() {\n        return globalText;\n    };\n\n    return LocalText;\n}();\n","require(\"metaphorjs-promise/src/lib/Promise.js\");\n\nconst extend = require(\"../func/extend.js\"),\n    isThenable = require(\"../func/isThenable.js\"),\n    isFunction = require(\"../func/isFunction.js\"),\n    isString = require(\"../func/isString.js\"),\n    isBool = require(\"../func/isBool.js\"),\n    instantiate = require(\"../func/instantiate.js\"),\n    MetaphorJs = require(\"../MetaphorJs.js\");\n    \n\nmodule.exports = MetaphorJs.lib.Provider = (function(){\n\nconst VALUE       = 1,\n    CONSTANT    = 2,\n    FACTORY     = 3,\n    SERVICE     = 4,\n    PROVIDER    = 5;\n    \nlet globalProvider;\n\nconst Provider = function() {\n    this.store  = {};\n};\n\nextend(Provider.prototype, {\n\n    store: null,\n\n    instantiate: function(fn, context, args, isClass) {\n        if (fn.$instantiate) {\n            return fn.$instantiate.apply(fn, args);\n        }\n        else if (isClass) {\n            return instantiate(fn, args);\n        }\n        else {\n            return fn.apply(context, args);\n        }\n    },\n\n    inject: function(injectable, context, currentValues, callArgs, isClass) {\n\n        currentValues   = currentValues || {};\n        callArgs        = callArgs || [];\n\n        var self = this;\n\n        if (isFunction(injectable)) {\n\n            if (injectable.inject) {\n                var tmp = injectable.inject.slice();\n                tmp.push(injectable);\n                injectable = tmp;\n            }\n            else {\n                return self.instantiate(injectable, context, callArgs, isClass);\n            }\n        }\n        else if (isString(injectable)) {\n            return self.resolve(injectable, currentValues);\n        }\n        else {\n            injectable = injectable.slice();\n        }\n\n        var values  = [],\n            fn      = injectable.pop(),\n            i, l;\n\n        for (i = -1, l = injectable.length; ++i < l;\n                values.push(self.resolve(injectable[i], currentValues))) {}\n\n        return MetaphorJs.lib.Promise.all(values).then(function(values){\n            return self.instantiate(fn, context, values, isClass);\n        });\n    },\n\n    value: function(name, value) {\n        this.store[name] = {\n            type: VALUE,\n            value: value\n        };\n    },\n\n    constant: function(name, value) {\n        var store = this.store;\n        if (!store[name]) {\n            store[name] = {\n                type: CONSTANT,\n                value: value\n            };\n        }\n    },\n\n    factory: function(name, fn, context, singleton) {\n\n        if (isBool(context)) {\n            singleton = context;\n            context = null;\n        }\n\n        this.store[name] = {\n            type: FACTORY,\n            singleton: singleton,\n            fn: fn,\n            context: context\n        };\n    },\n\n    service: function(name, constr, singleton) {\n        this.store[name] = {\n            type: SERVICE,\n            singleton: singleton,\n            fn: constr\n        };\n    },\n\n    provider: function(name, constr) {\n\n        this.store[name + \"Provider\"] = {\n            name: name,\n            type: PROVIDER,\n            fn: constr,\n            instance: null\n        };\n    },\n\n    isResolved: function(name) {\n        var item = this.store[name];\n        return item && (item.type === VALUE || item.type === CONSTANT);\n    },\n\n    resolve: function(name, currentValues, callArgs) {\n\n        var self    = this,\n            store   = self.store,\n            type,\n            item,\n            res;\n\n        currentValues = currentValues || {};\n        callArgs = callArgs || [];\n\n        if (currentValues[name] !== undefined) {\n            return currentValues[name];\n        }\n\n        if (item = store[name]) {\n\n            type    = item.type;\n\n            if (type === VALUE || type === CONSTANT) {\n                return item.value;\n            }\n            else if (type === FACTORY) {\n                res = self.inject(item.fn, item.context, currentValues, callArgs);\n            }\n            else if (type === SERVICE) {\n                res = self.inject(item.fn, null, currentValues, callArgs, true);\n            }\n            else if (type === PROVIDER) {\n\n                if (!item.instance) {\n\n                    item.instance = MetaphorJs.lib.Promise.resolve(\n                            self.inject(item.fn, null, currentValues)\n                        )\n                        .done(function(instance){\n                            item.instance = instance;\n                            store[item.name] = {\n                                type: FACTORY,\n                                fn: instance.$get,\n                                context: instance\n                            };\n                        });\n                }\n\n                return item.instance;\n            }\n\n            if (item.singleton) {\n                item.type = VALUE;\n                item.value = res;\n\n                if (type === FACTORY && isThenable(res)) {\n                    res[res.done ? \"done\" : \"then\"](function(value){\n                        item.value = value;\n                    });\n                }\n            }\n\n            return currentValues[name] = res;\n        }\n        else {\n\n            if (store[name + \"Provider\"]) {\n                self.resolve(name + \"Provider\", currentValues);\n                return self.resolve(name, currentValues);\n            }\n\n            if (self === globalProvider) {\n                throw new Error(\"Could not provide value for \" + name);\n            }\n            else {\n                return globalProvider.resolve(name);\n            }\n        }\n    },\n\n    $destroy: function() {\n        this.store = null;\n    }\n\n}, true, false);\n\nProvider.global = function() {\n    return globalProvider;\n};\n\nglobalProvider = new Provider;\n\nreturn Provider;\n}());\n","\nconst async = require(\"../func/async.js\"),\n    extend = require(\"../func/extend.js\"),\n    bind = require(\"../func/bind.js\"),\n    nextUid = require(\"../func/nextUid.js\"),\n    isThenable = require(\"../func/isThenable.js\"),\n    emptyFn = require(\"../func/emptyFn.js\"),\n    isNumber = require(\"../func/isNumber.js\"),\n    error = require(\"../func/error.js\"),\n    raf = require(\"metaphorjs-animate/src/func/raf.js\"),\n    MetaphorJs = require(\"../MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.lib.Queue = (function(){\n\n\nconst Queue = function(cfg) {\n\n    var self = this;\n\n    cfg = cfg || {};\n\n    self._queue = [];\n    self._map = {};\n    self.id = \"$$\" + nextUid();\n    self._f = bind(self._finish, self);\n\n    for (var i in cfg) {\n        self[i] = cfg[i];\n    }\n};\n\n\nQueue.REPLACE = 1;\nQueue.ONCE = 2;\nQueue.MULTIPLE = 3;\nQueue.ONCE_EVER = 4;\n\n\nextend(Queue.prototype, {\n\n    _queue: null,\n    _map: null,\n    _nextRequested: false,\n    _running: false,\n\n    currentItemNo: null,\n\n    length: 0,\n    id: null,\n    async: true,\n    auto: true,\n    thenable: false,\n    stack: false,\n    context: null,\n    onResult: null,\n    onFinish: null,\n    counter: 0,\n    mode: Queue.MULTIPLE,\n\n    add: function(fn, context, args, mode, prepend, async) {\n\n        var self    = this,\n            qid     = self.id,\n            id      = fn[qid] || nextUid(),\n            item    = {\n                id: id,\n                fn: fn,\n                context: context,\n                args: args,\n                async: async,\n                itemno: ++self.counter\n            };\n\n        mode = mode || self.mode;\n\n        if (mode === Queue.ONCE_EVER && fn[qid]) {\n            return fn[qid];\n        }\n\n        fn[qid] = id;\n\n        if (self._map[id]) {\n            if (mode === Queue.REPLACE) {\n                self.remove(id);\n            }\n            else if (mode === Queue.ONCE) {\n                return id;\n            }\n        }\n\n        self._queue[prepend ? \"unshift\" : \"push\"](item);\n        self._map[id] = item;\n\n        self.length = self._queue.length;\n\n        if (self.auto) {\n            self.next();\n        }\n\n        return id;\n    },\n\n    append: function(fn, context, args, mode, async) {\n        return this.add(fn, context, args, mode, false, async);\n    },\n\n    prepend: function(fn, context, args, mode, async) {\n        return this.add(fn, context, args, mode, true, async);\n    },\n\n    remove: function(id) {\n        var self = this,\n            queue = self._queue,\n            i, l;\n\n        for (i = 0, l = queue.length; i < l; i++) {\n            if (queue[i].id === id) {\n                queue.splice(i, 1);\n                break;\n            }\n        }\n        delete self._map[id];\n    },\n\n    isEmpty: function() {\n        return this.length === 0;\n    },\n\n    isRunning: function() {\n        return this._running;\n    },\n\n    next: function() {\n\n        var self    = this,\n            item,\n            res;\n\n        if (self._running) {\n            self._nextRequested = true;\n            return;\n        }\n\n        self._nextRequested = false;\n\n        item = self._queue[self.stack ? \"pop\" : \"shift\"]();\n        self.length = self._queue.length;\n\n        if (!item) {\n            return false;\n        }\n\n        self._running = true;\n        self.currentItemNo = item.itemno;\n\n        delete self._map[item.id];\n\n        var fn = function(){\n            try {\n                res = item.fn.apply(item.context || self.context, item.args || []);\n            }\n            catch (thrown) {\n                error(thrown);\n            }\n            finally {\n                if (isThenable(res)) {\n                    res.then(self._f, self._f);\n                }\n                else {\n                    self._finish(res);\n                }\n            }\n        };\n\n        var asnc = item.async || self.async || false;\n\n        !asnc && fn();\n        asnc === \"raf\" && raf(fn);\n        asnc && asnc !== \"raf\" && async(fn, null, null, isNumber(asnc) ? asnc : 0);\n    },\n\n    _finish: function(result) {\n        var self = this;\n        self.onResult && self.onResult.call(self.context, result);\n        if (self._running) {\n            self._running = false;\n            self.currentItemNo = null;\n            if (self.auto || self._nextRequested) {\n                if (self.next() === false) {\n                    self.onFinish && self.onFinish.call(self.context);\n                }\n            }\n            else {\n                self.length === 0 && self.onFinish && self.onFinish.call(self.context);\n            }\n        }\n    },\n\n    $destroy: function() {\n\n        var self = this;\n\n        self._queue = null;\n        self._map = null;\n        self.context = null;\n        self._nextRequested = false;\n        self._running = false;\n        self.next = emptyFn;\n\n    }\n}, true, false);\n\nreturn Queue;\n}());\n\n\n","require(\"../lib/Provider.js\");\nconst MetaphorJs = require(\"../MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.mixin.Provider = {\n\n    /**\n     * @type {Provider}\n     */\n    $$provider: null,\n\n    $beforeInit: function() {\n        this.$$provider = new MetaphorJs.lib.Provider;\n    },\n\n    value: function() {\n        var p = this.$$provider;\n        return p.value.apply(p, arguments);\n    },\n\n    constant: function() {\n        var p = this.$$provider;\n        return p.constant.apply(p, arguments);\n    },\n\n    factory: function() {\n        var p = this.$$provider;\n        return p.factory.apply(p, arguments);\n    },\n\n    service: function() {\n        var p = this.$$provider;\n        return p.service.apply(p, arguments);\n    },\n\n    provider: function() {\n        var p = this.$$provider;\n        return p.provider.apply(p, arguments);\n    },\n\n    isResolved: function() {\n        var p = this.$$provider;\n        return p.isResolved.apply(p, arguments);\n    },\n\n    resolve: function() {\n        var p = this.$$provider;\n        return p.resolve.apply(p, arguments);\n    },\n\n    inject: function() {\n        var p = this.$$provider;\n        return p.inject.apply(p, arguments);\n    },\n\n    $afterDestroy: function() {\n\n        this.$$provider.$destroy();\n        this.$$provider = null;\n\n    }\n};","const MetaphorJs = require(\"../../MetaphorJs.js\");\n\n\nmodule.exports = MetaphorJs.regexp.email = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?$/i;","\n\nconst MetaphorJs = require(\"../../MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.regexp.location = /^(((([^:\\/#\\?]+:)?(?:(\\/\\/)((?:(([^:@\\/#\\?]+)(?:\\:([^:@\\/#\\?]+))?)@)?(([^:\\/#\\?\\]\\[]+|\\[[^\\/\\]@#?]+\\])(?:\\:([0-9]+))?))?)?)?((\\/?(?:[^\\/\\?#]+\\/+)*)([^\\?#]*)))?(\\?[^#]+)?)(#.*)?/;","\nconst MetaphorJs = require(\"../../MetaphorJs.js\");\n///^((https?|ftp):\\/\\/|)(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i;\n\n// https://gist.github.com/dperini/729294\nmodule.exports = MetaphorJs.regexp.url = new RegExp(\n    \"^\" +\n        // protocol identifier\n    \"(?:(?:https?|ftp)://)\" +\n        // user:pass authentication\n    \"(?:\\\\S+(?::\\\\S*)?@)?\" +\n    \"(?:\" +\n        // IP address exclusion\n        // private & local networks\n    \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +\n    \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +\n    \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\" +\n        // IP address dotted notation octets\n        // excludes loopback network 0.0.0.0\n        // excludes reserved space >= 224.0.0.0\n        // excludes network & broacast addresses\n        // (first & last IP address of each class)\n    \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" +\n    \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" +\n    \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" +\n    \"|\" +\n        // host name\n    \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\" +\n        // domain name\n    \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\" +\n        // TLD identifier\n    \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\" +\n    \")\" +\n        // port number\n    \"(?::\\\\d{2,5})?\" +\n        // resource path\n    \"(?:/\\\\S*)?\" +\n    \"$\", \"i\"\n);","require(\"metaphorjs/src/app/Container.js\");\n\nvar cls = require(\"metaphorjs-class/src/cls.js\"),\n    ns = require(\"metaphorjs-namespace/src/var/ns.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nvar Test = {};\n\nns.register(\"Test\", Test);\n\ncls({\n    $class: \"Test.container.Cmp1\",\n    $extends: \"MetaphorJs.app.Component\",\n    as: \"ctrl\",\n    move: function() {\n        var parent1 = window.mainApp.getCmp(\"parent1\"),\n            parent2 = window.mainApp.getCmp(\"parent2\");\n\n        if (parent1.hasItem(this)) {\n            parent2.addItem(this);\n        }\n        else {\n            parent1.addItem(this);\n        }\n    },\n    template: {\n        html: \"<p>This is container child #1; \" +\n                \"<a href=\\\"#\\\" (click)=\\\"this.ctrl.move()\\\">move</a></p>\"\n    }\n});\n\ncls({\n    $class: \"Test.container.Cmp2\",\n    $extends: \"Test.container.Cmp1\",\n    as: \"ctrl\",\n    template: {\n        html: \"<p>This is container child #2; \"+\n                \"<a href=\\\"#\\\" (click)=\\\"this.ctrl.move()\\\">move</a></p>\"\n    }\n});\n\ncls({\n    $class: \"Test.container.Cmp3\",\n    $extends: \"MetaphorJs.app.Component\",\n    as: \"ctrl\",\n    template: {\n        html: \"<div>Before bind // <span ##bindhere></span> // After bind</div>\"\n    }\n}, \n{\n    supportsDirectives: {\n        \"bind-html\": \"bindhere\"\n    }\n}\n);\n\ncls({\n    $class: \"Test.container.Parent3\",\n    $extends: \"MetaphorJs.app.Container\",\n    $alias: \"MetaphorJs.directive.component.parent3\",\n    id: \"parent3\",\n    template: 'container2.html'\n});\n\ncls({\n    $class: \"Test.container.Cmp4\",\n    $extends: \"MetaphorJs.app.Component\",\n    $alias: \"MetaphorJs.directive.component.cmp4\",\n    template: {\n        html: \"<div>This is cmp4</div>\"\n    }\n});\n\n\ncls({\n    $class: \"Test.ContainerApp\",\n    $extends: \"MetaphorJs.app.App\",\n\n    initApp: function(node, state) {\n\n        window.mainApp = this;\n\n        state.bindText = \"AAA\";\n        state.$makePublicDefault();\n\n        var div = document.createElement(\"div\");\n        div.innerHTML = 'Dynamicly created node';\n\n        var parent1 = new MetaphorJs.app.Container({\n            id: \"parent1\",\n            defaultAddTo: \"body\",\n            renderTo: document.getElementById(\"container-app\"),\n            template: 'container1.html',\n            items: [\n                new Test.container.Cmp1({\n                    id: \"child1\"\n                }),\n                new Test.container.Cmp2({\n                    id: \"child2\"\n                }),\n                new Test.container.Cmp3({\n                    id: \"child3\",\n                    directives: {\n                        state: state,\n                        \"bind-html\": {\n                            value: {\n                                expression: \"this.bindText\"\n                            }\n                        }\n                    }\n                }),\n                div\n            ]\n        });\n\n        parent1.render();\n\n        var parent2 = new MetaphorJs.app.Container({\n            id: \"parent2\",\n            config: {\n                tag: \"div\"\n            }\n        });\n\n        parent2.render(document.getElementById(\"container-app\"));\n    }\n});\n\n\n\n\n\ncls({\n    $class: \"Test.UIApp\",\n    $extends: \"MetaphorJs.app.App\",\n\n    initApp: function(node, state) {\n\n        window.mainApp = this;\n        window.cls = cls;\n\n        this.menu1 = new MetaphorJs.ui.menu.Menu({\n            directives:{\n                \"class\": \"vertical\"\n            },\n            items: [\n                {\n                    text: \"Text 1\",\n                    callback: {\n                        click: function() {\n                            console.log(this)\n                            console.log(\"dynamic menu click\")\n                        }\n                    },\n                    items: [\n                        '<i class=\"dropdown icon\" @after></i>'\n                    ],\n                    menu: {items: [{text: \"Text 2\"}]}\n                },\n                '|',\n                {\n                    text: \"Test\"\n                }\n            ]\n        });\n    },\n\n    afterRender: function() {\n        this.menu1.render(this.getRefEl(\"dynamic-menu\"));\n    }\n});\n\n","\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nMetaphorJs.ui = MetaphorJs.ui || {\n    button: {},\n    panel: {},\n    window: {},\n    field: {view: {}},\n    dialog: {},\n    menu: {},\n    toolbar: {},\n    form: {},\n    mixin: {},\n    util: {\n        view: {}\n    }\n};","\n\nrequire(\"metaphorjs-shared/src/lib/Color.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @filter get\n * @param {object} input\n * @param {string} format\n * @returns {*}\n */\nMetaphorJs.filter.color = function(val, state, prop) {\n    var c = new MetaphorJs.lib.Color(val);\n    return c.getAs(prop);\n}","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"../mixin/WithActiveState.js\");\nrequire(\"../mixin/WithText.js\");\nrequire(\"../mixin/WithDropdown.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.button.Button = MetaphorJs.app.Container.$extend({\n    $mixins: [MetaphorJs.ui.mixin.WithActiveState, \n                MetaphorJs.ui.mixin.WithText,\n                MetaphorJs.ui.mixin.WithDropdown],\n    $class: \"MetaphorJs.ui.button.Button\",\n    $alias: \"MetaphorJs.directive.component.ui-button\",\n    template: \"ui/button/button.html\",\n    as: \"button\",\n\n    onClick: function(e) {\n        this.trigger(\"click\", this, e);\n    }\n}, {\n\n    defaultDropdown: {\n        on: \"click\"\n    },\n\n    supportsDirectives: {\n        show: true,\n        hide: true,\n        class: true,\n        style: true,\n        click: \"button\", \n        dblclick: \"button\", \n        mousedown: \"button\", \n        mouseup: \"button\",\n        mousemove: \"button\",\n        dropdown: true\n    },\n\n    propsToItems: {\n        \"menu\": \"MetaphorJs.ui.menu.Menu\"\n    },\n\n    dropdownClasses: [\"MetaphorJs.ui.menu.Menu\"],\n    configProps: [\"text\", \"active\"]\n});","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.button.Group = MetaphorJs.app.Container.$extend({\n    $class: \"MetaphorJs.ui.button.Group\",\n    template: \"ui/button/group.html\"\n}, {\n    allowUnwrapped: [\"MetaphorJs.ui.button.Button\"],\n    wrapper: \"MetaphorJs.ui.button.Button\",\n    supportsDirectives: {\n        show: true,\n        hide: true,\n        class: true,\n        style: true\n    }\n});\n","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"metaphorjs-dialog/src/dialog/Container.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.dialog.Popup = MetaphorJs.app.Container.$extend({\n\n});","\nrequire(\"../../__init.js\");\nrequire(\"./Field.js\");\nrequire(\"metaphorjs/src/lib/Input.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\");\n\n\nmodule.exports = MetaphorJs.ui.field.Checkbox = MetaphorJs.ui.field.Field.$extend({\n    $class: \"MetaphorJs.ui.field.Checkbox\",\n    $alias: \"MetaphorJs.directive.component.ui-checkbox\",\n    template: \"ui/field/checkbox.html\",\n\n    afterRender: function() {\n        var self = this,\n            input;\n\n        if (self.$refs.node.input) {\n            self.input = input = MetaphorJs.lib.Input.get(self.$refs.node.input);\n            self.setValue = bind(input.setValue, input);\n            self.getValue = bind(input.getValue, input);\n            self.onKey = bind(input.onKey, input);\n            self.unKey = bind(input.unKey, input);\n            self.$$observable.relayEvent(input, \"change\");\n        }\n\n        self.$super();\n    }\n}, {\n\n    supportsDirectives: {\n        bind: \"input\",\n        model: \"input\",\n        show: true,\n        hide: true,\n        class: true,\n        style: true,\n        \"in-focus\": \"input\",\n        click: true, \n        dblclick: true, \n        mousedown: true, \n        mouseup: true,\n        mousemove: true,\n        field: true\n    }\n});","require(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"metaphorjs/src/directive/attr/bind.js\");\nrequire(\"metaphorjs/src/directive/attr/model.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),    \n    emptyFn = require(\"metaphorjs-shared/src/func/emptyFn.js\");\n\nmodule.exports = MetaphorJs.ui.field.Field = MetaphorJs.app.Container.$extend({\n    $class: \"MetaphorJs.ui.field.Field\",\n\n    initConfig: function() {\n        \n        var self = this,\n            config = self.config;\n\n        config.setOption(\"defaultMode\", MetaphorJs.lib.Config.MODE_STATIC);\n        config.setType(\"inputAutoCapitalize\", \"bool\", null, true);\n        config.setType(\"inputAutoCorrect\", \"bool\", null, true);\n        config.setType(\"inputDisabled\", \"bool\", null, false);\n        config.setType(\"clearable\", \"bool\", null, true);\n        config.setType(\"as\", null, null, \"field\");\n        config.setType(\"disabled\", \"bool\", null, false);\n        config.setType(\"readonly\", \"bool\", null, false);\n        config.setType(\"fluid\", \"bool\", null, false);\n        config.setDefaultMode(\"name\", MetaphorJs.lib.Config.MODE_STATIC);\n        config.setDefaultValue(\"name\", \"\");\n\n        self.$super();  \n    },\n\n    onDestroy: function() {\n        var self = this;\n\n        if (self.bindDirective) {\n            self.bindDirective.$destroy();\n            self.bindDirective = null;\n        }\n        if (self.modelDirective) {\n            self.modelDirective.$destroy();\n            self.modelDirective = null;\n        }\n\n        self.$super();\n    },\n\n    \n    \n\n    /* Input API */\n    setValue: emptyFn,\n    getValue: emptyFn,\n    onKey: emptyFn,\n    unKey: emptyFn,\n    onChange: function(fn, ctx, opt) {\n        return this.on(\"change\", fn, ctx, opt);\n    },\n    unChange: function(fn, ctx) {\n        return this.un(\"change\", fn, ctx);\n    },\n\n    getInputApi: function() {\n        return this;\n    }\n}, {\n\n    supportsDirectives: {\n        \"bind\": true,\n        \"model\": true\n    }\n});\n","\nrequire(\"../../__init.js\");\nrequire(\"./Field.js\");\nrequire(\"metaphorjs/src/lib/Input.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\");\n\n\nmodule.exports = MetaphorJs.ui.field.Input = MetaphorJs.ui.field.Field.$extend({\n    $class: \"MetaphorJs.ui.field.Input\",\n    $alias: \"MetaphorJs.directive.component.ui-input\",\n    template: \"ui/field/input.html\",\n\n    initConfig: function() {\n        this.$super();\n\n        var config = this.config;\n        config.setType(\"type\", null, MetaphorJs.lib.Config.MODE_STATIC, \"text\");\n        config.setType(\"placeholder\", null, MetaphorJs.lib.Config.MODE_STATIC, \"\");\n    },\n\n    afterRender: function() {\n        var self = this,\n            input;\n\n        self.input = input = MetaphorJs.lib.Input.get(self.$refs.node.input);\n        self.setValue = bind(input.setValue, input);\n        self.getValue = bind(input.getValue, input);\n        self.onKey = bind(input.onKey, input);\n        self.unKey = bind(input.unKey, input);\n\n        self.$$observable.relayEvent(input, \"change\");\n\n        self.$super();\n    }\n}, {\n\n    supportsDirectives: {\n        bind: \"input\",\n        model: \"input\",\n        show: true,\n        hide: true,\n        class: true,\n        style: true,\n        \"in-focus\": \"input\",\n        click: true, \n        dblclick: true, \n        mousedown: true, \n        mouseup: true,\n        mousemove: true,\n        field: true\n    }\n});","\nrequire(\"../../__init.js\");\nrequire(\"../mixin/Selectable.js\");\nrequire(\"./Field.js\");\nrequire(\"metaphorjs-model/src/model/Store.js\");\nrequire(\"metaphorjs-shared/src/lib/Queue.js\");\nrequire(\"metaphorjs/src/func/dom/addClass.js\");\nrequire(\"metaphorjs/src/func/dom/removeClass.js\");\nrequire(\"metaphorjs/src/func/dom/getWidth.js\");\nrequire(\"metaphorjs/src/lib/EventBuffer.js\");\nrequire(\"metaphorjs-dialog/src/dialog/Dialog.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"metaphorjs/src/lib/MutationObserver.js\");\nrequire(\"metaphorjs/src/func/dom/getStyle.js\");\n\nrequire(\"./view/Select.js\");\n\nconst async = require(\"metaphorjs-shared/src/func/async.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.field.Select = MetaphorJs.ui.field.Field.$extend({\n\n    $mixins: [MetaphorJs.ui.mixin.Selectable],\n    $class: \"MetaphorJs.ui.field.Select\",\n    $alias: \"MetaphorJs.directive.component.ui-select\",\n    $view: \"MetaphorJs.ui.field.view.Select\",\n    template: \"ui/field/select.html\",\n\n    dialog: null,\n\n    currentValue: null,\n    prevValue: null,\n    currentName: null,\n    resizeBuffer: null,\n    _firstLoadSet: false,\n\n    initConfig: function() {\n\n        this.$super();\n\n        var config = this.config;\n\n        config.setDefaultMode(\"options\", MetaphorJs.lib.Config.MODE_DYNAMIC);\n        config.setDefaultMode(\"store\", MetaphorJs.lib.Config.MODE_SINGLE);\n\n        config.setType(\"searchable\", \"bool\", null, false);\n        config.setType(\"storeAutoLoad\", \"bool\", null, true);\n        config.setType(\"storePageSize\", \"int\", null, 20);\n        config.setType(\"storeFilter\", null, MetaphorJs.lib.Config.MODE_LISTENER);\n        config.setType(\"valueField\", null, null, \"id\");\n        config.setType(\"displayField\", null, null, \"name\");\n\n        config.setType(\"showEmptyItem\", \"bool\", null, true);\n        config.setType(\"showNotFound\", \"bool\", null, true);\n        config.setType(\"showSingleClear\", \"bool\", null, false);\n        config.setType(\"keepSelectedOptions\", \"bool\", null, true);\n        config.setType(\"cssDialog\", \"bool\", null, false);\n\n        config.setType(\"hiddenInputName\", \"string\", null, \"\");\n        config.setType(\"emptyText\", \"string\", null, \"\");\n        config.setType(\"emptyItemText\", \"string\", null, \"&nbsp;\");\n        config.setType(\"notFoundText\", \"string\", null, \"Nothing found\");\n        config.setType(\"placeholder\", \"string\", null, \"\");\n\n        config.setType(\"queryParam\", \"string\", null, \"q\");\n        config.setType(\"queryMinLength\", \"int\", null, 3);\n        config.setType(\"queryMode\", \"string\", null, \"local\");\n\n        config.on(\"options\", this.setOptions, this);\n    },\n\n    initComponent: function() {\n\n        var self = this,\n            state = self.state,\n            config = self.config;\n\n        self._prevQuery = \"\";\n        self.searchQueue = new MetaphorJs.lib.Queue({\n            auto: true,\n            async: 300,\n            mode: MetaphorJs.lib.Queue.REPLACE\n        });\n\n        state.loading = false;\n        state.opened = false;\n        state.searchQuery = \"\";\n        state.focused = false;\n\n        if (config.hasExpression(\"store\")) {\n            self.store = config.get(\"store\");\n        }\n\n        if (!self.store) {\n            self.store = new MetaphorJs.model.Store({\n                model: config.get(\"storeModel\") || {\n                    id: config.get(\"valueField\")\n                },\n                local: !config.hasExpression(\"storeModel\"),\n                autoLoad: config.hasExpression(\"storeModel\") && \n                            config.get(\"storeAutoLoad\"),\n                pageSize: config.get(\"storePageSize\")\n            });\n        }\n\n        self.store.on(\"loading-start\", self.onStoreStartLoading, self);\n        self.store.on(\"load\", self.onStoreLoad, self);\n\n        if (config.get(\"queryMode\") !== \"none\") {\n            self.store.filter(bind(self.storeFilter, self));\n        }\n\n        if (config.get(\"searchable\")) {\n            self.state.$watch(\n                \"this.searchQuery\",\n                self.onSearchQueryChange,\n                self\n            );\n        }\n\n        if (config.hasExpression(\"storeFilter\")) {\n            self.storeFilterFn = config.get(\"storeFilter\");\n        }\n        else self.storeFilterFn = null;\n\n        if (config.hasExpression(\"options\")) {\n            self.setOptions(config.get(\"options\"));\n        }\n\n        self.$super();\n    },\n\n    afterRender: function() {\n        var self = this;\n        async(self.initDialog, self, [], 300);\n    },\n\n    onDestroy: function() {\n        var self = this;\n\n        if (!self.config.$isDestroyed() && self.config.get(\"searchable\")) {\n            self.state.$unwatch(\n                \"this.searchQuery\",\n                self.onSearchQueryChange,\n                self\n            );\n        }\n\n        self.$super();\n    },\n\n    \n\n\n    /* PUBLIC API */\n\n    hasSelection: function() {\n        if (this.$$selection.length > 0) {\n            return true;\n        }\n        if (this.currentValue) {\n            return !isArray(this.currentValue) || this.currentValue.length > 0;\n        }\n        return false;\n    },\n\n    isSelectionEnabled: function() {\n        return true;\n        //return !this.config.get(\"disabled\");\n    },\n\n    getValue: function() {\n        var self = this, \n            sels = self.getSelectedValues();\n        if (self.isMultiSelection()) {\n            return sels;\n        }\n        else {\n            return sels.length ? sels[0] : null;\n        }\n    },\n\n    setValue: function(val, name) {\n        var self = this;\n\n        if (self.currentValue == val) {\n            return;\n        }\n\n        self.prevValue = self.currentValue;\n\n        if (self.hasSelection() && \n            !self.isMultiSelection()) {\n            self.$$observable.suspendEvent(\"change\");\n            self.unselectAll();\n            self.$$observable.resumeEvent(\"change\");\n        }\n\n        if (!val) {\n            self.currentValue = null;\n            return;\n        }\n\n        if (self.isMultiSelection()) {\n            if (!isArray(val)) {\n                val = [val];\n            }\n            self.currentValue = val;\n            var i, l;\n            for (i = 0, l = val.length; i < l; i++) {\n                self.selectItemById(val[i]);\n            }\n        }\n        else {\n            self.currentValue = val;\n            self.currentName = name;\n            self.selectItemById(val);\n        }\n        if (!self.state.$$checking) {\n            self.state.$check();\n        }\n    },\n\n    getSelectedValues: function() {\n        return this.$$selection.slice();\n    },\n\n    getSelectedName: function() {\n        var self = this;\n        if (self.isMultiSelection()) {\n            return null;\n        }\n        var sel = self.getSelection();\n        if (sel.length) {\n            return self.getItemName(sel[0]);\n        }\n        else if (self.currentName) {\n            return self.currentName;\n        }\n        return self.currentValue;\n    },\n\n    getMultiSelection: function() {\n        return this.isMultiSelection() ? \n                    this.getSelection() : [];\n    },\n\n    search: function(query) {\n        this.store.start = 0;\n        this.store.setParam(this.queryParam, query);\n        this.store.load();\n    },\n\n    setOptions: function(options) {\n        if (this.store && typeof this.store !== \"string\") {\n            this.store.clear();\n            if (options) {\n                this.store.addMany(options);\n            }\n        }\n    },\n\n\n    /* PRIVATE */\n\n    onSearchQueryChange: function(query, prev) {\n        var self = this;\n\n        self._prevQuery = prev;\n\n        if (!self.store.local && self.config.get(\"queryMode\") !== \"local\") {\n            if (query.length >= self.queryMinLength) {\n                self.searchQueue.append(\n                    self.search,\n                    self,\n                    [query]\n                );\n            }\n            else if (query === \"\") {\n                if (self.config.get(\"storeAutoLoad\")) {\n                    self.searchQueue.append(\n                        self.search,\n                        self,\n                        [query]\n                    );\n                }\n                else {                    \n                    self.store.clear();\n                }\n            }\n            else {\n                self.store.clear();\n            }\n        }\n        else {\n            self.store.update();\n        }\n\n        self.trigger(\"query-change\", self, query, prev);\n    },\n\n    onSelectionChange: function() {\n        this.store.update();\n        self.prevValue = self.currentValue;\n        this.currentValue = this.getValue();\n        this.trigger(\"change\", this.currentValue, this, this.prevValue);\n    },\n\n    getItemValue: function(item) {\n        return item[this.config.get(\"valueField\")];\n    },\n\n    getItemName: function(item) {\n        return item[this.config.get(\"displayField\")];\n    },\n\n    onStoreStartLoading: function() {\n        this.state.$set('loading', true);\n    },\n\n    onStoreLoad: function() {\n        var self = this;\n\n        if (!self._firstLoadSet) {\n            self._firstLoadSet = true;\n            if (self.currentValue) {\n                self.setValue(self.currentValue, self.currentName);\n            }\n        }\n        else {\n            if (self.currentValue) {\n                self.$$observable.suspendEvent(\"selection-change\");\n                self.setValue(self.currentValue, self.currentName);\n                self.$$observable.resumeEvent(\"selection-change\");\n            }\n        }\n        self.state.$set('loading', false);\n    },\n\n    storeFilter: function(item) {\n        var self = this,\n            config = self.config;\n\n        if (self.isSelected(item) && !config.get(\"keepSelectedOptions\")) {\n            return false;\n        }\n\n        if ((config.get(\"queryMode\") === \"local\" || self.store.local) && \n            self.state.searchQuery) {\n            var text = item[config.get(\"displayField\")];\n            if (text) {\n                if (self.storeFilterFn) {\n                    return self.storeFilterFn(item, text, self.state.searchQuery);\n                }\n                else {\n                    return (\"\"+text).toLowerCase().indexOf(\n                        self.state.searchQuery.toLowerCase()\n                    ) !== -1;\n                }\n            }\n        }\n\n        return true;\n    },\n\n    _getSelectOptions: function() {\n        var opts = [],\n            self = this;\n\n        if (self.config.get(\"showEmptyItem\") && !self.store.isEmpty()) {\n            opts.push({\n                name: self.config.get(\"emptyItemText\"),\n                value: null\n            });\n        }\n\n        self.store.each(function(item){\n            opts.push({\n                name: self.getItemName(item),\n                value: self.getItemValue(item)\n            });\n        });\n\n        return opts;\n    },\n\n\n\n\n\n    /* DIALOG */\n\n    onBeforeDialogShow: function() {\n        var self = this,\n            pl = MetaphorJs.dom.getStyle(self.node, \"padding-left\"),\n            pr = MetaphorJs.dom.getStyle(self.node, \"padding-right\");\n\n        if (self.disabled) {\n            return false;\n        }\n\n        pl = pl ? parseInt(pl) : 0;\n        pr = pr ? parseInt(pr) : 0;\n\n        self.dialog.getElem().style.minWidth = pl + pr + MetaphorJs.dom.getWidth(self.node) + \"px\";\n        MetaphorJs.dom.addClass(self.node, \"active\");\n    },\n\n    onDialogShow: function() {\n        this.state.$set('opened', true);\n    },\n\n    onDialogHide: function() {\n        this.state.$set('opened', false);\n        MetaphorJs.dom.removeClass(this.node, \"active\");\n    },\n\n    initDialog: function() {\n\n        var self = this,\n            cssD = self.config.get(\"cssDialog\"),\n            render,\n            position;\n\n        if (cssD) {\n            position = false;\n            render = {\n                el: self.getRefEl(\"menu_items\"),\n                appendTo: false,\n                keepInDOM: true\n            };\n        }\n        else {\n            position = {\n                type: \"bl\",\n                offsetY: 1\n            };\n            render = {\n                el: self.getRefEl(\"menu\"),\n                zIndex: 100,\n                appendTo: document.body,\n                style: {\n                    position: \"absolute\"\n                }\n            };\n        }\n\n        self.dialog = new MetaphorJs.dialog.Dialog({\n            target: self.node,\n            position: position,\n            content: false,\n            modal: false,\n            group: \"ui-select\",\n            render: render,\n            show: {\n                events: false,\n                single: true\n            },\n            hide: {\n                events: {\n                    \"body\": \"click\"\n                },\n                remove: false\n            }\n        });\n\n        self.dialog.on(\"show\", self.onDialogShow, self);\n        self.dialog.on(\"hide\", self.onDialogHide, self);\n        self.dialog.on(\"before-show\", self.onBeforeDialogShow, self);\n\n        self.$$observable.relayEvent(self.dialog, \"*\", null, \"menu-\");\n    }\n}, {\n\n    supportsDirectives: {\n        bind: true,\n        model: true,\n        show: true,\n        hide: true,\n        class: true,\n        style: true,\n        \"in-focus\": \"search\",\n        click: true, \n        dblclick: true, \n        mousedown: true, \n        mouseup: true,\n        mousemove: true,\n        field: true\n    }\n});\n","\nrequire(\"../../../__init.js\");\nrequire(\"metaphorjs/src/app/component/View.js\");\nrequire(\"metaphorjs/src/lib/EventBuffer.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.field.view.Select = MetaphorJs.app.component.View.$extend({\n\n    $beforeHostInit: function() {\n        var self = this;\n\n        self.component.$intercept(\"afterRender\", self.afterRender, self, \"after\");\n        self.component.$intercept(\n            \"onSearchQueryChange\",\n            self.onSearchQueryChange, \n            self, \n            \"after\"\n        );\n    },\n\n    $afterHostInit: function() {\n        var self = this,\n            cmp = self.component,\n            config = cmp.config;\n\n        config.setType(\"useHiddenSelect\", \"bool\", null, false);\n        config.setType(\"hiddenSelectBreakpoint\", \"int\");\n\n        if (config.get(\"useHiddenSelect\")) {\n            if (config.get(\"hiddenSelectBreakpoint\")) {\n                config.set(\"useHiddenSelect\", false);\n                self.resizeBuffer = MetaphorJs.dom.EventBuffer.get(window, \"resize\");\n                self.resizeBuffer.watchWidth();\n                self.resizeBuffer.onBreak(\n                    \"width\", \n                    config.get(\"hiddenSelectBreakpoint\"), \n                    self.onWindowBreak, \n                    self\n                );\n            }\n        }\n    },\n\n    afterRender: function() {\n        var self = this,\n            cmp = self.component;\n        if (cmp.isMultiSelection() && cmp.config.get(\"searchable\")) {\n            async(self.initSizer, self);\n        }\n        if (self.resizeBuffer) {\n            async(self.onWindowBreak, self);\n        }\n    },\n\n    onSearchQueryChange: function() {\n        var self = this,\n            cmp = self.component;\n        if (cmp.isMultiSelection()) {\n            async(self.setInputWidth, self);\n        }\n    },\n\n    onWindowBreak: function() {\n        var cmp = this.component;\n        cmp.config.set(\"useHiddenSelect\", \n            MetaphorJs.dom.getWidth(window) < \n                cmp.config.get(\"hiddenSelectBreakpoint\")\n        );\n        cmp.state.$check();\n    },\n\n    initSizer: function() {\n        if (this.component.getRefEl(\"sizer\")) {\n            var style = this.component.getRefEl(\"sizer\").style;\n            style.left = '-10000px';\n            style.maxWidth = '1000px';\n            style.display = 'inline-block';\n            style.position = 'absolute';\n        }\n    },\n\n    setInputWidth: function() {\n        var cmp = this.component;\n        cmp.getRefEl(\"search\").style.width =\n            (MetaphorJs.dom.getWidth(cmp.getRefEl(\"sizer\")) + 10) + \"px\";\n    },\n\n    setSearchFocus: function() {\n        this.component.getRefEl(\"search\").focus();\n    },\n\n    onSelfClick: function(e) {\n        var self = this,\n            cmp = self.component;\n\n        if (cmp.config.get(\"useHiddenSelect\")) {\n            e.stopPropagation();\n            return;\n        }\n\n        if (cmp.state.focused &&\n            cmp.dialog.isVisible()) {\n            e.stopPropagation();\n            return;\n        }\n\n        if (cmp.config.get(\"searchable\") && !cmp.state.focused) {\n            async(self.setSearchFocus, self);\n            e.stopPropagation();\n        }\n\n        if (!cmp.config.get(\"searchable\") &&\n            !cmp.dialog.isVisible()) {\n            cmp.dialog.show();\n            e.stopPropagation();\n        }\n    },\n\n    onDropdownIconClick: function(e) {\n        e.stopPropagation();\n        this.component.dialog.toggle(e, true);\n    },\n\n    onItemClick: function(item, e) {\n        var self = this,\n            cmp = self.component,\n            cfg = cmp.config;\n\n        if (cfg.get(\"readonly\")) {\n            e.stopPropagation();\n            cmp.dialog.hide();\n            return;\n        }\n\n        if (item) {\n            //this.selectItem(item);\n            cmp.setValue(\n                item[cfg.get(\"valueField\")], \n                item[cfg.get(\"displayField\")]\n            );\n        }\n        else {\n            cmp.unselectAll();\n        }\n\n        //if (!cfg.get(\"keepSelectedOptions\")) {\n        //    self.store.update();\n        //}\n\n        e.stopPropagation();\n\n        cmp.state.$set(\"searchQuery\", \"\");\n\n        if (!cmp.isMultiSelection()) {\n            cmp.dialog.hide();\n        }\n        else {\n            async(self.setSearchFocus, self);\n        }\n    },\n\n    onValueTextClick: function(e) {\n\n    },\n\n    onItemDeleteClick: function(item, e) {\n        var self = this,\n            cmp = self.component;\n        if (!cmp.isSelectionEnabled()) {\n            return;\n        }\n        cmp.unselectItem(item);\n        if (!cmp.config.get(\"keepSelectedOptions\")) {\n            cmp.store.update();\n        }\n        e.stopPropagation();\n    },\n\n    /*onNotFoundClick: function(item, e) {\n        e.stopPropagation();\n    },\n\n    onPaginationClick: function(e) {\n        e.stopPropagation();\n    },*/\n\n    onSearchFocus: function(e) {\n        var cmp = this.component;\n        cmp.state.$set(\"focused\", true);\n        if (!cmp.dialog.isVisible()) {\n            cmp.dialog.show();\n            e.stopPropagation();\n        }\n    },\n\n    onSearchBlur: function(e) {\n        var cmp = this.component;\n        cmp.state.$set(\"focused\", false);\n        if (!cmp.dialog.isVisible()) {\n            cmp.dialog.show();\n            e.stopPropagation();\n        }\n    },\n\n    onSearchBackspace: function() {\n        var cmp = this.component;\n        if (!cmp.state.searchQuery) {\n            if (!cmp._prevQuery) {\n                if (cmp.hasSelection()) {\n                    cmp.unselectItemById(\n                        cmp.$$selection[cmp.$$selection.length - 1]\n                    );\n                    cmp.store.update();\n                }\n            }\n            else {\n                cmp._prevQuery = \"\";\n            }\n        }\n    },\n\n    onHiddenSelectClick: function(e) {\n        e.stopPropagation();\n    },\n\n    onHiddenSelectChange: function(e) {\n        var self = this,\n            cmp = self.component,\n            val = cmp.getRefEl(\"hiddenselect\").value;\n\n        if (val) {\n            var item = cmp.store.find(cmp.config.get(\"valueField\"), val);\n            if (item) {\n                cmp.selectItem(item);\n            }\n        }\n        else {\n            cmp.unselectAll();\n        }\n    }\n});","require(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.menu.Divider = MetaphorJs.app.Container.$extend({\n    $class: \"MetaphorJs.ui.menu.Divider\",\n    $alias: \"MetaphorJs.directive.component.ui-menu-divider\",\n    template: \"ui/menu/divider.html\"\n}, {\n    supportsDirectives: {\n        show: true,\n        hide: true,\n        class: true,\n        style: true,\n        click: true, \n        dblclick: true, \n        mousedown: true, \n        mouseup: true,\n        mousemove: true\n    }\n});","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"../mixin/WithActiveState.js\");\nrequire(\"../mixin/WithText.js\");\nrequire(\"../mixin/WithDropdown.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.menu.Item = MetaphorJs.app.Container.$extend({\n    $mixins: [MetaphorJs.ui.mixin.WithActiveState, \n                MetaphorJs.ui.mixin.WithText,\n                MetaphorJs.ui.mixin.WithDropdown],\n    $class: \"MetaphorJs.ui.menu.Item\",\n    $alias: \"MetaphorJs.directive.component.ui-menu-item\",\n    as: \"item\",\n    template: {\n        name: {\n            expression: \"this.tpl\"\n        }\n    },\n\n    initComponent: function() {\n        this.state.tpl = this.$self.templates.item;\n        this.$super.apply(this, arguments);\n    },\n\n    _initChildItem: function(item) {\n        var self = this;\n        \n        if (item.type === \"component\") {\n            self.state.tpl = self.$self.templates.container;\n        }\n\n        self.$super();\n    },\n\n    _onDropdownCreated: function(component) {\n        this.state.tpl = this.$self.templates.submenu;\n    },\n\n    onClick: function(ev) {\n        this.trigger(\"click\", this, ev);\n    }\n}, {\n\n    supportsDirectives: {\n        show: true,\n        hide: true,\n        class: true,\n        style: true,\n        click: true, \n        dblclick: true, \n        mousedown: true, \n        mouseup: true,\n        mousemove: true,\n        dropdown: true\n    },\n\n    propsToItems: {\n        \"menu\": \"MetaphorJs.ui.menu.Menu\"\n    },\n\n    templates: {\n        item: \"ui/menu/item.html\",\n        container: \"ui/menu/container.html\",\n        submenu: \"ui/menu/item-with-sub.html\"\n    },  \n\n    configProps: [\"text\", \"active\"],\n\n    dropdownClasses: [\"MetaphorJs.ui.menu.Menu\"],\n    defaultDropdown: {\n        on: \"mouseover\"\n    }\n\n});","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"./Item.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    ns = require(\"metaphorjs-namespace/src/var/ns.js\");\n\nmodule.exports = MetaphorJs.ui.menu.Menu = MetaphorJs.app.Container.$extend({\n    $class: \"MetaphorJs.ui.menu.Menu\",\n    $alias: \"MetaphorJs.directive.component.ui-menu\",\n    template: \"ui/menu/menu.html\",\n\n    _initObjectItem: function(def) {\n        if (def.__containerItemDef) {\n            return def;\n        }\n        !def.state && (def.state = this.state.$new());\n        var itemCls = this.$self.classes.item;\n        typeof itemCls === \"string\" && (itemCls = ns.get(itemCls));\n        return itemCls.createFromPlainObject(def);\n    },\n\n    _initStringItem: function(def) {\n        if (def === '-' || def === '|') {\n            return this.$self.classes.divider;\n        }\n        return this.$super(def);\n    }\n}, {\n\n    supportsDirectives: {\n        show: true,\n        hide: true,\n        class: true,\n        style: true\n    },\n\n    allowUnwrapped: [\"MetaphorJs.ui.menu.Item\", \"MetaphorJs.ui.menu.Divider\"],\n    wrapper: \"MetaphorJs.ui.menu.Item\",\n\n    classes: {\n        item: \"MetaphorJs.ui.menu.Item\",\n        divider: \"MetaphorJs.ui.menu.Divider\"\n    }\n\n});\n","\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.mixin.Selectable = {\n\n    $beforeInit: function() {\n        this.$$selection = [];\n        this.$$_selectable_itemCache = {};\n    },\n\n    $initConfig: function() {\n        this.config.setType(\"selectionMode\", \n            null, MetaphorJs.lib.Config.MODE_STATIC, \"single\");\n    },\n\n    $beforeDestroy: function() {\n        this.$$_selectable_itemCache = null;\n    },\n\n    $$_selectable_getItemId: function(item) {\n        if (this.store) {\n            return this.store.getRecordId(item);\n        }\n        return item.id;\n    },\n\n    getSelection: function(index) {\n        var self = this,\n            store = self.store,\n            sels = self.$$selection,\n            items = [],\n            i, l, id;\n\n        for (i = 0, l = sels.length; i < l; i++) {\n            id = sels[i];\n            items.push(store.getById(id) || self.$$_selectable_itemCache[id]);\n        }\n        \n        return index !== undefined ? items[index] : items;\n    },\n\n    toggleItemSelected: function(item) {\n        var self = this;\n        if (self.isSelected(item)) {\n            self.unselectItem(item);\n        }\n        else {\n            self.selectItem(item);\n        }\n    },\n\n    selectItem: function(item) {\n        var self = this;\n        self.selectItemById(self.$$_selectable_getItemId(item));\n    },\n\n    selectItemById: function(id) {\n\n        var self = this;\n        if (!self.isSelectionEnabled()) {\n            return;\n        }\n\n        if (self.$$selection.indexOf(id) === -1) {\n\n            if (!self.isMultiSelection()) {\n                self.$$selection = [];\n                self.$$_selectable_itemCache = {};\n            }\n\n            var item = self.store.getById(id);\n\n            if (item) {\n                self.$$selection.push(id);\n                self.$$_selectable_itemCache[id] = item;\n                self.trigger(\"selection-change\");\n                self.onSelectionChange();\n            }\n        }\n    },\n\n    unselectItem: function(item) {\n        this.unselectItemById(this.$$_selectable_getItemId(item));\n    },\n\n    unselectItemById: function(id) {\n        var self = this,\n            inx = self.$$selection.indexOf(id);\n        if (!self.isSelectionEnabled()) {\n            return;\n        }\n        if (inx !== -1) {\n            self.$$selection.splice(inx, 1);\n            delete self.$$_selectable_itemCache[id];\n            self.trigger(\"selection-change\");\n            self.onSelectionChange();\n        }\n    },\n\n    toggleAllSelected: function() {\n        var self = this;\n        if (!self.isAllSelected()) {\n            self.selectAll();\n        }\n        else {\n            self.unselectAll();\n        }\n    },\n\n    selectAll: function() {\n        var self = this,\n            changed = !self.isAllSelected();\n\n        if (!self.isSelectionEnabled()) {\n            return;\n        }\n\n        if (self.config.get(\"selectionMode\") !== \"single\") {\n            self.$$selection = [];\n            self.$$_selectable_itemCache = {};\n            self.store.each(function(item){\n                var id = self.$$_selectable_getItemId(item);\n                self.$$selection.push(id);\n                self.$$_selectable_itemCache[id] = item;\n            });\n        }\n\n        if (changed) {\n            self.trigger(\"selection-change\");\n            self.onSelectionChange();\n        }\n    },\n\n    unselectAll: function() {\n        var self = this;\n        if (!self.isSelectionEnabled()) {\n            return;\n        }\n        if (self.$$selection.length > 0) {\n            self.$$selection = [];\n            self.$$_selectable_itemCache = {};\n            self.trigger(\"selection-change\");\n            self.onSelectionChange();\n        }\n    },\n\n    isIdSelected: function(id) {\n        return this.$$selection.indexOf(id) !== -1;\n    },\n\n    isSelected: function(item) {\n        return this.isIdSelected(this.$$_selectable_getItemId(item));\n    },\n\n    isSelectionEnabled: function() {\n        return true;\n    },\n\n    isMultiSelection: function() {\n        return this.config.get(\"selectionMode\") === \"multi\";\n    },\n\n    isAllSelected: function() {\n        return this.$$selection.length > 0 &&\n            this.$$selection.length === this.store.getLength();\n    },\n\n    hasSelection: function() {\n        return this.$$selection.length > 0;\n    },\n\n    onSelectionChange: function() {\n\n    }\n\n};","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.mixin.WithActiveState = {\n\n    $initConfig: function() {\n        this.config.setType(\"active\", \"bool\", null, false);\n        this.config.makeLocalDynamic(\"active\", \"this.active\");\n    },  \n\n    isActive: function() {\n        return this.config.get(\"active\");\n    },\n\n    setActive: function(state) {\n        state !== false && (state = true);\n        var prev = this.config.get(\"active\");\n        this.config.set(\"active\", state);\n        if (prev != state) {\n            this.trigger(\"active-state-change\", this, state, prev);\n        }\n    },\n\n    toggleActive: function() {\n        this.setActive(!this.config.get(\"active\"));\n    }\n}","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.mixin.WithDisabledState = {\n\n    $initConfig: function() {\n        this.config.setType(\"disabled\", \"bool\", null, false);\n        this.config.makeLocalDynamic(\"disabled\", \"this.disabled\");\n    },  \n\n    isDisabled: function() {\n        return this.config.get(\"disabled\");\n    },\n\n    setDisabled: function(state) {\n        state !== false && (state = true);\n        var prev = this.config.get(\"disabled\");\n        this.config.set(\"disabled\", state);\n        if (prev != state) {\n            this.trigger(\"disabled-state-change\", this, state, prev);\n        }\n    },\n\n    toggleDisabled: function() {\n        this.setDisabled(!this.config.get(\"disabled\"));\n    }\n}","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\");\n\nmodule.exports = MetaphorJs.ui.mixin.WithDropdown = {\n\n    $beforeInit: function() {\n        this.$$dropdowns = [];\n    },\n\n    $beforeDestroy: function() {\n        this.$$dropdowns = null;\n    },\n\n    $initChildItem: function(item) {\n        this._checkDropdownItem(item);\n    },\n\n    hasDropdown: function() {\n        return this.$$dropdowns.length > 0;\n    },\n\n    _checkDropdownItem: function(item) {\n        var clss = this.$self.dropdownClasses,\n            i, l;\n        if (clss && item.type === \"component\" && item.resolved) {\n            for (i = 0, l = clss.length; i < l; i++) {\n                if (item.component.$is(clss[i])) {\n                    this._initDropdownItem(item);\n                    return;\n                }\n            }\n        }\n    },\n\n    _initDropdownItem: function(item) {\n        var self = this,\n            dd = extend({}, self.$self.defaultDropdown);\n        dd.cmp = {value: item.component};\n        self.$$dropdowns.push(item.component);\n        self.applyDirective(\"dropdown\", dd);\n        self._onDropdownCreated(item.component);\n    },\n\n    _onDropdownCreated: function() {}\n}","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.mixin.WithLoadingState = {\n\n    $initConfig: function() {\n        this.config.setType(\"loading\", \"bool\", null, false);\n        this.config.makeLocalDynamic(\"loading\", \"this.loading\");\n    },  \n\n    isLoading: function() {\n        return this.config.get(\"loading\");\n    },\n\n    setLoading: function(state) {\n        state !== false && (state = true);\n        var prev = this.config.get(\"loading\");\n        this.config.set(\"loading\", state);\n        if (prev != state) {\n            this.trigger(\"loading-state-change\", this, state, prev);\n        }\n    },\n\n    toggleLoading: function() {\n        this.setLoading(!this.config.get(\"loading\"));\n    }\n}","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.mixin.WithText = {\n\n    $initConfig: function() {\n        this.config.setType(\"text\", \"string\", MetaphorJs.lib.Config.MODE_STATIC);\n        this.config.setProperty(\"text\", \"defaultValue\", \"\", false);\n        this.config.makeLocalDynamic(\"text\", \"this.text\");\n    },  \n\n    getText: function() {\n        return this.config.get(\"text\");\n    },\n\n    setText: function(text) {\n        this.config.set(\"text\", text);\n    }\n}","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.panel.Panel = MetaphorJs.app.Container.$extend({\n    $class: \"MetaphorJs.ui.panel.Panel\",\n    $alias: \"MetaphorJs.directive.component.ui-panel\",\n    template: \"ui/panel/panel.html\"\n}, {\n    supportsDirectives: {\n        show: true,\n        hide: true,\n        class: true,\n        style: true\n    }\n});\n","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"../menu/Divider.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.toolbar.Divider = MetaphorJs.ui.menu.Divider.$extend({\n    $class: \"MetaphorJs.ui.toolbar.Divider\",\n    $alias: \"MetaphorJs.directive.component.ui-toolbar-divider\",\n    template: \"ui/toolbar/divider.html\"\n});","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"../menu/Item.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.toolbar.Item = MetaphorJs.ui.menu.Item.$extend({\n    $class: \"MetaphorJs.ui.toolbar.Item\",\n    $alias: \"MetaphorJs.directive.component.ui-toolbar-item\"\n\n}, {\n\n    templates: {\n        item: \"ui/toolbar/item.html\",\n        container: \"ui/toolbar/container.html\",\n        submenu: \"ui/toolbar/item-with-sub.html\",\n        divider: \"ui/toolbar/divider.html\"\n    },\n\n    dropdownClasses: [\"MetaphorJs.ui.menu.Menu\"],\n    configProps: [\"text\"]\n\n});","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"../menu/Menu.js\");\nrequire(\"./Item.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.menu.Toolbar = MetaphorJs.ui.menu.Menu.$extend({\n    $class: \"MetaphorJs.ui.menu.Toolbar\",\n    $alias: \"MetaphorJs.directive.component.ui-toolbar\",\n    template: \"ui/toolbar/toolbar.html\"\n\n}, {\n    allowUnwrapped: [\"MetaphorJs.ui.toolbar.Item\", \n                        \"MetaphorJs.ui.menu.Menu\", \n                        \"MetaphorJs.ui.toolbar.Divider\"],\n    wrapper: \"MetaphorJs.ui.toolbar.Item\",\n    classes: {\n        item: \"MetaphorJs.ui.toolbar.Item\",\n        divider: \"MetaphorJs.ui.toolbar.Divider\"\n    }\n});\n","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Component.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"metaphorjs-shared/src/lib/Queue.js\");\nrequire(\"metaphorjs-shared/src/lib/Color.js\");\nrequire(\"metaphorjs/src/func/dom/getInnerWidth.js\");\nrequire(\"metaphorjs/src/func/dom/getInnerHeight.js\");\nrequire(\"metaphorjs/src/func/dom/whenAttached.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\");\n\nmodule.exports = MetaphorJs.ui.util.Canvas = MetaphorJs.app.Component.$extend({\n    $class: \"MetaphorJs.ui.util.Canvas\",\n    $alias: \"MetaphorJs.directive.component.ui-canvas\",\n    template: \"ui/util/canvas.html\",\n    as: \"cnv\",\n\n    _renderQueue: null,\n    _currentSize: null,\n    _sizePromise: null,\n    _sizeInterval: null,\n\n    initConfig: function() {\n        this.$super();\n        var config = this.config,\n            mst = MetaphorJs.lib.Config.MODE_STATIC;\n\n        config.setType(\"width\", \"int\", mst);\n        config.setType(\"height\", \"int\", mst);  \n    },\n\n    initComponent: function() {\n\n        var self = this;\n\n        self._sizeDelegate = bind(self.getSize, self);\n        self._sizePromise = new MetaphorJs.lib.Promise;\n        self._renderQueue = new MetaphorJs.lib.Queue({\n            async: \"raf\",\n            auto: true,\n            mode: MetaphorJs.lib.Queue.REPLACE,\n            context: self\n        });\n    },\n\n    queueAction: function(fn) {\n        var self = this;\n        self.getSizePromise().done(function(){\n            self._renderQueue.add(fn);\n        });\n    },\n\n    _onCfgWidthChange: function() {\n        this._currentSize = null;\n        this.queueAction(this.renderCanvas);\n    },\n\n    _onCfgHeightChange: function() {\n        this._currentSize = null;\n        this.queueAction(this.renderCanvas);\n    },\n\n    afterAttached: function() {\n        var self = this,\n            canvas = this.getRefEl(\"canvas\");\n\n        MetaphorJs.dom.whenAttached(canvas)\n            .done(function() {\n                self.queueAction(self.renderCanvas);\n            });\n\n        this.config.on(\"width\", this._onCfgWidthChange, this);\n        this.config.on(\"height\", this._onCfgHeightChange, this);\n    },\n\n\n    /**Sizing */\n\n\n    getCtx: function() {\n        if (!this._ctx) {\n            var canvas = this.getRefEl(\"canvas\");\n            this._ctx = canvas.getContext('2d');\n        }\n        return this._ctx;\n    },\n\n    getSize: function() {\n\n        var canvas = this.getRefEl(\"canvas\");\n\n        if (!this._currentSize) {\n            var config = this.config;\n\n            var w = config.has(\"width\"),\n                h = config.has(\"height\"),\n                main = this.getRefEl(\"main\");\n\n            if (!w) {\n                if (main) {\n                    w = main.style.width ? \n                            parseInt(main.style.width) :\n                            parseInt(MetaphorJs.dom.getInnerWidth(main));\n                    w && config.setDefaultValue(\"width\", w);\n                }\n            }\n            if (!h) {\n                if (main) {\n                    h = main.style.height ?\n                            parseInt(main.style.height) :\n                            parseInt(MetaphorJs.dom.getInnerHeight(main));\n                    h && config.setDefaultValue(\"height\", h);\n                }\n            }\n\n            w = config.get(\"width\");\n            h = config.get(\"height\");\n\n            if (w > 0 && h > 0) { \n                this._currentSize = {width: w, height: h};\n                if (this._sizeInterval) {\n                    window.clearInterval(this._sizeInterval);\n                    this._sizeInterval = null;\n                }\n            }\n            else {\n                if (!this._sizeInterval) {\n                    this._sizeInterval = window.setInterval(this._sizeDelegate, 50);\n                }\n            }\n        }\n\n        if (canvas && this._currentSize) {\n            if (canvas.width != this._currentSize.width || \n                canvas.height != this._currentSize.height) {\n                canvas.width = this._currentSize.width;\n                canvas.height = this._currentSize.height;\n                canvas.setAttribute(\"width\", this._currentSize.width);\n                canvas.setAttribute(\"height\", this._currentSize.height);\n            }\n            if (this._sizePromise && this._sizePromise.isPending()) {\n                // delay rendering\n                this._sizePromise.after(new MetaphorJs.lib.Promise(function(resolve){\n                    window.setTimeout(resolve, 100);\n                }));\n            }\n        }\n\n        if (this._currentSize && this._sizePromise.isPending()) {\n            this._sizePromise.resolve(this._currentSize);\n        }\n\n        return this._currentSize;\n    },\n    \n    getSizePromise: function() {\n        this.getSize();\n        return this._sizePromise;\n    },\n\n    getCanvasWidth: function() {\n        return this.getSize().width;\n    },\n\n    getCanvasHeight: function() {\n        return this.getSize().height;\n    },\n\n\n    /**Rendering */\n\n    renderCanvas: function() {},\n\n\n    onDestroy: function() {\n        this._renderQueue.$destroy();\n        this._sizePromise.$destroy();\n        this.$super();\n    }\n}, {\n    supportsDirectives: {\n        show: true,\n        hide: true,\n        class: true,\n        style: true,\n        click: true, \n        dblclick: true, \n        mousedown: true, \n        mouseup: true,\n        mousemove: true\n    }\n});","require(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Component.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"metaphorjs-shared/src/lib/Queue.js\");\nrequire(\"./Canvas.js\");\nrequire(\"metaphorjs-shared/src/lib/Color.js\");\nrequire(\"metaphorjs/src/func/dom/addListener.js\");\nrequire(\"metaphorjs/src/func/dom/removeListener.js\");\nrequire(\"metaphorjs/src/func/dom/getOffset.js\");\nrequire(\"metaphorjs/src/func/dom/getScrollTop.js\");\nrequire(\"metaphorjs/src/func/dom/getScrollLeft.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    emptyFn = require(\"metaphorjs-shared/src/func/emptyFn.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\");\n\nmodule.exports = MetaphorJs.ui.util.Color = MetaphorJs.ui.util.Canvas.$extend({\n    $class: \"MetaphorJs.ui.util.Color\",\n    template: \"ui/util/color.html\",\n\n    _apis: [\"dom\", \"input\"],\n    _lastX: 0,\n    _lastY: 0,\n\n    initComponent: function() {\n        var self = this;\n        self.$super();\n        self.state.pointerLeft = null;\n        self.state.pointerTop = null;\n        self._mouseDownDelegate = bind(self.onMouseDown, self);\n        self._mouseUpDelegate = bind(self.onMouseUp, self);\n        self._mouseMoveDelegate = bind(self.onMouseMove, self);\n        self._touchDownDelegate = bind(self.onTouchDown, self);\n        self._touchUpDelegate = bind(self.onTouchUp, self);\n        self._touchMoveDelegate = bind(self.onTouchMove, self);\n    },\n\n    isDragging: function() {\n        return this._drag;\n    },\n\n    afterAttached: function() {\n        var self = this;\n        self.$super();\n        self.queueAction(self.updatePointer);\n\n        var el = self.getRefEl(\"main\");\n        MetaphorJs.dom.addListener(el, \"mousedown\", self._mouseDownDelegate);\n        MetaphorJs.dom.addListener(el, \"touchstart\", self._touchDownDelegate, {\n            passive: false\n        });\n    },\n\n\n    renderCanvas: function(){},\n    updateColor: function(){},\n    updatePointer: function(){},\n\n\n    /**Mouse handling */\n\n    updateCoords: function(e) {\n        \n        var size = this.getSize(),\n            evt = e.type.indexOf(\"touch\") !== -1 ? e.changedTouches[0] : e,\n            clientX = evt.clientX,\n            clientY = evt.clientY,\n            ofs = MetaphorJs.dom.getOffset(this.getRefEl(\"main\")),\n            st = MetaphorJs.dom.getScrollTop(),\n            sl = MetaphorJs.dom.getScrollLeft(),\n            x = clientX + sl - ofs.left,\n            y = clientY + st - ofs.top;\n\n        x < 0 && (x = 0);\n        y < 0 && (y = 0);\n        x > size.width && (x = size.width);\n        y > size.height && (y = size.height);\n\n        this._lastX = x;\n        this._lastY = y;\n    },\n\n    onTouchDown: function(e) {\n        e.preventDefault();\n        var b = window.document.body;\n\n        MetaphorJs.dom.addListener(b, \"touchend\", this._touchUpDelegate, {\n            passive: false\n        });\n        MetaphorJs.dom.addListener(b, \"touchmove\", this._touchMoveDelegate, {\n            passive: false\n        });\n\n        this._drag = true;\n        this.updateCoords(e);\n        this.updateColor(); \n        this.updatePointer();\n    },\n\n    onTouchMove: function(e) {\n        e.preventDefault();\n        this.onMouseMove(e);\n    },\n\n    onTouchUp: function(e) {\n        e.preventDefault();\n        var b = window.document.body;\n        MetaphorJs.dom.removeListener(b, \"touchend\", this._touchUpDelegate);\n        MetaphorJs.dom.removeListener(b, \"touchmove\", this._touchMoveDelegate);\n        this.state.$check();\n        this._drag = false;\n    },\n\n    onMouseDown: function(e) {\n        var b = window.document.body;\n\n        MetaphorJs.dom.addListener(b, \"mouseup\", this._mouseUpDelegate);\n        MetaphorJs.dom.addListener(b, \"mousemove\", this._mouseMoveDelegate);\n\n        this._drag = true;\n        this.updateCoords(e);\n        this.updateColor(); \n        this.updatePointer();\n    },\n\n    onMouseMove: function(e) {\n        if (this._drag) {\n            this.updateCoords(e);\n            this.updateColor();        \n            this.updatePointer();\n            this.state.$check();\n        }\n    },\n\n    onMouseUp: function(e) {\n        var b = window.document.body;\n        MetaphorJs.dom.removeListener(b, \"mouseup\", this._mouseUpDelegate);\n        MetaphorJs.dom.removeListener(b, \"mousemove\", this._mouseMoveDelegate);\n        this.state.$check();\n        this._drag = false;\n    },\n\n\n    /* Input API */\n    setValue: emptyFn,\n    getValue: emptyFn,\n    onKey: emptyFn,\n    unKey: emptyFn,\n    onChange: function(fn, ctx, opt) {\n        return this.on(\"change\", fn, ctx, opt);\n    },\n    unChange: function(fn, ctx) {\n        return this.un(\"change\", fn, ctx);\n    },\n    getInputApi: function() {\n        return this;\n    }\n}, {\n    supportsDirectives: {\n        show: true,\n        hide: true,\n\n        class: true,\n        style: true,\n\n        bind: true,\n        model: true,\n        input: true,\n\n        click: true, \n        dblclick: true, \n        mousedown: true, \n        mouseup: true,\n        mousemove: true,\n        mouseover: true,\n        mouseout: true\n    }\n});","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"./Color.js\");\nrequire(\"metaphorjs-shared/src/lib/Color.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.util.ColorAlpha = MetaphorJs.ui.util.Color.$extend({\n    $class: \"MetaphorJs.ui.util.ColorAlpha\",\n    $alias: \"MetaphorJs.directive.component.ui-color-alpha\",\n\n    _apis: [\"dom\", \"input\"],\n    _color: null,\n    _alpha: null,\n    _lastX: 0,\n    _lastY: 0,\n\n    initConfig: function() {\n        this.$super();\n\n        var self = this,\n            config = self.config,\n            mst = MetaphorJs.lib.Config.MODE_STATIC;\n\n        config.setType(\"position\", \"string\", mst, \"v\");\n        config.setType(\"cursor\", \"string\", mst);\n        config.setType(\"alpha\", \"float\", null, 1);\n        config.setDefaultValue(\"color\", \"hsva(0,100,100,1)\")\n        config.on(\"alpha\", self.setValue, self);\n        config.on(\"color\", self.setColor, self);\n        config.on(\"hue\", self.setHue, self);\n    },\n\n    initComponent: function() {\n        this.$super();\n        this._color = new MetaphorJs.lib.Color(null, \"hsva\");\n        this._color.setColor(this.config.get(\"color\"));\n        if (this.config.has(\"alpha\")) {\n            this._alpha = this.config.get(\"alpha\");\n            this._color.setAlpha(this._alpha);\n        }\n        else this._alpha = this._color.getAlpha();\n    },\n\n    setColor: function(color) {\n        this._color.setColor(color);\n        if (this._attached) {\n            this.queueAction(this.renderCanvas);\n        }\n    },\n\n    setHue: function(hue) {\n        this._color.setHSVA(hue);\n        if (this._attached) {\n            this.queueAction(this.renderCanvas);\n        }\n    },\n\n    setValue: function(alpha) {\n        alpha = parseFloat(alpha);\n        alpha < 0 && (alpha = 0);\n        alpha > 1 && (alpha = 1);\n        var prev = this._alpha;\n        this._alpha = alpha;\n    \n        if (alpha != prev) {\n            if (this._attached) {\n                this.queueAction(this.updatePointer);\n            }\n            this.trigger(\"change\", alpha, prev);\n        }\n    },\n\n\n    /**Rendering */\n\n    renderCanvas: function() {\n\n        var self = this,\n            ctx = self.getCtx(),\n            size = self.getSize(),\n            pos = self.config.get(\"position\"),\n            c = new MetaphorJs.lib.Color(this._color),\n            grd;\n\n        c.setAlpha(1);\n        ctx.clearRect(0, 0, size.width, size.height);\n        ctx.rect(0, 0, size.width, size.height);\n\n        if (pos === \"v\") {\n            grd = ctx.createLinearGradient(0, 0, 0, size.height);\n        }\n        else {\n            grd = ctx.createLinearGradient(0, 0, size.width, 0);\n        }\n\n        grd.addColorStop(0, c.getRGBAString());\n        c.setAlpha(0);\n        grd.addColorStop(1, c.getRGBAString());\n        ctx.fillStyle = grd;\n        ctx.fill();\n    },\n\n\n    /** Color */\n\n    _getIntValue: function() {\n        var pos = this.config.get(\"position\"),\n            size = this.getSize()[pos === \"v\" ? \"height\" : \"width\"],\n            mouse = this[pos === \"v\" ? \"_lastY\" : \"_lastX\"];\n        return 1 - (mouse / size);\n    },\n\n    updateColor: function() {\n        this.setValue(this._getIntValue());\n    },\n\n    updatePointer: function() {\n        var mouse,\n            pos = this.config.get(\"position\"),\n            size = this.getSize(),\n            skey = pos === 'v' ? 'height' : 'width',\n            pkeyPrim = pos === 'v' ? 'pointerTop' : 'pointerLeft',\n            pkeySec = pos === 'v' ? 'pointerLeft' : 'pointerTop',\n            ckey = pos === 'v' ? '_lastY' : '_lastX';\n\n        // follow mouse\n        if (this._drag) {\n            mouse = this[ckey];\n        }   \n        // reflect current value\n        else {\n            mouse = (1 - this._alpha) * size[skey];\n        }\n\n        mouse < 0 && (mouse = 0);\n        mouse > size[skey] && (mouse = size[skey]);\n\n        this.state[pkeySec] = \"50%\";\n        this.state[pkeyPrim] = parseInt(mouse) + \"px\";\n\n        // if pointer is updated via renderQueue\n        if (!this._drag) {\n            this.state.$check();\n        }\n    }\n}, {\n    supportsDirectives: {\n        show: true,\n        hide: true,\n\n        class: true,\n        style: true,\n\n        bind: true,\n        model: true,\n        input: true,\n\n        click: true, \n        dblclick: true, \n        mousedown: true, \n        mouseup: true,\n        mousemove: true,\n        mouseover: true,\n        mouseout: true\n    }\n});","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"./Color.js\");\nrequire(\"metaphorjs-shared/src/lib/Color.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.util.ColorHue = MetaphorJs.ui.util.Color.$extend({\n    $class: \"MetaphorJs.ui.util.ColorHue\",\n    $alias: \"MetaphorJs.directive.component.ui-color-hue\",\n\n    _apis: [\"dom\", \"input\"],\n    _hue: 0,\n    _lastX: 0,\n    _lastY: 0,\n\n    initConfig: function() {\n        this.$super();\n\n        var config = this.config,\n            mst = MetaphorJs.lib.Config.MODE_STATIC;\n\n        config.setType(\"position\", \"string\", mst, \"v\");\n        config.setType(\"cursor\", \"string\", mst);\n        config.setType(\"hue\", \"float\", null, 0);\n        config.on(\"hue\", this.setValue, this);\n    },\n\n    initComponent: function() {\n        this.$super();\n\n        if (this.config.has(\"hue\")) {\n            this._hue = this.config.get(\"hue\");\n        }\n    },\n\n    setValue: function(hue) {\n        hue = parseFloat(hue);\n        hue < 0 && (hue = 0);\n        hue > 360 && (hue = 360);\n        var prev = this._hue;\n        this._hue = hue;\n        if (this._attached) {\n            this.queueAction(this.updatePointer);\n        }\n        if (hue !== prev) {\n            this.trigger(\"change\", hue, prev);\n        }\n    },\n\n\n    /**Rendering */\n\n    renderCanvas: function() {\n        var self = this,\n            ctx = self.getCtx(),\n            size = self.getSize(),\n            pos = self.config.get(\"position\"),\n            grd;\n        \n        ctx.clearRect(0, 0, size.width, size.height);\n        ctx.rect(0, 0, size.width, size.height);\n\n        if (pos === \"v\") {\n            grd = ctx.createLinearGradient(0, 0, 0, size.height);\n        }\n        else {\n            grd = ctx.createLinearGradient(0, 0, size.width, 0);\n        }\n        grd.addColorStop(0, 'rgba(255, 0, 0, 1)');\n        grd.addColorStop(0.17, 'rgba(255, 255, 0, 1)');\n        grd.addColorStop(0.34, 'rgba(0, 255, 0, 1)');\n        grd.addColorStop(0.51, 'rgba(0, 255, 255, 1)');\n        grd.addColorStop(0.68, 'rgba(0, 0, 255, 1)');\n        grd.addColorStop(0.85, 'rgba(255, 0, 255, 1)');\n        grd.addColorStop(1, 'rgba(255, 0, 0, 1)');\n        ctx.fillStyle = grd;\n        ctx.fill();\n    },\n\n\n    /** Color */\n\n    _getIntValue: function() {\n        var pos = this.config.get(\"position\"),\n            size = this.getSize()[pos === \"v\" ? \"height\" : \"width\"],\n            mouse = this[pos === \"v\" ? \"_lastY\" : \"_lastX\"];\n        return (mouse / size) * 360;\n    },\n\n    updateColor: function() {\n        this.setValue(this._getIntValue());\n    },\n\n    updatePointer: function() {\n        var mouse,\n            pos = this.config.get(\"position\"),\n            size = this.getSize(),\n            skey = pos === 'v' ? 'height' : 'width',\n            pkeyPrim = pos === 'v' ? 'pointerTop' : 'pointerLeft',\n            pkeySec = pos === 'v' ? 'pointerLeft' : 'pointerTop',\n            ckey = pos === 'v' ? '_lastY' : '_lastX';\n\n        // follow mouse\n        if (this._drag) {\n            mouse = this[ckey];\n        }   \n        // reflect current value\n        else {\n            mouse = (this._hue / 360) * size[skey];\n        }\n\n        mouse < 0 && (mouse = 0);\n        mouse > size[skey] && (mouse = size[skey]);\n\n        this.state[pkeySec] = \"50%\";\n        this.state[pkeyPrim] = parseInt(mouse) + \"px\";\n\n        // if pointer is updated via renderQueue\n        if (!this._drag) {\n            this.state.$check();\n        }\n    }\n}, {\n    supportsDirectives: {\n        show: true,\n        hide: true,\n\n        class: true,\n        style: true,\n\n        bind: true,\n        model: true,\n        input: true,\n\n        click: true, \n        dblclick: true, \n        mousedown: true, \n        mouseup: true,\n        mousemove: true,\n        mouseover: true,\n        mouseout: true\n    }\n});","require(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nrequire(\"metaphorjs-shared/src/lib/Color.js\");\nrequire(\"../../filter/color.js\");\nrequire(\"./ColorSV.js\");\nrequire(\"./ColorHue.js\");\nrequire(\"./ColorAlpha.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    emptyFn = require(\"metaphorjs-shared/src/func/emptyFn.js\");\n\nmodule.exports = MetaphorJs.ui.util.ColorPicker = MetaphorJs.app.Container.$extend({\n    $class: \"MetaphorJs.ui.util.ColorPicker\",\n    $alias: \"MetaphorJs.directive.component.ui-color-picker\",\n    template: \"ui/util/color-picker.html\",\n    as: \"pckr\",\n\n    _apis: [\"node\", \"input\"],\n    _updating: false,\n    _color: null,\n    _prev: null,\n\n    initComponent: function() {\n        this.$super();\n        this._color = this.state.color = new MetaphorJs.lib.Color(null, \"hsva\");\n        this._color.setColor(this.config.get(\"color\"));\n        this._prev = this._color.getHSVAString();\n    },\n\n    initConfig: function() {\n        this.$super();\n        this.config.setType(\"color\", null, null, \"hsva(0,100,100,1)\")\n    },\n\n    afterRender: function(){\n        this._updateCanvas();\n    },\n\n    _frame: function(val, min, max) {\n        val = parseFloat(val);\n        val < min && (val = min);\n        val > max && (val = max);\n        return val;\n    },\n\n    _updateCanvas: function() {\n        this._updating = true;\n\n        var sv = this.getRefCmp(\"sv\"),\n            hue = this.getRefCmp(\"hue\"),\n            alpha = this.getRefCmp(\"alpha\"),\n            c = this._color;\n\n        sv && sv.setValue(c);\n        hue && hue.setValue(c.getH());\n        alpha && alpha.setValue(c.getAlpha());\n\n        this.state.$check();\n        this._updating = false;\n    },\n\n\n    onInputHex: function(hex) {\n        hex = (\"\"+hex).toLowerCase().trim();\n        if (hex.substring(0,1) === \"#\") {\n            hex = hex.substring(1);\n        }\n        if (hex === this._color.getHEX()) {\n            return;\n        }\n        var c = new MetaphorJs.lib.Color(hex);\n        if (c.getHEX() === hex) {\n            this._color.setColor(hex);\n            this._updateCanvas();\n            this._onChange();\n        }\n    },\n\n    onInputRgba: function(rgbaStr) {\n        rgbaStr = (\"\"+rgbaStr).toLowerCase().trim();\n        rgbaStr = rgbaStr.replace(/\\s+/g, '');\n        this._color.setColor(rgbaStr);\n        this._updateCanvas();\n        this._onChange();\n    },\n\n    _onInputRGBA: function(r,g,b,a) {\n        this._color.setRGBA(r,g,b,a);\n        this._updateCanvas();\n        this._onChange();\n    },\n\n    onInputR: function(r) {\n        this._onInputRGBA(this._frame(r, 0, 255));\n    },\n    onInputG: function(g) {\n        this._onInputRGBA(null, this._frame(g, 0, 255));\n    },\n    onInputB: function(b) {\n        this._onInputRGBA(null, null, this._frame(b, 0, 255));\n    },\n    onInputA: function(a) {\n        this._onInputRGBA(null, null, null, this._frame(a, 0, 1));\n    },\n\n\n    _onInputHSV: function(h,s,v) {\n        this._color.setHSVA(h,s,v);\n        this._updateCanvas();\n        this._onChange();\n    },\n\n    onInputH: function(h) {\n        this._onInputHSV(this._frame(h, 0, 360));\n    },\n    onInputS: function(s) {\n        this._onInputHSV(null, this._frame(s, 0, 100));\n    },\n    onInputV: function(v) {\n        this._onInputHSV(null, null, this._frame(v, 0, 100));\n    },\n    \n\n\n    onInputSV: function(sv) {\n        if (this.getRefCmp(\"sv\").isDragging()) {\n            this._color.setHSVA(null, sv[0], sv[1]);\n            this._onChange();\n        }\n    },\n    onInputHue: function(hue) {\n        if (this.getRefCmp(\"hue\").isDragging()) {\n            this._color.setHSVA(hue);\n            this._onChange();\n        }\n    },\n    onInputAlpha: function(a) {\n        if (this.getRefCmp(\"alpha\").isDragging()) {\n            this._color.setAlpha(a);\n            this._onChange();\n        }\n    },\n\n\n    _onChange: function() {\n        var val = this._color.getRGBAString(),\n            prev = this._prev;\n        if (prev !== val) {\n            this._prev = val;\n            this.trigger(\"change\", val, prev, this._color, this);\n        }\n    },\n\n\n    /* Input API */\n    setValue: function(color) {\n        this._color.setColor(color);\n        this._onChange();\n        this.state.$check();\n        this._updateCanvas();\n    },\n    getValue: function() {\n        return this._color;\n    },\n    onKey: emptyFn,\n    unKey: emptyFn,\n    onChange: function(fn, ctx, opt) {\n        return this.on(\"change\", fn, ctx, opt);\n    },\n    unChange: function(fn, ctx) {\n        return this.un(\"change\", fn, ctx);\n    },\n\n    getInputApi: function() {\n        return this;\n    }\n}, {\n    supportsDirectives: {\n        show: true,\n        hide: true,\n\n        class: true,\n        style: true,\n\n        bind: true,\n        model: true,\n\n        click: true, \n        dblclick: true, \n        mousedown: true, \n        mouseup: true,\n        mousemove: true,\n        mouseover: true,\n        mouseout: true\n    }\n});","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"./Color.js\");\nrequire(\"metaphorjs-shared/src/lib/Color.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.util.ColorSV = MetaphorJs.ui.util.Color.$extend({\n    $class: \"MetaphorJs.ui.util.ColorSV\",\n    $alias: \"MetaphorJs.directive.component.ui-color-sv\",\n\n    _color: null,\n    _lastX: 0,\n    _lastY: 0,\n    _sv: null,\n    _hue: null,\n\n    initConfig: function() {\n        this.$super();\n        var config = this.config,\n            mst = MetaphorJs.lib.Config.MODE_STATIC;\n\n        config.setType(\"cursor\", \"string\", mst);\n        config.setType(\"color\", null, null, \"hsva(0,100,100,1)\");\n        config.on(\"color\", this.setColor, this);\n        config.on(\"hue\", this.setHue, this);\n    },\n\n    initComponent: function() {\n        this.$super();\n        this._color = new MetaphorJs.lib.Color(null, \"hsva\");\n        this._color.setColor(this.config.get(\"color\"));\n        this._color.setAlpha(1);\n\n        if (this.config.has(\"hue\")) {\n            this._color.setHSVA(this.config.get(\"hue\"));\n        }\n\n        this._sv = [this._color.getS(), this._color.getV()];\n        this._hue = this._color.getH();\n    },\n\n    setColor: function() {\n        var c = new MetaphorJs.lib.Color(this.config.get(\"color\"), \"hsva\");\n        this.setHue(c.getH());\n        this.setValue([c.getS(), c.getV()]);\n    },\n\n    setHue: function(hue) {\n        if (this._color.getH() !== hue) {\n            this._color.setHSVA(hue);\n            this._hue = this._color.getH();\n            if (this._attached) {\n                this.queueAction(this.renderCanvas);\n            }\n        }\n    },\n\n    setValue: function(sv) {\n\n        var prev = this._sv,\n            c = this._color;\n\n        c.setHSVA(this._hue, sv[0], sv[1]);\n\n        if (prev[0] !== c.getS() || prev[1] !== c.getV()) {\n            if (this._attached) {\n                this.queueAction(this.updatePointer);\n            }\n\n            this._sv = sv;\n            this.trigger(\"change\", sv, prev);\n        }\n    },\n\n    /**Rendering */\n\n    renderCanvas: function() {\n        var self = this,\n            ctx = self.getCtx(),\n            size = self.getSize(),\n            c = new MetaphorJs.lib.Color(null, \"hsva\");\n\n        c.setHSVA(this._color.getH(), 100, 100);\n\n        ctx.clearRect(0, 0, size.width, size.height);\n        ctx.rect(0, 0, size.width, size.height);\n        ctx.fillStyle = c.getRGBAString();\n        ctx.fillRect(0, 0, size.width, size.height);\n\n        var grdWhite = ctx.createLinearGradient(0, 0, size.width, 0);\n        grdWhite.addColorStop(0, 'rgba(255,255,255,1)');\n        grdWhite.addColorStop(1, 'rgba(255,255,255,0)');\n        ctx.fillStyle = grdWhite;\n        ctx.fillRect(0, 0, size.width, size.height);\n\n        var grdBlack = ctx.createLinearGradient(0, 0, 0, size.height);\n        grdBlack.addColorStop(0, 'rgba(0,0,0,0)');\n        grdBlack.addColorStop(1, 'rgba(0,0,0,1)');\n        ctx.fillStyle = grdBlack;\n        ctx.fillRect(0, 0, size.width, size.height);\n    },\n    \n\n    /** Color */\n\n    _getS: function() {\n        var size = this.getSize().width,\n            mouse = this._lastX;\n        return parseInt((mouse / size) * 100);\n    },\n\n    _getV: function() {\n        var size = this.getSize().height,\n            mouse = this._lastY;\n        return 100 - parseInt((mouse / size) * 100);\n    },\n\n    updateColor: function() {\n        this.setValue([this._getS(), this._getV()]);\n    },\n\n    updatePointer: function() {\n        var size = this.getSize(),\n            pleft,\n            ptop,\n            x, y,\n            hsva;\n\n        if (!size || !size.width) {\n            return;\n        }\n\n        // follow mouse\n        if (this._drag) {\n\n            x = this._lastX;\n            y = this._lastY;\n\n            x < 0 && (x = 0);\n            x > size.width && (x = size.width);\n            y < 0 && (y = 0);\n            y > size.width && (y = size.width);\n\n            x = x / size.width;\n            y = y / size.height;\n\n            pleft = parseInt(x * 100) + \"%\";\n            ptop = parseInt(y * 100) + \"%\";\n        }   \n        // reflect current value\n        else {\n            hsva = this._color.getHSVA();\n            pleft = hsva[1] + \"%\";\n            ptop = (100-hsva[2]) + \"%\";\n        }\n\n        this.state.pointerLeft = pleft;\n        this.state.pointerTop = ptop;\n\n        // if pointer is updated via renderQueue\n        if (!this._drag) {\n            this.state.$check();\n        }\n    }\n}, {\n    supportsDirectives: {\n        show: true,\n        hide: true,\n\n        class: true,\n        style: true,\n\n        bind: true,\n        model: true,\n        input: true,\n\n        click: true, \n        dblclick: true, \n        mousedown: true, \n        mouseup: true,\n        mousemove: true,\n        mouseover: true,\n        mouseout: true\n    }\n});","require(\"metaphorjs/src/lib/Config.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/func/dom/getOffset.js\");\nrequire(\"metaphorjs/src/func/dom/getScrollParent.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nmodule.exports = MetaphorJs.ui.util.Pagination = MetaphorJs.app.Container.$extend({\n    $class: \"MetaphorJs.ui.util.Pagination\",\n    $alias: \"MetaphorJs.directive.component.ui-pagination\",\n    template: \"ui/util/pagination.html\",\n\n    _apis: [\"dom\", \"input\"],\n\n    initComponent: function() {\n\n        var state = this.state;\n\n        state.start = 0;\n        state.limit = 0;\n        state.total = 0;\n        state.pages = 0;\n        state.page = 0;\n        state.hasPrev = 0;\n        state.hasNext = 0;\n        state.loading = false;\n        state.changePage = 0;\n        state.hidden = true;\n\n        var store = this.config.get(\"store\") || (\n                        this.parentCmp ? this.parentCmp.store : null\n                    );\n\n        store && this.setStore(store);\n    },\n\n    initConfig: function() {\n        var config = this.config,\n            mst = MetaphorJs.lib.Config.MODE_STATIC;\n        config.setType(\"as\", null, null, \"pgn\");\n        config.setType(\"simple\", \"bool\", mst, false);\n        config.setType(\"autoscroll\", \"bool\", mst, false);\n        config.setType(\"store\", null, MetaphorJs.lib.Config.MODE_DYNAMIC);\n        config.on(\"simple\", this.updatePages, this, {async: true});\n    },\n\n    setStore: function(s) {\n        this.store && this._bindStore(this.store, \"un\");\n        this.store = s;\n        s && this._bindStore(s, \"on\");\n        s && this.updatePages();\n    },\n\n    _bindStore: function(s, fn) {\n        s[fn](\"loading-start\", this.onStoreStartLoading, this);\n        s[fn](\"load\", this.onStoreLoad, this);\n        s[fn](\"update\", this.onStoreLoad, this);\n    },\n\n    $onPropertyChange: function(val, prev, name) {\n        if (name === \"simple\" && (val === false || val === true)) {\n            async(this.updatePages, this);\n        }\n    },\n\n    onStoreStartLoading: function() {\n        this.state.$set({\n            loading: true\n        });\n    },\n\n    onStoreLoad: function() {\n        this.updatePages();\n    },\n\n    updatePages: function() {\n        var store = this.store,\n            total,\n            count,\n            start = store.start,\n            pageSize = store.pageSize,\n            pages,\n            page;\n\n        if (!this.config.get(\"simple\")) {\n\n            total = store.getTotalLength();\n\n            if (!pageSize) {\n                pageSize = total;\n            }\n\n            pages = Math.ceil(total / pageSize);\n            page = Math.floor(start / pageSize) + 1;\n\n            this.state.$set({\n                start: start,\n                end: Math.min(start + pageSize, total),\n                limit: pageSize,\n                total: total,\n                pages: pages,\n                changePage: page,\n                page: page,\n                hasPrev: page > 1,\n                hasNext: page < pages,\n                loading: false,\n                hidden: pages < 2\n            });\n        }\n        else {\n            count = store.getLength();\n\n            this.state.$set({\n                loading: false,\n                start: start,\n                end: start + count,\n                limit: pageSize,\n                hasNext: count >= pageSize,\n                hasPrev: start > 0,\n                hidden: start === 0 && count < pageSize\n            });\n        }\n    },\n\n    onPrevClick: function() {\n        this.store.loadPrevPage();\n        this.scrollToParent();\n    },\n\n    onNextClick: function() {\n        this.store.loadNextPage();\n        this.scrollToParent();\n    },\n\n    hasPages: function() {\n        return !this.config.get(\"simple\") ?\n            this.state.pages > 1 :\n            true;\n    },\n\n    onPageKeyDown: function() {\n\n        var page = this.state.changePage;\n        if (isNaN(page)) {\n            page = 1;\n        }\n        if (page < 1) {\n            page = 1;\n        }\n        if (page > this.state.pages) {\n            page = this.state.pages;\n        }\n        this.state.$set({\n            page: page\n        });\n\n        this.store.loadPage((this.state.page - 1) * this.state.limit);\n        this.scrollToParent();\n    },\n\n    scrollToParent: function() {\n        if (this.config.get(\"autoscroll\") === false) {\n            return;\n        }\n        var sp = MetaphorJs.dom.getScrollParent(this.$refs.node.main.parentNode);\n        if (sp) {\n            if (sp === document.body) {\n                if (this.parentCmp) {\n                    var ofs = MetaphorJs.dom.getOffset(this.parentCmp.getRefEl(\"main\"));\n                    sp.scrollTop = ofs.top;\n                    document.documentElement.scrollTop = ofs.top;\n                }\n            }\n            else {\n                sp.scrollTop = 0;\n            }\n        }\n    },\n\n    onDestroy: function() {\n        this.setStore(null);\n    }\n}, {\n    resolve: {\n        parentCmp: '$parentCmp'\n    },\n    supportsDirectives: {\n        show: true,\n        hide: true,\n        class: true,\n        style: true,\n        \"in-focus\": \"input\"\n    }\n});","\nrequire(\"../../__init.js\");\nrequire(\"metaphorjs/src/app/Container.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.ui.window.Window = MetaphorJs.app.Container.$extend({\n    $class: \"MetaphorJs.ui.window.Window\",\n    template: \"ui/window/window.html\",\n\n    _initDraggable: function() {\n        \n    }\n}, {\n    supportsDirectives: {\n        show: true,\n        hide: true,\n        class: true,\n        style: true\n    }\n});\n","\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n// add namespace manually\nMetaphorJs.validator = MetaphorJs.validator || {};","\nrequire(\"metaphorjs/src/lib/Config.js\");\n\nconst Directive = require(\"metaphorjs/src/app/Directive.js\"),\n    ns = require(\"metaphorjs-namespace/src/var/ns.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nrequire(\"../validator/Component.js\");\n\nDirective.registerAttribute(\"form\", 250, function(){\n    var dir = function form_directive(state, node, config, renderer, attrSet) {\n\n        dir.initConfig(config)\n    \n        var cls     = config.get(\"value\"),\n            constr  = ns.get(cls);\n    \n        if (!constr) {\n            error(new Error(\"Class '\"+cls+\"' not found\"));\n        }\n        else {\n            Directive.resolveNode(node, \"form\", function(node) {\n                if (!renderer.$destroyed) {\n                    var v = new constr(node, state, renderer, config);\n                    renderer.on(\"destroy\", v.$destroy, v);\n                }\n            });\n        }\n    };\n\n    dir.initConfig = function(config) {\n        config.setProperty(\"value\", {\n            mode: MetaphorJs.lib.Config.MODE_STATIC,\n            type: \"string\",\n            defaultValue: \"MetaphorJs.validator.Component\"\n        });\n        config.setMode(\"submit\", MetaphorJs.lib.Config.MODE_FUNC);\n    };\n\n    dir.deepInitConfig = function(config) {\n        MetaphorJs.validator.Component.initConfig(config);\n    }\n\n    return dir;\n}());\n\n","\nrequire(\"metaphorjs/src/func/dom/data.js\");\nrequire(\"metaphorjs/src/func/dom/getAttr.js\");\nrequire(\"../validator/Validator.js\");\n\nconst Directive = require(\"metaphorjs/src/app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nDirective.registerAttribute(\"validate\", 200, function(){\n\n    var dir = function validate_directive(state, node, config, renderer) { \n\n        Directive.resolveNode(node, \"validate\", function(node){\n    \n            if (!renderer.$destroyed) {\n                var id = MetaphorJs.dom.getAttr(node, \"name\") ||\n                        MetaphorJs.dom.getAttr(node, \"id\"),\n                v = MetaphorJs.validator.Validator.getValidator(node),\n                f = v ? v.getField(id) : null;\n    \n                if (f) {\n                    f.setConfigRules(config);\n                }\n    \n                config.clear();\n            }\n        });\n    }\n\n    dir.deepInitConfig = function(config) {\n        MetaphorJs.validator.Field.deepInitConfig(config);\n    }\n\n    return dir;\n\n}());\n","\nrequire(\"../__init.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.validator.checkable = function(elem) {\n    return /radio|checkbox/i.test(elem.type);\n};","\nrequire(\"../__init.js\");\nrequire(\"./checkable.js\");\nrequire(\"./getLength.js\");\nrequire(\"metaphorjs/src/func/dom/getInputValue.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n// from http://bassistance.de/jquery-plugins/jquery-plugin-validation/\nmodule.exports = MetaphorJs.validator.empty = function(value, element) {\n\n    if (!element) {\n        return value == undefined || value === '';\n    }\n\n    switch(element.nodeName.toLowerCase()) {\n        case 'select':{\n            // could be an array for select-multiple or a string, both are fine this way\n            var val = MetaphorJs.dom.getInputValue(element);\n            return !val || val.length == 0;\n        }\n        case 'input':{\n            if (MetaphorJs.validator.checkable(element))\n                return MetaphorJs.validator.getLength(value, element) == 0;\n            break;\n        }\n    }\n\n    return value.trim().length == 0;\n};","\nrequire(\"../__init.js\");\n\nconst MetaphorJs      = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    isFunction      = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    isArray         = require(\"metaphorjs-shared/src/func/isArray.js\");\n\nmodule.exports = MetaphorJs.validator.format = function(str, params) {\n\n    if (isFunction(params)) {\n        return str;\n    }\n\n    if (!isArray(params)) {\n        params = [params];\n    }\n\n    var i, l = params.length;\n\n    for (i = -1; ++i < l;\n         str = str.replace(new RegExp(\"\\\\{\" + i + \"\\\\}\", \"g\"), params[i])){}\n\n    return str;\n};","\nrequire(\"../__init.js\");\nrequire(\"./checkable.js\");\n\nconst MetaphorJs      = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    eachNode        = require(\"metaphorjs/src/func/dom/eachNode.js\"),\n    select          = require(\"metaphorjs/src/func/dom/select.js\"),\n    isAttached      = require(\"metaphorjs/src/func/dom/isAttached.js\");\n\n// from http://bassistance.de/jquery-plugins/jquery-plugin-validation/\nmodule.exports = MetaphorJs.validator.getLength = function(value, el) {\n    var l = 0;\n    switch( el.nodeName.toLowerCase() ) {\n        case 'select':\n            eachNode(el, function(node){\n                if (node.selected) {\n                    l++;\n                }\n            });\n            return l;\n        case 'input':\n            if (MetaphorJs.validator.checkable(el)) {\n                if (el.form) {\n                    eachNode(el.form, function (node) {\n                        if (node.type == el.type && node.name == el.name && \n                            node.checked) {\n                            l++;\n                        }\n                    });\n                }\n                else {\n                    var parent,\n                        inputs,\n                        i, len;\n\n                    if (isAttached(el)) {\n                        parent  = el.ownerDocument;\n                    }\n                    else {\n                        parent = el;\n                        while (parent.parentNode) {\n                            parent = parent.parentNode;\n                        }\n                    }\n\n                    inputs  = select(\"input[name=\"+ el.name +\"]\", parent);\n                    for (i = 0, len = inputs.length; i < len; i++) {\n                        if (inputs[i].checked) {\n                            l++;\n                        }\n                    }\n                }\n                return l;\n            }\n    }\n    return value.length;\n};","\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    error = require(\"metaphorjs-shared/src/func/error.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"../__init.js\");\nrequire(\"./Validator.js\");\nrequire(\"metaphorjs/src/lib/Expression.js\");\nrequire(\"metaphorjs/src/func/dom/eachNode.js\");\nrequire(\"metaphorjs/src/func/dom/isField.js\");\nrequire(\"metaphorjs/src/func/dom/getAttr.js\");\n\n\nmodule.exports = MetaphorJs.validator.Component = cls({\n\n    node: null,\n    state: null,\n    validator: null,\n    stateData: null,\n    fields: null,\n    formName: null,\n    nodeCfg: null,\n\n    $init: function(node, state, renderer, nodeCfg) {\n\n        var self        = this;\n\n        self.$self.initConfig(nodeCfg);\n\n        self.node       = node;\n        self.state      = state;\n        self.stateData = {};\n        self.fields     = [];\n        self.nodeCfg    = nodeCfg;\n        self.validator  = self.createValidator();\n        self.formName   = nodeCfg.get(\"ref\") ||\n                            MetaphorJs.dom.getAttr(node, 'name') || \n                            MetaphorJs.dom.getAttr(node, 'id') || \n                            '$form';\n\n        self.initState();\n        self.initStateData();\n        self.initValidatorEvents();\n\n        // wait for the renderer to finish\n        // before making judgements :)\n        renderer.on(\"rendered\", self.validator.check, self.validator, {\n            once: true\n        });\n        renderer.on(\"destroy\", self.$destroy, self);\n        state.$on(\"destroy\", self.$destroy, self);\n    },\n\n    createValidator: function() {\n        var self    = this,\n            node    = self.node,\n            cfg     = {},\n            ncfg    = self.nodeCfg,\n            submit;\n\n        if ((submit = ncfg.get(\"submit\"))) {\n            cfg.callback = cfg.callback || {};\n            cfg.callback.submit = function(fn, state){\n                return function() {\n                    try {\n                        return fn(state);\n                    }\n                    catch(thrownError) {\n                        error(thrownError);\n                    }\n                }\n            }(submit, self.state);\n        }\n\n        return new MetaphorJs.validator.Validator(node, cfg);\n    },\n\n    initValidatorEvents: function() {\n\n        var self    = this,\n            v       = self.validator;\n\n        v.on('field-state-change', self.onFieldStateChange, self);\n        v.on('state-change', self.onFormStateChange, self);\n        v.on('display-state-change', self.onDisplayStateChange, self);\n        v.on('field-error-change', self.onFieldErrorChange, self);\n        v.on('reset', self.onFormReset, self);\n    },\n\n    initState: function() {\n\n        const state   = this.state,\n              name    = this.formName;\n\n        state[name] = this.stateData;\n    },\n\n\n    initStateData: function() {\n\n        var self    = this,\n            node    = self.node,\n            state   = self.stateData,\n            fields  = self.fields,\n            els, el,\n            i, l,\n            name;\n\n        if (node.elements) {\n            els     = node.elements;\n        }\n        else {\n            els     = [];\n            MetaphorJs.dom.eachNode(node, function(el) {\n                if (MetaphorJs.dom.isField(el)) {\n                    els.push(el);\n                }\n            });\n        }\n\n        for (i = -1, l = els.length; ++i < l;) {\n            el = els[i];\n            name = MetaphorJs.dom.getAttr(el, \"name\") || \n                    MetaphorJs.dom.getAttr(el, 'id');\n\n            if (name && !state[name]) {\n                fields.push(name);\n                state[name] = {\n                    $error: null,\n                    $invalid: null,\n                    $pristine: true,\n                    $errorMessage: null\n                };\n            }\n        }\n\n        state.$$validator = self.validator;\n        state.$invalid = false;\n        state.$pristine = true;\n        state.$isDestroyed = bind(self.$isDestroyed, self);\n        state.$submit = bind(self.validator.onSubmit, self.validator);\n        state.$reset = bind(self.validator.reset, self.validator);\n    },\n\n    onDisplayStateChange: function(vld, state) {\n\n        var self    = this;\n\n        if (!state) {\n            self.onFormReset(vld);\n        }\n        else {\n            state   = self.stateData;\n            var i, l, f,\n                fields = self.fields;\n\n            for (i = 0, l = fields.length; i < l; i++) {\n                f = state[fields[i]];\n                if (f.$real) {\n                    state[fields[i]] = f.$real;\n                }\n            }\n\n            state.$invalid = !vld.isValid();\n            state.$pristine = false;\n\n            self.state.$check();\n        }\n\n    },\n\n    onFieldErrorChange: function(vld, field, error) {\n        this.onFieldStateChange(vld, field, field.isValid());\n    },\n\n    onFormReset: function(vld) {\n\n        var self    = this,\n            state   = self.stateData,\n            i, l, f,\n            fields = self.fields;\n\n        for (i = 0, l = fields.length; i < l; i++) {\n            f = state[fields[i]];\n            f.$error = null;\n            f.$errorMessage = null;\n            f.$invalid = null;\n            f.$pristine = true;\n        }\n\n        state.$invalid = false;\n        state.$pristine = true;\n\n        self.state.$check();\n    },\n\n    onFormStateChange: function(vld, valid) {\n\n        var self    = this,\n            state   = self.stateData;\n\n        state.$invalid = valid === false && vld.isDisplayStateEnabled();\n        state.$pristine = false;\n\n        self.state.$check();\n    },\n\n    onFieldStateChange: function(vld, field, valid) {\n\n        var self    = this,\n            state   = self.stateData,\n            name    = field.getName(),\n            ds      = vld.isDisplayStateEnabled(),\n            fstate  = {\n                $error: field.getErrorRule(),\n                $errorMessage: field.getError(),\n                $invalid: valid === false,\n                $pristine: field.getExactValidState() === null\n            };\n\n        if (ds) {\n            state[name] = fstate;\n        }\n        else {\n            state[name].$real = fstate;\n        }\n\n        self.state.$check();\n    },\n\n\n    onDestroy: function() {\n        var self = this;\n\n        self.validator.$destroy();\n\n        if (self.state) {\n            delete self.state[self.formName];\n        }\n    }\n\n}, {\n    initConfig: function(config) {\n        config.setDefaultMode(\"ref\", MetaphorJs.lib.Config.MODE_STATIC);\n    }\n});\n\n","\nconst cls             = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs      = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    extend          = require(\"metaphorjs-shared/src/func/extend.js\"),\n    bind            = require(\"metaphorjs-shared/src/func/bind.js\"),\n    isFunction      = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    isString        = require(\"metaphorjs-shared/src/func/isString.js\"),\n    isBool          = require(\"metaphorjs-shared/src/func/isBool.js\");\n\nrequire(\"../__init.js\");\nrequire(\"metaphorjs/src/func/dom/data.js\");\nrequire(\"metaphorjs/src/func/dom/getAttr.js\");\nrequire(\"metaphorjs/src/func/dom/setAttr.js\");\nrequire(\"metaphorjs/src/func/dom/removeAttr.js\");\nrequire(\"metaphorjs/src/func/dom/addClass.js\");\nrequire(\"metaphorjs/src/func/dom/removeClass.js\");\nrequire(\"metaphorjs/src/func/dom/normalizeEvent.js\");\nrequire(\"metaphorjs/src/lib/Input.js\");\nrequire(\"metaphorjs/src/lib/Config.js\");\nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");\nrequire(\"../var/messages.js\");\nrequire(\"../var/methods.js\");\nrequire(\"../func/empty.js\");\nrequire(\"../func/format.js\");\n\n\nmodule.exports = MetaphorJs.validator.Field = (function(){\n\n    /* ***************************** FIELD ****************************************** */\n\n\n    /**\n     * @object MetaphorJs.validator.Field.defaults\n     */\n    var defaults = {\n\n        /**\n         * @property {boolean} allowSubmit call form.submit() on field's ENTER keyup\n         */\n        allowSubmit:\t\ttrue,\n\n        /**\n         * @property {boolean} alwaysCheck run tests even the field is proven \n         * valid and hasn't changed since last check\n         */\n        alwaysCheck:\t\tfalse,\n\n        /**\n         * @property {boolean} alwaysDisplayState \n         */\n        alwaysDisplayState:\tfalse,\n\n        /**\n         * @property {*} data User data to store with the field\n         */\n        data:\t\t\t\tnull,\n\n        /**\n         * @property {boolean} ignore put ignore:true to field config to ignore the field completely\n         */\n        ignore:\t\t\t\tnull,\n\n        /**\n         * @property {boolean} disabled make validator disabled for this field initially\n         */\n        disabled:\t\t\tfalse,\n\n        /**\n         * @object cls\n         */\n        cls: {\n            /**\n             * @property {string} valid css class for a valid state\n             */\n            valid: \t\t\t'',\n            /**\n             * @property {string} error css class for an error state\n             */\n            error:\t\t\t'',\n            /**\n             * @property {string} remote css class for the field with it is being checked remotely\n             */\n            remote:\t\t\t''\n\n            /**\n             * @end-object\n             */\n        },\n\n        // if string is provided, considered errorBox: {tag: '...'}\n        /**\n         * @object errorBox error box config\n         */\n        errorBox: {\n            /**\n             * @property {string} cls error box css class\n             */\n            cls: \t\t\t'',\n            /**\n             * @property {function} fn {\n             *  Must return dom node (cancels auto creation)\n             *  @param {MetaphorJs.validator.Field} f\n             *  @returns {HTMLElement}\n             * }\n             */\n            fn:\t\t\t\tnull,\n            /**\n             * @property {string} tag Auto-create element with this tag\n             */\n            tag:\t\t\t'',\n            /**\n             * @property {string} position {\n             *  before|after|appendParent where to put newly created element\n             *  @default after\n             * }\n             */\n            position:\t\t'after',\n            /**\n             * @property {string|DomNode} elem {\n             *  Use this element as error box. (Dom node or selector)\n             * }\n             */\n            elem:\t\t\tnull,\n            /**\n             * @property {boolean} enabled {\n             *  Enable or disable error box\n             *  @default true\n             * }\n             */\n            enabled:\t\ttrue\n\n            /**\n             * @end-object\n             */\n        },\n\n        // callbacks are case insensitive\n        // you can use camel case if you like.\n        /**\n         * @object callback\n         */\n        callback: {\n            /**\n             * @property {object} state all callback's context\n             */\n            state:\t\t\tnull,\n\n            /**\n             * @property {function} * {\n             *  eventName: function(f); See class's events\n             *  @param {MetaphorJs.validator.Field} f\n             * }\n             */\n\n            destroy:\t\tnull,\t\t\t// called when field's validator is being destroyed. fn(api)\n            statechange:\tnull,\t\t\t// when field's state has been changed. fn(api, (boolean) state)\n            errorchange:\tnull,\t\t\t// fn(api, error)\n            submit:\t\t\tnull,\t\t\t// when enter key was pressed. fn(api, event). return false to prevent submitting even\n            // if the form is valid\n            check:          null,           // called after each check (may not be relevant, if there is a remote check) fn(api, valid)\n            beforeRemote:\tnull,\t\t\t// when remote check is about to be executed. fn(api, requestData)\n            afterRemote:\tnull,\t\t\t// when remote check ended. fn(api)\n\n            displaystate:\tnull\t\t\t// use this to display custom field state: fn(api, valid, error)\n            /**\n             * @end-object\n             */\n        },\n\n        /**\n         * @property {object} rules {\n         *  Keys of this object are validators from \n         *  <code>MetaphorJs.validator.methods</code>, values\n         *  of this object are validator params.<br>\n         *  Rule can also be a function (custom validator):\n         *  fn(fieldValue, dom, ruleValue, field)<br>\n         *  The function must return error message, false or true.\n         * }\n         */\n        rules: \t\t\t\t{},\n\n        /**\n         * @property {object} messages {\n         *  <code>rule: message</code>, error messages \n         * }\n         */\n        messages: \t\t\t{}\n\n        /**\n         * @end-object\n         */\n    };\n\n\n    var fixFieldShorthands = function(options) {\n\n        if (!options) {\n            return {};\n        }\n\n        var fix = function(level1, level2, type) {\n            var value   = options[level1],\n                yes     = false;\n\n            if (value === undefined) {\n                return;\n            }\n\n            switch (type) {\n                case \"string\": {\n                    yes     = isString(value);\n                    break;\n                }\n                case \"function\": {\n                    yes     = isFunction(value);\n                    break;\n                }\n                case \"boolean\": {\n                    yes = isBool(value);\n                    break;\n                }\n            }\n            if (yes) {\n                options[level1] = {};\n                options[level1][level2] = value;\n            }\n        };\n\n        fix(\"errorBox\", \"enabled\", \"boolean\");\n        fix(\"errorBox\", \"tag\", \"string\");\n        fix(\"errorBox\", \"fn\", \"function\");\n\n        return options;\n    };\n\n\n    var messages = MetaphorJs.validator.messages,\n        methods = MetaphorJs.validator.methods,\n        empty = MetaphorJs.validator.empty,\n        format = MetaphorJs.validator.format;\n\n\n    /**\n     * @class MetaphorJs.validator.Field\n     * @mixes MetaphorJs.mixin.Observable\n     */\n    return cls({\n\n        /**\n         * @event check {\n         *  @param {MetaphorJs.validator.Field} f\n         *  @param {boolean} valid\n         * }\n         */\n        /**\n         * @event display-state {\n         *  @param {MetaphorJs.validator.Field} f\n         *  @param {boolean} valid\n         *  @param {string} error\n         * }\n         */\n        /**\n         * @event state-change {\n         *  @param {MetaphorJs.validator.Field} f\n         *  @param {boolean} valid\n         * }\n         */\n        /**\n         * @event error-change {\n         *  @param {MetaphorJs.validator.Field} f\n         *  @param {string} error \n         *  @param {string} rule\n         * }\n         */\n        /**\n         * @event submit {\n         *  @param {MetaphorJs.validator.Field} f\n         *  @param {MetaphorJs.lib.DomEvent} event\n         *  @returns {boolean} return false to cancel\n         * }\n         */\n        /**\n         * @event before-remote {\n         *  @param {MetaphorJs.validator.Field} f\n         *  @param {object} remoteCfg\n         * }\n         */\n        /**\n         * @event after-remote {\n         *  @param {MetaphorJs.validator.Field} f\n         * }\n         */\n        \n        $mixins: [MetaphorJs.mixin.Observable],\n\n        vldr:           null,\n        elem:           null,\n        rules:          null,\n        cfg:            null,\n\n        input:          null,\n\n        enabled:\t\ttrue,\n        valid:\t\t\tnull,\t\t\t// the field has been checked and is valid (null - not checked yet)\n        dirty:\t\t\tfalse,\t\t\t// the field's value changed, hasn't been rechecked yet\n        id:\t\t\t\tnull,\n        prev:\t\t\t'',\n        error:\t\t\tnull,\n        errorRule:      null,\n        pending: \t\tnull,\n        rulesNum:\t\t0,\n        displayState:\tfalse,\n        data:\t\t\tnull,\n        checking:\t\tfalse,\n        checkTmt:\t\tnull,\n        errorBox:       null,\n        customError:    false,\n\n        /**\n         * @constructor\n         * @method\n         * @param {HTMLElement} elem \n         * @param {object} options See <code>MetaphorJs.validator.Field.defaults</code>\n         * @param {MetaphorJs.validator.Validator} vldr \n         */\n        $init: function(elem, options, vldr) {\n            options             = options || {};\n\n            var self            = this,\n                cfg;\n\n            self.cfg            = cfg = extend({}, defaults,\n                fixFieldShorthands(MetaphorJs.validator.Field.defaults),\n                fixFieldShorthands(options),\n                true, true\n            );\n\n            self.input          = MetaphorJs.lib.Input.get(elem);\n            self.input.onChange(self.onInputChange, self);\n            self.input.onKey(13, self.onInputSubmit, self);\n\n            self.elem           = elem;\n            self.vldr           = vldr;\n            self.enabled        = !elem.disabled;\n            self.id             = MetaphorJs.dom.getAttr(elem, 'name') || \n                                    MetaphorJs.dom.getAttr(elem, 'id');\n            self.data           = options.data;\n            self.rules\t\t\t= {};\n\n            cfg.messages        = extend({}, messages, cfg.messages, true, true);\n\n            MetaphorJs.dom.setAttr(elem, \"data-validator\", vldr.getVldId());\n\n            if (self.input.radio) {\n                self.initRadio();\n            }\n\n            if (cfg.rules) {\n                self.setRules(cfg.rules, false);\n            }\n\n            self.readRules();\n\n            self.prev \t= self.input.getValue();\n\n            if (cfg.disabled) {\n                self.disable();\n            }\n        },\n\n        /**\n         * @method\n         * @returns {MetaphorJs.validator.Validator}\n         */\n        getValidator: function() {\n            return this.vldr;\n        },\n\n        initRadio: function() {\n\n            var self    = this,\n                radios  = self.input.radio,\n                vldId   = self.vldr.getVldId(),\n                i,l;\n\n            for(i = 0, l = radios.length; i < l; i++) {\n                MetaphorJs.dom.setAttr(radios[i], \"data-validator\", vldId);\n            }\n        },\n\n        /**\n         * Set/add field rules\n         * @method\n         * @param {object} list {\n         *  name: value set of rules. See \n         *  <code>MetaphorJs.validator.Field.defaults.rules</code> \n         * }\n         * @param {boolean} check {\n         *  Re-check field's validity\n         *  @default false\n         * }\n         */\n        setRules: function(list, check) {\n\n            var self    = this;\n\n            check = check == undefined ? true : check;\n\n            for (var i in list) {\n                self.setRule(i, list[i], false);\n            }\n\n            if (check) {\n                self.check(false);\n            }\n            else {\n                self.setValidState(null);\n            }\n\n            return self;\n        },\n\n        /**\n         * Set/add field rule\n         * @method\n         * @param {string} rule Validator name\n         * @param {*|function} value\n         * @param {boolean} check {\n         *  Re-check field's validity\n         *  @default false\n         * }\n         */\n        setRule: function(rule, value, check) {\n\n            var self    = this,\n                rules   = self.rules;\n\n            check = check == undefined ? true : check;\n\n            if (value === null) {\n                if (rules[rule]) {\n                    self.rulesNum--;\n                }\n                delete rules[rule];\n            }\n            else {\n                if (!rules[rule]) {\n                    self.rulesNum++;\n                }\n                rules[rule] = value;\n                if (self.valid !== null) {\n                    self.setValidState(false);\n                }\n            }\n\n            if (check) {\n                self.check(false);\n            }\n            else {\n                self.setValidState(null);\n            }\n\n            return self;\n        },\n\n        /**\n         * Set rule message\n         * @method\n         * @param {string} rule\n         * @param {string} message\n         */\n        setMessage: function(rule, message) {\n            this.cfg.messages[rule] = message;\n            return this;\n        },\n\n        /**\n         * Set rule messages\n         * @method\n         * @param {object} messages {\n         *  rule: message \n         * }\n         */\n        setMessages: function(messages) {\n\n            var self = this;\n\n            for (var i in messages) {\n                self.setMessage(i, messages[i]);\n            }\n            return self;\n        },\n\n        /**\n         * Get rule messages\n         * @method \n         * @returns {object}\n         */\n        getMessages: function() {\n            return extend({}, this.cfg.messages);\n        },\n\n        /**\n         * @ignore\n         * Read rules from attributes and classes\n         * (this happens on init)\n         */\n        readRules: function() {\n\n            var self        = this,\n                elem        = self.elem,\n                cls \t\t= elem.className,\n                found\t\t= {},\n                val, i, name, len;\n\n            for (i in methods) {\n\n                if (methods.hasOwnProperty(i)) {\n\n                    val = MetaphorJs.dom.getAttr(elem, i) || \n                            MetaphorJs.dom.getAttr(elem, \"data-validate-\" + i);\n\n                    if (val == undefined || val === false) {\n                        continue;\n                    }\n                    if ((i === 'minlength' || i === 'maxlength') && \n                        (val = parseInt(val, 10)) === -1) {\n                        continue;\n                    }\n\n                    found[i] = val;\n\n                    val = MetaphorJs.dom.getAttr(elem, \"data-message-\" + i);\n                    val && self.setMessage(i, val);\n                }\n            }\n\n            if ((val = MetaphorJs.dom.getAttr(elem, 'remote'))) {\n                found['remote'] = val;\n            }\n\n            if (cls) {\n                cls = cls.split(\" \");\n                for (i = 0, len = cls.length; i < len; i++) {\n\n                    name = cls[i].trim();\n\n                    if (methods[name] || name === 'remote') {\n                        found[name] = true;\n                    }\n                }\n            }\n\n            for (i in found) {\n                self.setRule(i, found[i], false);\n            }\n        },\n\n        setConfigRules: function(config) {\n            var self    = this,\n                elem    = self.elem,\n                val, i;\n\n            this.$self.deepInitConfig(config);\n\n            for (i in methods) {\n\n                if (methods.hasOwnProperty(i)) {\n\n                    val = config.get(i);\n\n                    if (val == undefined || val === false) {\n                        continue;\n                    }\n                    if ((i === 'minlength' || i === 'maxlength') && \n                        (val = parseInt(val, 10)) === -1) {\n                        continue;\n                    }\n\n                    self.setRule(i, val, false);\n\n                    val = (config ? config.get(i + \".msg\") : null) ||\n                            MetaphorJs.dom.getAttr(elem, \"data-message-\" + i);\n                    val && self.setMessage(i, val);\n                }\n            }\n        },\n\n        /**\n         * Get field rules\n         * @method\n         * @returns {object}\n         */\n        getRules: function() {\n            return this.rules;\n        },\n\n        /**\n         * @method\n         * @param {string} name\n         * @return {boolean}\n         */\n        hasRule: function(name) {\n            return this.rules[name] ? true : false;\n        },\n\n        /**\n         * Get field value\n         * @method\n         * @returns {string}\n         */\n        getValue: function() {\n            return this.input.getValue();\n        },\n\n        /**\n         * Get user data\n         * @method\n         * @returns {*}\n         */\n        getUserData: function() {\n            return this.data;\n        },\n\n        /**\n         * Set user data\n         * @method\n         * @param {*} data\n         */\n        setUserData: function(data) {\n            var self    = this,\n                old     = self.data;\n            self.data = data;\n            return old;\n        },\n\n        /**\n         * Is the field currently empty\n         * @method\n         * @returns {boolean}\n         */\n        isEmpty: function() {\n            var self = this;\n            return empty(self.getValue(), self.elem);\n        },\n\n        /**\n         * Enable field validation\n         * @method\n         */\n        enable: function() {\n            var self = this;\n            self.enabled = true;\n            self.vldr.reset();\n            return self;\n        },\n\n        /**\n         * Disable field validation\n         * @method\n         */\n        disable: function() {\n            var self = this;\n            self.enabled = false;\n\n            if (self.valid === false) {\n                self.setValidState(true);\n                self.doDisplayState();\n            }\n            return self;\n        },\n\n        /**\n         * @method\n         */\n        enableDisplayState:\tfunction() {\n            this.displayState = true;\n        },\n\n        /**\n         * @method\n         */\n        disableDisplayState:\tfunction() {\n            this.displayState = false;\n        },\n\n        /**\n         * @method\n         * @returns {boolean}\n         */\n        isDisplayStateEnabled: function() {\n            return this.displayState;\n        },\n\n        /**\n         * @method\n         * @param {boolean} state \n         */\n        toggleErrorBox: function(state) {\n\n            var self    = this,\n                cfg     = self.cfg,\n                prev    = cfg.errorBox.enabled;\n\n            cfg.errorBox.enabled = state;\n\n            if (!prev && state && state.displayState && self.valid() === false) {\n                self.doDisplayState();\n            }\n        },\n\n        /**\n         * @method\n         * @returns {boolean}\n         */\n        isEnabled: function() {\n            return this.enabled;\n        },\n\n        /**\n         * Get field's dom node\n         * @method\n         * @returns {HTMLElement}\n         */\n        getElem: function() {\n            return this.elem;\n        },\n\n        /**\n         * @method\n         * @returns {string}\n         */\n        getName: function() {\n            return this.id;\n        },\n\n        /**\n         * Get current error\n         * @method\n         * @returns {string|null}\n         */\n        getError: function() {\n            return this.error;\n        },\n\n        /**\n         * Get the name of last validator that invalidated the field\n         * @method\n         * @returns {string|null}\n         */\n        getErrorRule: function() {\n            return this.errorRule;\n        },\n\n        /**\n         * @method\n         * @returns {boolean}\n         */\n        isValid: function() {\n\n            var self = this;\n\n            if (!self.isEnabled()) {\n                return true;\n            }\n            if (self.customError) {\n                return false;\n            }\n\n            return (self.valid === true && !self.pending) || \n                    self.rulesNum === 0;\n        },\n\n        getExactValidState: function() {\n            return this.valid;\n        },\n\n        /**\n         * Set custom error\n         * @method\n         * @param {string} error \n         * @param {string} rule \n         */\n        setCustomError:\tfunction(error, rule) {\n            var self = this;\n            self.customError = error ? true : false;\n            self.setValidState(error ? false : true);\n            self.setError(error === true ? null : error, rule);\n            self.doDisplayState();\n        },\n\n        /**\n         * Reset field to untouched state\n         * @method\n         */\n        reset: function() {\n\n            var self = this;\n\n            self.abort();\n            self.dirty \t= false;\n            self.prev \t= '';\n\n            self.setValidState(null);\n            self.setError(null);\n            self.doDisplayState();\n\n            return self;\n        },\n\n        /**\n         * Abort remote check\n         * @method\n         */\n        abort: function() {\n            var self = this;\n            if (self.pending) {\n                console.error(\"Abort not implemented; Implement AbortController!\")\n                //self.pending.abort();\n                //self.pending = null;\n            }\n            return self;\n        },\n\n        /**\n         * Check if field is valid\n         * @method\n         * @param {boolean} force Check even if field's value haven't changed\n         * @returns {boolean}\n         */\n        check: function(force) {\n\n            var self = this,\n                rules = self.rules,\n                cfg = self.cfg,\n                elem = self.elem;\n\n            // disabled field validator always returns true\n            if (!self.isEnabled()) {\n                return true;\n            }\n\n            if (self.customError) {\n                return false;\n            }\n\n            // if there are no rules, we return true\n            if (self.rulesNum == 0 && self.valid !== false) {\n                return true;\n            }\n\n            if (self.checking) {\n                if (!self.checkTmt) {\n                    self.checkTmt\t= setTimeout(bind(self.checkTimeout, self), 100);\n                }\n                return self.valid === true;\n            }\n\n            self.checking = true;\n\n            // nothing changed since last check\n            // we need to find a way to indicate that (if) this field depends on others\n            // and state.dirty doesn't really work in this case\n            if (force !== true &&\n                !rules.equalTo && !rules.notEqualTo &&\n                !self.dirty && self.valid !== null &&\n                !cfg.alwaysCheck) {\n\n                if (!self.pending) {\n                    self.doDisplayState();\n                }\n\n                self.checking = false;\n                return self.valid === true;\n            }\n\n            var valid \t\t\t= true,\n                remote \t\t\t= false,\n                val\t\t\t\t= self.getValue(),\n                msg;\n\n            for (var i in rules) {\n\n                // we always call remote check after all others\n                if (i === 'remote') {\n                    if (self.dirty || cfg.alwaysCheck || \n                        self.valid === null || force === true) {\n                        if (val || rules[i].checkEmpty) {\n                            remote = true;\n                        }\n                    }\n                    continue;\n                }\n\n                var fn = isFunction(rules[i]) ? rules[i] : methods[i];\n\n                if ((msg = fn.call(self.$$callbackContext, val, elem, rules[i], self)) !== true) {\n                    valid = false;\n                    self.setError(format(msg || cfg.messages[i] || \"\", rules[i]), i);\n                    break;\n                }\n            }\n\n            remote\t= remote && valid;\n\n            if (valid) {\n                self.setError(null);\n            }\n\n            if (!remote) {\n                self.setValidState(valid);\n                self.doDisplayState();\n            }\n            else {\n                self.remoteCheck();\n            }\n\n            self.dirty = false;\n            self.checking = false;\n\n            self.trigger(\"check\", self, self.valid);\n\n            return self.valid === true && !remote;\n        },\n\n        doDisplayState: function() {\n\n            var self        = this,\n                cfg         = self.cfg,\n                valid \t\t= self.isValid(),\n                errorCls\t= cfg.cls.error,\n                validCls\t= cfg.cls.valid,\n                elem        = self.elem;\n\n            if (!self.displayState && !cfg.alwaysDisplayState) {\n                valid\t= null;\n            }\n\n            if (self.valid === null) {\n                valid \t= null;\n            }\n\n            if (errorCls) {\n                valid === false ? MetaphorJs.dom.addClass(elem, errorCls) : \n                                    MetaphorJs.dom.removeClass(elem, errorCls);\n            }\n            if (validCls) {\n                valid === true ? MetaphorJs.dom.addClass(elem, validCls) : \n                                    MetaphorJs.dom.removeClass(elem, validCls);\n            }\n\n            var box \t= self.getErrorBox(),\n                error \t= self.error;\n\n            if (box) {\n                if (valid === false && error) {\n                    box.innerHTML = state.error;\n                }\n                box.style.display = valid !== false || !error || !cfg.errorBox.enabled ? 'none' : 'block';\n            }\n\n            self.trigger('display-state', self, valid, self.error);\n        },\n\n        /**\n         * @method\n         * @returns {HTMLElement}\n         */\n        getErrorBox: function() {\n\n            var self        = this,\n                cfg         = self.cfg,\n                eb\t\t\t= cfg.errorBox;\n\n            if (eb.tag || eb.fn || eb.selector) {\n                if (!self.errorBox && eb.enabled) {\n                    self.createErrorBox();\n                }\n                return self.errorBox;\n            }\n            else {\n                return null;\n            }\n        },\n\n\n        onDestroy: function() {\n\n            var self = this;\n\n            MetaphorJs.dom.removeAttr(self.elem, \"data-validator\");\n\n            if (self.errorBox) {\n                self.errorBox.parentNode.removeChild(self.errorBox);\n            }\n\n            self.input.$destroy();\n        },\n\n\n        /**\n         * Is this field still running remote check\n         * @method\n         * @returns {boolean}\n         */\n        isPending: function() {\n            return this.pending !== null;\n        },\n\n        setValidState: function(valid) {\n\n            var self = this;\n\n            if (self.valid !== valid) {\n                self.valid = valid;\n                self.trigger('state-change', self, valid);\n            }\n        },\n\n\n        setError:\t\tfunction(error, rule) {\n\n            var self = this;\n\n            if (self.error != error || self.errorRule != rule) {\n                self.error = error;\n                self.errorRule = rule;\n                self.trigger('error-change', self, error, rule);\n            }\n        },\n\n\n        checkTimeout: function() {\n\n            var self = this;\n\n            self.checkTmt = null;\n            if (self.checking) {\n                return;\n            }\n            self.check(false);\n        },\n\n        onInputChange: function(val) {\n\n            var self    = this,\n                prev    = self.prev;\n\n            if (prev !== val) {\n                self.dirty = true;\n                self.customError = false;\n                self.abort();\n                if (!self.pending) {\n                    self.check(false);\n                }\n\n                self.prev = self.input.getValue();\n            }\n        },\n\n        onInputSubmit: function(e) {\n\n            e = MetaphorJs.dom.normalizeEvent(e);\n\n            if (!e.isDefaultPrevented || !e.isDefaultPrevented()) {\n                var res = this.trigger(\"submit\", this, e);\n                if (res === false) {\n                    e.preventDefault();\n                    return false;\n                }\n            }\n        },\n\n        createErrorBox: function() {\n\n            var self    = this,\n                cfg     = self.cfg,\n                eb\t\t= cfg.errorBox,\n                tag \t= eb.tag,\n                cls\t\t= eb.cls,\n                fn\t\t= eb.fn,\n                pos\t\t= eb.position,\n                dom\t\t= eb.elem;\n\n            if (fn) {\n                self.errorBox = fn.call(self.$$callbackContext, self);\n            }\n            else if(dom) {\n                self.errorBox = dom;\n            }\n            else {\n                self.errorBox = window.document.createElement(tag);\n                self.errorBox.className = cls;\n\n                var r = self.input.radio,\n                    f = r ?\n                        r[r - 1] :\n                        self.elem;\n\n                if (pos == 'appendParent') {\n                    f.parentNode.appendChild(self.errorBox);\n                }\n                else if (pos == \"before\") {\n                    f.parentNode.insertBefore(self.errorBox, f);\n                }\n                else {\n                    f.parentNode.insertBefore(self.errorBox, f.nextSibling);\n                }\n            }\n        },\n\n        remoteCheck: function() {\n\n            var self    = this,\n                rules   = self.rules,\n                elem    = self.elem,\n                rm\t\t= rules['remote'],\n                val \t= self.getValue(),\n                cfg     = self.cfg;\n\n            var acfg \t= extend({}, isString(rm) ? {url: rm} : rm, true);\n\n            acfg.body \t\t= acfg.body || {};\n            acfg.body[acfg.paramName || MetaphorJs.dom.getAttr(elem, 'name') || \n                                        MetaphorJs.dom.getAttr(elem, 'id')] = val;\n\n            if (acfg.fn) {\n                if (cfg.cls.remote) {\n                    MetaphorJs.dom.addClass(elem, cfg.cls.remote);\n                }\n                self.trigger('before-remote', self, acfg);\n                self.pending = acfg.fn(acfg.body).then(bind(self.onRemoteSuccess, self));\n                return;\n            }\n\n            if (!acfg.handler) {\n                acfg.dataType \t= 'text';\n            }\n\n            acfg.cache \t\t= false;\n\n            if (cfg.cls.remote) {\n                MetaphorJs.dom.addClass(elem, cfg.cls.remote);\n            }\n\n            self.trigger('before-remote', self, acfg);\n\n            self.pending = fetch(acfg).then(r => r.text())\n                .then(bind(self.onRemoteSuccess, self))\n                .catch(bind(self.onRemoteError, self));\n        },\n\n        onRemoteSuccess: function(data) {\n\n            var self    = this,\n                rules   = self.rules,\n                cfg     = self.cfg;\n\n            self.pending \t= null;\n            var valid \t\t= true;\n\n            if (rules['remote'].handler) {\n\n                var res = rules['remote'].handler.call(self.$$callbackContext, self, data);\n\n                if (res !== true) {\n                    self.setError(format(res || cfg.messages['remote'] || \"\", rules['remote']), 'remote');\n                    valid \t\t= false;\n                }\n            }\n            else {\n                if (data) {\n                    self.setError(data, 'remote');\n                    valid \t\t= false;\n                }\n                else {\n                    self.setError(null);\n                }\n            }\n\n            if (cfg.cls.remote) {\n                MetaphorJs.dom.removeClass(self.elem, cfg.cls.remote);\n            }\n\n            self.setValidState(valid);\n            self.doDisplayState();\n            self.trigger('after-remote', self);\n        },\n\n        onRemoteError: function(xhr, status) {\n\n            var self        = this,\n                cfg         = self.cfg,\n                response    = xhr.responseData,\n                rules       = self.rules;\n\n            if (response && rules['remote'].handler) {\n\n                var res = rules['remote'].handler.call(self.$$callbackContext, self, response);\n\n                if (res !== true) {\n                    self.setError(format(res || cfg.messages['remote'] || \"\", rules['remote']), 'remote');\n                }\n            }\n\n            if (cfg.cls.remote) {\n                MetaphorJs.dom.removeClass(self.elem, cfg.cls.remote);\n            }\n\n            self.pending = null;\n\n            if (status != 'abort' && xhr != \"abort\") {\n                self.setValidState(false);\n                self.doDisplayState();\n                self.trigger('after-remote', self);\n            }\n        }\n    }, {\n\n        defaults: {},\n        messages: {},\n\n        deepInitConfig: function(config) {\n            var ms = MetaphorJs.lib.Config.MODE_STATIC;\n            for (var i in methods) {\n                if (methods.hasOwnProperty(i)) {\n                    if (config.hasProperty(i)) {\n                        config.setDefaultMode(i, ms);\n                        config.setDefaultMode(i+\".msg\", ms);\n                    }\n                }\n            }\n        }\n\n    });\n\n\n}());","\nconst cls             = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs      = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    extend          = require(\"metaphorjs-shared/src/func/extend.js\"),\n    isFunction      = require(\"metaphorjs-shared/src/func/isFunction.js\");\n\nrequire(\"../__init.js\");\nrequire(\"metaphorjs/src/func/dom/addClass.js\");\nrequire(\"metaphorjs/src/func/dom/removeClass.js\");\nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");\nrequire(\"../var/messages.js\");\nrequire(\"../var/methods.js\");\nrequire(\"../func/format.js\");\n\n\nmodule.exports = MetaphorJs.validator.Group = (function(){\n\n\n/* ***************************** GROUP ****************************************** */\n\n\n    /**\n     * @object MetaphorJs.validator.Group.defaults\n     */\n    var defaults\t= {\n\n        /**\n         * @property {boolean} alwaysCheck run tests even the group is proven \n         * valid and hasn't changed since last check\n         */\n        alwaysCheck:\t\tfalse,\n\n        /**\n         * @property {boolean} alwaysDisplayState \n         */\n        alwaysDisplayState:\tfalse,\n\n        /**\n         * @property {boolean} disabled Make group disabled by default\n         */\n        disabled:\t\t\tfalse,\n\n        /**\n         * @property {function} value { \n         *  @param {object} values Field values - name:value\n         *  @param {MetaphorJs.validator.Group} g \n         *  @returns {*} group value\n         * }\n         */\n        value:\t\t\t\tnull,\n\n        /**\n         * @property {HTMLElement} elem Group's dom node. \n         */\n        elem:\t\t\t\tnull,\t\t\t// dom node\n\n        /**\n         * @property {string|DomNode|function} errorBox {\n         *  string: either field name/id or selector<br>\n         *  function: fn(MetaphorJs.validator.Group)\n         * }\n         */\n        errorBox:\t\t\tnull,\t\t\t\n\n        /**\n         * @property {string} errorField field's name or id - where to display group's error\n         */\n        errorField:\t\t\tnull,\n\n        /**\n         * @property {*} data User data\n         */\n        data:\t\t\t\tnull,\n\n        /**\n         * @object cls\n         */\n        cls: {\n            /**\n             * @property {string} valid Css class for valid state\n             */\n            valid: \t\t\t'',\n            /**\n             * @property {string} error Css class for error state\n             */\n            error:\t\t\t''\n\n            /**\n             * @end-object\n             */\n        },\n\n        /**\n         * @property {array} fields Array of field names/ids\n         */\n        fields:\t\t\t\t[],\n\n        /**\n         * @property {object} rules {\n         *  Keys of this object are validators from \n         *  <code>MetaphorJs.validator.methods</code>, values\n         *  of this object are validator params.<br>\n         *  Rule can also be a function (custom validator):\n         *  fn(fieldValue, dom, ruleValue, field)<br>\n         *  The function must return error message, false or true.\n         * }\n         */\n        rules:\t\t\t\t{},\n\n        /**\n         * @property {object} messages {\n         *  <code>rule: message</code>, error messages \n         * }\n         */\n        messages:\t\t\t{},\n\n        /**\n         * @object callback\n         */\n        callback:\t\t{\n            /**\n             * @property {object} state all callback's context\n             */\n            state:\t\t\tnull,\n\n            /**\n             * @property {function} * {\n             *  eventName: function(f); See class's events\n             *  @param {MetaphorJs.validator.Field} f\n             * }\n             */\n            destroy:\t\tnull,\n            statechange:\tnull,\n            errorchange:\tnull,\n            displaystate:\tnull\n\n            /**\n             * @end-object\n             */\n        }\n\n        /**\n         * @end-object\n         */\n    };\n\n\n    var messages = MetaphorJs.validator.messages,\n        methods = MetaphorJs.validator.methods,\n        format = MetaphorJs.validator.format;\n\n\n    /**\n     * @class MetaphorJs.validator.Group\n     * @mixes MetaphorJs.mixin.Observable\n     */\n    return cls({\n\n        /**\n         * @event error-change {\n         *  @param {MetaphorJs.validator.Group} grp\n         *  @param {string} error\n         * }\n         */\n        /**\n         * @event display-state {\n         *  @param {MetaphorJs.validator.Group} grp\n         *  @param {boolean} valid\n         * }\n         */\n        /**\n         * @event state-change {\n         *  @param {MetaphorJs.validator.Group} grp\n         *  @param {boolean} valid\n         * }\n         */\n        /**\n         * @event field-state-change {\n         *  @param {MetaphorJs.validator.Group} grp\n         *  @param {MetaphorJs.validator.Field} fld \n         *  @param {boolean} valid\n         * }\n         */\n\n        $mixins: [MetaphorJs.mixin.Observable],\n\n        fields:         null,\n        rules:          null,\n        cfg:            null,\n        vldr:           null,\n        enabled:\t\tfalse,\n        invalid:\t\tnull,\n        valid:\t\t\tnull,\n        displayState:\tfalse,\n        rulesNum:\t    0,\n        error:\t\t\tnull,\n        data:\t\t\tnull,\n        errorBox:\t\tnull,\n        el:\t\t\t    null,\n\n        /**\n         * @constructor\n         * @method\n         * @param {object} options See <code>MetaphorJs.validator.Group.defaults</code>\n         * @param {MetaphorJs.validator.Validator} vldr \n         */\n        $init: function(options, vldr) {\n\n            options     = options || {};\n\n            var self            = this,\n                cfg;\n\n            self._vldr          = vldr;\n\n            self.cfg            = cfg = extend({},\n                defaults,\n                MetaphorJs.validator.Group.defaults,\n                options,\n                true, true\n            );\n\n            self.data           = options.data;\n            self.el             = options.elem;\n            self.fields         = {};\n            self.rules\t\t    = {};\n\n            cfg.messages        = extend({}, messages, cfg.messages, true, true);\n\n            var i, len;\n\n            if (cfg.rules) {\n                self.setRules(cfg.rules, false);\n            }\n\n            if (cfg.fields) {\n                for (i = 0, len = options.fields.length; i < len; i++) {\n                    self.add(vldr.getField(cfg.fields[i]));\n                }\n            }\n\n            self.enabled = !cfg.disabled;\n        },\n\n        /**\n         * Enable group (enabled by default)\n         * @method\n         */\n        enable:\t\tfunction() {\n            this.enabled\t= true;\n            return this;\n        },\n\n        /**\n         * Disable group\n         * @method\n         */\n        disable:\tfunction() {\n            this.enabled\t= false;\n            return this;\n        },\n\n        /**\n         * Is group enabled\n         * @method\n         * @return {boolean}\n         */\n        isEnabled:\tfunction() {\n            return this.enabled;\n        },\n\n        /**\n         * Are all fields in this group valid\n         * @method\n         * @return {boolean}\n         */\n        isValid:\t\tfunction() {\n            var self = this;\n            return !self.enabled || (self.invalid === 0 && self.valid === true);\n        },\n\n        /**\n         * @method\n         * @return {boolean|null}\n         */\n        getExactValidState: function() {\n            return this.valid;\n        },\n\n        /**\n         * Reset group\n         * @method\n         */\n        reset:\t\tfunction() {\n            var self = this;\n            self.invalid\t= 0;\n            self.setValidState(null);\n            self.setError(null);\n            self.doDisplayState();\n            return self;\n        },\n\n        /**\n         * Get user data specified in group config\n         * @method\n         * @returns {*}\n         */\n        getUserData: function() {\n            return this.data;\n        },\n\n        /**\n         * Get group name\n         * @method\n         * @returns {string}\n         */\n        getName: function() {\n            return this.cfg.name;\n        },\n\n        /**\n         * Set group's rules\n         * @method\n         * @param {object} list {rule: param}\n         * @param {bool} check Re-check group\n         */\n        setRules: \tfunction(list, check) {\n\n            var self = this;\n\n            check = check == undefined ? true : check;\n\n            for (var i in list) {\n                self.setRule(i, list[i], false);\n            }\n\n            if (check) {\n                self.check();\n            }\n            else {\n                self.setValidState(null);\n            }\n\n            return self;\n        },\n\n        /**\n         * Add group rule\n         * @method\n         * @param {string} rule\n         * @param {*} value\n         * @param {boolean} check Re-check group\n         */\n        setRule:\tfunction(rule, value, check) {\n\n            var self = this,\n                rules = self.rules;\n\n            check = check == undefined ? true : check;\n\n            if (value === null) {\n                if (rules[rule]) {\n                    self.rulesNum--;\n                }\n                delete rules[rule];\n            }\n            else {\n                if (!rules[rule]) {\n                    self.rulesNum++;\n                }\n                rules[rule] = value;\n                if (self.valid !== null) {\n                    self.setValidState(false);\n                }\n            }\n\n            if (check) {\n                self.check();\n            }\n            else {\n                self.setValidState(null);\n            }\n\n            return self;\n        },\n\n        /**\n         * Get group rules\n         * @method\n         * @returns {name: value}\n         */\n        getRules:\tfunction() {\n            return extend({}, this.rules);\n        },\n\n        /**\n         * @method\n         * @param {string} name\n         * @returns {boolean}\n         */\n        hasRule:\tfunction(name) {\n            return this.rules[name] ? true : false;\n        },\n\n        /**\n         * Set group custom error\n         * @method\n         * @param {string} error\n         */\n        setError:\tfunction(error) {\n\n            var self = this,\n                cfg = self.cfg;\n\n            if (self.error != error) {\n\n                if (cfg.errorField) {\n                    self.vldr.getField(cfg.errorField).setError(error);\n                    self.error = null;\n                }\n                else {\n                    self.error = error;\n                    self.trigger('error-change', self, error);\n                }\n            }\n        },\n\n        /**\n         * Get current error\n         * @method\n         * @returns {string}\n         */\n        getError: function() {\n            return this.error;\n        },\n\n        /**\n         * @method \n         * @returns {object} \n         */\n        getFields: function() {\n            return this.fields;\n        },\n\n        /**\n         * @method\n         */\n        enableDisplayState:\t\tfunction() {\n            this.displayState\t= true;\n            return this;\n        },\n\n        /**\n         * @method\n         */\n        disableDisplayState:\tfunction() {\n            this.displayState\t= false;\n            return this;\n        },\n\n        /**\n         * @method\n         * @returns {boolean}\n         */\n        check: function() {\n\n            var self    = this,\n                cfg     = self.cfg,\n                fields  = self.fields,\n                rules   = self.rules;\n\n            if (!self.enabled || self.rulesNum == 0) {\n                self.setValidState(null);\n                self.doDisplayState();\n                return true;\n            }\n\n            self.countInvalid();\n\n            if (self.invalid > 0) {\n                self.setValidState(null);\n                self.doDisplayState();\n                return true;\n            }\n\n            var vals\t= {},\n                valid\t= true,\n                val\t\t= null,\n                msg,\n                i;\n\n            if (cfg.value) {\n\n                for (i in fields) {\n                    vals[i]\t= fields[i].getValue();\n                }\n\n                val\t= cfg.value.call(self.$$callbackContext, vals, self);\n            }\n\n            for (i in rules) {\n\n                var fn = isFunction(rules[i]) ? rules[i] : methods[i];\n\n                if ((msg = fn.call(self.$$callbackContext, val, null, rules[i], self, vals)) !== true) {\n\n                    valid = false;\n\n                    if (msg || cfg.messages[i]) {\n                        self.setError(format(msg || cfg.messages[i] || \"\", rules[i]));\n                    }\n                    else {\n                        self.setError(null);\n                    }\n\n                    break;\n                }\n\n            }\n\n            if (valid) {\n                self.setError(null);\n            }\n\n            self.setValidState(valid);\n            self.doDisplayState();\n\n            return self.valid === true;\n        },\n\n        doDisplayState:\t\t\tfunction() {\n\n            var self    = this,\n                valid\t= self.valid,\n                cfg     = self.cfg;\n\n            if (!self.displayState && !cfg.alwaysDisplayState) {\n                valid\t= null;\n            }\n\n            if (cfg.errorBox) {\n\n                var ebox = self.getErrorBox();\n\n                if (valid !== null) {\n\n                    if (ebox) {\n                        ebox.innerHTML = self.error || '';\n                        ebox.style.display = self.valid === false ? 'block' : 'none';\n                    }\n                }\n                else {\n                    if (ebox) {\n                        ebox.style.display = \"none\";\n                    }\n                }\n            }\n\n            var errorCls\t= cfg.cls.error,\n                validCls\t= cfg.cls.valid;\n\n            valid = self.valid;\n\n            if (errorCls) {\n                valid === false ? MetaphorJs.dom.addClass(self.el, errorCls) : \n                                    MetaphorJs.dom.removeClass(self.el, errorCls);\n            }\n            if (validCls) {\n                valid === true ? MetaphorJs.dom.addClass(self.el, validCls) : \n                                    MetaphorJs.dom.removeClass(self.el, validCls);\n            }\n\n            self.trigger('display-state', self, self.valid);\n        },\n\n        /**\n         * @method\n         * @returns {HTMLElement}\n         */\n        getErrorBox: function() {\n\n            var self    = this,\n                cfg     = self.cfg,\n                fields  = self.fields,\n                eb\t    = cfg.errorBox;\n\n            if (fields[eb]) {\n                return fields[eb].getErrorBox();\n            }\n            else if (!self.errorBox) {\n\n                if (isFunction(cfg.errorBox)) {\n                    self.errorBox\t= cfg.errorBox.call(self.$$callbackContext, self);\n                }\n                else {\n                    self.errorBox\t= cfg.errorBox;\n                }\n            }\n\n            return self.errorBox;\n        },\n\n\n        onDestroy:\tfunction() {\n\n            var self    = this,\n                fields  = self.fields;\n\n            for (var i in fields) {\n                if (fields[i]) {\n                    self.setFieldEvents(fields[i], 'un');\n                }\n            }\n\n            if (self.errorBox) {\n                self.errorBox.parentNode.removeChild(self.errorBox);\n            }\n        },\n\n        /**\n         * Add field to the group\n         * @method\n         * @param {MetaphorJs.validator.Field} field \n         */\n        add:\t\tfunction(field) {\n\n            var self    = this,\n                fields  = self.fields,\n                id\t    = field.getName();\n\n            if (!fields[id]) {\n                fields[id] \t= field;\n\n                self.setFieldEvents(field, 'on');\n            }\n        },\n\n        setFieldEvents:\t\tfunction(f, mode) {\n            var self = this;\n            f[mode]('state-change', self.onFieldStateChange, self);\n        },\n\n        /**\n         * Remove field from the group\n         * @method\n         * @param {MetaphorJs.validator.Field} field \n         */\n        remove:\t\tfunction(field) {\n\n            var self    = this,\n                fields  = self.fields,\n                id\t    = field.getName();\n\n            if (fields[id]) {\n                delete fields[id];\n                self.setFieldEvents(field, 'un');\n            }\n\n            return self;\n        },\n\n        setValidState:\t\t\tfunction(valid) {\n            var self = this;\n            if (self.valid !== valid) {\n                self.valid = valid;\n                self.trigger('state-change', self, valid);\n            }\n        },\n\n        countInvalid:\t\t\tfunction() {\n\n            var self = this,\n                fields = self.fields;\n\n            self.invalid\t= 0;\n            for (var i in fields) {\n                self.invalid += fields[i].isValid() ? 0 : 1;\n            }\n        },\n\n        onFieldStateChange:\t\tfunction(f, valid) {\n            var self = this;\n            self.trigger(\"field-state-change\", self, f, valid);\n            self.check();\n        }\n    }, {\n\n        defaults: {}\n    });\n\n}());","\nconst cls             = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs      = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    extend          = require(\"metaphorjs-shared/src/func/extend.js\"),\n    bind            = require(\"metaphorjs-shared/src/func/bind.js\"),\n    isFunction      = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    isString        = require(\"metaphorjs-shared/src/func/isString.js\"),\n    nextUid         = require(\"metaphorjs-shared/src/func/nextUid.js\");\n\nrequire(\"../__init.js\");\nrequire(\"metaphorjs/src/func/dom/addListener.js\");\nrequire(\"metaphorjs/src/func/dom/removeListener.js\");\nrequire(\"metaphorjs/src/func/dom/addClass.js\");\nrequire(\"metaphorjs/src/func/dom/removeClass.js\");\nrequire(\"metaphorjs/src/func/dom/select.js\");\nrequire(\"metaphorjs/src/func/dom/isField.js\");\nrequire(\"metaphorjs/src/func/dom/normalizeEvent.js\");\nrequire(\"metaphorjs/src/func/dom/getAttr.js\");\nrequire(\"metaphorjs/src/func/dom/setAttr.js\");\nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");    \nrequire(\"./Field.js\");\nrequire(\"./Group.js\");\n\n\nmodule.exports = MetaphorJs.validator.Validator = (function(){\n\n\n    var validators  = {};\n\n    var Field = MetaphorJs.validator.Field,\n        Group = MetaphorJs.validator.Group;\n\n\n    /**\n     * @object MetaphorJs.validator.Validator.defaults\n     */\n    var defaults = {\n\n        /**\n         * @property {HTMLElement} form The form being validated\n         */\n        form:               null,\n\n        /**\n         * @property {object} all All fields properties. \n         * See <code>MetaphorJs.validator.Field.defaults</code>\n         */\n        all: \t\t\t\t{},\n\n        /**\n         * @property {object} fields {\n         *  <code>name: config</code>. \n         * For config see <code>MetaphorJs.validator.Field.defaults</code>.\n         * }\n         */\n        fields: \t\t\t{},\n\n        /**\n         * @property {object} rules {\n         *  <code>field: []</code> set of rules. \n         *  See <code>MetaphorJs.validator.Field.defaults</code> for rules description.\n         * }\n         */\n        rules: \t\t\t\t{},\t\t\t\t// {field: rules}\n\n        /**\n         * Css classes to apply to the form\n         * @object cls\n         */\n        cls: {\n            /**\n             * @property {string} valid Form is valid\n             */\n            valid: \t\t\t'',\t\n            /**\n             * @property {string} valid Form has an error\n             */\t\n            error:\t\t\t'',\t\t\t\n            /**\n             * @property {string} valid Form is being checked (async check)\n             */\n            checking:\t\t''\n\n            /**\n             * @end-object\n             */\n        },\n\n        /**\n         * @property {object} groups {\n         *  <code>name: cfg</code> set of options. \n         * See <code>MetaphorJs.validator.Group.defaults</code>.\n         * }\n         */\n        groups: \t\t\t{},\t\t\t\t// see groupDefaults. {name: cfg}\n\n        // callbacks are case insensitive\n        // you can use camel case if you like.\n        /**\n         * @object callback\n         */\n        callback: {\n            /**\n             * @property {object} state all callback's context\n             */\n            state:\t\t\tnull,\n\n            /**\n             * @property {function} * {\n             *  eventName: function(v); See class's events\n             *  @param {MetaphorJs.validator.Validator} v\n             * }\n             */\n\n            destroy:\t\tnull,\t\t\t// when validator is being destroyed. fn(api)\n            reset:\t\t\tnull,\t\t\t// when the form was resetted. fn(api)\n            beforesubmit:\tnull,\t\t\t// when form is about to be submitted: valid and non-valid. fn(api)\n            submit:\t\t\tnull,\t\t\t// when form is about to be submitted: only valid. fn(api).\n            // return false to prevent submitting\n            statechange:\tnull,\t\t\t// when form's state has been changed. fn(api, state)\n            check:\t\t\tnull,\t\t\t// fn(api) performe some additional out-of-form checks\n            // if false is returned, form becomes invalid\n\n            displaystate:\tnull,\t\t\t// fn(api, valid)\n            displaystatechange:\tnull\t\t// fn(api, state)\n\n            /**\n             * @end-object\n             */\n        }\n        /**\n         * @end-object\n         */\n    };\n\n\n    /**\n     * @class MetaphorJs.validator.Validator\n     * @mixes MetaphorJs.mixin.Observable\n     */\n    var Validator = cls({\n\n        /**\n         * @event display-state-change {\n         *  When displayState has been enabled or disabled\n         *  @param {MetaphorJs.validator.Validator} v\n         *  @param {boolean} state\n         * }\n         */\n        /**\n         * @event check {\n         *  When form is being checked\n         *  @param {MetaphorJs.validator.Validator} v\n         *  @returns {boolean} return false to cancel check\n         * }\n         */\n        /**\n         * @event state-change {\n         *  After form check, if it changed its state\n         *  @param {MetaphorJs.validator.Validator} v\n         *  @param {boolean} valid \n         * }\n         */\n        /**\n         * @event reset {\n         *  @param {MetaphorJs.validator.Validator} v\n         * }\n         */\n        /**\n         * @event before-submit {\n         *  @param {MetaphorJs.validator.Validator} v\n         *  @returns {boolean} return false to cancel submitting\n         * }\n         */\n        /**\n         * @event submit {\n         *  @param {MetaphorJs.validator.Validator} v\n         *  @returns {boolean} return false to cancel submitting\n         * }\n         */\n        /**\n         * @event failed-submit {\n         *  @param {MetaphorJs.validator.Validator} v\n         * }\n         */\n        /**\n         * @event field-error-change {\n         *  @param {MetaphorJs.validator.Validator} v\n         *  @param {MetaphorJs.validator.Field} f \n         *  @param {string} error\n         * }\n         */\n        /**\n         * @event field-state-change {\n         *  @param {MetaphorJs.validator.Validator} v\n         *  @param {MetaphorJs.validator.Field} f \n         *  @param {boolean} valid\n         * }\n         */\n        /**\n         * @event display-state {\n         *  @param {MetaphorJs.validator.Validator} v\n         *  @param {boolean} valid\n         * }\n         */\n\n        $mixins: [MetaphorJs.mixin.Observable],\n\n        id:             null,\n        el:             null,\n        cfg:            null,\n        enabled: \t\tfalse,\n        invalid:\t\tnull,\t\t\t\t\t// array of invalid fields\n        pending: \t\t0,\t\t\t\t\t\t// number of pending requests\n        grps:\t\t\t0,\t\t\t\t\t\t// number of invalid groups\n        outside:\t\ttrue,\t\t\t\t\t// true - outside check passed or not present\n        submitted:\t\tfalse,\n        displayState:\tfalse,\n        isForm: \t\tfalse,\n        isField: \t\tfalse,\n        submitButton: \tnull,\n        hidden:\t\t\tnull,\n\n        preventFormSubmit: false,\n\n        fields:         null,\n        groups:         null,\n\n\n        /**\n         * @constructor\n         * @method\n         * @param {HTMLElement} el \n         * @param {object} options See <code>MetaphorJs.validator.Validator.defaults</code>\n         */\n\n        /**\n         * @constructor\n         * @method\n         * @param {HTMLElement} el \n         * @param {string} preset Preset name to take options from. \n         * (Preset options will be overriden by <code>options</code>)\n         * @param {object} options See <code>MetaphorJs.validator.Validator.defaults</code>\n         */\n        $init: function(el, preset, options) {\n\n            var self    = this,\n                tag     = el.nodeName.toLowerCase(),\n                cfg;\n\n            self.id     = nextUid();\n            validators[self.id] = self;\n\n            MetaphorJs.dom.setAttr(el, \"data-validator\", self.id);\n\n            self.el     = el;\n\n            if (preset && !isString(preset)) {\n                options         = preset;\n                preset          = null;\n            }\n\n            self.cfg            = cfg = extend({}, defaults, Validator.defaults, Validator[preset], options, true, true);\n\n            self.$initObservable(cfg);\n\n            self.isForm         = tag === 'form';\n            self.isField        = /input|select|textarea/.test(tag);\n\n            self.fields         = {};\n            self.groups         = {};\n\n            self.$$observable.createEvent(\"submit\", false);\n            self.$$observable.createEvent(\"beforesubmit\", false);\n\n            self.onRealSubmitClickDelegate  = bind(self.onRealSubmitClick, self);\n            self.resetDelegate = bind(self.reset, self);\n            self.onSubmitClickDelegate = bind(self.onSubmitClick, self);\n            self.onFormSubmitDelegate = bind(self.onFormSubmit, self);\n\n            var i;\n\n            self.initFields();\n\n            var fields  = self.fields;\n\n            for (i in cfg.rules) {\n                if (!fields[i]) {\n                    continue;\n                }\n                fields[i].setRules(cfg.rules[i], false);\n            }\n\n            cfg.rules\t= null;\n\n            for (i in cfg.groups) {\n                self.addGroup(i, cfg.groups[i]);\n            }\n\n            self.initForm('bind');\n\n            delete cfg.rules;\n            delete cfg.fields;\n            delete cfg.groups;\n\n            self.enabled = true;\n        },\n\n        /**\n         * Get validator id\n         * @method\n         * @returns {string}\n         */\n        getVldId:       function() {\n            return this.id;\n        },\n\n        /**\n         * Get form element\n         * @method\n         * @returns {HTMLElement}\n         */\n        getElem:        function() {\n            return this.el;\n        },\n\n        /**\n         * Get group by its name\n         * @method\n         * @param {string} name\n         * @returns {MetaphorJs.validator.Group}\n         */\n        getGroup: function(name) {\n            return this.groups[name] || null;\n        },\n\n        /**\n         * Get field by name or id\n         * @method\n         * @param {string} id\n         * @return {MetaphorJs.validator.Field}\n         */\n        getField:\tfunction(id) {\n            return this.fields[id] || null;\n        },\n\n        /**\n         * Enable validator (enabled by default)\n         * @method\n         */\n        enable: function() {\n            this.enabled = true;\n            return this;\n        },\n\n        /**\n         * Disable validator\n         * @method\n         */\n        disable: function() {\n            this.enabled = false;\n            return this;\n        },\n\n        /**\n         * Is this validator enabled\n         * @method\n         * @returns {boolean}\n         */\n        isEnabled: function() {\n            return this.enabled;\n        },\n\n        /**\n         * Make validator show form errors and other messages. (Enabled by default)\n         * @method\n         */\n        enableDisplayState:\tfunction() {\n\n            var self    = this,\n                fields  = self.fields,\n                groups  = self.groups,\n                i;\n\n            if (self.displayState !== true) {\n\n                self.displayState = true;\n\n                for (i in fields) {\n                    fields[i].enableDisplayState();\n                }\n                for (i in groups) {\n                    groups[i].enableDisplayState();\n                }\n\n                self.trigger('display-state-change', self, true);\n            }\n\n            return self;\n        },\n\n        /**\n         * Make validator not show form errors and other messages\n         * @method\n         */\n        disableDisplayState:\tfunction() {\n\n            var self    = this,\n                groups  = self.groups,\n                fields  = self.fields,\n                i;\n\n            if (self.displayState !== false) {\n\n                self.displayState = false;\n\n                for (i in fields) {\n                    fields[i].disableDisplayState();\n                }\n                for (i in groups) {\n                    groups[i].disableDisplayState();\n                }\n\n                self.trigger('display-state-change', self, false);\n            }\n\n            return self;\n        },\n\n        /**\n         * Check if form shows errors and messages\n         * @method\n         * @return {boolean}\n         */\n        isDisplayStateEnabled:\tfunction() {\n            return this.displayState;\n        },\n\n        /**\n         * Is the form valid\n         * @return {boolean}\n         */\n        isValid: function() {\n\n            var self    = this;\n\n            if (self.enabled === false) {\n                return true;\n            }\n            return \tself.invalid === 0 &&\n                      self.pending === 0 &&\n                      self.grps === 0 &&\n                      self.outside === true;\n        },\n\n        /**\n         * Get form errors\n         * @method \n         * @param {boolean} plain {\n         *  If plain=true, will return array [err, err], if false (default),\n         *  object: (field: err, field: err)\n         * }\n         * @returns {array|object}\n         */\n        getErrors: function(plain) {\n\n            var self    = this,\n                ers     = plain === true ? [] : {},\n                err,\n                i, j,\n                all     = [self.fields, self.groups],\n                curr;\n\n            if (!self.isEnabled()) {\n                return ers;\n            }\n\n            for (j = 0; j < 2; j++) {\n\n                curr = all[j];\n\n                for (i in curr) {\n                    if (curr[i].getExactValidState() === null) {\n                        curr[i].check();\n                    }\n\n                    if (!curr[i].isValid()) {\n\n                        err = curr[i].getError();\n\n                        // it can be invalid, but have no error\n                        if (err) {\n                            if (plain) {\n                                ers.push(err);\n                            }\n                            else {\n                                ers[i] = err;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return ers;\n        },\n\n\n        /**\n         * Check form for errors\n         * @method\n         * @returns {boolean} returns current form state \n         * (it may change in a second after remote checks)\n         */\n        check: function() {\n\n            var self    = this,\n                fields  = self.fields,\n                groups  = self.groups;\n\n            // disabled field validator always returns true\n            if (!self.isEnabled()) {\n                return true;\n            }\n\n            var prevValid\t= self.isValid(),\n                nowValid,\n                i;\n\n            for (i in fields) {\n                fields[i].check();\n            }\n\n            for (i in groups) {\n                groups[i].check();\n            }\n\n            self.outside \t= self.trigger('check', self) !== false;\n            nowValid\t\t= self.isValid();\n\n            if (prevValid != nowValid) {\n                self.doDisplayState();\n                self.trigger('state-change', self, false);\n            }\n\n            return nowValid;\n        },\n\n\n        /**\n         * Add field\n         * @method \n         * @param {HTMLElement} node\n         * @param {object} fieldCfg See <code>MetaphorJs.validator.Field.defaults</code>\n         * @returns {MetaphorJs.validator.Validator}\n         */\n        add: function(node, fieldCfg) {\n\n            var self    = this;\n\n            if (!MetaphorJs.dom.isField(node)) {\n                return self;\n            }\n            if (MetaphorJs.dom.getAttr(node, \"data-no-validate\") !== null) {\n                return self;\n            }\n            if (MetaphorJs.dom.getAttr(node, \"data-validator\") !== null) {\n                return self;\n            }\n\n            var id \t\t\t= MetaphorJs.dom.getAttr(node, 'name') || \n                                MetaphorJs.dom.getAttr(node, 'id'),\n                cfg         = self.cfg,\n                fields      = self.fields,\n                fcfg,\n                f;\n\n            if (!id) {\n                return self;\n            }\n\n            fcfg \t= cfg.fields && cfg.fields[id] ? cfg.fields[id] : (fieldCfg || {});\n\n            if (isString(fcfg)) {\n                fcfg \t= {rules: [fcfg]};\n            }\n\n            fcfg \t= extend({}, cfg.all || {}, fcfg, true, true);\n\n            if (fcfg.ignore) {\n                return self;\n            }\n\n            if (!fcfg.callback) {\n                fcfg.callback = {\n                    context:\tself.$$callbackContext\n                };\n            }\n\n            f       = new Field(node, fcfg, self);\n            fcfg    = null;\n            id      = f.getName();\n\n            if (fields[id]) {\n                return self; // already added\n            }\n\n            fields[id] = f;\n\n            self.setFieldEvents(f, 'on');\n\n            if (self.displayState) {\n                f.enableDisplayState();\n            }\n\n            if (self.isEnabled() && self.invalid !== null) {\n                f.check();\n            }\n\n            return self;\n        },\n\n        /**\n         * Add group of fields\n         * @method\n         * @param {string} name\n         * @param {object} cfg See <code>MetaphorJs.validator.Group.defaults</code>\n         * @returns {MetaphorJs.validator.Validator}\n         */\n        addGroup:\t\tfunction(name, cfg) {\n\n            var self    = this,\n                groups  = self.groups;\n\n            if (!groups[name]) {\n\n                cfg.name\t\t= name;\n\n                groups[name]\t= new Group(cfg, self);\n                self.setGroupEvents(groups[name], 'on');\n\n                if (self.isEnabled() && self.invalid !== null) {\n                    groups[name].check();\n                }\n            }\n\n            return self;\n        },\n\n\n        /**\n         * Focus first invalid field\n         * @method\n         */\n        focusInvalid: function() {\n            var fields  = this.fields;\n            for (var i in fields) {\n                if (!fields[i].isValid()) {\n                    fields[i].getElem().focus();\n                    return;\n                }\n            }\n        },\n\n\n        /**\n         * Reset validator: reset all groups and fields to untouched state.\n         * @method\n         */\n        reset: function() {\n\n            var self    = this,\n                fields  = self.fields,\n                groups  = self.groups,\n                i;\n\n            self.submitted \t= false;\n\n            self.disableDisplayState();\n\n            for (i in groups) {\n                groups[i].reset();\n            }\n\n            for (i in fields) {\n                fields[i].reset();\n            }\n\n            self.pending \t\t= 0;\n            self.invalid \t\t= null;\n            self.grps\t\t\t= 0;\n            self.outside\t\t= false;\n\n            self.doDisplayState();\n            self.trigger('reset', self);\n\n            return self;\n        },\n\n\n        /**\n         * Submit form or display errors\n         * @method\n         */\n        submit: function() {\n\n            var self    = this,\n                el      = self.el;\n\n            if (!self.isForm) {\n                self.onSubmit();\n                return;\n            }\n\n            if (isFunction(el.submit)) {\n\n                if (self.trigger('before-submit', self) !== false &&\n                    self.trigger('submit', self) !== false) {\n                    el.submit();\n                }\n            }\n            else {\n                self.onSubmit();\n            }\n        },\n\n        setFieldEvents: function(v, mode) {\n            var self    = this;\n            v[mode]('state-change', self.onFieldStateChange, self);\n            v[mode]('before-remote', self.onBeforeRemote, self);\n            v[mode]('after-remote', self.onAfterRemote, self);\n            v[mode]('submit', self.onFieldSubmit, self);\n            v[mode]('destroy', self.onFieldDestroy, self);\n            v[mode]('error-change', self.onFieldErrorChange, self);\n        },\n\n        setGroupEvents:\tfunction(g, mode) {\n            g[mode]('state-change', this.onGroupStateChange, this);\n        },\n\n\n        initFields: function() {\n\n            var self    = this,\n                el      = self.el,\n                els, i, l;\n\n            if (self.isField) {\n                self.add(el);\n                return self;\n            }\n\n            els = MetaphorJs.dom.select(\"input, textarea, select\", el);\n\n            for (i = -1, l = els.length; ++i < l; self.add(els[i])){}\n\n            return self;\n        },\n\n        initForm: function(mode) {\n\n            var self    = this,\n                el      = self.el,\n                nodes   = el.getElementsByTagName(\"input\"),\n                submits = MetaphorJs.dom.select(\".submit\", el),\n                resets  = MetaphorJs.dom.select(\".reset\", el),\n                fn      = mode === \"bind\" ? MetaphorJs.dom.addListener : \n                                            MetaphorJs.dom.removeListener,\n                i, l,\n                type,\n                node;\n\n            for (i = 0, l = nodes.length; i < l; i++) {\n                node = nodes[i];\n                type = node.type;\n                if (type === \"submit\") {\n                    fn(node, \"click\", self.onRealSubmitClickDelegate);\n                }\n                else if (type === \"reset\") {\n                    fn(node, \"click\", self.resetDelegate);\n                }\n            }\n\n            for (i = -1, l = submits.length; ++i < l;){\n                if (submits[i].type !== \"submit\" || \n                    submits[i].tagName.toLowerCase() === \"button\")  {\n                    fn(submits[i], \"click\", self.onSubmitClickDelegate);\n                }\n            }\n\n            for (i = -1, l = resets.length;\n                 ++i < l;\n                 resets[i].type !== \"reset\" && fn(resets[i], \"click\", self.resetDelegate)\n            ){}\n\n            if (self.isForm) {\n                fn(el, \"submit\", self.onFormSubmitDelegate);\n            }\n        },\n\n        onRealSubmitClick: function(e) {\n            e = MetaphorJs.dom.normalizeEvent(e || window.event);\n            this.submitButton  = e.target || e.srcElement;\n            this.preventFormSubmit = false;\n            return this.onSubmit(e);\n        },\n\n        onSubmitClick: function(e) {\n            this.preventFormSubmit = false;\n            return this.onSubmit(MetaphorJs.dom.normalizeEvent(e || window.event));\n        },\n\n        onFormSubmit: function(e) {\n            e = MetaphorJs.dom.normalizeEvent(e);\n            if (!this.isValid() || this.preventFormSubmit) {\n                e.preventDefault();\n                return false;\n            }\n\n        },\n\n        onFieldSubmit: function(fapi, e) {\n            var self    = this;\n            self.preventFormSubmit = false;\n            self.enableDisplayState();\n            self.submitted = true;\n\n            return self.onSubmit(e);\n        },\n\n        onSubmit: function(e) {\n            var self    = this;\n\n            self.enableDisplayState();\n\n            if (!self.isForm) {\n                e && e.preventDefault();\n                e && e.stopPropagation();\n            }\n\n            if (self.pending) {\n                e && e.preventDefault();\n                return false;\n            }\n\n            var buttonClicked = !!self.submitButton;\n\n            if (self.isForm) {\n\n                if (self.hidden) {\n                    self.el.removeChild(self.hidden);\n                    self.hidden = null;\n                }\n\n                // submit button's value is only being sent with the form if you click the button.\n                // since there can be a delay due to remote checks and the form will be submitted later\n                // automatically, we need to create a hidden field\n                if (self.submitButton && /input|button/.test(self.submitButton.nodeName)) {\n                    self.hidden = window.document.createElement(\"input\");\n                    self.hidden.type = \"hidden\";\n                    MetaphorJs.dom.setAttr(self.hidden, \"name\", self.submitButton.name);\n                    self.hidden.value = self.submitButton.value;\n                    self.el.appendChild(self.hidden);\n                }\n            }\n\n            self.submitButton = null;\n\n            if (!self.isValid()) {\n                self.check();\n                self.onFieldStateChange();\n\n                if (self.pending) {\n                    // TODO: find out why this flag is not being set in all onSubmit handlers\n                    self.submitted = true;\n                    e && e.preventDefault();\n                    return false;\n                }\n            }\n\n            if (self.trigger('before-submit', self) === false || !self.isValid()) {\n\n                if (e) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                }\n\n                if (!self.pending) {\n                    self.focusInvalid();\n                    self.submitted = false;\n                }\n\n                self.trigger('failed-submit', self, buttonClicked);\n                return false;\n            }\n\n            if (!self.pending) {\n                self.submitted = false;\n            }\n\n            var res = self.trigger('submit', self);\n            self.preventFormSubmit = res === false;\n            return !self.isForm ? false : res;\n        },\n\n        onFieldDestroy: function(f) {\n\n            var elem \t= f.getElem(),\n                id\t\t= MetaphorJs.dom.getAttr(elem, 'name') || \n                            MetaphorJs.dom.getAttr(elem, 'id');\n\n            delete this.fields[id];\n        },\n\n        onFieldErrorChange: function(f, error) {\n            this.trigger(\"field-error-change\", this, f, error);\n        },\n\n        onFieldStateChange: function(f, valid) {\n\n            var self        = this,\n                num \t\t= self.invalid,\n                fields      = self.fields;\n\n            self.invalid \t= 0;\n\n            for (var i in fields) {\n                self.invalid += fields[i].isValid() ? 0 : 1;\n            }\n\n            if (f) {\n                self.trigger('field-state-change', self, f, valid);\n            }\n\n            if (num === null || (num !== null && self.invalid !== num)) {\n                self.doDisplayState();\n                self.trigger('state-change', self, self.isValid());\n            }\n        },\n\n        onGroupStateChange:\tfunction() {\n\n            var self        = this,\n                groups      = self.groups,\n                num \t\t= self.grps;\n\n            self.grps \t= 0;\n\n            for (var i in groups) {\n                self.grps += groups[i].isValid() ? 0 : 1;\n            }\n\n            if (num === null || (num !== null && self.grps !== num)) {\n                self.doDisplayState();\n                self.trigger('state-change', self, self.isValid());\n            }\n        },\n\n        doDisplayState: function() {\n\n            var self        = this,\n                cfg         = self.cfg,\n                valid \t\t= self.isValid(),\n                errorCls\t= cfg.cls.error,\n                validCls\t= cfg.cls.valid,\n                el          = self.el;\n\n            if (self.isField || !self.displayState) {\n                valid\t\t= null;\n            }\n\n            if (self.invalid === null) {\n                valid = null;\n            }\n\n            if (errorCls) {\n                valid === false ? MetaphorJs.dom.addClass(el, errorCls) : \n                                MetaphorJs.dom.removeClass(el, errorCls);\n            }\n            if (validCls) {\n                valid === true ? MetaphorJs.dom.addClass(el, validCls) : \n                                MetaphorJs.dom.removeClass(el, validCls);\n            }\n\n            self.trigger('display-state', self, valid);\n        },\n\n        onBeforeRemote: function() {\n            var self = this;\n            self.pending++;\n            if (self.cfg.cls.remote) {\n                MetaphorJs.dom.addClass(self.el, self.cfg.cls.remote);\n            }\n        },\n\n        onAfterRemote: function() {\n\n            var self    = this,\n                fields  = self.fields,\n                cfg     = self.cfg;\n\n            self.pending = 0;\n\n            for (var i in fields) {\n                self.pending += fields[i].isPending() ? 1 : 0;\n            }\n\n            self.doDisplayState();\n\n            if (cfg.cls.remote) {\n                MetaphorJs.dom.removeClass(self.el, cfg.cls.remote);\n            }\n\n            if (self.submitted && self.pending == 0) {\n                self.submitted = false;\n\n                if (self.isValid()) {\n                    self.submit();\n                }\n                else {\n                    self.focusInvalid();\n                }\n            }\n        },\n\n\n        onDestroy: function() {\n\n            var self    = this,\n                groups  = self.groups,\n                fields  = self.fields,\n                i;\n\n            self.reset();\n            //self.trigger('destroy', self);\n\n            delete validators[self.id];\n\n            for (i in groups) {\n                if (groups.hasOwnProperty(i) && groups[i]) {\n                    self.setGroupEvents(groups[i], 'un');\n                    groups[i].$destroy();\n                }\n            }\n\n            for (i in fields) {\n                if (fields.hasOwnProperty(i) && fields[i]) {\n                    self.setFieldEvents(fields[i], 'un');\n                    fields[i].$destroy();\n                }\n            }\n\n            self.initForm('unbind');\n\n            self.fields = null;\n            self.groups = null;\n            self.el = null;\n            self.cfg = null;\n        }\n\n    }, {\n\n        defaults:   {},\n\n        /**\n         * Add validator\n         * @static\n         * @method\n         * @param {string} name \n         * @param {function} fn {\n         *  @param {string} value\n         *  @param {HTMLElement} node\n         *  @param {string|*} param {\n         *      Validator's attribute value. <br>\n         *      <pre><input minlength=\"10\"></pre><br>\n         *      param=10\n         *  }\n         *  @returns {boolean} Return false to invalidate field\n         * }\n         * @param {string} message Error message to display if the field is invalid\n         */\n        addMethod:  function(name, fn, message) {\n            var methods = ns.get(\"MetaphorJs.validator.methods\");\n            if (!methods[name]) {\n                methods[name] = fn;\n                if (message) {\n                    Validator.messages[name] = message;\n                }\n            }\n        },\n\n        /**\n         * Check if dom element already has validator initialized\n         * @static\n         * @method\n         * @param {HTMLElement} el \n         * @returns {MetaphorJs.validator.Validator|null}\n         */\n        getValidator: function(el) {\n            var vldId = MetaphorJs.dom.getAttr(el, \"data-validator\");\n            return validators[vldId] || null;\n        }\n    });\n\n\n\n    return Validator;\n\n}());\n","\nrequire(\"../__init.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @var {object} MetaphorJs.validator.messages {\n *  Validator error messages. _validator_: \"_message_\".\n * }\n */\nmodule.exports = MetaphorJs.validator.messages = {\n    required: \t\t\"This field is required.\",\n    remote:\t \t\t\"Please fix this field.\",\n    email: \t\t\t\"Please enter a valid email address.\",\n    url: \t\t\t\"Please enter a valid URL.\",\n    date: \t\t\t\"Please enter a valid date.\",\n    dateISO: \t\t\"Please enter a valid date (ISO).\",\n    number: \t\t\"Please enter a valid number.\",\n    digits: \t\t\"Please enter only digits.\",\n    creditcard: \t\"Please enter a valid credit card number.\",\n    equalTo: \t\t\"Please enter the same value again.\",\n    accept: \t\t\"Please enter a value with a valid extension.\",\n    maxlength: \t\t\"Please enter no more than {0} characters.\",\n    minlength: \t\t\"Please enter at least {0} characters.\",\n    rangelength: \t\"Please enter a value between {0} and {1} characters long.\",\n    range: \t\t\t\"Please enter a value between {0} and {1}.\",\n    max: \t\t\t\"Please enter a value less than or equal to {0}.\",\n    min: \t\t\t\"Please enter a value greater than or equal to {0}.\"\n};","\nrequire(\"../__init.js\");\nrequire(\"../func/empty.js\");\nrequire(\"../func/getLength.js\");\nrequire(\"metaphorjs/src/func/dom/getInputValue.js\");\nrequire(\"metaphorjs-shared/src/var/regexp/url.js\");\nrequire(\"metaphorjs-shared/src/var/regexp/email.js\");\n\nconst MetaphorJs      = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    isString        = require(\"metaphorjs-shared/src/func/isString.js\");\n\nmodule.exports = (function(){\n\n    var empty = MetaphorJs.validator.empty,\n        getLength = MetaphorJs.validator.getLength;\n\n    // from http://bassistance.de/jquery-plugins/jquery-plugin-validation/\n    // i've changed most of the functions, but the result is the same.\n    // this === field's api.\n\n    return MetaphorJs.validator.methods = {\n\n        /**\n         * Checks that field value is not empty\n         * @validator required\n         * @param {boolean} param \n         */\n        required: function(value, element, param) {\n            if (param === false) {\n                return true;\n            }\n            return !empty(value, element);\n        },\n\n        /**\n         * Test field's value using this regular expression. \n         * Empty value passes as success.\n         * @validator regexp\n         * @param {string|Regexp} param \n         */\n        regexp: function(value, element, param) {\n            var reg = param instanceof RegExp ? param : new RegExp(param);\n            return empty(value, element) || reg.test(value);\n        },\n\n        /**\n         * Same as validator.regexp but with the opposite result.\n         * Empty value passes as success.\n         * @validator notregexp\n         * @param {string|Regexp} param \n         */\n        notregexp: function(value, element, param) {\n            var reg = param instanceof RegExp ? param : new RegExp(param);\n            return empty(value, element) || !reg.test(value);\n        },\n\n        /**\n         * Check if field's value length more than param. \n         * Empty value passes as success.\n         * @validator minlength\n         * @param {string|int} param \n         */\n        minlength: function(value, element, param) {\n            return empty(value, element) ||\n                   (\n                       element ?\n                       getLength(value.trim(), element) >= param :\n                       value.toString().length >= param\n                   );\n        },\n\n        /**\n         * Check if field's value length less than param.\n         * Empty value passes as success.\n         * @validator maxlength\n         * @param {string|int} param \n         */\n        maxlength: function(value, element, param) {\n            return empty(value, element) ||\n                   (\n                       element ?\n                       getLength(value.trim(), element) <= param:\n                       value.toString().length <= param\n                   );\n        },\n\n        /**\n         * Check if field's value length between given range.\n         * Empty value passes as success.\n         * @validator rangelength\n         * @param {array} param [min, max]\n         */\n        rangelength: function(value, element, param) {\n            var length = element ? getLength(value.trim(), element) : value.toString().length;\n            return empty(value, element) || ( length >= param[0] && length <= param[1] );\n        },\n\n        /**\n         * Check if field's value is greater than given number.\n         * Empty value passes as success.\n         * @validator min\n         * @param {int} param \n         */\n        min: function(value, element, param) {\n            return empty(value, element) || parseInt(value, 10) >= param;\n        },\n\n        /**\n         * Check if field's value is lesser than given number.\n         * Empty value passes as success.\n         * @validator max\n         * @param {int} param \n         */\n        max: function(value, element, param) {\n            return empty(value, element) || parseInt(value, 10) <= param;\n        },\n\n        /**\n         * Check if field's value is between given range.\n         * Empty value passes as success.\n         * @validator range\n         * @param {array} param [min, max]\n         */\n        range: function(value, element, param) {\n            value = parseInt(value, 10);\n            return empty(value, element) || ( value >= param[0] && value <= param[1] );\n        },\n\n        // http://docs.jquery.com/Plugins/Validation/Methods/email\n        /**\n         * Check is field's value matches email regexp. \n         * Empty value passes as success.\n         * @validator email\n         */\n        email: function(value, element) {\n            // contributed by Scott Gonzalez: http://projects.scottsplayground.com/email_address_validation/\n            return empty(value, element) || MetaphorJs.regexp.email.test(value);\n        },\n\n        // http://docs.jquery.com/Plugins/Validation/Methods/url\n        /**\n         * Check is field's value matches url regexp. \n         * Empty value passes as success.\n         * @validator email\n         */\n        url: function(value, element) {\n            // contributed by Scott Gonzalez: http://projects.scottsplayground.com/iri/\n            return empty(value, element) || MetaphorJs.regexp.url.test(value);\n        },\n\n        // http://docs.jquery.com/Plugins/Validation/Methods/date\n        /**\n         * Check if field's value can be parsed as a date.\n         * Empty value passes as success.\n         * @validator date\n         */\n        date: function(value, element) {\n            return empty(value, element) || !/Invalid|NaN/.test(new Date(value));\n        },\n\n        // http://docs.jquery.com/Plugins/Validation/Methods/dateISO\n        /**\n         * Check if field's value can be parsed as a yyyy-mm-dd date.\n         * Empty value passes as success.\n         * @validator dateiso\n         */\n        dateiso: function(value, element) {\n            return empty(value, element) || /^\\d{4}[\\/-]\\d{1,2}[\\/-]\\d{1,2}$/.test(value);\n        },\n\n        // http://docs.jquery.com/Plugins/Validation/Methods/number\n        /**\n         * Check if field's value is a number. Empty value passes as success.\n         * @validator number\n         */\n        number: function(value, element) {\n            return empty(value, element) || /^-?(?:\\d+|\\d{1,3}(?:,\\d{3})+)(?:\\.\\d+)?$/.test(value);\n        },\n\n        // http://docs.jquery.com/Plugins/Validation/Methods/digits\n        /**\n         * Check if field's value only consists of digits. Empty value passes as success.\n         * @validator digits\n         */\n        digits: function(value, element) {\n            return empty(value, element) || /^\\d+$/.test(value);\n        },\n\n        // http://docs.jquery.com/Plugins/Validation/Methods/creditcard\n        // based on http://en.wikipedia.org/wiki/Luhn\n        /**\n         * Check if field's value passes for credit card number. Empty value passes as success.\n         * @validator creditcard\n         */\n        creditcard: function(value, element) {\n\n            if (empty(value, element)) {\n                return true; \n            }\n\n            // accept only digits and dashes\n            if (/[^0-9-]+/.test(value)) {\n                return false;\n            }\n\n            var nCheck \t= 0,\n                bEven \t= false,\n                nDigit,\n                cDigit;\n\n            value = value.replace(/\\D/g, \"\");\n\n            for (var n = value.length - 1; n >= 0; n--) {\n\n                cDigit = value.charAt(n);\n                nDigit = parseInt(cDigit, 10);\n\n                if (bEven) {\n                    if ((nDigit *= 2) > 9) {\n                        nDigit -= 9;\n                    }\n                }\n\n                nCheck \t+= nDigit;\n                bEven \t= !bEven;\n            }\n\n            return (nCheck % 10) == 0;\n        },\n\n        // http://docs.jquery.com/Plugins/Validation/Methods/accept\n        /**\n         * Makes a file upload accept only specified mime-types. \n         * Empty value passes as success.\n         * @param {string} param mime type string\n         */\n        accept: function(value, element, param) {\n            param = isString(param) ? param.replace(/,/g, '|') : \"png|jpe?g|gif\";\n            return empty(value, element) || value.match(new RegExp(\".(\" + param + \")$\", \"i\"));\n        },\n\n        // http://docs.jquery.com/Plugins/Validation/Methods/equalTo\n        /**\n         * Check if field's value equals to another field's value\n         * @validator equalto\n         * @param {*} param Another field's name or id\n         */\n        equalto: function(value, element, param, api) {\n            // bind to the blur event of the target in order to revalidate \n            // whenever the target field is updated\n\n            var f       = api.getValidator().getField(param),\n                target  = f ? f.getElem() : param;\n\n            return value == MetaphorJs.dom.getInputValue(target);\n        },\n\n        /**\n         * Check if field's value does not equal another field's value\n         * @validator notequalto\n         * @param {*} param Another field's name or id\n         */\n        notequalto: function(value, element, param, api) {\n\n            var f       = api.getValidator().getField(param),\n                target  = f ? f.getElem() : param;\n\n            return value != MetaphorJs.dom.getInputValue(target);\n        },\n\n        // this is handled separately, but should be here\n        // so that validator knew that remote method exists\n        remote: function() {\n            return false;\n        },\n\n        /**\n         * Password strength estimator. Expects zxcvbn() \n         * func to be available globally. \n         * @param {*} param \n         */\n        zxcvbn: function(value, element, param) {\n            return zxcvbn(value).score >= parseInt(param);\n        }\n    };\n\n\n}());","require(\"../lib/State.js\");\nrequire(\"./Renderer.js\");\nrequire(\"../func/dom/getAttr.js\");\nrequire(\"../func/dom/removeAttr.js\");\nrequire(\"../func/dom/onReady.js\");\nrequire(\"metaphorjs-shared/src/lib/LocalText.js\");\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\nrequire(\"metaphorjs-shared/src/mixin/Provider.js\");\nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");\n\nconst   cls = require(\"metaphorjs-class/src/cls.js\"),\n        MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n        emptyFn = require(\"metaphorjs-shared/src/func/emptyFn.js\"),\n        toArray = require(\"metaphorjs-shared/src/func/toArray.js\");\n\n/**\n * @class MetaphorJs.app.App\n */\nmodule.exports = MetaphorJs.app.App = cls({\n\n    $mixins: [MetaphorJs.mixin.Observable, \n                MetaphorJs.mixin.Provider],\n\n    lang: null,\n    state: null,\n    renderer: null,\n    cmpPromises: null,\n    cmpListeners: null,\n    components: null,\n    sourceObs: null,\n\n    /**\n     * @constructor\n     * @method\n     * @param {HTMLElement} node \n     * @param {object} data \n     */\n    $init: function(node, data) {\n\n        const self        = this,\n            state       = data instanceof MetaphorJs.lib.State ? \n                                data : \n                                new MetaphorJs.lib.State(data);\n        let args;\n\n        MetaphorJs.dom.removeAttr(node, \"mjs-app\");\n\n        state.$app      = self;\n        self.$super();\n\n        self.lang       = new MetaphorJs.lib.LocalText;\n\n        self.node           = node;\n        self.state          = state;\n        self.cmpListeners   = {};\n        self.components     = {};\n        self.cmpPromises    = {};\n        self.$refs          = {node: {}, cmp: {}};\n\n        self.factory('$parentCmp', ['$node', self.getParentCmp], self);\n        self.value('$app', self);\n        self.value('$rootState', state.$root);\n        self.value('$lang', self.lang);\n        self.value('$locale', self.lang);\n\n        self.renderer       = new MetaphorJs.app.Renderer;\n        self.renderer.on(\"rendered\", self.afterRender, self);\n        self.renderer.on(\"reference\", self._onChildReference, self);\n\n        args = toArray(arguments);\n        args[1] = state;\n        self.initApp.apply(self, args);\n    },\n\n    initApp: emptyFn,\n\n    afterRender: function() {\n\n    },\n\n    _onChildReference: function(type, ref, item) {\n        const self = this;\n        if (!self.$refs[type]) {\n            self.$refs[type] = {};\n        }\n        self.$refs[type][ref] = item;\n    },\n\n    /**\n     * Start processing the DOM\n     * @method\n     */\n    run: function() {\n        this.renderer.process(this.node, this.state);\n    },\n\n    /**\n     * Create data source gate\n     * @param {string} name Source name\n     * @param {string|bool} returnResult See MetaphorJs.lib.Observable.createEvent()\n     */\n    createSource: function(name, returnResult) {\n        var key = \"source-\" + name,\n            self = this;\n\n        if (!self.$$observable.getEvent(key)) {\n            self.$$observable.createEvent(key, returnResult || \"nonempty\");\n        }\n    },\n\n    /**\n     * Register data source\n     * @param {string} name Source name\n     * @param {function} fn Function yielding the data\n     * @param {object} context fn's context\n     */\n    registerSource: function(name, fn, context) {\n        this.on(\"source-\" + name, fn, context);\n    },\n\n    /**\n     * Unregister data source\n     * @param {string} name Source name\n     * @param {function} fn Data function\n     * @param {object} context fn's context\n     */\n    unregisterSource: function(name, fn, context) {\n        this.un(\"source-\" + name, fn, context);\n    },\n\n    /**\n     * Collect data from data source\n     * @param {string} name Source name\n     * @returns {object|array}\n     */\n    collect: function(name) {\n        arguments[0] = \"source-\" + arguments[0];\n        return this.trigger.apply(this, arguments);\n    },\n\n    /**\n     * Get parent component for given node\n     * @param {HTMLElement} node \n     * @param {bool} includeSelf \n     * @returns {MetaphorJs.app.Component}\n     */\n    getParentCmp: function(node, includeSelf) {\n\n        const self    = this;\n        let parent  = includeSelf ? node : node.parentNode,\n            id;\n\n        while (parent && parent !== window.document.documentElement) {\n            //if (id = (MetaphorJs.dom.getAttr(parent, \"cmp-id\") || parent.$$cmpId)) {\n            if (id = parent.$$cmpId) {\n                return self.getCmp(id);\n            }\n            parent = parent.parentNode;\n        }\n\n        return null;\n    },\n\n    /**\n     * Get referenced node from top level\n     * @param {string} name \n     * @returns Node|null\n     */\n    getRefEl: function(name) {\n        return this.$refs['node'][name];\n    },\n\n    /**\n     * Register callback for when component becomes available\n     * @param {string} id \n     * @param {function} fn \n     * @param {object} context \n     * @returns {MetaphorJs.lib.Promise}\n     */\n    onAvailable: function(id, fn, context) {\n\n        const self = this,\n            promises = self.cmpPromises,\n            components = self.components,\n            ev = \"available-\" + id;\n\n        self.$$observable.createEvent(ev);\n\n        if (fn) {\n            self.$$observable.on(ev, fn, context);\n        }\n\n        if (!promises[id]) {\n            promises[id] = new MetaphorJs.lib.Promise;\n            self.$$observable.once(ev, promises[id].resolve, promises[id]);\n        }\n\n        if (components[id]) {\n            self.$$observable.trigger(ev, components[id]);\n        }\n\n        return promises[id];\n    },\n\n    /**\n     * Get component\n     * @param {string} id \n     * @returns {MetaphorJs.app.Component}\n     */\n    getCmp: function(id) {\n        return this.components[id] || null;\n    },\n\n    /**\n     * Register component\n     * @param {MetaphorJs.app.Component} cmp \n     * @param {string} byKey \n     */\n    registerCmp: function(cmp, byKey) {\n        const self = this,\n            id = cmp[byKey],\n            ev = \"available-\" + id,\n            deregister = function() {\n                delete self.cmpPromises[id];\n                delete self.components[id];\n            };\n\n        self.components[id] = cmp;\n        self.$$observable.trigger(ev, cmp);\n\n        if (cmp.on) {\n            cmp.on(\"destroy\", deregister);\n        }\n    },\n\n    onDestroy: function() {\n\n        const self    = this;\n\n        self.renderer.$destroy();\n        self.state.$destroy();\n        self.lang.$destroy();\n\n        self.$super();\n    }\n\n});\n\n","\nrequire(\"../func/dom/getAttr.js\");\nrequire(\"../func/dom/setAttr.js\");\nrequire(\"../func/dom/removeAttr.js\");\nrequire(\"../func/dom/isAttached.js\");\nrequire(\"./Template.js\");\nrequire(\"./Directive.js\");\nrequire(\"./Renderer.js\");\nrequire(\"../func/dom/addClass.js\");\nrequire(\"../func/dom/removeClass.js\");\nrequire(\"../lib/State.js\");\nrequire(\"../lib/Config.js\");\nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\nrequire(\"./Controller.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    emptyFn = require(\"metaphorjs-shared/src/func/emptyFn.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\")\n    htmlTags = require(\"../var/dom/htmlTags.js\");\n\n/**\n * @class MetaphorJs.app.Component\n */\nmodule.exports = MetaphorJs.app.Component = MetaphorJs.app.Controller.$extend({\n\n    /**\n     * @var {boolean}\n     * @access protected\n     */\n    useShadowDOM:   false,\n\n    /**\n     * @var {boolean}\n     * @access protected\n     */\n    replaceCustomNode: true,\n\n    /**\n     * @var {string|HtmlElement}\n     * @access protected\n     */\n    renderTo:       null,\n\n    /**\n     * @var {boolean}\n     */\n    autoRender:     false,\n\n    /**\n     * @var {boolean}\n     */\n    autoAttach:     false,\n\n    /**\n     * @var {bool}\n     * @access protected\n     */\n    destroyEl:      true,\n\n    /**\n     * @var {Template}\n     */\n    template:       null,\n\n    /**\n     * @var {boolean}\n     * @access private\n     */\n    _nodeReplaced:  false,\n\n    /**\n     * @var {boolean}\n     * @access private\n     */\n    _nodeCreated:   false,\n\n    /**\n     * @var {bool}\n     * @access protected\n     */\n    _rendered:      false,\n\n    /**\n     * @var {bool}\n     * @access protected\n     */\n    _attached:      false,\n\n\n    __nodeId:       \"$$cmpId\",\n    __idPfx:        \"cmp-\",\n    __initInstance: \"_initComponent\",\n\n\n    $constructor: function(cfg) {\n        var self = this,\n            viewCls = self.$view || (cfg ? cfg.$view : null);\n\n        // see MetaphorJs.app.component.View\n        viewCls && self.$plugins.push(viewCls);\n        self.$super();\n    },\n\n    /**\n     * @constructor\n     * @param {object} cfg\n     */\n    $init: function() {\n\n        var self    = this;\n        self.$super.apply(self, arguments);\n\n        self.config.getAll(); // calc all values into $cfg\n        self._initTemplate();\n\n        self.afterInitComponent.apply(self, arguments);\n\n        if (self.autoRender) {\n            self.template.resolve()\n                .done(self.template.render, self.template)\n                .done(self.render, self);\n        }\n    },\n\n    // this gets called inside parent's $init\n    _initComponent: function() {\n        var self = this;\n\n        if (self.$view) {   \n            self.state.$view = self.$view;\n        }\n\n        self.initComponent.apply(self, arguments);\n    },\n\n    _initTemplate: function() {\n\n        var self = this,\n            tpl = self.template,\n            rootNode = null,\n            replaceNode = null,\n            attachTo = null,\n            config = self.config;\n\n        if (self.node) {\n            self._nodeReplaced = self.replaceCustomNode && \n                                    htmlTags.indexOf(\n                                        self.node.tagName.toLowerCase()\n                                    ) === -1;\n            if (self._nodeReplaced) {\n                replaceNode = self.node;\n                self.node = null;\n                self.$refs.node.main = null;\n            }\n            else {\n                attachTo = self.node;\n            }\n        }\n\n        if (!tpl && config.has(\"template\")) {\n            tpl = config.get(\"template\");\n        }\n\n        if (!self.node && config.has(\"tag\")) {\n            rootNode = window.document.createElement(config.get(\"tag\"));\n            self.node = rootNode;\n            self.$refs.node.main = rootNode;\n            self._nodeCreated = true;\n            if (self._nodeReplaced && replaceNode.parentNode) {\n                replaceNode.parentNode.replaceChild(replaceNode, rootNode);\n                rootNode = null;\n                attachTo = self.node;\n            }\n        }\n\n        var tplConfig = new MetaphorJs.lib.Config({\n            deferRendering: true,\n            runRenderer: true,\n            useShadow: config.copyProperty(\"useShadow\"),\n            makeTranscludes: config.copyProperty(\"makeTranscludes\")\n        }, { state: self.state });\n\n        attachTo && tplConfig.setStatic(\"useComments\", false);\n        MetaphorJs.app.Template.prepareConfig(tplConfig, tpl);\n\n        self._initTplConfig(tplConfig);\n\n        self.template = tpl = new MetaphorJs.app.Template({\n            state: self.state,\n            config: tplConfig,\n\n            rootNode: rootNode,\n            attachTo: attachTo,\n            replaceNode: replaceNode,\n\n            callback: {\n                context: self,\n                reference: self._onChildReference,\n                rendered: self._onRenderingFinished,\n                attached: self._onTemplateAttached\n            }\n        });\n\n        if (self._nodeCreated) {\n            self.template.setNamedNode(\"main\", self.node);\n        }\n    },\n\n    _initTplConfig: function(config) {},\n\n    initConfig: function() {\n        var self = this;\n        self.$super();\n        self.$self.initConfig(self.config);\n    },\n\n    hasDirective: function(name) {\n        return this.directives && !!this.directives[name];\n    },\n\n    applyDirective: function(name, cfg) {\n        var self = this,\n            support = self.$self.supportsDirectives,\n            dir;\n\n        if (!support) {\n            return;\n        }\n        if (support !== true && !support[name]) {\n            return;\n        }\n\n        if (self._rendered) {\n            dir = MetaphorJs.app.Directive.getDirective(\"attr\", name);\n            if (dir) {\n                MetaphorJs.app.Renderer.applyDirective(\n                    dir.handler, \n                    self._getDirectiveState(), \n                    self, \n                    self._prepareDirectiveCfg(dirCfg)\n                );\n            }\n            else {\n                throw new Error(\"Directive \" + name + \" not found\");\n            }\n        }\n        else {\n            if (!self.directives) {\n                self.directives = {};\n            }\n            if (!self.directives[name]) {\n                self.directives[name] = [cfg];\n            }\n            else {\n                self.directives[name].push(cfg);\n            }\n        }\n    },\n\n    _getDirectiveState: function() {\n        const dirs = this.directives || {};\n        return  dirs.state ||\n                this.parentState ||\n                this.state.$parent || \n                this.config.getOption(\"state\") ||\n                this.state;\n    },\n\n    _prepareDirectiveCfg: function(cfg) {\n\n        if (cfg instanceof MetaphorJs.lib.Config) {\n            return cfg;\n        }\n\n        var self = this,\n            config;\n\n        if (typeof cfg === \"string\") {\n            cfg = {\n                value: {\n                    value: cfg\n                }\n            }\n        }\n\n        config = new MetaphorJs.lib.Config(\n            cfg, \n            { state: self._getDirectiveState() }\n        );\n        self.on(\"destroy\", config.$destroy, config);\n        return config;\n    },\n\n    _initDirectives: function() {\n        var self = this,\n            dirs = self.directives,\n            support = self.$self.supportsDirectives,\n            ds,\n            handlers = MetaphorJs.app.Directive.getAttributes(),\n            i, len, name,\n            j, jlen;\n\n        if (!support) {\n            return;\n        }\n\n        for (i = 0, len = handlers.length; i < len; i++) {\n            name    = handlers[i].name;\n\n            if (!(support === true || support[name])) {\n                continue;\n            }\n\n            if ((ds = dirs[name]) !== undefined) {\n\n                !isArray(ds) && (ds = [ds]);\n\n                for (j = 0, jlen = ds.length; j < jlen; j++) {\n\n                    MetaphorJs.app.Renderer.applyDirective(\n                        handlers[i].handler, \n                        self._getDirectiveState(), \n                        self, \n                        self._prepareDirectiveCfg(ds[j])\n                    );\n                }\n            }\n        }\n    },\n\n    _onChildReference: function(type, ref, item) {\n        var self = this;\n\n        // change comment's reference name so\n        // that it won't get referenced twice\n        if (item) {\n            if (item.nodeType && \n                item.nodeType === window.document.COMMENT_NODE) {\n                item.textContent = \"*\" + self.id + \"*\" + ref + \"*\";\n            }\n            else {\n                if (!self.node && type === \"node\" && ref === \"main\") {\n                    self.node = item;\n                    self._claimNode();\n                }\n                if (self.template instanceof MetaphorJs.app.Template) {\n                    self.template.setNamedNode(ref, item);\n                }\n            }\n        }    \n\n        self.$super.apply(self, arguments);\n    },\n\n\n\n\n\n\n\n\n\n    render: function(parent, before) {\n\n        var self = this;\n\n        if (parent && parent.nodeType === window.document.COMMENT_NODE) {\n            before = parent;\n            parent = parent.parentNode;\n        }\n\n        if (self._rendered) {\n            parent && self.attach(parent, before);\n        }\n        else if (parent) {\n            self.renderTo = parent;\n            self.renderBefore = before;\n        }\n\n        self.onBeforeRender();\n        self.trigger('render', self);\n\n        if (self.template) {\n            self.template.render();\n        }\n    },\n\n    isAttached: function(parent) {\n        return this.template.isAttached(parent);\n    },\n\n    attach: function(parent, before) {\n        var self = this;\n\n        if (!parent) {\n            throw new Error(\"Parent node is required\");\n        }\n\n        self.template.attach(parent, before);\n    },\n\n    detach: function() {\n        var self = this;\n        if (self.template.isAttached()) {\n            self.template.detach();\n        }\n    },\n\n    onBeforeRender: function() {\n    },\n\n    _onRenderingFinished: function() {\n        var self = this;\n\n        self._rendered   = true;\n        self.afterRender();\n        self.trigger('after-render', self);\n\n        if (self.renderTo) {\n            self.template.attach(self.renderTo, self.renderBefore);\n        }\n\n        if (self.directives) {\n            self._initDirectives();\n        }\n    },\n\n\n    _onTemplateAttached: function() {\n        this._attached = true;\n        this.afterAttached();\n        this.trigger('after-attached', this);\n    },\n\n\n\n\n\n\n\n\n    /**\n     * @access public\n     * @return bool\n     */\n    isRendered: function() {\n        return this._rendered;\n    },\n\n    /**\n     * @access public\n     * @return bool\n     */\n    isDestroyed: function() {\n        return this.$destroyed;\n    },\n\n    /**\n     * Returns api (in a simplest case - dom element) \n     * for directive to work with\n     * @param {string} directive \n     */\n    getDomApi: function(directive) {\n        var sup = this.$self.supportsDirectives;\n        if (!sup || !sup[directive]) {\n            return null;\n        }\n        var ref = sup[directive] === true ? \"main\" : sup[directive];\n        return this.getRefEl(ref) || this.getRefElPromise(ref);\n    },\n\n    getInputApi: function() {\n        return null;\n    },\n\n    getApi: function(type, directive) {\n        if (type === \"node\") {\n            return this.getDomApi(directive);\n        }\n        else if (type === \"input\") {\n            return this.getInputApi();\n        }\n    },\n\n    /**\n     * @method\n     * @access protected\n     */\n    beforeInitComponent:  emptyFn,\n\n    /**\n     * @method\n     * @access protected\n     */\n    initComponent:  emptyFn,\n\n    /**\n     * @method\n     * @access protected\n     */\n    afterInitComponent:  emptyFn,\n\n    /**\n     * @method\n     * @access protected\n     */\n    afterRender:    emptyFn,\n\n    /**\n     * @method\n     * @access protected\n     */\n    afterAttached:  emptyFn,\n\n    /**\n     * @method\n     * @access protected\n     */\n    afterDetached:  emptyFn,\n\n\n    \n    onDestroy:      function() {\n\n        var self    = this;\n\n        if (self.template) {\n            self.template.$destroy();\n        }\n\n        if (self.node) {\n            if (self.destroyEl) {\n                if (MetaphorJs.dom.isAttached(self.node)) {\n                    self.node.parentNode.removeChild(self.node);\n                }\n            }\n            else {\n                self._releaseNode();\n            }\n        }\n\n        self.$super();\n    }\n\n}, {\n\n    initConfig: function(config) {\n        var mst = MetaphorJs.lib.Config.MODE_STATIC;\n        config.setType(\"makeTranscludes\", \"bool\", mst, false);\n        config.setType(\"useShadow\", \"bool\", mst, false);\n        config.setDefaultMode(\"tag\", mst);\n    },\n\n    registerWebComponent: function(tagName) {\n        var cls = this;\n        Directive.registerComponent(tagName, cls);\n        return MetaphorJs.dom.webComponentWrapper(tagName, cls);\n    },\n\n    registerDirective: function(cmp) {\n        if (typeof(cmp) === \"string\") {\n            Directive.registerComponent(cmp);\n        }\n        else {\n            Directive.registerComponent(cmp.prototype.$class, cmp);\n        }\n    },\n\n\n    /**\n     * @static\n     * @var {object|bool}\n     */\n    supportsDirectives: false,\n\n    configProps: [],\n\n    createFromPlainObject: function(obj) {\n\n        if (obj instanceof this) {\n            return obj;\n        }\n\n        if (!obj.config) {\n            var config = {},\n                props = this.configProps,\n                i, l, name;\n\n            obj.config = config;\n\n            for (i = 0, l = props.length; i < l; i++) {\n                name = props[i];\n                if (obj[name]) {\n                    config[name] = obj[name];\n                    delete obj[name];\n                }\n            }\n        }\n\n        return new this(obj);\n    }\n});\n","\nrequire(\"./__init.js\");\nrequire(\"./Component.js\");\nrequire(\"./Template.js\");\nrequire(\"./Renderer.js\");\nrequire(\"../func/app/resolve.js\");\nrequire(\"../func/dom/getAttrSet.js\");\nrequire(\"../func/dom/is.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    isPlainObject = require(\"metaphorjs-shared/src/func/isPlainObject.js\"),\n    toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    isThenable = require(\"metaphorjs-shared/src/func/isThenable.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    ns = require(\"metaphorjs-namespace/src/var/ns.js\");\n\nmodule.exports = MetaphorJs.app.Container = MetaphorJs.app.Component.$extend({\n\n    $mixinEvents: [\"$initChildItem\"],\n    _itemsInitialized: false,\n    defaultAddTo: \"main\",\n\n    _initComponent: function() {\n        var self = this;\n\n        self.$super.apply(self, arguments);\n\n        if (self.node && self.template && self.node.firstChild) {\n            self._prepareDeclaredItems(toArray(self.node.childNodes));\n        }\n\n        self._initItems();\n    },\n\n    _initTplConfig: function(tplConfig) {\n        tplConfig.setStatic(\"makeTranscludes\", false);\n        tplConfig.setFinal(\"makeTranscludes\");\n    },\n\n    _prepareDeclaredItems: function(nodes) {\n\n        var self = this,\n            i, l, node, renderer,\n            found = false,\n            idkey = self._getIdKey(),\n            renderRef, attrSet,\n            foundCmp, foundPromise,\n            state = self.state,\n            items = self.items || [],\n            def,\n\n            refCallback = function(type, ref, cmp, cfg, attrSet){\n                if (cfg.node === node) {\n                    foundCmp = cmp;\n                    renderRef = attrSet.at;\n                }\n            },\n\n            promiseCallback = function(promise, cmpName, cfg, attrSet){\n                if (cfg.node === node) {\n                    foundPromise = promise;\n                    renderRef = attrSet.at;\n                }\n            };\n\n        if (!self._itemsInitialized && isArray(items)) {\n            items = {\n                body: items\n            }\n        }\n\n        for (i = 0, l = nodes.length; i < l; i++) {\n            node = nodes[i];\n\n            if (!node) {\n                continue;\n            }\n\n            def = null;\n            if (node.nodeType === window.document.ELEMENT_NODE) {\n\n                if (node[idkey]) {\n                    continue;\n                }\n\n                // detach node\n                node.parentNode && !node.hasAttribute(\"slot\") && \n                    node.parentNode.removeChild(node);\n\n                foundCmp = null;\n                foundPromise = null;\n                renderRef = null;\n                renderer = new MetaphorJs.app.Renderer;\n                state.$on(\"destroy\", renderer.$destroy, renderer);\n                renderer.on(\"reference\", refCallback);\n                renderer.on(\"reference-promise\", promiseCallback);\n                renderer.process(node, state);\n\n                if (foundCmp || foundPromise) {\n                    if (!renderRef) {\n                        renderRef = self.defaultAddTo;\n                    }\n                    def = extend({\n                        type: \"component\",\n                        renderRef: renderRef,\n                        renderer: renderer,\n                        component: foundCmp || foundPromise,\n                        resolved: !!foundCmp\n                    }, self._createDefaultItemDef());\n                    node[idkey] = def.id;\n                }\n                else {\n                    attrSet = MetaphorJs.dom.getAttrSet(node);\n                    renderRef = attrSet.at || attrSet.rest.slot || self.defaultAddTo;\n                    def = extend({\n                        type: \"node\",\n                        renderRef: renderRef,\n                        node: node\n                    }, self._createDefaultItemDef());\n                }\n\n                found = true;\n                renderer.un(\"reference\", refCallback);\n                renderer.un(\"reference-promise\", promiseCallback);\n\n                if (!self._itemsInitialized) {\n                    if (!items[renderRef]) {\n                        items[renderRef] = [];\n                    }\n                    items[renderRef].push(def);\n                }\n                else {\n                    self.addItem(def);\n                }\n            }\n        }\n\n        if (found && !self._itemsInitialized) {\n            self.items = items;\n        }\n\n    },\n\n    _initItems: function() {\n\n        var self = this,\n            items = self.items || [],\n            p2i = self.$self.propsToItems,\n            defs,\n            list = [],\n            item, name,\n            i, l, ref;\n\n        self._itemsInitialized = true;\n        self.itemsMap = {};\n\n        if (isArray(items)) {\n            var tmp = {};\n            tmp[self.defaultAddTo] = items;\n            items = tmp;\n        }\n\n        if (p2i) {\n            for (name in p2i) {\n                if (self[name]) {\n                    self._initIntoItems(self[name], p2i[name]);\n                }\n            }\n        }\n\n        for (ref in items) {\n            defs = items[ref];\n            if (!isArray(defs)) {\n                defs = [defs];\n            }\n            for (i = -1, l = defs.length; ++i < l;) {\n                item = self._processItemDef(defs[i]);\n\n                if (item) {\n                    item.renderRef = ref;\n                    list.push(item);\n                }\n            }\n        }\n\n        self.items = list;\n    },\n\n    _getIdKey: function() {\n        return \"$$container_\" + this.id;\n    },\n\n    _createDefaultItemDef: function() {\n        var id = nextUid();\n        return {\n            __containerItemDef: true,\n            type: \"component\",\n            placeholder: window.document.createComment(\"*\" + this.id + \"*\" + id + \"*\"),\n            id: id,\n            resolved: true,\n            processed: false,\n            attached: false\n        };\n    },\n\n    _processItemDef: function(def, ext) {\n\n        var self = this,\n            idkey = self._getIdKey(),\n            item;\n\n        if (def.__containerItemDef) {\n            item = def;\n            self.itemsMap[item.id] = item;\n        }\n        else {\n            item = self._createDefaultItemDef();\n\n            if (ext) {\n                extend(item, ext, false, false);\n            }\n\n            self.itemsMap[item.id] = item;\n\n            // component[idkey] = item.id\n            // every child component contains `idkey` field\n            // holding its id in parent container;\n            // and by idkey itself we can identify container\n\n            if (typeof def === \"string\") {\n                def = self._initStringItem(def);\n            }\n            if (isPlainObject(def)) {\n                def = self._initObjectItem(def);\n            }\n\n            if (isPlainObject(def)) {\n                item = extend({}, def, item, false, false);\n                self.itemsMap[item.id] = item; // rewrite item map\n            }\n            else if (typeof def === \"function\") {\n                item.component = new def({\n                    state: self.state.$new()\n                });\n            }\n            else if (def instanceof MetaphorJs.app.Component) {\n                item.component = def;\n            }\n            else if (def instanceof window.Node) {\n                item.type = \"node\";\n                item.node = def;\n            }\n            else if (def instanceof MetaphorJs.app.Template) {\n                item.component = new MetaphorJs.app.Component({\n                    state: self.state,\n                    template: def\n                });\n            }\n            else if (typeof def === \"string\") {\n                var cfg = { state: self.state };\n                item.component = MetaphorJs.app.resolve(def, cfg);\n            }\n            else if (isThenable(def)) {\n                item.component = def;\n            }\n            else {\n                throw new Error(\"Failed to initialize item\");\n            }\n        }\n\n        if (!item.processed) {\n\n            var prevItem = item;\n\n            if (!self._allowChildItem(item)) {\n                return null;\n            }\n\n            if (item.type === \"node\") {\n                item = self._wrapChildItem(item);\n                item.node[idkey] = item.id;\n            }\n            else if (item.type === \"component\") {\n                if (isThenable(item.component)) {\n                    item.resolved = false;\n                    item.component.done(function(cmp){\n                        item.component = cmp;\n                        if (!self._allowChildItem(item)) {\n                            return null;\n                        }\n                        item = self._wrapChildItem(item);\n                        item.component[idkey] = item.id;\n                        self._onChildResolved(item.component);\n                    });\n                }\n                else {\n                    item = self._wrapChildItem(item);\n                    item.component[idkey] = item.id;\n                    self._onChildResolved(item.component);\n                }\n            }\n\n            // item got wrapped\n            if (prevItem !== item) {\n                delete self.itemsMap[prevItem.id];\n                self.itemsMap[item.id] = item;\n            }\n\n            self._initChildItem(item);\n            self.$callMixins(\"$initChildItem\", item);\n\n            item.processed = true;\n        }\n\n        return item;\n    },\n\n    _initChildItem: function(item) {},\n\n    _allowChildItem: function(item) {\n        var allow = this.$self.allowItems || [\"*\"];\n        typeof allow === \"string\" && (allow = [allow]);\n        if (allow.indexOf(\"*\") !== -1)  {\n            return true;\n        }\n        if (item.type === \"component\") {\n            return allow.indexOf(item.component.$class) !== -1;\n        }\n        return true;\n    },\n\n    _wrapChildItem: function(item) {\n\n        var self = this,\n            cls = self.$self,\n            allow = cls.allowUnwrapped || [],\n            wrapper = cls.wrapper,\n            wrapCls;\n\n        typeof allow === \"string\" && (allow = [allow]);\n\n        if (!wrapper || allow.indexOf(\"*\") !== -1) {\n            return item;\n        }\n\n        if (item.type === \"component\") {\n\n            if (allow.indexOf(item.component.$class) !== -1) {\n                return item;\n            }\n\n            wrapCls = typeof wrapper === \"string\" || typeof wrapper === \"function\" ? \n                        wrapper :\n                        (wrapper[item.component.$class] || wrapper[\"*\"]);\n            wrapCls = typeof wrapper === \"string\" ? ns.get(wrapper) : wrapper;\n\n            var newItem = self._createDefaultItemDef();\n            newItem.component = new wrapCls({\n                state: self.state,\n                items: [\n                    item.component\n                ]\n            });\n\n            return newItem;\n        }\n\n        return item;\n    },\n\n    _initObjectItem: function(def) {\n        return def;\n    },\n\n    _initStringItem: function(def) {\n        if (def.substring(0,1) === '<') {\n            var div = document.createElement(\"div\");\n            div.innerHTML = def;\n            return div.firstChild;\n        }\n        return def;\n    },\n\n    _initChildEvents: function(mode, cmp) {\n        var self = this;\n        cmp[mode](\"remove-from-container\", self._onChildRemove, self);\n    },\n\n    _onChildRemove: function(cmp) {\n        var self = this,\n            idkey = self._getIdKey(),\n            itemid = cmp[idkey],\n            item, inx;\n\n        if (itemid && (item = self.itemsMap[itemid])) {\n            delete cmp[idkey];\n            delete self.itemsMap[itemid];\n            inx = self.items.indexOf(item);\n            if (cmp instanceof MetaphorJs.app.Component) {\n                self._initChildEvents(\"un\", cmp);\n            }\n            if (inx !== -1) {\n                self.items.splice(inx, 1);\n            }\n            self._detachChildItem(item);\n        }\n    },\n\n    _onChildResolved: function(cmp) {\n        \n        var self = this,\n            idkey = self._getIdKey(),\n            itemid = cmp[idkey],\n            item, ref;\n\n        if (itemid && (item = self.itemsMap[itemid])) {\n            item.resolved = true;\n            item.component = cmp;\n\n            if (ref = cmp.config.get(\"ref\")) {\n                self._onChildReference(\"cmp\", ref, cmp);\n            }\n\n            self._initChildEvents(\"on\", cmp);\n\n            if (self._rendered) {\n                item.component.render();\n                self._putItemInPlace(item);\n            }\n        }\n    },\n\n    _initIntoItems: function(smth, cls) {\n        var self = this,\n            item = self._createDefaultItemDef();\n\n        typeof cls === \"string\" && (cls = ns.get(cls));\n\n        if (!(smth instanceof cls)) {\n            smth = cls.createFromPlainObject(smth);\n        }\n\n        item.component = smth;\n        item.resolved = !isThenable(smth);\n        !self.items && (self.items = []);\n        if (isArray(self.items)) {\n            self.items.push(item);\n        }\n        else {\n            self.items.body.push(item);\n        }\n    },\n\n    render: function() {\n\n        var self = this,\n            items = self.items || [],\n            i, l;\n\n        for (i = -1, l = items.length; ++i < l;){\n            if (items[i].type === \"component\" && items[i].resolved) {\n                items[i].component.render();\n            }\n        }\n\n        self.$super.apply(self, arguments);\n    },\n\n\n    _onTemplateAttached: function() {\n        var self = this, i, l, items = self.items;\n\n        // insert all placeholders, but\n        // attach only resolved items\n        for (i = -1, l = items.length; ++i < l;){\n            self._putItemInPlace(items[i]);\n        }\n\n        self.$super();\n    },\n\n    _putItemInPlace: function(item) {\n        var self = this;\n        if (item.placeholder && !item.placeholder.parentNode) {\n            self._preparePlaceholder(item);\n        }\n        if (item.resolved && !item.attached) {\n            if (item.renderRef) {\n                self.template.setNamedNode(item.renderRef, item.node || item.component);\n            }\n            self._attachChildItem(item);\n        }\n    },\n\n    _preparePlaceholder: function(item) {\n        var self = this,\n            refnode = self.getRefEl(item.renderRef);\n\n        if (item.type === \"node\" && item.node.hasAttribute(\"slot\")) {\n            return;\n        }\n\n        if (!refnode) {\n            throw new Error(\"Can't find referenced node: \" + item.renderRef);\n        }\n\n        // if refnode is <slot> we do nothing;\n        // when attaching, we just set \"slot\" attribute on item\n        if (refnode instanceof window.HTMLSlotElement) {\n            return;\n        }\n\n        // comment\n        if (refnode.nodeType === window.document.COMMENT_NODE) {\n            refnode.parentNode.insertBefore(item.placeholder, refnode);\n        }\n        else refnode.appendChild(item.placeholder);\n    },\n\n    // only resolved components get here; so do attach\n    _attachChildItem: function(item) {\n        var self = this,\n            refnode = self.getRefEl(item.renderRef);\n\n        if (item.attached) {\n            return;\n        }\n\n        if (item.type === \"node\") {\n            if (item.node.hasAttribute(\"slot\")) {\n                item.attached = true;\n                return;\n            }\n            if (refnode instanceof window.HTMLSlotElement) {\n                item.node.setAttribute(\"slot\", refnode.getAttribute(\"name\"));\n            }\n            else if (refnode.nodeType === window.document.COMMENT_NODE) {\n                refnode.parentNode.insertBefore(item.node, item.placeholder);\n            }\n            else {\n                refnode.insertBefore(item.node, item.placeholder);\n            }\n        }\n        else if (item.type === \"component\") {\n            if (refnode.nodeType === window.document.COMMENT_NODE)\n                item.component.render(refnode.parentNode, item.placeholder);    \n            else item.component.render(refnode, item.placeholder);\n        }\n\n        item.attached = true;\n    },\n\n    _detachChildItem: function(item) {\n        if (!item.attached) {\n            return;\n        }\n        if (item.type === \"node\") {\n            item.node.parentNode && item.node.parentNode.removeChild(item.node);\n        }\n        else if (item.type === \"component\") {\n            item.component.detach();\n            item.placeholder.parentNode && \n                item.placeholder.parentNode.removeChild(item.placeholder);\n        }\n        item.attached = false;\n    },\n\n    hasItem: function(cmp) {\n        var self = this,\n            idkey = self._getIdKey(),\n            id,\n            item;\n\n        if (typeof cmp === \"string\" || typeof cmp === \"function\") {\n            for (id in self.itemMap) {\n                item = self.itemMap[id];\n                if (item.type === \"component\" && \n                    (item.componet.id === cmp || item.component.$is(cmp))) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        else return !!cmp[idkey];\n    },\n\n    hasItemIn: function(ref, smth) {\n        if (!this.items[ref] || this.items[ref].length === 0) {\n            return false;\n        }\n        var i, l, item;\n        for (i = 0, l = this.items[ref].length; i < l; i++) {\n            item = this.items[ref][i];\n            if (item.type === \"component\") {\n                if (item.component.$is(smth)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n\n    addItem: function(cmp, to) {\n        var self = this,\n            item;\n\n        if (self.hasItem(cmp)) {\n            return;\n        }\n\n        if (cmp instanceof MetaphorJs.app.Component) {\n            cmp.trigger(\"remove-from-container\", cmp);\n        }\n\n        item = self._processItemDef(cmp, {\n            renderRef: to || self.defaultAddTo\n        });\n        self.items.push(item);\n\n        // component item got attached via onChildResolved\n        if (item.type === \"node\" && self._attached) {\n            self._putItemInPlace(item);\n        }\n    },\n\n    removeItem: function(cmp) {\n        var self = this;\n\n        if (!self.hasItem(cmp)) {\n            return;\n        }\n\n        if (cmp instanceof MetaphorJs.app.Component) {\n            cmp.trigger(\"remove-from-container\", cmp);\n        }\n        else {\n            self._onChildRemove(cmp);\n        }\n    },\n\n    onDestroy: function() {\n\n        var self = this,\n            i, l, item;\n\n        for (i = 0, l = self.items.length; i < l; i++) {\n            item = self.items[i];\n            if (item.renderer) {\n                item.renderer.$destroy();\n            }\n            if (item.type === \"component\") {\n                item.component.$destroy && item.component.$destroy();\n            }\n        }\n        self.items = null;\n\n        self.$super();\n    }\n}, {\n\n    allowItems: [\"*\"],\n    allowUnwrapped: [\"*\"],\n    wrapper: null\n\n});","\n\nrequire(\"../lib/State.js\");\nrequire(\"../lib/Config.js\");\nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    emptyFn = require(\"metaphorjs-shared/src/func/emptyFn.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    isThenable = require(\"metaphorjs-shared/src/func/isThenable.js\");\n\n/**\n * @class MetaphorJs.app.Controller\n */\nmodule.exports = MetaphorJs.app.Controller = cls({\n\n    $mixins: [MetaphorJs.mixin.Observable],\n    $mixinEvents: [\"$initConfig\"],\n\n    /**\n     * @access protected\n     * @var {string}\n     */\n    id:             null,\n\n    /**\n     * @var {HtmlElement}\n     * @access protected\n     */\n    node:           null,\n\n    /**\n     * @var {MetaphorJs.lib.State}\n     */\n    state:          null,\n\n    /**\n     * @var {MetaphorJs.app.Renderer}\n     */\n    parentRenderer: null,\n\n    /**\n     * @var {MetaphorJs.lib.Config}\n     */\n    config:         null,\n\n    /**\n     * @var {bool}\n     */\n    destroyState:   false,\n\n\n    __nodeId:       \"$$ctrlId\",\n    __idPfx:        \"ctrl-\",\n    __initInstance: \"initController\",\n\n\n    /**\n     * @constructor\n     * @param {object} cfg\n     */\n    $init: function(cfg) {\n\n        let self    = this,\n            state,\n            config;\n\n        cfg = cfg || {};\n\n        self._protoCfg = self.config;\n        self.config = null;\n        self.$super(cfg);\n        extend(self, cfg, true, false);\n\n        if (!self.state || (typeof(self.state) === \"string\" && \n                            self.state.indexOf(\":new\") !== -1)) {\n            self.destroyState = true;\n        }\n        state = self.state = MetaphorJs.lib.State.$produce(self.state);\n\n        // We initialize config with current state or change config's state\n        // to current so that all new properties that come from initConfig\n        // are bound to local state. \n        // All pre-existing properties are already bound to outer state;\n        // Also, each property configuration can have its own state specified\n        config = self.config = MetaphorJs.lib.Config.create(\n            self.config,\n            { state }, \n            /*scalarAs: */\"defaultValue\"\n        )\n        config.setOption(\"state\", state);\n        state.$cfg = {};\n        config.setTo(state.$cfg);\n        self.initConfig();\n        self.$callMixins(\"$initConfig\", config);\n        if (self._protoCfg) {\n            config.addProperties(\n                self._protoCfg, \n                /*scalarAs: */\"defaultValue\"\n            );\n        }\n\n        self.id = config.get(\"id\");\n        self.$refs = {node: {}, cmp: {}};\n        if (self.node) {\n            self.$refs.node.main = self.node;\n        }\n\n        if (config.has(\"init\")) {\n            config.get(\"init\")(state);\n        }\n        if (config.has(\"as\")) {\n            state[config.get(\"as\")] = self;\n        }\n\n        self[self.__initInstance].apply(self, arguments);\n\n        if (state.$app) {\n            state.$app.registerCmp(self, \"id\");\n        }\n\n        if (self.parentRenderer) {\n            self.parentRenderer.on(\"destroy\", self._onParentRendererDestroy, self);\n        }\n\n        self._claimNode();\n    },\n\n    initConfig: function() {\n        var self = this,\n            state = self.state,\n            config = self.config,\n            mst = MetaphorJs.lib.Config.MODE_STATIC;\n\n        config.setType(\"id\", \"string\", mst, self.id || self.__idPfx + nextUid())\n        self.$self.initConfig(config);\n\n        if (self.as) {\n            config.setDefaultValue(\"as\", self.as);\n        }\n\n        MetaphorJs.lib.Observable.$initHostConfig(self, config, state, self.node);\n    },\n\n    _claimNode: function() {\n        var self = this;\n        self.node && (self.node[self.__nodeId] = self.id);\n    },\n\n    _releaseNode: function() {\n        var self = this;\n        self.node && (self.node[self.__nodeId] = null);\n    },\n\n    _onChildReference: function(type, ref, item) {\n        var self = this;\n\n        if (!self.$refs[type]) {\n            self.$refs[type] = {};\n        }\n\n        var th = self.$refs[type][ref];\n\n        if (!th) {\n            self.$refs[type][ref] = item;\n        }\n        if (isThenable(th)) {\n            th.resolve(item);\n        }\n    },\n\n\n    getRefEl: function(name) {\n        return this.$refs['node'][name];\n    },\n\n    getRefCmp: function(name) {\n        return this.$refs['cmp'][name];\n    },\n\n\n    _getRefPromise: function(type, name) {\n        var ref = this.$refs[type][name];\n        if (!ref) {\n            return this.$refs[type][name] = new MetaphorJs.lib.Promise;\n        }\n        else if (isThenable(ref)) {\n            return ref;\n        }\n        else {\n            return MetaphorJs.lib.Promise.resolve(ref);\n        }\n    },\n\n    getRefElPromise: function(name) {\n        return this._getRefPromise(\"node\", name);\n    },\n\n    getRefCmpPromise: function(name) {\n        return this._getRefPromise(\"cmp\", name);\n    },\n\n    /**\n     * @access public\n     * @return Element\n     */\n    getEl: function() {\n        return this.node;\n    },\n\n\n    /**\n     * @access public\n     * @return bool\n     */\n    isDestroyed: function() {\n        return this.$$destroyed;\n    },\n\n    /**\n     * @method\n     * @access protected\n     */\n    initController:  emptyFn,\n\n    \n    _onParentRendererDestroy: function() {\n        this.$destroy();\n    },\n\n    onDestroy:      function() {\n\n        if (this.destroyState && this.state) {\n            this.state.$destroy();\n        }\n\n        this._releaseNode();\n        this.config.$destroy();\n        this.$super();\n    }\n\n}, {\n    initConfig: function(config) {\n        const mst = MetaphorJs.lib.Config.MODE_STATIC;\n        config.setMode(\"init\", MetaphorJs.lib.Config.MODE_FUNC);\n        config.setDefaultMode(\"as\", mst);\n        config.setDefaultMode(\"state\", mst);\n    }\n});\n","\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\nrequire(\"../lib/Expression.js\");\nrequire(\"../lib/MutationObserver.js\");\nrequire(\"../func/dom/commentWrap.js\");\nrequire(\"../lib/Config.js\");\nrequire(\"../func/dom/isField.js\");\nrequire(\"../lib/Input.js\");\nrequire(\"metaphorjs-observable/src/lib/Observable.js\");\nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");\n\nconst isString = require(\"metaphorjs-shared/src/func/isString.js\"),\n    isThenable = require(\"metaphorjs-shared/src/func/isThenable.js\"),\n    async = require(\"metaphorjs-shared/src/func/async.js\"),\n    cls = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    ns = require(\"metaphorjs-namespace/src/var/ns.js\");\n\n\nmodule.exports = MetaphorJs.app.Directive = (function() {\n\n    var attr = {},\n        tag = {},\n        component = {},\n        attributes          = [],\n        attributesSorted    = false,\n        compare             = function(a, b) {\n            return a.priority - b.priority;\n        }\n\n    MetaphorJs.directive = MetaphorJs.directive || {\n        attr: attr,\n        tag: tag,\n        component: component\n    };\n\n    return cls({\n\n        $mixins: [MetaphorJs.mixin.Observable],\n\n        state: null,\n        node: null,\n        component: null,\n        attrSet: null,\n        renderer: null,\n        wrapperOpen: null,\n        wrapperClose: null,\n\n        _apis: [\"node\"],\n        _autoOnChange: true,\n        _initPromise: null,\n        _nodeAttr: null,\n        _initial: true,\n        _asyncInit: false,\n\n        $init: function(state, node, config, renderer, attrSet) {\n\n            var self        = this;\n\n            self.state      = state;\n            self.config     = config;\n            self.renderer   = renderer;\n            self.attrSet    = attrSet;\n            self._nodeAttr  = node;\n\n            self.initConfig();\n            self.initState();\n\n            self._asyncInit && self.initAsyncInit();\n            self.initNodeAttr();\n\n            self._initPromise ? \n                self._initPromise.done(self.initDirective, self) :\n                self.initDirective();\n        },\n\n        initAsyncInit: function() {\n            var self = this;\n            self._initPromise = new MetaphorJs.lib.Promise;\n            var asnc = new MetaphorJs.lib.Promise;\n            self._initPromise.after(asnc);\n\n            async(function(){\n                if (!self.$destroyed) {\n                    asnc.resolve();\n                }\n            });\n        },\n\n        initNodeAttr: function() {\n            var self = this,\n                node = self._nodeAttr;\n\n            if (node instanceof window.Node) {\n                self.node = node;\n                self.initNode(node);\n                self._initPromise && self._initPromise.resolve();\n            }\n            else if (node.$is && node.$is(\"MetaphorJs.app.Component\")) {\n                self.component = node;\n                self.initComponent(node);\n                self._initPromise && self._initPromise.resolve();\n            }\n            else if (isThenable(node)) {\n                node.done(function(node){ self._nodeAttr = node })\n                    .done(self.initNodeAttr, self);\n            }\n        },\n\n        initConfig: function() {\n            var config = this.config;\n            this.$self.initConfig(config, this);\n            MetaphorJs.lib.Observable.$initHostConfig(this, config, this.state);\n        },\n\n        initState: function() {\n            this.state.$on(\"destroy\", this.onStateDestroy, this);\n            this.state.$on(\"reset\", this.onStateReset, this);\n        },\n\n        initComponent: function(component) {\n            var self = this,\n                apis = self._apis,\n                i, l, res;\n            for (i = 0, l = apis.length; i < l; i++) {\n                res = self.initApi(component, apis[i]);\n                if (isThenable(res)) {\n                    !self._initPromise && \n                        (self._initPromise = new MetaphorJs.lib.Promise);\n                    self._initPromise.after(res);\n                }\n            }\n        },\n\n        initNode: function(node) {\n            if (this._apis.indexOf(\"input\") !== -1 && \n                MetaphorJs.dom.isField(node)) {\n                this.input = MetaphorJs.lib.Input.get(node, this.state);\n            }\n        },\n\n        initApi: function(component, apiType) {\n            var self = this,\n                api = component.getApi(apiType, self.id);\n            if (isThenable(api)) {\n                return api.done(function(api){\n                    self._onApiResolved(apiType, api);\n                });\n            }\n            else self._onApiResolved(apiType, api);\n        },\n\n        _onApiResolved: function(apiType, api) {\n            this[apiType] = api;\n        },\n\n        initDirective: function() {\n            this.initChange();\n        },\n\n        initChange: function() {\n            var self = this,\n                val;\n            self.config.on(\"value\", self.onStateChange, self);\n            if (self._autoOnChange && (val = self.config.get(\"value\")) !== undefined) {\n                self.onStateChange(val, undefined);\n            }\n        },\n\n        createCommentWrap: function(node, name) {\n            var cmts = MetaphorJs.dom.commentWrap(node, name || this.$class);\n            this.wrapperOpen = cmts[0];\n            this.wrapperClose = cmts[1];\n        },\n\n        onStateDestroy: function() {\n            this.$destroy();\n        },\n\n        onStateReset: function() {},\n\n        onStateChange: function(val) {\n            this.saveStateOnChange(val);\n        },\n\n        saveStateOnChange: function(val) {\n            if (this._prevState !== undefined) {\n                this.trigger(\"change\", val, this._prevState);\n            }\n            this._prevState = val;\n        },\n\n        onDestroy: function() {\n            var self    = this;\n\n            if (isThenable(self.node)) {\n                self.node.$destroy();\n            }\n\n            if (self._initPromise) {\n                self._initPromise.$destroy();   \n            }\n\n            if (self.state) {\n                self.state.$un(\"destroy\", self.onStateDestroy, self);\n                self.state.$un(\"reset\", self.onStateReset, self);\n            }\n\n            if (self.config) {\n                self.config.$destroy();\n            }\n\n            if (self.wrapperOpen && self.wrapperOpen.parentNode) {\n                self.wrapperOpen.parentNode.removeChild(self.wrapperOpen);\n            }\n            if (self.wrapperClose && self.wrapperClose.parentNode) {\n                self.wrapperClose.parentNode.removeChild(self.wrapperClose);\n            }\n\n            self.$super();\n        }\n    }, {\n\n        attr: {},\n        tag: {},\n\n        /**\n         * Get directive by name\n         * @static\n         * @method\n         * @param {string} type \n         * @param {string} name \n         */\n        getDirective: function(type, name) {\n            return ns.get(\"MetaphorJs.directive.\" + type +\".\"+ name);\n        },\n\n        /**\n         * Register attribute directive\n         * @param {string} name Attribute name\n         * @param {int} priority \n         * @param {function|MetaphorJs.app.Directive} handler \n         */\n        registerAttribute: function registerAttribute(name, priority, handler) {\n            if (!attr[name]) {\n                attributes.push({\n                    priority: priority,\n                    name: name,\n                    handler: attr[name] = handler\n                });\n                attributesSorted = false;\n            }\n        },\n\n        /**\n         * Get attribute directives sorted by priority\n         * @static\n         * @method\n         * @returns {array}\n         */\n        getAttributes: function getAttributes() {\n            if (!attributesSorted) {\n                attributes.sort(compare);\n                attributesSorted = true;\n            }\n            return attributes;\n        },\n\n        /**\n         * Register tag directive\n         * @param {string} name Tag name (case insensitive)\n         * @param {function|MetaphorJs.app.Directive} handler \n         */\n        registerTag: function registerTag(name, handler) {\n            if (!tag[name]) {\n                tag[name] = handler;\n            }\n        },\n\n        /**\n         * Register tag component\n         * @param {string} name Tag name (case sensitive)\n         * @param {MetaphorJs.app.Component} cmp \n         */\n        registerComponent: function(name, cmp) {\n            if (!cmp) {\n                cmp = name;\n            }\n            if (isString(cmp)) {\n                cmp = ns.get(cmp, true);\n            }\n            if (!component[name]) {\n                component[name] = cmp;\n            }\n        },\n\n        /**\n         * Resolve received something into a dom node.\n         * @param {Promise|Node|Component} node \n         * @param {string} directive Directive name\n         * @param {function} cb {\n         *  @param {Node} node\n         *  @param {MetaphorJs.app.Component} cmp\n         * }\n         * @param {string} apiType {\n         *  node|input|...\n         *  @default resolveNode\n         * }\n         */\n        resolveNode: function(node, directive, cb, apiType) {\n            if (node instanceof window.Node){\n                cb(node);\n            }\n            else if (node.getApi) {\n                var cmp = node;\n                node = node.getApi(apiType || \"node\", directive);\n                if (isThenable(node)) {\n                    node.done(function(node){\n                        cb(node, cmp);\n                    });\n                }\n                else if (node) {\n                    cb(node, cmp);\n                }\n            }\n        },\n\n        /**\n         * Static config initializer called from instance's initConfig\n         * or from template prebuilder\n         * @static\n         * @protected\n         * @method\n         * @param {MetaphorJs.lib.Config} config\n         * @param {function|Metaphor.app.Directive} instance\n         */\n        initConfig: function(config, instance) {\n            var msl = MetaphorJs.lib.Config.MODE_LISTENER;\n            config.setDefaultMode(\"callbackContext\", MetaphorJs.lib.Config.MODE_SINGLE);\n            config.eachProperty(function(name) {\n                if (name.substring(0,4) === 'on--') {\n                    config.setMode(name, msl);\n                }\n            });\n        }\n    });\n}());\n","\nrequire(\"../func/dom/commentWrap.js\");\nrequire(\"../func/dom/getAttr.js\");\nrequire(\"../func/dom/toFragment.js\");\nrequire(\"./Renderer.js\");\nrequire(\"metaphorjs-shared/src/lib/Queue.js\");\nrequire(\"../lib/MutationObserver.js\");\nrequire(\"../lib/Config.js\");\nrequire(\"metaphorjs-animate/src/animate/animate.js\");\nrequire(\"metaphorjs-animate/src/animate/isCssSupported.js\");\nrequire(\"../func/app/prebuilt.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    emptyFn = require(\"metaphorjs-shared/src/func/emptyFn.js\"),\n    isNull = require(\"metaphorjs-shared/src/func/isNull.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    isNumber = require(\"metaphorjs-shared/src/func/isNumber.js\"),\n    isPrimitive = require(\"metaphorjs-shared/src/func/isPrimitive.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    isFunction = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    levenshteinDiff = require(\"metaphorjs-shared/src/func/levenshteinDiff.js\"),\n    levenshteinMove = require(\"metaphorjs-shared/src/func/levenshteinMove.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.app.ListRenderer = cls({\n\n    id: null,\n    config: null,\n    state: null,\n    listSourceExpr: null,\n    itemStateName: null,\n\n    _tagMode: false,\n    _animateMove: false,\n    _animate: false,\n    _buffered: false,\n    _trackBy: null,\n    _parentRenderer: null,\n    _template: null,\n    _items: null,\n    _prevEl: null,\n    _nextEl: null,\n    _renderQueue: null,\n    _attachQueue: null,\n    _mo: null,\n    _trackByFn: null,\n    _filterFn: null,\n    _localTrack: false,\n    _griDelegate: null,\n\n    $constructor: function(state, node, config, parentRenderer, attrSet) {\n\n        var self = this;\n\n        self.config         = config;\n        self.state          = state;\n        self.initConfig();\n\n        self._tagMode       = node.nodeName.toLowerCase() === \"mjs-each\";\n        self._animateMove   = !self._tagMode && \n                                !config.hasValue(\"buffered\") &&\n                                config.get(\"animateMove\") && \n                                MetaphorJs.animate.isCssSupported();\n\n        self._animate       = !self._tagMode && \n                                !config.hasValue(\"buffered\") && \n                                config.get(\"animate\");\n\n        if (self._animate) {\n            self.$plugins.push(config.get(\"animatePlugin\"));\n        }\n\n        if (config.hasValue(\"observable\")) {\n            self.$plugins.push(\"MetaphorJs.plugin.Observable\");\n        }\n\n        if (config.hasValue(\"buffered\") && !self._tagMode) {\n            self._buffered = true;\n            var buff = config.get(\"buffered\");\n            buff === true && (buff = config.getProperty(\"buffered\").defaultValue);\n            self.$plugins.push(buff);\n        }\n\n        if (config.has('plugin')) {\n            self.$plugins.push(config.get(\"plugin\"));\n        }\n\n        if (config.has(\"filter\")) {\n            self._filterFn = config.get(\"filter\");\n            if (typeof self._filterFn !== \"function\") {\n                throw new Error(\"{each.$filter} must be a function\");\n            }\n        }\n\n        self._trackBy = config.get(\"trackBy\");\n    },\n\n    $init: function(state, node, config, parentRenderer, attrSet) {\n\n        var self = this,\n            expr = self._tagMode ? \n                        MetaphorJs.dom.getAttr(node, \"value\") : \n                        config.getExpression(\"value\");\n\n        self._parseExpr(expr);\n\n        self._template  = self._tagMode ? \n                            MetaphorJs.dom.toFragment(node.childNodes) : \n                            node;\n        self._items     = [];\n        self.id         = config.has('id') ? config.get('id') : nextUid();\n\n        if (!self._trackBy && self._trackBy !== false) {\n            self._localTrack = true;\n        }\n\n        var cmts = MetaphorJs.dom.commentWrap(node,  \"list-\" + self.id);\n        self._prevEl    = cmts[0];\n        self._nextEl    = cmts[1];\n\n        self._parentRenderer    = parentRenderer;\n        self._renderQueue       = new MetaphorJs.lib.Queue({\n            async: false, auto: true, thenable: true,\n            stack: false, context: self, mode: MetaphorJs.lib.Queue.ONCE\n        });\n        self._attachQueue       = new MetaphorJs.lib.Queue({\n            async: \"raf\", auto: true, thenable: true,\n            stack: false, context: self, mode: MetaphorJs.lib.Queue.ONCE\n        });\n\n        node.parentNode.removeChild(node);\n\n        self.initDataSource();\n        self.state.$app.registerCmp(self, \"id\");\n\n        self._renderQueue.add(self.render, self, [self.getList()]);\n    },\n\n    getList: function() {\n        var list = toArray(this._mo.getValue()),\n            i, l, filter = this._filterFn;\n\n        if (filter) {\n            var all = list;\n            list = [];\n            for (i = 0, l = all.length; i < l; i++) {\n                if (filter(all[i])) {\n                    list.push(all[i]);\n                }\n            }\n        }\n        return list;\n    },\n\n    initConfig: function() {\n        var config = this.config,\n            ms = MetaphorJs.lib.Config.MODE_STATIC;\n        config.setType(\"animate\", \"bool\", ms, false);\n        config.setType(\"animateMove\", \"bool\", ms, false);\n        config.setDefaultMode(\"trackBy\", ms);\n        config.setDefaultMode(\"id\", ms);\n        config.setDefaultMode(\"plugin\", ms);\n        config.setType(\"observable\", \"bool\", ms, false);\n        config.setDefaultValue(\"buffered\", \"MetaphorJs.plugin.ListBuffered\");\n        config.setType(\"animatePlugin\", null, ms, \"MetaphorJs.plugin.ListAnimated\");\n    },\n\n    initDataSource: function() {\n\n        var self        = this;\n        self._mo        = MetaphorJs.lib.MutationObserver.get(\n                            self.state, self.listSourceExpr, \n                            self.onChange, self,\n                            {\n                                localFilter: bind(self.localTracklistFilter, self)\n                            }\n                        );\n        if (self._localTrack && !self._trackBy) {\n            self._trackBy = \"$$\" + self._mo.id;\n        }\n        self._griDelegate = bind(self.stateGetRawIndex, self);\n    },\n\n    trigger: emptyFn,\n\n    /*\n     * <!-- render and re-render\n     */\n\n    render: function(list) {\n\n        var self        = this,\n            items       = self._items,\n            tpl         = self._template,\n            i, len;\n\n        for (i = 0, len = list.length; i < len; i++) {\n            items.push(self.createItem(tpl.cloneNode(true), list, i));\n        }\n\n        self.renderOrUpdate();\n        self._attachQueue.add(self.attachAllItems, self);\n    },\n\n    createItem: function(el, list, index) {\n\n        var self        = this,\n            iname       = self.itemStateName,\n            itemState   = self.state.$new(),\n            tm          = self._tagMode;\n\n        itemState.$on(\"changed\", self.state.$check, self.state);\n\n        itemState[iname]    = self.getListItem(list, index);\n        el = tm ? toArray(el.childNodes) : el;\n\n        return {\n            index: index,\n            action: \"enter\",\n            el: el,\n            placeholder: window.document.createComment(\"*list*\" + index + \"*\"),\n            state: itemState,\n            attached: false,\n            rendered: false,\n            hidden: false\n        };\n    },\n\n    attachAllItems: function() {\n\n        var self        = this,\n            fragment    = window.document.createDocumentFragment(),\n            items       = self._items,\n            tm          = self._tagMode,\n            i, len;\n\n        for (i = 0, len = items.length; i < len; i++) {\n\n            if (!items[i].hidden) {\n                if (tm) {\n                    fragment.appendChild(MetaphorJs.dom.toFragment(items[i].el));\n                }\n                else {\n                    fragment.appendChild(items[i].el);\n                }\n                items[i].attached = true;\n                fragment.appendChild(items[i].placeholder);\n            }\n        }\n\n        self._nextEl.parentNode && \n            self._nextEl.parentNode.insertBefore(fragment, self._nextEl);\n        self.trigger(\"attached\", self);\n    },\n\n    renderOrUpdate: function(start, end, action, renderOnly) {\n\n        var self        = this,\n            items       = self._items,\n            index       = start || 0,\n            cnt         = items.length,\n            x           = end || cnt - 1,\n            list        = self.getList(),\n            trackByFn   = self.getTrackByFunction();\n\n        if (x > cnt - 1) {\n            x = cnt - 1;\n        }\n\n        for (; index <= x; index++) {\n\n            if (action && items[index].action !== action) {\n                continue;\n            }\n\n            self.renderItem(index, items, list, trackByFn, renderOnly);\n        }\n    },\n\n    renderItem: function(index, items, list, trackByFn, renderOnly) {\n\n        const self = this;\n\n        list = list || self.getList();\n        items = items || self._items;\n        trackByFn = trackByFn || self.getTrackByFunction();\n\n        const   item        = items[index],\n                state       = item.state,\n                last        = items.length - 1,\n                even        = !(index % 2);\n\n        if (renderOnly && item.rendered) {\n            return;\n        }\n\n        state.$index    = index;\n        state.$first    = index === 0;\n        state.$last     = index === last;\n        state.$even     = even;\n        state.$odd      = !even;\n        state.$trackId  = trackByFn(list[index]);\n        state.$getRawIndex = self.griDelegate;\n\n        if (!item.renderer) {\n            item.renderer  = new MetaphorJs.app.Renderer;\n            state.$on(\"destroy\", item.renderer.$destroy, item.renderer);\n            item.renderer.process(item.el, state);\n            item.rendered = true;\n        }\n        else {\n            state.$check();\n        }\n    },\n\n\n    \n\n    /*\n     * render and re-render -->\n     */\n\n    /*\n     * <!-- reflect changes\n     */\n\n    onChange: function(current, prev) {\n        var self = this;\n        self._renderQueue.prepend(self.applyChanges, self, [prev], \n                                    MetaphorJs.lib.Queue.REPLACE);\n    },\n\n    applyChanges: function(prevList) {\n\n        \n\n        var self        = this,\n            items       = self._items,\n            tpl         = self._template,\n            index       = 0,\n            list        = self.getList(),\n            updateStart = null,\n            animateMove = self._animateMove,\n            newItems    = [],\n            iname       = self.itemStateName,\n            origItems   = items.slice(),\n            doesMove    = false,\n            prevItem,\n            prevItemInx,\n            i, len,\n            item,\n            action;\n\n        // if we don't track items, we just re-render the whole list\n        if (!self._trackBy) {\n            items = self._items.slice();\n            updateStart = 0;\n            doesMove = false;\n            for (i = 0, len = list.length; i < len; i++) {\n                item = self.createItem(tpl.cloneNode(true), list, i);\n                newItems.push(item);\n            }\n        }\n        // if items are tracked\n        else {\n            // we generate a move prescription\n            // by finding an array difference.\n            // But we don't compare original arrays, \n            // we only compare list of ids - \n            // since we only care about position change.\n            var prevTrackList = self.getTrackList(prevList),\n                trackList = self.getTrackList(list),\n                prs = levenshteinDiff(prevTrackList, trackList),\n                movePrs = levenshteinMove(\n                    prevTrackList, trackList, \n                    prs.prescription, \n                    function(item) { return item }\n                );\n\n            // move prescription is a list of instructions\n            // of the same length as new list of items.\n            // it either contains number - index of \n            // item in the old list, or something else\n            // which basically means - create a new item\n            for (i = 0, len = movePrs.length; i < len; i++) {\n\n                action = movePrs[i];\n\n                // int entry is a position of old item\n                // in the new order of things.\n                if (isNumber(action)) {\n                    prevItemInx = action;\n                    prevItem    = items[prevItemInx];\n\n                    if (prevItemInx !== index && isNull(updateStart)) {\n                        updateStart = i;\n                    }\n\n                    prevItem.action = \"move\";\n                    prevItem.state[iname] = self.getListItem(list, i);\n                    doesMove = animateMove;\n\n                    newItems.push(prevItem);\n                    items[prevItemInx] = null;\n                    index++;\n                }\n                else {\n                    if (isNull(updateStart)) {\n                        updateStart = i;\n                    }\n                    item = self.createItem(tpl.cloneNode(true), list, i);\n                    newItems.push(item);\n                    // add new elements to old renderers\n                    // so that we could correctly determine positions\n                }\n            }\n        }\n\n        self._items  = newItems;\n\n        self.reflectChanges({\n            oldItems:       items,\n            updateStart:    updateStart,\n            newItems:       newItems,\n            origItems:      origItems,\n            doesMove:       doesMove\n        });\n    },\n\n\n    reflectChanges: function(vars) {\n        var self = this;\n        self.renderOrUpdate();\n        self.applyDomPositions(vars.oldItems);\n        self.removeOldElements(vars.oldItems);\n        self.trigger(\"change\", self);\n    },\n\n\n\n    removeOldElements: function(items) {\n        var i, len, item,\n            j, jl,\n            self = this,\n            tm = self._tagMode;\n\n        for (i = 0, len = items.length; i < len; i++) {\n            item = items[i];\n            if (item && item.attached) {\n                item.attached = false;\n                if (!tm) {\n                    item.el.parentNode && item.el.parentNode.removeChild(item.el);\n                }\n                else {\n                    for (j = 0, jl = item.el.length; j < jl; j++) {\n                        if (item.el[j].parentNode) {\n                            item.el[j].parentNode.removeChild(item.el[j]);\n                        }\n                    }\n                }\n                item.placeholder.parentNode && \n                    item.placeholder.parentNode.removeChild(item.placeholder);\n            }\n            if (item && item.state) {\n                item.state.$destroy();\n                item.rendered = false;\n            }\n        }\n    },\n\n\n    applyDomPositions: function() {\n\n        var self        = this,\n            items       = self._items,\n            tm          = self._tagMode,\n            nc          = self._nextEl,\n            next, parent,\n            i, j, l, el, item, first;\n\n        for (i = 0, l = items.length; i < l; i++) {\n            item = items[i];\n            el = item.el;\n            next = null;\n\n            if (item.hidden) {\n                if (tm) {\n                    MetaphorJs.dom.toFragment(el);\n                }\n                else if (el.parentNode) { \n                    el.parentNode.removeChild(el);\n                }\n                item.placeholder.parentNode && \n                    item.placeholder.parentNode.removeChild(item.placeholder);\n                item.attached = false;\n                continue;\n            }\n\n            for (j = Math.max(i - 1, 0); j >= 0; j--) {\n                if (items[j].attached) {\n                    next = items[j].placeholder.nextSibling;\n                    break;\n                }\n            }\n\n            if (!next) {\n                next = nc;\n            }\n\n            first = tm ? el[0] : el;\n            parent = next.parentNode;\n\n            if (first !== next) {\n                if (next && item.placeholder.nextSibling !== next) {\n                    parent.insertBefore(tm ? MetaphorJs.dom.toFragment(el) : el, next);\n                    parent.insertBefore(item.placeholder, next);\n                }\n                else if (!next) {\n                    parent.appendChild(tm ? MetaphorJs.dom.toFragment(el) : el);\n                    parent.appendChild(item.placeholder);\n                }\n            }\n\n            item.attached = true;\n        }\n    },\n\n    /*\n     * reflect changes -->\n     */\n\n\n    /*\n     * <!-- configurable item functions\n     */\n\n\n    getListItem: function(list, index) {\n        return list[index];\n    },\n\n    getTrackByFunction: function() {\n\n        var self = this,\n            trackBy;\n\n        if (!self._trackByFn) {\n\n            trackBy = self._trackBy;\n\n            if (!trackBy || trackBy === '$') {\n                self._trackByFn = function(item) {\n                    return isPrimitive(item) ? item : undefined;\n                };\n            }\n            else if (isFunction(trackBy)) {\n                self._trackByFn = trackBy;\n            }\n            else {\n                self._trackByFn = function(item) {\n                    if (item && !isPrimitive(item)) {\n                        if (self._localTrack && !item[trackBy]) {\n                            item[trackBy] = nextUid();\n                        }\n                        return item[trackBy];\n                    }\n                    else return undefined;\n                    //return item && !isPrimitive(item) ? item[trackBy] : undefined;\n                };\n            }\n        }\n\n        return self._trackByFn;\n    },\n\n    localTracklistFilter: function(rawList, mo) {\n        if (!rawList) {\n            return [];\n        }\n        if (!isArray(rawList)) {\n            rawList = [rawList];\n        }\n        var self = this;\n        if (self._trackBy !== false && self._localTrack) {\n            if (!self._trackBy) {\n                self._trackBy = \"$$\" + mo.id;\n            }\n\n            self.getTrackList(rawList);\n        }\n        return rawList;\n    },\n\n    getTrackList: function(list) {\n        var trackByFn = this.getTrackByFunction(),\n            trackList = [],\n            i, l;\n        for (i = -1, l = list.length; ++i < l; \n            trackList.push(trackByFn(list[i]))){}\n        return trackList;\n    },\n\n\n    stateGetRawIndex: function(id) {\n\n        if (id === undefined) {\n            return -1;\n        }\n\n        var self        = this,\n            list        = self.getList(),\n            trackByFn   = self.getTrackByFunction(),\n            i, l;\n\n        for (i = 0, l = list.length; i < l; i++) {\n            if (trackByFn(list[i]) === id) {\n                return i;\n            }\n        }\n\n        return -1;\n    },\n\n    /*\n     * configurable item functions -->\n     */\n\n\n\n    _parseExpr: function(expr) {\n\n        var parts, pb;\n\n        if (MetaphorJs.app.prebuilt.isKey(expr)){\n            pb = MetaphorJs.app.prebuilt.get(\"config\", expr);\n            parts = {\n                model: pb,\n                name: pb.inflate.itemName\n            };\n            this.listSourceExpr = pb;\n        }\n        else {\n            parts = MetaphorJs.app.Directive.getDirective(\"attr\", \"each\")\n                             .splitExpression(expr);\n            this.listSourceExpr = parts.model;\n        }\n\n        this.itemStateName = parts.name;\n    },\n\n\n    onDestroy: function() {\n\n        var self        = this,\n            items       = self._items,\n            i, len;\n\n        for (i = 0, len = items.length; i < len; i++) {\n            if (items[i].renderer && !items[i].renderer.$destroyed) {\n                items[i].renderer.$destroy();\n            }\n        }\n\n        self._renderQueue.$destroy();\n        self._attachQueue.$destroy();\n\n        if (self._mo) {\n            self._mo.unsubscribe(self.onChange, self);\n            self._mo.$destroy(true);\n        }\n    }\n\n});\n","require(\"../lib/State.js\");\nrequire(\"metaphorjs-observable/src/lib/Observable.js\");\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\nrequire(\"../lib/Text.js\");\nrequire(\"../func/dom/setAttr.js\");\nrequire(\"./Directive.js\");\nrequire(\"../lib/Config.js\");\nrequire(\"../func/dom/removeAttr.js\");\nrequire(\"../func/dom/getAttrSet.js\");\n\nconst nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    isThenable = require(\"metaphorjs-shared/src/func/isThenable.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\");\n\n\nmodule.exports = MetaphorJs.app.Renderer = function() {\n\n    let handlers                = null;\n    const dirs                    = MetaphorJs.directive,\n        nodeCmt                 = window.document.COMMENT_NODE,\n        nodeText                = window.document.TEXT_NODE,\n        nodeElem                = window.document.ELEMENT_NODE,\n\n        collectNodes    = function(coll, add) {\n            if (add) {\n                if (add.nodeType) {\n                    coll.push(add);\n                }\n                else if (isArray(add)) {\n                    for (var i = -1, l = add.length; ++i < l; collectNodes(coll, add[i])){}\n                }\n            }\n        },\n\n        skipMap = {\n            \"script\": true,\n            \"template\": true,\n            \"mjs-template\": true,\n            \"style\": true,\n            \"link\": true\n        },\n\n        applyDirective = function(dir, parentState, node, config, attrs, renderer) {\n\n            config.setDefaultMode(\"state\", MetaphorJs.lib.Config.MODE_STATIC);\n\n            const state = config.has(\"state\") ? \n                            MetaphorJs.lib.State.$produce(config.get(\"state\"), parentState) :\n                            parentState,\n                app     = parentState.$app || state.$app,\n                inject  = {\n                    $state: state,\n                    $node: node,\n                    $config: config,\n                    $attrSet: attrs,\n                    $renderer: renderer\n                },\n                args    = [state, node, config, renderer, attrs],\n                processRes = function(res) {\n                \n                    if (res && res.$destroy) {\n                        if (renderer) {\n                            if (renderer.$destroyed) res.$destroy();\n                            else renderer.on(\"destroy\", res.$destroy, res);\n                        }\n                        else parentState.$on(\"destroy\", res.$destroy, res);\n                    }\n                    else if (typeof res === \"function\") {\n                        if (renderer) {\n                            if (renderer.$destroyed) res();\n                            else renderer.on(\"destroy\", res);\n                        }\n                        else parentState.$on(\"destroy\", res);\n                    }\n                };\n\n            let res;\n\n            if (config.has(\"state\")) {\n                config.setOption(\"state\", state);\n            }\n\n            if (app) {\n                res = app.inject(dir, null, inject, args);\n            }\n            else if (dir.$instantiate) {\n                res = dir.$instantiate.apply(dir, args);\n            }\n            else {\n                res = dir.apply(null, args);\n            }\n\n            if (isThenable(res)) {\n                res.done(processRes);\n            }\n            else processRes(res);\n\n            return res;\n        },\n\n        observer = new MetaphorJs.lib.Observable;\n\n    var Renderer = function(parent) {\n\n        var self            = this;\n\n        self.id             = nextUid();\n        self.parent         = parent;\n\n        self._texts             = [];\n        self._flowControlState  = {};\n        self._treeState = {\n            countdown: 0\n        };\n\n        observer.createEvent(\"transclude-sources-\" + self.id, \"all\");\n        observer.createEvent(\"rendered-\" + self.id, {\n            limit: 1\n        });\n\n        if (parent) {\n            parent.on(\"destroy\", self.$destroy, self);\n        }\n    };\n    \n    \n    extend(Renderer.prototype, {\n\n        id: null,\n        parent: null,\n\n        _flowControlState: null,\n        _treeState: null,\n        _texts: null,\n        $destroyed: false,\n\n        on: function(event, fn, context, opt) {\n            return observer.on(event + '-' + this.id, fn, context, opt);\n        },\n\n        un: function(event, fn, context) {\n            return observer.un(event + '-' + this.id, fn, context);\n        },\n\n        trigger: function(event) {\n            arguments[0] = event + \"-\" + this.id;\n            return observer.trigger.apply(observer, arguments);\n        },\n\n        attached: function(to) {\n            this.trigger(\"attached\", this, to);\n        },\n\n        detached: function() {\n            this.trigger(\"detached\", this);\n        },\n\n        flowControl: function(key, value) {\n            this._flowControlState[key] = value;\n        },\n\n        _resetFC: function() {\n            var fc = this._flowControlState;\n            fc.waitFor = null;\n            fc.nodes = null;\n            fc.stop = false;\n            fc.ignoreInside = false;\n            fc.newState = null;\n        },\n\n        _checkFCState: function(defers, nodes, attrs) {\n            var fc = this._flowControlState;\n            fc.waitFor && defers && defers.push(fc.waitFor);\n            fc.nodes && nodes && collectNodes(nodes, fc.nodes);\n            fc.ignoreInside && attrs && (attrs.renderer.ignoreInside = true);\n            fc.newState && (this._treeState.newState = fc.newState);\n            this._resetFC();\n        },\n\n\n\n\n\n        _processCommentNode: function(node) {\n            var cmtData = node.textContent || node.data;\n            if (cmtData.substring(0,2) === '##') {\n                this.trigger(\n                    \"reference\", \"node\",\n                    cmtData.substring(2), node\n                );\n            }\n        },\n\n        _processTextNode: function(node) {\n            var self    = this,\n                texts   = self._texts,\n                textStr = node.textContent || node.nodeValue,\n                textRenderer;\n\n            if (MetaphorJs.lib.Text.applicable(textStr)) {\n                textRenderer = new MetaphorJs.lib.Text(\n                    self._treeState.state,\n                    textStr\n                );\n                textRenderer.subscribe(self._onTextChange, self, {\n                    append: [texts.length]\n                });\n                texts.push({node: node, tr: textRenderer});\n                self._renderText(texts.length - 1);\n            }\n        },\n\n        // skip <slot> but reference it same way as ##ref\n        _processSlotNode: function(node) {\n            this.trigger(\n                \"reference\", \"node\",\n                node.getAttribute(\"name\"), node\n            );\n            return false;\n        },\n\n        _processComponent: function(component, node, attrs) {\n            var self = this,\n                config = new MetaphorJs.lib.Config(\n                    attrs.config, \n                    {state: self._treeState.state}\n                );\n    \n            var directive = MetaphorJs.app.Directive.getDirective(\"attr\", \"cmp\");\n            config.setProperty(\"value\", {\n                mode: MetaphorJs.lib.Config.MODE_STATIC,\n                expression: component\n            });\n\n            self.on(\"destroy\", config.$destroy, config);\n\n            return applyDirective(directive, self._treeState.state, \n                                    node, config, attrs, self);\n        },\n\n        _processTag: function(directive, node, attrs) {\n\n            var self = this,\n                config = new MetaphorJs.lib.Config(\n                    attrs.config, \n                    {state: self._treeState.state}\n                );\n            self.on(\"destroy\", config.$destroy, config);\n\n            return applyDirective(directive, self._treeState.state, \n                                    node, config, attrs, self);\n        },\n\n        _processDirAttribute: function(node, directive, name, dcfg, attrs) {\n\n            var self = this,\n                config = new MetaphorJs.lib.Config(\n                    dcfg,\n                    {state: self._treeState.state}\n                );\n            self.on(\"destroy\", config.$destroy, config);\n\n            return applyDirective(directive, self._treeState.state, \n                                    node, config, attrs, self);\n        },\n\n        _processReferences: function(node, attrs) {\n            var self = this, i, len, ref,\n                state = self._treeState.state;\n            for (i = 0, len = attrs.references.length; i < len; i++) {\n                ref = attrs.references[i];\n                if (ref[0] === '#') {\n                    self.trigger(\"reference\", \"node\", ref.substring(1), node);\n                }\n                else {\n                    state[ref] = node;\n                }\n                MetaphorJs.dom.removeAttr(node, '#' + ref);\n            }\n        },\n\n        _processAttribute: function(node, name, attrs) {\n            var self = this,\n                texts = self._texts,\n                textStr = attrs['attributes'][name],\n                textRenderer = new MetaphorJs.lib.Text(\n                    self._treeState.state, \n                    textStr, \n                    {\n                        recursive: !!attrs.renderer.recursive,\n                        fullExpr: !MetaphorJs.lib.Text.applicable(textStr)\n                    }\n                );\n\n            MetaphorJs.dom.removeAttr(node, attrs['__attributes'][name]);\n            textRenderer.subscribe(self._onTextChange, self, {\n                append: [texts.length]\n            });\n            texts.push({\n                node: node,\n                attr: name,\n                tr: textRenderer\n            });\n            self._renderText(texts.length - 1);\n        },\n\n\n\n\n\n        \n\n        _processNode: function(node, _attrs) {\n\n            var self        = this,\n                nodeType    = node.nodeType;\n\n            if (nodeType === nodeCmt) {\n                self._processCommentNode(node);\n            }\n            else if (nodeType === nodeText) {\n                self._processTextNode(node);\n            }\n            else if (nodeType === nodeElem) {\n\n                self._resetFC();\n\n                var tag     = node.tagName.toLowerCase(),\n                    defers  = [],\n                    nodes   = [],\n                    fc = self._flowControlState,\n                    component, directive,\n                    name, ds,\n                    i, len,\n                    j, jlen,\n                    attrs = _attrs || MetaphorJs.dom.getAttrSet(node);\n\n                if (tag.substr(0, 4) === \"mjs-\") {\n                    tag = tag.substr(4);\n                }\n                if (tag === \"slot\") {\n                    return this._processSlotNode(node);\n                }\n                if (attrs.renderer.ignore) {\n                    return false;\n                }\n                if (attrs.__plain && !dirs.component[tag] && !dirs.tag[tag]) {\n                    return;\n                }\n\n                // this tag represents component\n                // we just pass it to attr.cmp directive\n                // by adding it to the attr map\n                if (component = dirs.component[tag]) {\n                    attrs.__remove(node, \"config\");\n                    self._processComponent(component, node, attrs);\n                }\n                else if (directive = dirs.tag[tag]) {\n                    self._processTag(directive, node, attrs);\n                }\n\n                if (fc.stop) return false;\n                self._checkFCState(defers, nodes, attrs);\n\n                if (attrs.references && attrs.references.length) {\n                    self._processReferences(node, attrs);\n                }\n\n                // this is an attribute directive\n                for (i = 0, len = handlers.length; i < len; i++) {\n\n                    name = handlers[i].name;\n\n                    if ((ds = attrs['directives'][name]) !== undefined &&\n                        !attrs['__directives'][name].handled) {\n\n                        attrs.__remove(node, \"directive\", name);\n                        attrs.__directives[name].handled = true;\n\n                        for (j = 0, jlen = ds.length; j < jlen; j++) {\n                            self._processDirAttribute(\n                                node, handlers[i].handler, name, \n                                ds[j], attrs\n                            );\n\n                            if (fc.stop) return false;\n                            self._checkFCState(defers, nodes, attrs);\n                        }\n                    }\n                }\n\n                for (i in attrs['attributes']) {\n                    self._processAttribute(node, i, attrs);\n                }\n\n                if (attrs.renderer.ignoreInside) {\n                    return false;\n                }\n\n                if (defers.length) {\n                    var deferred = new MetaphorJs.lib.Promise;\n                    MetaphorJs.lib.Promise.all(defers).done(function(values){\n                        collectNodes(nodes, values);\n                        deferred.resolve(nodes);\n                    });\n                    return deferred;\n                }\n\n                return nodes.length ? nodes : true;\n            }\n\n            return true;\n        },\n\n        /**\n         * Processes one single node and gives glues on there to go next.<br>\n         * Return false to skip this branch. Do not go inside this node.<br>\n         * Return a Node or array of Nodes to add to processing list\n         * along with this node's children<br>\n         * Return a Promise resolving in any of the above\n         * @param {Node} node \n         * @param {MetaphorJs.lib.State} state\n         * @returns {boolean|array|Promise|Node}\n         */\n        processNode: function(node, state, /*system private attr */_attrs) {\n            var self = this;\n            self._treeState.state = state;\n            self._processNode(node, _attrs);\n        },\n\n        process: function(smth, state) {\n            var self    = this;\n\n            if (!handlers) {\n                handlers = MetaphorJs.app.Directive.getAttributes();\n            }\n            if (!smth) {\n                return;\n            }\n\n            self._treeState.state = state;\n\n            if (smth.nodeType) {\n                self._treeState.countdown++;\n                self._eachNode(smth);\n            }\n            else {\n                if (self._nodeChildren(null, smth) === 0 && \n                    self._treeState.countdown === 0) {\n                    self._onProcessingFinished();\n                }\n            }\n        },\n\n\n\n        _nodeChildren: function(res, el) {\n\n            var children = [],\n                i, len,\n                ts = this._treeState;\n\n            if (res && res !== true) {\n                if (res.nodeType) {\n                    ts.countdown += 1;\n                    this._eachNode(res);\n                    return 1;\n                }\n                else {\n                    children = res.slice();\n                }\n            }\n\n            if (!children.length) {\n                children = toArray(el.childNodes || el);\n            }\n\n            len = children.length;\n            ts.countdown += len;\n\n            for(i = -1;\n                ++i < len;\n                this._eachNode(children[i])){}\n\n            return len;\n        },\n\n        _eachNode: function(el) {\n\n            if (!el) {\n                return;\n            }\n\n            var res,\n                self = this,\n                tag = el.nodeName,\n                subState = {\n                    thisLevelState: null,\n                    childLevelState: null\n                },\n                ts = self._treeState;\n\n            if (tag && skipMap[tag.toLowerCase()]) {\n                --ts.countdown === 0 && self._onProcessingFinished();\n                return;\n            }\n\n            res = self._processNode(el);\n\n            if (ts.newState) {\n                subState.thisLevelState = ts.state;\n                subState.childLevelState = ts.newState;\n                delete ts.newState;\n            }\n\n            isThenable(res) ?\n                res.done(function(res) {\n                    self._eachNodeRun(res, el, subState);\n                }) :\n                self._eachNodeRun(res, el, subState);\n        },\n\n        _eachNodeRun: function(res, el, sub) {\n            var self = this,\n                ts = self._treeState;\n    \n            if (res !== false) {\n                sub.childLevelState && (ts.state = sub.childLevelState);\n                self._nodeChildren(res, el);\n                sub.thisLevelState && (ts.state = sub.thisLevelState);\n            }\n\n            --ts.countdown === 0 && self._onProcessingFinished();\n        },\n\n        _onProcessingFinished: function() {\n            observer.trigger(\"rendered-\" + this.id, this);\n        },\n\n\n\n\n\n\n\n\n        _onTextChange: function(textRenderer, inx) {\n            this._renderText(inx);\n        },\n\n        _renderText: function(inx) {\n\n            var self        = this,\n                text        = self._texts[inx],\n                res         = text.tr.getString(),\n                attrName    = text.attr;\n\n            if (res === undefined || res === null) {\n                res = \"\";\n            }\n\n            if (attrName) {\n\n                if (attrName === \"value\") {\n                    text.node.value = res;\n                }\n                else if (attrName === \"class\") {\n                    text.node.className = res;\n                }\n                else if (attrName === \"src\") {\n                    text.node.src = res;\n                }\n\n                if (res === false) {\n                    MetaphorJs.dom.removeAttr(text.node, attrName);\n                }\n                else {\n                    MetaphorJs.dom.setAttr(text.node, attrName, res);\n                }\n            }\n            else {\n                //text.node.textContent = res;\n                text.node.nodeValue = res;\n            }\n        },\n\n\n        $destroy: function() {\n\n            var self    = this,\n                texts   = self._texts,\n                i, len;\n\n            if (self.$destroyed) {\n                return;\n            }\n\n            for (i = -1, len = texts.length; ++i < len; texts[i].tr.$destroy()) {}\n\n            if (self.parent) {\n                self.parent.un(\"destroy\", self.$destroy, self);\n            }\n\n            observer.trigger(\"destroy-\" + self.id);\n\n            observer.destroyEvent(\"transclude-sources-\"+self.id);\n            observer.destroyEvent(\"destroy-\" + self.id);\n            observer.destroyEvent(\"rendered-\" + self.id);\n            observer.destroyEvent(\"reference-\" + self.id);\n            observer.destroyEvent(\"reference-promise-\" + self.id);\n            observer.destroyEvent(\"attached-\" + self.id);\n\n            for (var k in self) {\n                if (self.hasOwnProperty(k)) {\n                    self[k] = null;\n                }\n            }\n\n            self.$destroyed = true;\n        }\n\n    });\n    \n    Renderer.skip = function(tag, value) {\n        skipMap[tag] = value;\n    };\n\n    Renderer.applyDirective = applyDirective;\n\n    return Renderer;\n\n}();\n\n","\nrequire(\"../lib/Expression.js\");\nrequire(\"../lib/Config.js\");\nrequire(\"../lib/MutationObserver.js\");\nrequire(\"../app/ListRenderer.js\");\nrequire(\"../func/app/prebuilt\");\n\nconst bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.app.StoreRenderer = MetaphorJs.app.ListRenderer.$extend({\n\n    store: null,\n\n    $constructor: function(state, node, config, parentRenderer, attrSet) {\n\n        config.setDefaultMode(\"pullNext\", MetaphorJs.lib.Config.MODE_STATIC);\n\n        if (config.hasValue(\"pullNext\") && config.get(\"pullNext\")) {\n            if (config.hasValue(\"buffered\")) {\n                config.setStatic(\"bufferedPullNext\", true);\n                config.setStatic(\"buffered\", false);\n            }\n\n            var plg = config.get(\"pullNext\");\n            this.$plugins.push(\n                typeof plg === \"string\" ? plg : \"MetaphorJs.plugin.ListPullNext\");\n        }\n\n        this.$super(state, node, config, parentRenderer, attrSet);\n    },\n\n    initDataSource: function() {\n\n        var self            = this,\n            store;\n\n        self.store          = store = MetaphorJs.lib.Expression.get(\n                                    self.listSourceExpr, \n                                    self.state\n                                );\n        if (self._trackBy !== false) {\n            self._trackByFn = bind(store.getRecordId, store);\n        }\n\n        self._mo            = MetaphorJs.lib.MutationObserver.get(\n                                store, \"current\", \n                                self.onChange, self);\n        self._griDelegate   = bind(store.indexOfId, store);\n        self.bindStore(store, \"on\");\n    },\n\n    bindStore: function(store, fn) {\n\n        var self    = this;\n\n        store[fn](\"update\", self.onStoreUpdate, self);\n        store[fn](\"clear\", self.onStoreUpdate, self);\n        store[fn](\"destroy\", self.onStoreDestroy, self);\n    },\n\n    onStoreUpdate: function() {\n        this._mo.check();\n    },\n\n    getListItem: function(list, index) {\n        return this.store.getRecordData(list[index]);\n    },\n\n    onStoreDestroy: function() {\n        var self = this;\n        if (self._mo) {\n            self.onStoreUpdate();\n            self._mo.unsubscribe(self.onChange, self);\n            self._mo.$destroy(true);\n            self._mo = null;\n        }\n    },\n\n    onDestroy: function() {\n        var self = this;\n        if (!self.store.$destroyed) {\n            self.bindStore(self.store, \"un\");\n        }\n        self.$super();\n    }\n\n});\n\n\n","\nrequire(\"../func/dom/data.js\");\nrequire(\"../func/dom/toFragment.js\");\nrequire(\"../func/dom/clone.js\");\nrequire(\"metaphorjs-animate/src/animate/animate.js\");\nrequire(\"../func/dom/select.js\");\nrequire(\"../func/dom/getAttrSet.js\");\nrequire(\"../func/dom/getAttr.js\");\nrequire(\"../func/dom/setAttr.js\");\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\nrequire(\"metaphorjs-observable/src/lib/Observable.js\");\nrequire(\"metaphorjs-shared/src/lib/Cache.js\");\nrequire(\"../lib/State.js\");\nrequire(\"../lib/Expression.js\");\nrequire(\"../lib/MutationObserver.js\");\nrequire(\"../lib/Config.js\");\nrequire(\"./Renderer.js\");\nrequire(\"../func/dom/commentWrap.js\");\nrequire(\"metaphorjs-observable/src/lib/Observable.js\");\nrequire(\"../func/dom/isAttached.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    copy = require(\"metaphorjs-shared/src/func/copy.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\");\n\nmodule.exports = MetaphorJs.app.Template = function() {\n\n    var observable      = new MetaphorJs.lib.Observable,\n        cache           = new MetaphorJs.lib.Cache,\n        options         = {},\n        shadowSupported = !!(window.document.head && window.document.head.attachShadow),\n        pblt,\n        pbltOpt,\n\n        //TODO: Check if this is a performance issue\n        getFragmentContent  = function(frg) {\n            var div = window.document.createElement(\"div\");\n            div.appendChild(MetaphorJs.dom.clone(frg));\n            return div.innerHTML;\n        },\n\n        resolveInclude  = function(cmt, tplId) {\n            var frg = getTemplate(tplId.trim());\n            if (!frg) {\n                return \"\";\n            }\n            if (typeof frg === \"string\") {\n                return frg;\n            }\n            return getFragmentContent(frg);\n        },\n\n        resolveIncludes = function(tpl) {\n            return tpl.replace(/<!--\\s*include (.+?)-->/ig, resolveInclude);\n        },\n\n        getTemplate     = function(tplId) {\n\n            var tpl = cache.get(tplId),\n                opt = options[tplId] || {};\n\n            if (typeof tpl === \"function\") {\n                tpl = tpl(tplId);\n            }\n            if (typeof tpl === \"string\" && !opt.text) {\n                if (!opt.processed) {\n                    tpl = processTextTemplate(tplId, tpl);\n                }\n                tpl = MetaphorJs.dom.toFragment(tpl);\n                cache.add(tplId, tpl);\n            }\n            else if (tpl && tpl.nodeType) {\n                // do not re-create fragments;\n                if (tpl.nodeType !== window.document.DOCUMENT_FRAGMENT_NODE) { // document fragment\n                    if (\"content\" in tpl) {\n                        tpl = tpl.content;\n                    }\n                    else {\n                        tpl = MetaphorJs.dom.toFragment(tpl.childNodes);\n                    }\n                    cache.add(tplId, tpl);\n                }\n            }\n\n            return tpl;\n        },\n\n        processTextTemplate = function(tplId, tpl) {\n\n            var opt, inx;\n\n            if (tpl.substring(0,5) === \"<!--{\") {\n                inx = tpl.indexOf(\"-->\");\n                opt = MetaphorJs.lib.Expression.get(tpl.substr(4, inx-4), {});\n                options[tplId] = opt;\n                tpl = tpl.substr(inx + 3);\n            }\n\n            if (!options[tplId]) {\n                options[tplId] = {};\n            }\n\n            opt = options[tplId];           \n            opt.processed = true;\n\n            //if (opt.includes) {\n            tpl = resolveIncludes(tpl);\n            //}\n\n            if (opt.text) {\n                return tpl;\n            }\n\n            return MetaphorJs.dom.toFragment(tpl);\n        },\n\n        findInPrebuilt = function(tplId) {\n            var tpl;\n            if (!pblt) {\n                pblt = MetaphorJs.prebuilt.templates;\n                pbltOpt = MetaphorJs.prebuilt.templateOptions;\n            }\n            if (tpl = pblt[tplId]) {\n                delete pblt[tplId];\n                /*if (pbltOpt[tplId]) {\n                    options[tplId] = pbltOpt[tplId];\n                    delete pbltOpt[tplId];\n                }*/\n                return tpl;\n            }\n        },\n\n        findInScripts = function(tplId) {\n            var tplNode = window.document.getElementById(tplId),\n                tpl,\n                tag;\n\n            if (tplNode) {\n                tag = tplNode.tagName.toLowerCase();\n                if (tag === \"script\") {\n                    tpl = tplNode.innerHTML;\n                    tplNode.parentNode.removeChild(tplNode);\n                    return tpl;\n                }\n                else {\n                    return tplNode;\n                }\n            }\n        },\n\n        loadPromises = {},\n\n        loadTemplate = function(name, url) {\n\n            if (!cache.exists(name)) {\n                if (!loadPromises[url]) {\n                    loadPromises[url] = fetch(url)\n                    .then(r => r.text())\n                    .then(response => {\n                        return MetaphorJs.dom.toFragment(response);\n                    })\n                    .then(fragment => { \n                        cache.add(name, fragment);\n                        delete loadPromises[url];\n                        return fragment;\n                    });\n                }\n\n                return loadPromises[url];\n            }\n            return MetaphorJs.lib.Promise.resolve(cache.get(name));\n        };\n\n    if (MetaphorJs.prebuilt && MetaphorJs.prebuilt.templates) {\n        cache.addFinder(findInPrebuilt);\n    }\n\n    cache.addFinder(findInScripts);\n\n    var Template = function(cfg) {\n        var self    = this;\n\n        extend(self, cfg, true, false);\n\n        if (self.parentRenderer) {\n            self._parentRenderer = self.parentRenderer;\n            delete self.parentRenderer;\n        }\n        self.id = nextUid();\n        self._virtualSets = {};\n        self._namedNodes = {};\n        observable.createEvent(\"rendered-\" + self.id, {\n            returnResult: false,\n            autoTrigger: true\n        });\n        observable.createEvent(\"attached-\" + self.id);\n\n        self.state = MetaphorJs.lib.State.$produce(self.state);\n        self.config = MetaphorJs.lib.Config.create(\n            self.config, \n            {state: self.state}\n        );\n\n        MetaphorJs.lib.Observable.$initHost(this, cfg, observable);\n\n        var config = self.config,\n            sm = MetaphorJs.lib.Config.MODE_STATIC;\n\n        config.on(\"name\", self._onNameChange, self);\n        config.on(\"html\", self._onHtmlChange, self);\n\n        Template.initConfig(config);\n\n        !shadowSupported && config.setStatic(\"useShadow\", false);\n        config.get(\"useShadow\") && config.setStatic(\"useComments\", false);\n        config.get(\"useShadow\") && config.setStatic(\"makeTranscludes\", false);\n\n        /*if (config.get(\"runRenderer\") && self._parentRenderer) {\n            self._parentRenderer.on(\"destroy\",\n                self._onParentRendererDestroy, self\n            );\n        }*/\n        self.state.$on(\"destroy\", self._onStateDestroy, self);\n\n        self._collectInitialNodes(self.attachTo || self.replaceNode);\n        self.resolve();\n\n        if (!config.get(\"deferRendering\")) {\n            self.render();\n        }\n    };\n\n\n    extend(Template.prototype, {\n\n        _rendering:         false,\n        _rendered:          false,\n        _renderer:          null,\n        _attached:          false,\n        _initial:           true,\n        _fragment:          null,\n        _template:          null,\n        _nodes:             null,\n        _prevEl:            null,\n        _nextEl:            null,\n        _attachTo:          null,\n        _attachBefore:      null,\n        _replaceNode:       null,\n        _shadowRoot:        null,\n        _resolvePromise:    null,\n        _pubResolvePromise: null,\n        _parentRenderer:    null,\n        _virtualSets:       null,\n        _namedNodes:        null,\n\n        attachTo:           null,\n        attachBefore:       null,\n        replaceNode:        null,\n        rootNode:           null,\n\n        /**\n         * @var {MetpahorJs.lib.State}\n         */\n        state:              null,\n\n        /**\n         * @var {MetpahorJs.lib.Config}\n         */\n        config:             null,        \n\n        render: function() {\n\n            var self    = this;\n\n            if (self._rendering || !self._initial) {\n                return;\n            }\n\n            self._rendering = true;\n            self.config.setStatic(\"deferRendering\", false);\n\n            if (self.config.has(\"name\") || \n                self.config.has(\"html\")) {\n                self._prepareTranscludes();\n                self.resolve()   \n                    .done(self._runRenderer, self)\n                    .done(self.attachOrReplace, self);\n            }\n            else {\n                self._runRenderer();\n                self.attachOrReplace();\n            }\n\n            self._initial = false;\n            self._rendering = false;\n        },\n\n        attach: function(parent, before) {\n\n            var self = this;\n\n            if (self._attachTo !== parent) {\n\n                self._attached && self.detach();\n                self._nextEl && self._removeComments();\n                self._shadowRoot && self._destroyShadow();\n\n                delete self.attachTo;\n                delete self.attachBefore;\n\n                self._attachTo = parent;\n                self._attachBefore = before;  \n\n                if (self._rendered) {\n                    if (window.requestAnimationFrame && \n                        MetaphorJs.dom.isAttached(self._attachTo)) {\n                        window.requestAnimationFrame(function(){\n                            self._rafAttach();\n                        });\n                    }\n                    else {\n                        self._rafAttach();\n                    }\n                }\n            }\n        },\n\n        _rafAttach: function() {\n            var self = this;\n\n            if (self.$destroyed) {\n                return;\n            }\n\n            self._createShadow();\n            self._createComments();\n\n            if (self._nodes) {\n                self._doAttach();   \n            }\n            else {\n                self._setAttached();\n            }\n        },\n\n        replace: function(node, attachTo) {\n\n            var self = this;\n\n            if (self._replaceNode !== node || \n                self._attachTo !== attachTo) {\n\n                // can't replace node if it is not attached\n                if (!node.parentNode) {\n                    return;\n                }\n\n                self._attached && self.detach();\n                self._nextEl && self._removeComments();\n                self._shadowRoot && self._destroyShadow();\n                delete self.replaceNode;\n                delete self.attachTo;\n\n                self._replaceNode = node;\n                self._attachTo = attachTo;\n                self._attachBefore = null;\n\n                if (self._rendered) {\n                    if (window.requestAnimationFrame) {\n                        window.requestAnimationFrame(function(){\n                            self._rafReplace();\n                        });\n                    }\n                    else self._rafReplace();\n                }\n\n                return true;\n            }\n        },\n\n        _rafReplace: function() {\n            var self = this;\n\n            if (self.$destroyed) {\n                return;\n            }\n\n            if (self._attachTo) {\n                self._replaceNodeWithNode(node, self._attachTo);\n                self._createShadow();\n            }   \n            else {\n                self._replaceNodeWithComments(self._replaceNode);\n            }\n\n            if (self._nodes) {\n                self._doAttach();\n            }\n            else self._setAttached();\n        },\n\n        attachOrReplace: function() {\n            var self = this;\n            if (self._attached || !self._rendered) {\n                return;\n            }\n            // new attachment via replace\n            if (self.replaceNode && self.replaceNode.parentNode) {\n                self.replace(self.replaceNode, self.attachTo);\n            }\n            // new attachment via append\n            else if (self.attachTo) {\n                if (self.attachBefore) {\n                    self.attachBefore.parentNode && \n                        self.attach(self.attachTo, self.attachBefore);\n                }\n                else {\n                    self.attach(self.attachTo);\n                }\n            }\n            // reattaching to previous\n            else if (self._nextEl || self._attachTo || self._shadowRoot) {\n                self._doAttach();\n            }\n            else if (self._nodes && self._nodes.length && \n                    MetaphorJs.dom.isAttached(self._nodes[0])) {\n                self._setAttached();\n            }\n        },\n\n        isAttached: function() {\n            return this._attached;\n        },\n\n        detach: function() {\n            var self = this;\n\n            if (!self._attached) {\n                return;\n            }\n\n            self._nodes = self._clear();            \n        },\n\n        resolve: function(renew) {\n            var self    = this,\n                config = self.config;\n\n            if (self._resolvePromise) {\n                if (renew) {\n                    self._resolvePromise.$destroy();\n                    self._resolvePromise = null;\n                    self._pubResolvePromise.$destroy();\n                    self._pubResolvePromise = null;\n                    self._nodes = null;\n                    self._template = null;\n                    self._fragment = null;\n                }\n                else {\n                    return self._pubResolvePromise;\n                }\n            }\n\n            self._pubResolvePromise = new MetaphorJs.lib.Promise;\n\n            if (config.has(\"name\")) {\n                config.get(\"name\") && \n                    (self._resolvePromise = self._resolveTemplate());\n            }\n            else if (config.has(\"html\")) {\n                config.get(\"html\") &&\n                    (self._resolvePromise = self._resolveHtml());\n            }\n\n            !self._resolvePromise &&\n                (self._resolvePromise = MetaphorJs.lib.Promise.resolve());\n\n            self._resolvePromise.fail(self._onTemplateNotFound, self);\n\n            return self._resolvePromise.done(self._onTemplateResolved, self);\n        },\n\n        getVirtualSet: function(ref) {\n            return this._virtualSets[ref] ? copy(this._virtualSets[ref]) : null;\n        },\n\n        setNamedNode: function(ref, node) {\n            var self = this,\n                nodes = self._namedNodes[ref];\n\n            if (node['__namedRenderer'] && node['__namedRenderer'][ref]) {\n                return;\n            }\n\n            if (!nodes) {\n                nodes = self._namedNodes[ref] = [];\n            }\n\n            if (node && nodes.indexOf(node) === -1) {\n                nodes.push(node);\n                if (self._renderer && self._virtualSets[ref]) {\n                    self._renderer.processNode(node, self.state, self.getVirtualSet(ref));\n                }\n            }\n        },\n\n        removeNamedNode: function(ref, node) {\n            var nodes = this._namedNodes[ref],\n                inx;\n            if (!nodes || (inx = nodes.indexOf(node)) !== -1) {\n                nodes.splice(inx, 1);\n            }\n        },\n\n\n        _extractVirtualSets: function(frag) {\n            var self = this,\n                node = frag.firstChild,\n                cmtType = window.document.COMMENT_NODE,\n                data, next;\n            while (node) {\n                next = node.nextSibling;\n                if (node.nodeType === cmtType) {\n                    data = node.textContent || node.data;\n                    if (data.substring(0,1) === '<' && \n                        data.substring(data.length-1) === '>') {\n                        self._processVirtualSet(data);\n                        frag.removeChild(node);\n                    }\n                }\n                node = next;\n            }\n        },\n\n        _processVirtualSet: function(data) {\n            var div = window.document.createElement(\"div\");\n            div.innerHTML = data;\n            var node = div.firstChild;\n            if (node) {\n                var ref = node.tagName.toLowerCase(),\n                    attrSet = MetaphorJs.dom.getAttrSet(node);\n                this._virtualSets[ref] = attrSet;\n            }\n        },\n\n        _onTemplateResolved: function(fragment) {\n            var self = this,\n                root = self.rootNode;\n\n            if (self._attached) {\n                self._clear();\n            }\n\n            if (fragment) {\n                self._template = typeof fragment === \"string\" ? \n                                MetaphorJs.dom.toFragment(fragment) :\n                                fragment;\n                self._fragment = MetaphorJs.dom.clone(self._template);\n\n                self._extractVirtualSets(self._fragment);\n\n                if (root) {\n                    while (root.firstChild) {\n                        root.removeChild(root.firstChild);\n                    }\n                    root.appendChild(self._fragment);\n                    if (!root.parentNode) {\n                        self._fragment.appendChild(root);\n                    }\n                    self._nodes = [root];\n                }\n                else {\n                    self._nodes = toArray(self._fragment.childNodes);\n                }\n            }\n            else if (root) {\n                self._nodes = [root];\n            }\n\n            self._pubResolvePromise.resolve();\n        },\n\n        _onTemplateNotFound: function() {\n            throw new Error(\"Template \" + this.config.get(\"name\") + \" not found\");\n        },\n\n        _collectInitialNodes: function(parent) {\n            var self = this;\n            if (!self.config.has(\"name\") && !self.config.has(\"html\")) {\n                parent = parent || self._attachTo || self.attachTo;\n                parent && (self._nodes = toArray(parent.childNodes));\n            }\n        },\n\n\n\n        createEvent: function(event, opt) {\n            return observable.createEvent(event + \"-\" + this.id, opt);\n        },\n\n        on: function(event, fn, context, opt) {\n            return observable.on(event + \"-\" + this.id, fn, context, opt);\n        },\n\n        un: function(event, fn, context) {\n            return observable.un(event + \"-\" + this.id, fn, context);\n        },\n\n\n        _prepareTranscludes: function() {\n            var self = this,\n                saveIn, takeFrom;\n            \n            if (self.replaceNode) {\n                saveIn = self.replaceNode.parentNode;\n                takeFrom = self.replaceNode;\n            }\n            else if (self.attachTo) {\n                saveIn = takeFrom = self.attachTo;\n            }\n\n            if (saveIn && takeFrom && \n                self.config.get(\"makeTranscludes\") && \n                takeFrom.firstChild && \n                !MetaphorJs.dom.data(saveIn, \"mjs-transclude\")) {\n                MetaphorJs.dom.data(saveIn, \"mjs-transclude\", \n                    MetaphorJs.dom.toFragment(takeFrom.childNodes));\n            }\n        },\n\n        _replaceNodeWithComments: function(node) {\n            var self = this,\n                cmts = MetaphorJs.dom.commentWrap(node, self.id);\n            node.parentNode && node.parentNode.removeChild(node);\n            self._prevEl = cmts[0];\n            self._nextEl = cmts[1];\n        },\n\n        _replaceNodeWithNode: function(replacedNode, withNode) {\n            var frg = MetaphorJs.dom.toFragment(replacedNode.childNodes);\n            replacedNode.parentNode && \n                replacedNode.parentNode.replaceChild(replacedNode, withNode);\n            withNode.appendChild(frg);\n        },\n\n        _createComments: function() {\n            var self = this,\n                parent = self._attachTo,\n                before = self._attachBefore;\n\n            if (parent && !self._prevEl && self.config.get(\"useComments\")) {\n                var cmts = [\n                        window.document.createComment(\"<\" + self.id),\n                        window.document.createComment(self.id + \">\")\n                    ];\n                parent.insertBefore(cmts[0], before);\n                parent.insertBefore(cmts[1], before);\n                self._prevEl = cmts[0];\n                self._nextEl = cmts[1];\n            }\n        },\n\n        _removeComments: function() {\n            var self = this,\n                next = self._nextEl,\n                prev = self._prevEl;\n\n            next.parentNode && next.parentNode.removeChild(next);\n            prev.parentNode && prev.parentNode.removeChild(prev);\n            self._nextEl = null;\n            self._prevEl = null;\n        },\n\n        _createShadow: function() {\n            var self = this;\n            if (self._attachTo && !self._shadowRoot && \n                self.config.get(\"useShadow\")) {\n                self._shadowRoot = self._attachTo.shadowRoot || \n                                    self._attachTo.attachShadow({mode: \"open\"});\n            }\n        },\n\n        _destroyShadow: function() {\n            this._shadowRoot = null;\n        },\n\n        _runRenderer: function() {\n            var self = this;\n\n            if (self.config.get(\"runRenderer\")) {\n                \n                self._destroyRenderer();\n\n                observable.trigger(\"before-render-\" + self.id, self);\n\n                self._renderer   = new MetaphorJs.app.Renderer;\n\n                if (self.config.get(\"passReferences\") && self._parentRenderer) {\n                    self._renderer.on(\n                        \"reference\", \n                        self._parentRenderer.trigger,\n                        self._parentRenderer,\n                        {\n                            prepend: [\"reference\"]\n                        }\n                    );\n                }\n\n                self._renderer.on(\"transclude-sources\", self._onTranscludeSource, self);\n                // after renderer had its course, the list of nodes may have changed.\n                // we need to reflect this in _nodes before attaching stuff\n                self._renderer.on(\"rendered\", self._collectedNodesAfterRendered, self);\n                // then we apply directives to all named nodes we have at the moment\n                self._renderer.on(\"rendered\", self._processNamedNodes, self);\n                // then send the 'rendered' signal up the chain\n                observable.relayEvent(self._renderer, \"rendered\", \"rendered-\" + self.id);\n\n                observable.relayEvent(self._renderer, \"reference\", \"reference-\" + self.id);\n                \n                if (self._nodes) {\n                    self._renderer.process(self._nodes, self.state);\n                }\n                else {\n                    self._renderer.trigger(\"rendered\", self._renderer);\n                }\n            }\n        },\n\n        _onTranscludeSource: function() {\n            return this._replaceNode || this.replaceNode || \n                    this._attachTo || this.attachTo;\n        },\n\n        _collectedNodesAfterRendered: function() {\n            var self = this;\n            self._rendered = true;\n            if (self._fragment) {\n                this._nodes = toArray(self._fragment.childNodes);\n            }\n        },\n\n        _processNamedNodes: function() {\n            var self = this,\n                vnodes = self._namedNodes,\n                vsets = self._virtualSets,\n                ref, i, l,\n                node, nr, attrSet,\n                attr;\n\n            for (ref in vnodes) {\n                if (vsets[ref]) {\n                    for (i = 0, l = vnodes[ref].length; i < l; i++) {\n                        node = vnodes[ref][i];\n                        nr = node['__namedRenderer'] || {};\n                        nr[ref] = self._renderer.id;\n                        node['__namedRenderer'] = nr;\n                        attrSet = self.getVirtualSet(ref);\n\n                        if (attrSet.rest && node.nodeType === window.document.ELEMENT_NODE) {\n                            for (attr in attrSet.rest) {\n                                node.setAttribute(attr, attrSet.rest[attr]);\n                            }\n                        }\n                        self._renderer.processNode(node, self.state, attrSet);\n                    }\n                }\n            }\n        },\n\n        _destroyRenderer: function() {\n            var self = this;\n\n            self._rendered = false;\n\n            if (self._renderer) {\n                var id = self._renderer.id,\n                    vnodes = self._namedNodes,\n                    ref, i, l,\n                    node, nr;\n                self._renderer.$destroy();\n                self._renderer = null;\n\n                for (ref in vnodes) {\n                    for (i = 0, l = vnodes[ref].length; i < l; i++) {\n                        node = vnodes[ref][i];\n                        nr = node['__namedRenderer'];\n                        nr && nr[ref] === id && (nr[ref] = null);\n                    }\n                }\n                self._namedNodes = {};\n            }\n        },\n\n        _resolveTemplate: function() {\n            var tpl = this.config.get(\"name\");\n            return new MetaphorJs.lib.Promise(\n                function(resolve, reject) {\n                    if (tpl) {\n                        tpl = getTemplate(tpl);\n                        tpl ? resolve(tpl) : reject();\n                    }\n                    else reject();\n                }\n            )\n            \n        },\n\n        _resolveHtml: function() {\n            var html = this.config.get(\"html\");\n            return new MetaphorJs.lib.Promise(\n                function(resolve, reject) {\n                    html ? resolve(html): reject();\n                }\n            )\n        },\n\n        _onHtmlChange: function() {\n            var self = this;\n            if (!self.config.get(\"deferRendering\")) {\n                self.resolve(true)   \n                    .done(self._runRenderer, self)\n                    .done(self.attachOrReplace, self);\n            }\n        },\n\n        _onNameChange: function() {\n            var self = this;\n            if (!self.config.get(\"deferRendering\")) {\n                self.resolve(true)   \n                    .done(self._runRenderer, self)\n                    .done(self.attachOrReplace, self);\n            }\n        },\n\n        _collectBetweenComments: function() {\n            var next = this._nextEl,\n                prev = this._prevEl,\n                node = prev,\n                els = [];\n\n            if (prev && next) {\n                while (node && node.nextSibling && \n                        node.nextSibling !== next) {\n                    els.push(node.nextSibling);\n                    node = node.nextSibling;\n                }\n            }\n\n            return els;\n        },\n\n        _doAttach: function() {\n            \n            var self = this,\n                i, l, \n                nodes= self._nodes,\n                child,\n                attached = false,\n                next = self._nextEl,\n                parent = self._shadowRoot || self._attachTo,\n                before = self._attachBefore;\n\n            if (!nodes || self._attached) {\n                return;\n            }\n\n            // without the fragment we're in no-template mode\n            // processing parent's children\n            if (self._fragment || self.rootNode) {\n\n                // if we have children in the fragment,\n                // we use them (they might have changed since)\n                // this template has been rendered\n                // because of inner templates and renderers\n                if (self._fragment && self._fragment.firstChild) {\n                    self._nodes = nodes = toArray(self._fragment.childNodes);\n                }\n\n                for (i = 0, l = nodes.length; i < l; i++) {\n                    child = nodes[i];\n\n                    // between comments mode\n                    if (next) {\n                        next.parentNode.insertBefore(child, next);\n                        attached = true;\n                    }\n                    // shadow or normal parent\n                    else if (parent) {\n                        if (before) {\n                            parent.insertBefore(child, before);\n                        }\n                        else {\n                            parent.appendChild(child);\n                        }\n                        attached = true;\n                    }\n                }\n            }\n            else {\n                attached = true;\n            }\n\n            self._attached = attached;\n            if (attached) {\n                self._setAttached(nodes);\n            }\n        },\n\n        _setAttached: function(nodes) {\n            var self = this;\n            self._attached = true;\n            observable.trigger(\"attached-\" + self.id, self, nodes);\n            if (self._renderer) {\n                self._renderer.attached(self._attachTo);\n            }\n        },\n\n        _collectNodes: function() {\n            var self = this,\n                nodes = [], parent;\n\n            // remove all children between prev and next\n            if (self._nextEl) {\n                nodes = self._collectBetweenComments();\n            }\n            else {\n                // remove all children of main node\n                var parent = self._shadowRoot || self._attachTo;\n                if (parent) {\n                    nodes = toArray(parent.childNodes);\n                }\n            }\n\n            return nodes;\n        },\n\n        _clear: function() {\n            var self = this,\n                nodes = self._collectNodes(), \n                i, l, n;\n\n            for (i = 0, l = nodes.length; i < l; i++) {\n                n = nodes[i];\n                n.parentNode && n.parentNode.removeChild(n);\n            }\n\n            self._attached = false;\n\n            if (self._renderer) {\n                self._renderer.detached();\n                observable.trigger(\"detached-\" + self.id, self, nodes);\n            }\n\n            return nodes;\n        },\n\n        /*_onParentRendererDestroy: function() {\n            //var self = this;\n\n            if (!self.$destroyed && self._renderer &&\n                !self._renderer.$destroyed) {\n                self._renderer.$destroy();\n            }\n\n            this.$destroy();\n        },*/\n\n        _onStateDestroy: function() {\n            this.$destroy();\n        },\n\n        $destroy: function() {\n\n            var self = this;\n\n            self.$destroyed = true;\n\n            if (self._nextEl && self._nextEl.parentNode) {\n                self._nextEl.parentNode.removeChild(self._nextEl);\n            }\n\n            if (self._prevEl && self._prevEl.parentNode) {\n                self._prevEl.parentNode.removeChild(self._prevEl);\n            }\n\n            if (self._renderer) {\n                self._renderer.$destroy();\n            }\n\n            observable.destroyEvent(\"rendered-\" + self.id);\n            observable.destroyEvent(\"attached-\" + self.id);\n\n            if (self.config) {\n                self.config.clear();\n                self.config = null;\n            }\n        }\n    });\n\n\n    Template.load = loadTemplate;\n    Template.cache = cache;\n\n    Template.add = function(name, tpl) {\n        Template.cache.add(name, tpl);\n    };\n\n    Template.get = getTemplate;\n\n    Template.prepareConfig = function(config, values) {\n        if (typeof values === 'string') {\n            config.setDefaultValue(\"name\", values);\n        }\n        else if (values) {\n            if (!values.name && !values.html && values.expression) {\n                values.name = {expression: values.expression};\n            }\n            config.addProperties(values, \"defaultValue\");\n        }\n    };\n\n\n    Template.initConfig = function(config) {\n        var sm = MetaphorJs.lib.Config.MODE_STATIC;\n        config.setDefaultMode(\"value\", sm);\n        config.setDefaultMode(\"name\", sm);\n        config.setDefaultMode(\"html\", sm);\n        config.setType(\"runRenderer\", \"bool\", sm);\n        config.setType(\"useComments\", \"bool\", sm);\n        config.setType(\"useShadow\", \"bool\", sm);\n        config.setType(\"deferRendering\", \"bool\", sm);\n        config.setType(\"makeTranscludes\", \"bool\", sm);\n        config.setType(\"passReferences\", \"bool\", sm);\n\n        config.setProperty(\"useComments\", \"defaultValue\", true, /*override: */false);\n        config.setProperty(\"makeTranscludes\", \"defaultValue\", true, /*override: */false);\n        config.setProperty(\"passReferences\", \"defaultValue\", false, /*override: */false);\n    };\n\n    return Template;\n}();\n\n","const MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nMetaphorJs.app.view = MetaphorJs.app.view || {};\nMetaphorJs.app.component = MetaphorJs.app.component || {};","\nrequire(\"../__init.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nmodule.exports = MetaphorJs.app.component.View = cls({\n\n    $init: function(host) {\n        this.component = host;\n        this.component.$view = this;\n    }\n});","\nrequire(\"../__init.js\");\nrequire(\"../../func/dom/data.js\");\nrequire(\"../../func/dom/toFragment.js\");\nrequire(\"../../func/dom/addClass.js\");\nrequire(\"../../func/dom/removeClass.js\");\nrequire(\"metaphorjs-animate/src/animate/animate.js\");\nrequire(\"../../lib/Config.js\");\nrequire(\"../../func/app/resolve.js\");\nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    raf = require(\"metaphorjs-animate/src/func/raf.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    isObject = require(\"metaphorjs-shared/src/func/isObject.js\"),\n    isString = require(\"metaphorjs-shared/src/func/isString.js\");\n\nmodule.exports = MetaphorJs.app.view.Base = cls({\n\n    $mixins: [MetaphorJs.mixin.Observable],\n\n    $init: function(cfg)  {\n\n        var self    = this;\n\n        extend(self, cfg, true, false);\n\n        if (!self.config) {\n            self.config = new MetaphorJs.lib.Config(null, {\n                state: self.state\n            });\n        }\n\n        self.initConfig();\n\n        var node = self.node;\n\n        if (node && node.firstChild) {\n            MetaphorJs.dom.data(node, \"mjs-transclude\", \n                MetaphorJs.dom.toFragment(node.childNodes));\n        }\n\n        if (!self.id) {\n            self.id = self.config.get(\"id\") || nextUid();\n        }\n\n        self.state.$app.registerCmp(self, \"id\");        \n        self.initView();\n    },\n\n    initView: function() {},\n\n    initConfig: function() {\n        var config = this.config,\n            s = MetaphorJs.lib.Config.MODE_STATIC;\n        config.setType(\"scrollOnChange\", \"bool\", s);\n        config.setDefaultMode(\"defaultCmp\", s);\n        config.setDefaultMode(\"id\", s);\n    },\n\n\n    clearComponent: function() {\n        var self    = this,\n            node    = self.node,\n            curr    = self.currentComponent;\n\n        if (curr) {\n\n            var anim = null,\n                cfg = self.config;\n\n            if (cfg && !cfg.$isDestroyed() && cfg.get(\"animate\")) {\n                anim = \"leave\";\n            }\n\n            MetaphorJs.animate.animate(node, anim).done(function(){\n\n                curr && !curr.$isDestroyed() && curr.$destroy();\n    \n                while (node.firstChild) {\n                    node.removeChild(node.firstChild);\n                }\n\n                self.currentComponent = null;\n            });\n        }\n    },\n\n    onCmpDestroy: function(cmp) {},\n\n    setComponent: function(cmp) {\n\n        var self    = this,\n            node    = self.node;\n\n        self.beforeCmpChange(cmp);\n        MetaphorJs.animate.stop(self.node);\n        self.clearComponent();\n\n        MetaphorJs.animate.animate(node, self.config.get(\"animate\") ? \"enter\" : null, function(){\n\n            var cfg     = isObject(cmp) ? cmp : {},\n                cls     = (isString(cmp) ? cmp : null) || \"MetaphorJs.app.Component\",\n                state   = cfg.state || self.state.$new();\n\n            cfg.destroyEl = false;\n            cfg.autoRender = true;\n            cfg.state = state;\n\n            return MetaphorJs.app.resolve(cls, cfg, node, [cfg]).done(function(newCmp){\n                newCmp.on(\"destroy\", self.onCmpDestroy, self);\n                self.currentComponent = newCmp;\n                self.afterCmpChange();\n            });\n        });\n    },\n\n    currentIs: function(cls) {\n        return this.currentComponent && this.currentComponent.$is(cls);\n    },\n\n    beforeCmpChange: function(cmpCls) {},\n\n    afterCmpChange: function() {\n        var self = this;\n        self.trigger(\"change\", self);\n        if (self.config.get(\"scrollOnChange\")) {\n            raf(function () {\n                self.node.scrollTop = 0;\n            });\n        }\n    },\n\n    onDestroy: function() {\n\n        var self = this;\n\n        self.clearComponent();\n\n        if (self.node) {\n            MetaphorJs.dom.data(self.node, \"mjs-transclude\", null, \"remove\");\n        }\n\n        self.state = null;\n        self.currentComponent = null;\n        self.currentView = null;\n\n        self.$super();\n    }\n});","\nrequire(\"../../lib/Config.js\");\nrequire(\"./Base.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.app.view.Component = MetaphorJs.app.view.Base.$extend({\n\n    initConfig: function() {\n        this.config.setDefaultMode(\"value\", MetaphorJs.lib.Config.MODE_DYNAMIC);\n        this.$super();\n    },\n\n    initView: function() {\n        var self = this;\n        self.config.on(\"value\", self.onCmpChange, self);\n        self.onCmpChange();\n    },\n\n    onCmpChange: function() {\n        var self    = this,\n            cmp     = self.config.get(\"value\") || \n                        self.config.get(\"defaultCmp\");\n\n        if (!cmp) {\n            self.currentComponent && self.clearComponent();\n        }\n        else {\n            self.setComponent(cmp);\n        }\n    }\n});","require(\"../__init.js\");\nrequire(\"../../lib/History.js\");\nrequire(\"../../lib/UrlParam.js\");\nrequire(\"../../lib/Config.js\");\nrequire(\"metaphorjs-animate/src/animate/animate.js\");\nrequire(\"metaphorjs-animate/src/animate/stop.js\");\nrequire(\"metaphorjs-shared/src/func/browser/parseLocation.js\");\nrequire(\"../../func/dom/data.js\");\nrequire(\"../../func/dom/toFragment.js\");\nrequire(\"../../func/app/resolve.js\");\nrequire(\"../../func/dom/addClass.js\")\nrequire(\"../../func/dom/removeClass.js\")\nrequire(\"../../lib/MutationObserver.js\");\nrequire(\"./Base.js\");\n\nconst extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    async = require(\"metaphorjs-shared/src/func/async.js\"),\n    isThenable = require(\"metaphorjs-shared/src/func/isThenable.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.app.view.Router = MetaphorJs.app.view.Base.$extend({\n\n    initView: function() {\n\n        var self = this;\n\n        self.routeMap = {};\n        self.cmpCache = {};\n        self.domCache = {};\n        self.route = self.route || [];\n\n        MetaphorJs.lib.History.init();\n        MetaphorJs.lib.History.on(\"location-change\", self.onLocationChange, self);\n        self.initRoutes();\n        self.onLocationChange();\n    },\n\n    initRoutes: function() {\n\n        var self = this,\n            routes = self.route,\n            params,\n            param,\n            route,\n            i, l,\n            j, z;\n\n        for (i = 0, l = routes.length; i < l; i++) {\n            route = routes[i];\n            route.id = route.id || nextUid();\n\n            if (route.params) {\n                params = {};\n                for (j = 0, z = route.params.length; j < z; j++) {\n                    param = route.params[j];\n                    if (param.name) {\n                        params[param.name] = new MetaphorJs.lib.UrlParam(\n                            extend({}, param, {enabled: false}, true, false)\n                        );\n                    }\n                }\n                route.params = params;\n            }\n\n            self.routeMap[route.id] = route;\n        }\n    },\n\n\n    onLocationChange: function() {\n\n        if (this.$destroyed || this.$destroying) {\n            return;\n        }\n\n        var self        = this,\n            url         = MetaphorJs.lib.History.current(),\n            loc         = MetaphorJs.browser.parseLocation(url),\n            path        = loc.pathname + loc.search + loc.hash,\n            routes      = self.route,\n            def,\n            i, len,\n            r, matches;\n\n        for (i = 0, len = routes.length; i < len; i++) {\n            r = routes[i];\n\n            if (r.regexp && (matches = loc.pathname.match(r.regexp))) {\n                self.resolveRoute(r, matches);\n                return;\n            }\n            else if (r.regexpFull && (matches = path.match(r.regexp))) {\n                self.resolveRoute(r, matches);\n                return;\n            }\n            if (r['default'] && !def) {\n                def = r;\n            }\n        }\n\n        var tmp = self.onNoMatchFound(loc);\n\n        if (tmp) {\n            if (isThenable(tmp)) {\n                tmp.done(self.resolveRoute, self);\n                tmp.fail(function(){\n                    self.finishOnLocationChange(def);\n                });\n            }\n            else {\n                self.resolveRoute(tmp);\n            }\n        }\n        else {\n            self.finishOnLocationChange(def);\n        }\n    },\n\n    finishOnLocationChange: function(def) {\n        var self = this;\n        if (self.$destroyed || self.$destroying) {\n            return;\n        }\n        if (def) {\n            self.resolveRoute(def);\n        }\n        else if (self.config.hasExpression(\"defaultCmp\")) {\n            self.setComponent(self.config.get(\"defaultCmp\"));\n        }\n    },\n\n    resolveRoute: function(route, matches) {\n\n        var self = this;\n\n        matches = matches || [];\n\n        if (route.resolve) {\n            var promise = route.resolve.call(self, route, matches);\n            if (isThenable(promise)) {\n                promise.done(function(){\n                    self.setRouteComponent(route, matches);\n                });\n            }\n            else if (promise) {\n                self.setRouteComponent(route, matches);\n            }\n        }\n        else {\n            self.setRouteComponent(route, matches);\n        }\n\n    },\n\n\n    onNoMatchFound: function() {},\n\n    toggleRouteParams: function(route, fn) {\n        if (route.params) {\n            for (var i in route.params) {\n                route.params[i][fn]();\n            }\n        }\n    },\n\n    setRouteClasses: function(route) {\n        var self    = this;\n\n        if (route.cls) {\n            self.currentCls = route.cls;\n            MetaphorJs.dom.addClass(self.node, route.cls);\n        }\n        if (route.htmlCls) {\n            self.currentHtmlCls = route.htmlCls;\n            MetaphorJs.dom.addClass(window.document.documentElement, route.htmlCls);\n        }\n    },\n\n    onRouteFail: function(route) {},\n\n    onRouteParamChange: function() {\n\n    },\n\n    setRouteComponent: function(route, matches, force) {\n\n        var self    = this,\n            node    = self.node,\n            params  = route.params,\n            cview   = self.currentView || {};\n\n        if (self.$destroyed || self.$destroying) {\n            return;\n        }\n\n        if (route.id === cview.id && !route.resetOnParamChange) {\n            if (self.currentComponent && self.currentComponent.onViewRepeat) {\n                self.currentComponent.onViewRepeat();\n            }\n            return;\n        }\n\n        if (route.ttlTmt) {\n            clearTimeout(route.ttlTmt);\n        }\n\n        self.beforeRouteCmpChange(route);\n\n        self.toggleRouteParams(cview, \"disable\");\n        self.toggleRouteParams(route, \"enable\");\n        MetaphorJs.animate.stop(self.node);\n        self.clearComponent();\n\n        if (cview.teardown) {\n            cview.teardown(cview, route, matches);\n        }\n\n        self.setRouteClasses(route);\n\n        self.currentView = route;\n\n        MetaphorJs.animate.animate(node, self.config.get(\"animate\") ? \"enter\" : null, function(){\n\n            var args    = matches || [],\n                cfg     = {\n                    destroyEl: false,\n                    autoRender: true,\n                    node: node,\n                    destroyState: true,\n                    state: self.state.$new()\n                };\n\n            if (route.config) {\n                cfg.config = route.config;\n            }\n            if (route.template) {\n                cfg.template = route.template;\n            }\n\n            args.shift();\n\n            if (params) {\n                extend(cfg, params, false, false);\n            }\n\n            args.unshift(cfg);\n\n            if (self.cmpCache[route.id]) {\n                self.currentComponent = self.cmpCache[route.id];\n                node.appendChild(self.domCache[route.id]);\n                self.currentComponent.unfreeze(self);\n                self.afterRouteCmpChange();\n                self.afterCmpChange();\n            }\n            else {\n\n                if (route.setup) {\n                    route.setup(route, matches);\n                }\n                else {\n\n                    return MetaphorJs.app.resolve(\n                        route.cmp || \"MetaphorJs.app.Component\",\n                        cfg,\n                        node,\n                        args\n                    )\n                    .done(function (newCmp) {\n\n                        self.currentComponent = newCmp;\n\n                        if (route.keepAlive) {\n                            newCmp[self.id] = route.id;\n                            self.cmpCache[route.id] = newCmp;\n                            self.domCache[route.id] = window.document.createDocumentFragment();\n                            newCmp.on(\"destroy\", self.onCmpDestroy, self);\n                        }\n\n                        self.afterRouteCmpChange();\n                        self.afterCmpChange();\n                    })\n                    .fail(function(){\n                        self.onRouteFail(route);\n                    });\n                }\n            }\n        });\n    },\n\n    currentIs: function(cls) {\n        if (this.currentView && this.currentView.id == cls) {\n            return true;\n        }\n        return this.$super(cls);\n    },\n\n\n    clearComponent: function() {\n        var self    = this,\n            node    = self.node,\n            cview   = self.currentView || {};\n\n        if (self.$destroyed || self.$destroying) {\n            return;\n        }\n\n        if (self.currentCls) {\n            MetaphorJs.dom.removeClass(self.node, self.currentCls);\n        }\n\n        self.currentView = null;\n\n        if (self.currentHtmlCls) {\n            MetaphorJs.dom.removeClass(window.document.documentElement, self.currentHtmlCls);\n        }\n\n        if (self.currentComponent) {\n\n            MetaphorJs.animate.animate(node, self.config.get(\"animate\") ? \"leave\" : null).done(function(){\n                \n                if (!cview.keepAlive) {\n\n                    if (self.currentComponent &&\n                        !self.currentComponent.$destroyed &&\n                        !self.currentComponent.$destroying) {\n                        self.currentComponent.$destroy();\n                    }\n\n                    while (node.firstChild) {\n                        node.removeChild(node.firstChild);\n                    }\n                }\n                else {\n                    self.currentComponent.freeze(self);\n                    var frg = self.domCache[cview.id];\n                    while (node.firstChild) {\n                        frg.appendChild(node.firstChild);\n                    }\n                    if (cview.ttl) {\n                        cview.ttlTmt = async(self.onCmpTtl, self, [cview], cview.ttl);\n                    }\n                }\n\n                self.currentComponent = null;\n            });\n        }\n    },\n\n\n    onCmpTtl: function(currentView) {\n\n        var self = this,\n            id = currentView.id;\n        route.ttlTmt = null;\n\n        if (self.$destroyed || self.$destroying) {\n            return;\n        }\n\n        if (self.cmpCache[id]) {\n            self.cmpCache[id].$destroy();\n            delete self.cmpCache[id];\n            delete self.domCache[id];\n        }\n    },\n\n    onCmpDestroy: function(cmp) {\n\n        var self = this,\n            id = cmp[self.id];\n\n        if (self.$destroyed || self.$destroying) {\n            return;\n        }\n\n        if (id && self.cmpCache[id]) {\n            delete self.cmpCache[id];\n            delete self.domCache[id];\n        }\n    },\n\n\n    beforeRouteCmpChange: function(route) {},\n    afterRouteCmpChange: function() {},\n\n\n\n    onDestroy: function() {\n\n        var self    = this,\n            i, l, j\n\n        MetaphorJs.lib.History.un(\"location-change\", self.onLocationChange, self);\n\n        for (i = 0, l = self.route.length; i < l; i++) {\n            if (self.route[i].params) {\n                for (j in self.route[i].params) {\n                    self.route[i].params[j].$destroy();\n                }\n            }\n        }\n\n        self.route = null;\n        self.$super();\n    }\n});\n\n\n","\n\nconst run = require(\"../func/app/run.js\");\n\nrun();\n\n","\nrequire(\"../../app/Directive.js\");\nrequire(\"../../lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nconst appDirective = function(state, node, config, renderer) {\n    renderer && renderer.flowControl(\"stop\", true);\n};\n\nappDirective.$prebuild = {\n    defaultMode: MetaphorJs.lib.Config.MODE_STATIC,\n    ignore: true\n};\n\nMetaphorJs.app.Directive.registerAttribute(\"app\", 100, appDirective);","\n\nconst Directive = require(\"../../app/Directive.js\"),\n    async = require(\"metaphorjs-shared/src/func/async.js\");\n\nDirective.registerAttribute(\"in-focus\", 500, Directive.$extend({\n\n    $class: \"MetaphorJs.app.Directive.attr.Autofocus\",\n    id: \"autofocus\",\n\n    initChange: function() {},\n\n    initDirective: function() {\n\n        var self = this,\n            val = self.config.get(\"value\");\n\n        if (\"\"+parseInt(val) === val) {\n            val = parseInt(val);\n        }\n        else {\n            if (val === \"false\") val = false;\n            else val = !!val;\n        }\n\n        if (val) {\n            var set = function() {\n                self.node.focus();\n                self.$destroy();\n            };\n            async(set, null, [], val === true ? 300 : val);\n        }\n    }\n}));\n","\nrequire(\"./bind.js\");\nconst Directive = require(\"../../app/Directive.js\");\n\nDirective.registerAttribute(\"bind-html\", 1000, \n    Directive.attr.Bind.$extend({\n        $class: \"MetaphorJs.app.Directive.attr.BindHtml\",\n        id: \"bind-html\",\n        _apis: [\"node\"],\n\n        updateElement: function(val) {\n            this.node.innerHTML = val;\n        }\n    }));","require(\"../../lib/State.js\");\nrequire(\"../../lib/Text.js\");\nrequire(\"../../func/dom/isField.js\");\nrequire(\"../../lib/Input.js\");\nrequire(\"../../lib/Config.js\");\nrequire(\"../../func/dom/addListener.js\");\nrequire(\"../../func/dom/removeListener.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    Directive = require(\"../../app/Directive.js\");\n\nDirective.registerAttribute(\"bind\", 1000, \n    Directive.$extend({\n        $class: \"MetaphorJs.app.Directive.attr.Bind\",\n        id: \"bind\",\n        \n        _apis: [\"node\", \"input\"],\n        input: null,\n        textRenderer: null,\n\n        initDirective: function() {\n\n            var self    = this,\n                config  = self.config;\n\n            if (self.input) {\n                self.input.onChange(self.onInputChange, self);\n            }\n\n            self.optionsChangeDelegate = bind(self.onOptionsChange, self);\n            MetaphorJs.dom.addListener(self.node, \"optionschange\", \n                                    self.optionsChangeDelegate);\n\n            if (config.has(\"if\")) {\n                config.on(\"if\", self.onIfChange, self);\n            }\n\n            if (config.get(\"recursive\")) {\n                config.disableProperty(\"value\");\n                config.disableProperty(\"recursive\");\n                self.textRenderer = new MetaphorJs.lib.Text(\n                    self.state, \n                    config.getExpression(\"value\"), \n                    {\n                        recursive: true, \n                        fullExpr: true,\n                        once: config.get(\"once\")\n                    }\n                );\n                self.textRenderer.subscribe(self.onTextRendererChange, self);\n                self.onTextRendererChange();\n            }\n            else {\n                self.$super();\n            }\n        },\n\n        initNode: function(node) {\n            var self = this;\n            if (MetaphorJs.dom.isField(node)) {\n                self.input = MetaphorJs.lib.Input.get(node);\n            }\n        },\n\n        onInputChange: function() {\n\n            var self = this,\n                config = self.config,\n                stateVal,\n                inputVal;\n\n            if (config.has(\"locked\") && config.get(\"locked\")) {\n                stateVal = self.config.get(\"value\") || null;\n                inputVal = self.input.getValue() || null;\n                if (stateVal != inputVal) {\n                    self.onStateChange();\n                }\n            }\n        },\n\n        onTextRendererChange: function() {\n            this.onStateChange();\n        },\n\n        onOptionsChange: function() {\n            this.onStateChange();\n        },\n\n        onIfChange: function(val) {\n            if (this.config.get(\"if\")) {\n                this.onStateChange();\n            }\n        },\n\n        onStateChange: function() {\n            var config = this.config;\n            if (config.has(\"if\") && !config.get(\"if\")) {\n                return;\n            }\n            var val = this.textRenderer ? \n                        this.textRenderer.getString() :\n                        this.config.get(\"value\")\n            this.updateElement(val);\n        },\n\n        updateElement: function(val) {\n\n            var self = this;\n\n            if (self.input) {\n                if (self.input.getValue() != val) {\n                    self.input.setValue(val);\n                }\n            }\n            else {\n                self.node[typeof self.node.textContent === \"string\" ? \"textContent\" : \"innerText\"] = val;\n            }\n        },\n\n        onDestroy: function() {\n\n            var self    = this;\n\n            MetaphorJs.dom.removeListener(\n                self.node, \"optionschange\", \n                self.optionsChangeDelegate);\n\n            if (self.textRenderer) {\n                self.textRenderer.$destroy();\n                self.textRenderer = null;\n            }\n\n            if (self.input) {\n                self.input.unChange(self.onInputChange, self);\n                self.input.$destroy();\n                self.input = null;\n            }\n\n            self.$super();\n        }\n    }, {\n        initConfig: function(config, instance) {\n            config.setType(\"if\", \"bool\");\n            config.setType(\"recursive\", \"bool\");\n            config.setType(\"once\", \"bool\", MetaphorJs.lib.Config.MODE_STATIC);\n            config.setType(\"locked\", \"bool\");\n        }\n    }));","\nrequire(\"metaphorjs-animate/src/animate/animate.js\");\nrequire(\"metaphorjs-animate/src/animate/stop.js\");\nrequire(\"../../func/dom/addClass.js\");\nrequire(\"../../func/dom/removeClass.js\");\nrequire(\"../../func/dom/hasClass.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\");\n\n/*\nvalue is always an object in the end\n{class: \"condition\", class: \"condition\"}\n\narray turns into _: []\n{_: [class, class]}\n(which is then turned into {class: true, class: true}\nDO NOT put class=\"{}\" when using class.name=\"{}\"\n */\n\n\n(function(){\n\n    var toggleClass = function(node, cls, toggle, doAnim) {\n\n        var has;\n\n        if (!node.className) {\n            node.className = \"\";\n        }\n\n        if (toggle !== null) {\n            if (toggle === MetaphorJs.dom.hasClass(node, cls)) {\n                return;\n            }\n            has = !toggle;\n        }\n        else {\n            has = MetaphorJs.dom.hasClass(node, cls);\n        }\n\n        if (has) {\n            if (doAnim) {\n                MetaphorJs.animate.animate(node, [cls + \"-remove\"]).done(function(){\n                    MetaphorJs.dom.removeClass(node, cls);\n                });\n            }\n            else {\n                MetaphorJs.dom.removeClass(node, cls);\n            }\n        }\n        else {\n            if (doAnim) {\n                MetaphorJs.animate.animate(node, [cls + \"-add\"]).done(function(){\n                    MetaphorJs.dom.addClass(node, cls);\n                });\n            }\n            else {\n                MetaphorJs.dom.addClass(node, cls);\n            }\n        }\n    };\n\n\n    var flatten = function(values) {\n        var clss = {},\n            i, l, val,\n            j, jl;\n\n        for (i = 0, l = values.length; i < l; i++) {\n            val = values[i];\n\n            if (typeof val === 'string') {\n                clss[val] = true;\n                continue;\n            }\n            else if (isArray(val)) {\n                for (j = -1, jl = val.length; ++j < jl; clss[val[j]] = true){}\n            }\n            for (j in val) {\n                if (j === '_') {\n                    for (j = -1, jl = val._.length; ++j < jl;\n                         clss[val._[j]] = true){}\n                }\n                else {\n                    clss[j] = val[j];\n                }\n            }\n        }\n\n        return clss;\n    };\n\n    Directive.registerAttribute(\"class\", 1000, Directive.$extend({\n\n        $class: \"MetaphorJs.app.Directive.attr.Class\",\n        id: \"class\",\n        \n        _initial: true,\n        _prev: null,\n\n        initConfig: function() {\n            var self = this,\n                config = self.config;\n            config.eachProperty(function(k) {\n                if (k === 'value' || k.indexOf(\"value.\") === 0) {\n                    config.on(k, self.onStateChange, self);\n                }\n            });\n            self.$super();\n        },\n\n        initChange: function() {\n            var self = this;\n            if (self._autoOnChange) {\n                self.onStateChange();\n            }\n        },\n\n        getCurrentValue: function() {\n            var all = this.config.getAllValues(),\n                values = [];\n\n            if (all[\"\"]) {\n                values.push(all['']);\n                delete all[''];\n            }\n            values.push(all);\n            \n            return flatten(values);\n        },\n\n        onStateChange: function() {\n\n            var self    = this,\n                node    = self.node,\n                clss    = self.getCurrentValue(),\n                prev    = self._prev,\n                i;\n\n            MetaphorJs.animate.stop(node);\n\n            if (prev) {\n                for (i in prev) {\n                    if (prev.hasOwnProperty(i)) {\n                        if (clss[i] === undefined) {\n                            toggleClass(node, i, false, false);\n                        }\n                    }\n                }\n            }\n\n            for (i in clss) {\n                if (clss.hasOwnProperty(i)) {\n                    toggleClass(node, i, !!clss[i], \n                        !self._initial && \n                        self.config.get(\"animate\"));\n                }\n            }\n\n            self._prev = clss;\n            self._initial = false;\n        }\n    }, {\n        initConfig: function(config, instance) {\n            config.setType(\"animate\", \"bool\");\n        }\n    }));\n\n}());","\nrequire(\"../../func/app/resolve.js\");\nrequire(\"../../lib/Config.js\");\nrequire(\"../../lib/State.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    ns = require(\"metaphorjs-namespace/src/var/ns.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n(function(){\n\n    var cmpAttr = function(state, node, config, renderer, attrSet) {\n\n        if (!(node instanceof window.Node)) {\n            throw new Error(\"cmp directive can only work with DOM nodes\");\n        }\n\n        // if there is no instructions regarding component's state,\n        // we create a new child state by default\n        if (!config.has(\"state\")) {\n            state = state.$new();\n        }\n\n        cmpAttr.initConfig(config);\n\n        var cmpName = config.get(\"value\"),\n            tag     = node.tagName.toLowerCase();\n\n        config.removeProperty(\"value\");\n\n        var cfg = {\n            state: state,\n            node: node,\n            config: config,\n            parentRenderer: renderer,\n            autoRender: true\n        };\n\n        if (MetaphorJs.directive.component[tag]) {\n            cfg.directives = attrSet.directives;\n            renderer.flowControl(\"stop\", true);\n        }\n\n        var promise = MetaphorJs.app.resolve(cmpName, cfg, node, [cfg])\n            .done(function(cmp){\n                if (renderer.$destroyed || state.$$destroyed) {\n                    cmp.$destroy();\n                }\n                else {\n                    renderer.on(\"destroy\", cmp.$destroy, cmp);\n                    renderer.trigger(\n                        \"reference\", \"cmp\", config.get(\"ref\") || cmp.id, \n                        cmp, cfg, attrSet\n                    );\n                }\n            });\n\n        renderer.trigger(\"reference-promise\", promise, cmpName, cfg, attrSet);\n        renderer.flowControl(\"ignoreInside\", true);\n    };\n\n    cmpAttr.initConfig = function(config, instance) {\n        var ms = MetaphorJs.lib.Config.MODE_STATIC;\n\n        config.setDefaultMode(\"value\", ms);\n        config.setDefaultMode(\"init\", MetaphorJs.lib.Config.MODE_FUNC);\n        config.setDefaultMode(\"as\", ms);\n        config.setDefaultMode(\"ref\", ms);\n        config.setDefaultMode(\"state\", ms);\n        config.setMode(\"into\", ms);\n        config.setType(\"cloak\", \"bool\", ms);\n    }\n\n    cmpAttr.deepInitConfig = function(config) {\n        var cmpName = config.get(\"value\");\n        var constr  = typeof cmpName === \"string\" ? ns.get(cmpName) : cmpName;\n        if (!constr) {\n            return;\n        }\n        if (constr.initConfig) {\n            constr.initConfig(config);\n        }\n    };\n\n    Directive.registerAttribute(\"cmp\", 200, cmpAttr);\n\n}());","\nrequire(\"../../func/app/resolve.js\");\nrequire(\"../../lib/Config.js\");\nrequire(\"../../lib/State.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    ns = require(\"metaphorjs-namespace/src/var/ns.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n(function(){\n\n    var ctrlAttr = function(state, node, config, renderer, attrSet) {\n\n        ctrlAttr.initConfig(config);\n        var ctrlName = config.get(\"value\");\n        config.removeProperty(\"value\");\n\n        // if there is instructions regarding controller's state\n        // we set this state for all children of current node\n        if (config.has(\"state\")) {\n            renderer.flowControl(\"newState\", state);\n        }\n\n        var cfg = {\n            state: state,\n            node: node,\n            config: config,\n            parentRenderer: renderer,\n            attrSet: attrSet\n        };\n\n        MetaphorJs.app.resolve(ctrlName, cfg, node, [cfg])\n            .done(function(ctrl) {\n                if (renderer.$destroyed || state.$$destroyed) {\n                    ctrl.$destroy();\n                }\n                else {\n                    renderer.on(\"destroy\", ctrl.$destroy, ctrl);\n                }\n            });\n    };\n\n    ctrlAttr.initConfig = function(config, instance) {\n        var ms = MetaphorJs.lib.Config.MODE_STATIC;\n        config.setDefaultMode(\"value\", ms);\n        config.setDefaultMode(\"as\", ms);\n        config.setDefaultMode(\"state\", ms);\n    };\n\n    ctrlAttr.deepInitConfig = function(config) {\n        const ctrlName = config.get(\"value\");\n        const constr   = typeof ctrlName === \"string\" ? ns.get(ctrlName) : ctrlName;\n        if (!constr) {\n            return;\n        }\n        if (constr.initConfig) {\n            constr.initConfig(config);\n        }\n    };\n\n    Directive.registerAttribute(\"controller\", 200, ctrlAttr);\n\n}());","\nrequire(\"../../func/dom/getAttr.js\");\nrequire(\"../../app/ListRenderer.js\");\nrequire(\"../../lib/Expression.js\");\nrequire(\"../../func/app/prebuilt.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    split = require(\"metaphorjs-shared/src/func/split.js\");\n\n\n(function(){\n\n    var types = [];\n\n    function detectModelType(expr, state) {\n        var i = 0,\n            l = types.length,\n            pb;\n\n        if (MetaphorJs.app.prebuilt.isKey(expr)) {\n            pb = MetaphorJs.app.prebuilt.get(\"config\", expr);\n        }\n        else if (typeof expr !== \"string\") {\n            pb = expr;\n        }\n\n        if (pb) {\n            var getter = MetaphorJs.lib.Expression.construct(pb, {getterOnly: true});\n            var obj = getter(state);\n        }\n        else {\n            var tmp = expr.split(\" in \"),\n                model = tmp.length === 1 ? expr : tmp[1],\n                obj = MetaphorJs.lib.Expression.get(model, state);\n        }\n\n        for (; i < l; i++) {\n            if (obj instanceof types[i][0]) {\n                return types[i][1];\n            }\n        }\n\n        return null;\n    }\n\n    var eachDirective = function eachDirective(state, node, config, renderer, attrSet) {\n\n        if (!(node instanceof window.Node)) {\n            throw new Error(\"'each' directive can only work with DOM nodes\");\n        }\n\n        renderer && renderer.flowControl(\"stop\", true);\n\n        config.disableProperty(\"value\");\n        var tagMode = node.nodeName.toLowerCase() === \"mjs-each\",\n            expr;\n\n        if (tagMode) {\n            expr = MetaphorJs.dom.getAttr(node, \"value\");\n        }\n        else {\n            expr = config.getExpression(\"value\");\n        }\n\n        var handler = detectModelType(expr, state) || MetaphorJs.app.ListRenderer;\n\n        return new handler(state, node, config, renderer, attrSet);\n    };\n\n\n    eachDirective.registerType = function(objectClass, handlerClass) {\n        types.push([objectClass, handlerClass]);\n    };\n\n    eachDirective.deepInitConfig = function(config) {\n        var prop = config.getProperty(\"value\"),\n            parts = this.splitExpression(prop.expression);\n        prop.expression = parts.model;\n        prop.inflate = prop.inflate || {};\n        prop.inflate.itemName = parts.name;\n    };\n\n    eachDirective.splitExpression = function(expr) {\n        var tmp = expr.split(\" \"),\n            i, len,\n            model, name,\n            row;\n\n        for (i = 0, len = tmp.length; i < len; i++) {\n\n            row = tmp[i];\n\n            if (row === \"\" || row === \"in\") {\n                continue;\n            }\n\n            if (!name) {\n                name = row;\n            }\n            else {\n                model = tmp.slice(i).join(\" \");\n                break;\n            }\n        }\n\n        return {\n            model: model,\n            name: name || \"item\"\n        }\n    };\n\n    eachDirective.registerType(Array, MetaphorJs.app.ListRenderer);\n\n    Directive.registerAttribute(\"each\", 100, eachDirective);\n    Directive.registerTag(\"each\", eachDirective);\n\n}());\n\n\n","require(\"../../lib/EventHandler.js\");\nrequire(\"../../lib/Expression.js\");\nrequire(\"../../lib/Input.js\");\nrequire(\"../../lib/Config.js\");\nrequire(\"../../func/dom/addListener.js\");\nrequire(\"../../func/dom/removeListener.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n(function(){\n\n    const events = [  'click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',\n                    'mouseout', 'mousemove', 'keydown', 'keyup', 'keypress',\n                    'change',\n                    'focus', 'blur', 'copy', 'cut', 'paste', 'load', 'mousewheel',\n                    'touchstart', 'touchend', 'touchcancel', \n                    'touchleave', 'touchmove',\n                    'dragstart', 'dragenter', 'dragleave', 'dragend', 'drop'];\n    let i, len;\n\n    const prepareConfig = function(config) {\n        const ms = MetaphorJs.lib.Config.MODE_STATIC;\n        config.setProperty(\"preventDefault\", {\n            type: \"bool\", \n            defaultValue: true,\n            defaultMode: ms\n        });\n        config.setDefaultMode(\"state\", ms);\n        config.setType(\"stopPropagation\", \"bool\", ms);\n        config.setType(\"stopImmediatePropagation\", \"bool\", ms);\n        config.setType(\"if\", \"bool\");\n        config.setType(\"passive\", \"bool\");\n        config.setType(\"not\", \"string\", ms);\n        config.eachProperty(function(k){\n            if (k === 'value' || k.indexOf('value.') === 0) {\n                config.setMode(k, MetaphorJs.lib.Config.MODE_FUNC);\n            }\n        });\n        return config;\n    };\n\n    const createHandler = function(name, state, node, config) {\n        return new MetaphorJs.lib.EventHandler(\n            name, state, node, prepareConfig(config)\n        );\n    };\n\n    const getNode = function(node, config, directive, cb) {\n        Directive.resolveNode(node, directive, function(node, cmp){\n            if(cmp) {\n                config.setProperty(\"targetComponent\", {\n                    mode: MetaphorJs.lib.Config.MODE_STATIC,\n                    value: cmp\n                });\n            }\n            cb(node);\n        });\n    };\n\n    for (i = 0, len = events.length; i < len; i++) {\n\n        (function(name){\n\n            var dir = function(state, node, config, renderer, attrSet) {\n\n                var eh,\n                    destroyed = false,\n                    rs = window.document.readyState,\n                    init = function(node) {\n                        if (!destroyed) {\n                            eh = createHandler(name, state, node, config);\n                        }\n                    };\n\n                if (rs === \"complete\" || rs === undefined) {\n                    getNode(node, config, name, init);\n                }\n                else MetaphorJs.dom.addListener(window, \"load\", function(){\n                    getNode(node, config, name, init);\n                });\n\n                return function() {\n                    destroyed = true;\n                    if (eh) {\n                        eh.$destroy();\n                        eh = null;\n                    }\n                };\n            };\n\n            dir.initConfig = function(config, instance) {\n                prepareConfig(config);\n            };\n\n            Directive.registerAttribute(name, 1000, dir);\n\n        }(events[i]));\n    }\n\n    const dir = function(state, node, config) {\n\n        prepareConfig(config);\n\n        var fn = config.get(\"value\"),\n            handler = function(){\n                fn(state);\n                config.checkState(\"value\")\n            },\n            resolvedNode,\n            init = function(node) {\n                if (handler) {\n                    resolvedNode = node;\n                    MetaphorJs.lib.Input.get(node).onKey(13, handler);\n                }\n            };\n\n        if (window.document.readyState === \"complete\") {\n            getNode(node, config, \"submit\", init);\n        }\n        MetaphorJs.dom.addListener(window, \"load\", function(){\n            getNode(node, config, \"submit\", init);\n        });\n\n        return function() {\n            if (resolvedNode) {\n                MetaphorJs.lib.Input.get(resolvedNode).unKey(13, handler);\n            }\n            handler = null;\n            fn = null;\n        };\n    };\n\n    dir.initConfig = prepareConfig;\n\n    Directive.registerAttribute(\"submit\", 1000, dir);\n\n}());\n","\nrequire(\"../../func/dom/addListener.js\");\nrequire(\"../../func/dom/removeListener.js\");\nrequire(\"../../lib/Config.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nDirective.registerAttribute(\"focused\", 600, Directive.$extend({\n\n    $class: \"MetaphorJs.app.Directive.attr.InFocus\",\n    id: \"focused\",\n\n    initChange: function() {},\n\n    initDirective: function() {\n\n        this.focusDelegate = bind(this.onInputFocus, this);\n        this.blurDelegate = bind(this.onInputBlur, this);\n\n        MetaphorJs.dom.addListener(this.node, \"focus\", this.focusDelegate);\n        MetaphorJs.dom.addListener(this.node, \"blur\", this.blurDelegate);\n    },\n\n    onInputFocus: function() {\n        this.config.get(\"value\")(this.state, true);\n        this.state.$check();\n    },\n    onInputBlur: function() {\n        this.config.get(\"value\")(this.state, false);\n        this.state.$check();\n    },\n\n    onDestroy: function(){\n        MetaphorJs.dom.removeListener(this.node, \"focus\", this.focusDelegate);\n        MetaphorJs.dom.removeListener(this.node, \"blur\", this.blurDelegate);\n        this.$super();\n    }\n}, {\n    initConfig: function(config) {\n        config.setMode(\"value\", MetaphorJs.lib.Config.MODE_SETTER);\n    }\n}));\n","require(\"./show.js\");\n\nconst Directive = require(\"../../app/Directive.js\");\n\nDirective.registerAttribute(\"hide\", 500, Directive.attr.Show.$extend({\n\n    $class: \"MetaphorJs.app.Directive.attr.Hide\",\n    id: \"hide\",\n\n    onStateChange: function(val) {\n        var self    = this;\n        self.runAnimation(!val);\n        self._initial = false;\n        self.saveStateOnChange(val);\n    }\n}));","\nrequire(\"metaphorjs-animate/src/animate/animate.js\");\nrequire(\"../../lib/Config.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    raf = require(\"metaphorjs-animate/src/func/raf.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nDirective.registerAttribute(\"if\", 500, Directive.$extend({\n\n    $class: \"MetaphorJs.app.Directive.attr.If\",\n    id: \"if\",\n\n    _initial: true,\n   \n    initDirective: function() {\n        this.createCommentWrap(this.node, \"if\");\n        this.$super();\n    },\n\n\n    onStateChange: function() {\n        var self    = this,\n            config  = self.config,\n            val     = config.get(\"value\"),\n            node    = self.node,\n            initial = self._initial,\n\n            show    = function() {\n                self.wrapperClose.parentNode.insertBefore(node, self.wrapperClose);\n                if (!initial) {\n                    raf(self.trigger, self, [\"show\", node]);\n                }\n            },\n\n            hide    = function() {\n                node.parentNode.removeChild(node);\n                if (!initial) {\n                    raf(self.trigger, self, [\"hide\", node]);\n                }\n            };\n\n        if (val) {\n            initial || !self.config.get(\"animate\") ?\n                (initial ? show() : raf(show)) : \n                MetaphorJs.animate.animate(node, \"enter\", show);\n        }\n        else {\n            if (node.parentNode) {\n                initial || !self.config.get(\"animate\") ?\n                    (initial ? hide() : raf(hide)) : \n                    MetaphorJs.animate.animate(node, \"leave\").done(hide);\n            }\n        }\n\n        self.$super(val);\n\n        if (self._initial) {\n            self._initial = false;\n        }\n        else {\n            if (self.config.get(\"once\")) {\n                self.$destroy();\n            }\n        }\n    }\n}, {\n    initConfig: function(config) {\n        config.setType(\"animate\", \"bool\", MetaphorJs.lib.Config.MODE_STATIC)\n        config.setType(\"value\", \"bool\");\n        config.setType(\"once\", \"bool\", MetaphorJs.lib.Config.MODE_STATIC);\n    }\n}));\n","\nrequire(\"../../app/Template.js\");\nrequire(\"../../lib/Config.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nDirective.registerAttribute(\"include\", 1100, function(){\n\n    const dir = function include_directive(state, node, config, renderer, attrSet){\n\n        if (!(node instanceof window.Node)) {\n            throw new Error(\"'include' directive can only work with Node\");\n        }\n    \n        config.disableProperty(\"value\");\n        config.setProperty(\"name\", config.getProperty(\"value\"));\n        config.removeProperty(\"value\");\n        config.enableProperty(\"name\");\n        config.set(\"passReferences\", true);\n    \n        dir.initConfig(config);\n    \n        var tpl = new MetaphorJs.app.Template({\n            state: state,\n            attachTo: node,\n            parentRenderer: renderer,\n            config: config\n        });\n    \n        renderer.on(\"destroy\", function(){\n            tpl.$destroy();\n            tpl = null;\n        });\n    \n        renderer.flowControl(\"ignoreInside\", true);\n    };\n\n    dir.initConfig = function(config) {\n        config.setType(\"asis\", \"bool\", MetaphorJs.lib.Config.MODE_STATIC);\n        config.setDefaultValue(\"runRenderer\", !config.get(\"asis\"));\n    };\n\n    dir.deepInitConfig = function(config) {\n        MetaphorJs.app.Template.initConfig(config);\n    };\n\n    return dir;\n}());","\nrequire(\"../../lib/Expression.js\");\nrequire(\"../../lib/Config.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nDirective.registerAttribute(\"init\", 250, function() {\n    \n    const initDir = function(state, node, config) {\n        initDir.initConfig(config);\n        config.eachProperty(function(k, prop) {\n            if (k === 'value' || k.indexOf('value.') === 0) {\n                var fn = config.get(k);\n                fn && fn(state);\n            }\n        });\n        config.clear();\n    };\n\n    initDir.initConfig = function(config) {\n        var mf = MetaphorJs.lib.Config.MODE_FUNC;\n        config.eachProperty(function(k, prop) {\n            if (k === 'value' || k.indexOf('value.') === 0) {\n                config.setDefaultMode(k, mf);\n            }\n        });\n    };\n\n    return initDir;\n}());","require(\"../../lib/State.js\");\nrequire(\"../../lib/Expression.js\");\nrequire(\"../../lib/MutationObserver.js\");\nrequire(\"../../lib/Config.js\");\nrequire(\"../../func/dom/addListener.js\");\nrequire(\"../../func/dom/removeListener.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    emptyFn = require(\"metaphorjs-shared/src/func/emptyFn.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nDirective.registerAttribute(\"input\", 1000, Directive.$extend({\n\n    $class: \"MetaphorJs.app.Directive.attr.Model\",\n    id: \"input\",\n    _apis: [\"node\", \"input\"],\n\n    _inProg: false,\n    _prev: null,\n\n    initDirective: function() {\n\n        var self    = this;\n\n        self.input.onChange(self.onInputChange, self);\n        self._prev = self.input.getValue();\n        self.$super();\n    },\n\n    initChange: emptyFn,\n\n    onOptionsChange: function() {\n        this.onStateChange();\n    },\n\n    onInputChange: function(val) {\n\n        const self    = this,\n            state   = self.state,\n            config  = self.config;\n\n        if (config.has(\"if\") && !config.get(\"if\")) {\n            return;\n        }\n        if (self._prev == val || self._inProg) {\n            return;\n        }\n\n        self._inProg = true;\n\n        var fn = config.get(\"value\");\n        state.$prev = self._prev;\n        state.$value = val;\n        fn(state);\n        state.$prev = null;\n        state.$value = null;\n\n        config.checkState(\"value\");\n        self._prev = val;\n        self._inProg = false;\n    },\n\n    onDestroy: function() {\n        var self        = this;\n\n        self.input.unChange(self.onInputChange, self);\n        self.input.$destroy();\n        self.input = null;\n\n        self.$super();\n    }\n\n\n}, {\n\n    initConfig: function(config) {\n        config.setType(\"if\", \"bool\");\n        config.setMode(\"value\", MetaphorJs.lib.Config.MODE_FUNC);\n    },\n\n    $prebuild: {\n        skip: true\n    }\n\n}));","\nrequire(\"../../lib/Expression.js\");\nrequire(\"../../lib/Input.js\");\nrequire(\"../../lib/Config.js\");\nrequire(\"../../func/dom/addListener.js\");\nrequire(\"../../func/dom/removeListener.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n(function() {\n\nconst keys = {\n    \"enter\": 13,\n    \"esc\": 27,\n    \"escape\": 27,\n    \"backspace\": 8,\n    \"tab\": 9,\n    \"shift\": 16,\n    \"ctrl\": 17,\n    \"alt\": 18,\n    \"pause\": 19,\n    \"caps\": 20,\n    \"space\": 32,\n    \"pageup\": 33,\n    \"pagedown\": 34,\n    \"end\": 35,\n    \"home\": 36,\n    \"left\": 37,\n    \"up\": 38,\n    \"right\": 39,\n    \"down\": 40,\n    \"insert\": 45,\n    \"delete\": 46,\n    \"0\": 48,\n    \"1\": 49,\n    \"2\": 50,\n    \"3\": 51,\n    \"4\": 52,\n    \"5\": 53,\n    \"6\": 54,\n    \"7\": 55,\n    \"8\": 56,\n    \"9\": 57,\n    \"a\":\t65,\n    \"b\":\t66,\n    \"c\":\t67,\n    \"d\":\t68,\t\n    \"e\":\t69,\n    \"f\":\t70,\n    \"g\":\t71,\n    \"h\":\t72,\n    \"i\":\t73,\n    \"j\":\t74,\n    \"k\":\t75,\n    \"l\":\t76,\n    \"m\":\t77,\n    \"n\":\t78,\n    \"o\":\t79,\n    \"p\":\t80,\n    \"q\":\t81,\n    \"r\":\t82,\n    \"s\":\t83,\n    \"t\":\t84,\n    \"u\":\t85,\n    \"v\":\t86,\n    \"w\":\t87,\n    \"x\":\t88,\n    \"y\":\t89,\n    \"z\":\t90,\n    \"f1\":   112,\n    \"f2\":   113,\n    \"f3\":   114,\n    \"f4\":   115,\n    \"f5\":   116,\n    \"f6\":   117,\n    \"f7\":   118,\n    \"f8\":   119,\n    \"f9\":   120,\n    \"f10\":  121,\n    \"f11\":  122,\n    \"f12\":  123,\n    \"leftwin\": 91,\n    \"rightwin\": 92,\n    \"select\": 93,\n    \"num0\": 96,\n    \"num1\": 97,\n    \"num2\": 98,\n    \"num3\": 99,\n    \"num4\": 100,\n    \"num5\": 101,\n    \"num6\": 102,\n    \"num7\": 103,\n    \"num8\": 104,\n    \"num9\": 105,\n    \"*\": 106,\n    \"multiply\": 106,\n    \"+\": 107,\n    \"add\": 107,\n    \"-\": 109,\n    \"subtract\": 109,\n    \"decimal\": 110,\n    \"/\": 111,\n    \"divide\": 111,\n    \"numlock\": 144,\n    \"scrolllock\": 145,\n    \"semicolon\": 186,\n    \"equal\": 187,\n    \"comma\": 188,\n    \"dash\": 189,\n    \"period\": 190,\n    \"forwardslash\": 191,\n    \"graveaccent\": 192,\n    \"openbracket\": 219,\n    \"backslash\": 220,\n    \"closebracket\": 221,\n    \"quote\": 222\n};\n\n\n/*\nvalue is always an array in the end:\n[{keyCode: 1, handler: fn}, {...}]\n\nDO NOT MIX {key}=\"{...}\" with  {key.enter}=\"{...}\"\n\nNO:\n{key}=\"{...}\"\n{key.enter}=\"{...}\"\n\nYES:\n{key}=\"{...}\"\n\nor\n\n{key}=\"[{...}]\"\n{key.enter}=\"{...}\"\n\n */\n\nconst getNode = function(node, config, cb) {\n    Directive.resolveNode(node, \"key\", function(node, cmp){\n        if (cmp) {\n            config.setProperty(\"targetComponent\", {\n                mode: MetaphorJs.lib.Config.MODE_STATIC,\n                value: cmp\n            });\n        }\n        cb(node);\n    });\n};\n\nconst dir = function key_directive(state, node, config, renderer, attrSet){\n\n    dir.initConfig(config);\n\n    var createHandler = function(node, name, cfg) {\n\n        if (typeof cfg === \"function\") {\n            cfg = {handler: cfg};\n        }\n\n        var h = cfg.handler;\n        var context = cfg.context || state;\n\n        delete cfg.handler;\n        delete cfg.context;\n\n        if (!cfg.keyCode) {\n            cfg.keyCode = keys[name] || parseInt(name,10);\n        }\n\n        var handler = function(e) {\n            state.$event = e;\n            state.$eventCmp = config.get(\"targetComponent\");\n            h(state);\n            state.$event = null;\n            state.$eventCmp = null;\n            state.$check();\n        };\n        \n        MetaphorJs.lib.Input.get(node).onKey(cfg, handler, context);\n\n        return function() {\n            MetaphorJs.lib.Input.get(node).unKey(cfg, handler, context);\n        };\n    };\n\n    var cfgs = config.getAllValues(),\n        name,\n        uninstall = [],\n        init = function(node) {\n            if (cfgs) {\n                for (name in cfgs) {\n                    if (cfgs.hasOwnProperty(name) && cfgs[name]) {\n                        uninstall.push(createHandler(node, name, cfgs[name]));\n                    }\n                }\n            }\n        };\n\n    if (window.document.readyState === \"complete\") {\n        getNode(node, config, init);\n    }\n    MetaphorJs.dom.addListener(window, \"load\", function(){\n        getNode(node, config, init);\n    });\n\n    return function() {\n        var i, l;\n        for (i = 0, l = uninstall.length; i < l; i++) {\n            uninstall[i]();\n        }\n        uninstall = null;\n    };\n};\n\n\ndir.initConfig = function(config) {\n    config.disableProperty(\"value\");\n    config.eachProperty(function(k, prop){\n        if (k.indexOf('value.') === 0) {\n            if (prop.expression.charAt(0) !== '{') {\n                config.setMode(k, MetaphorJs.lib.Config.MODE_FUNC);\n            }\n        }\n    });\n};\n\nDirective.registerAttribute(\"key\", 1000, dir);\n\n}());","require(\"../../lib/State.js\");\nrequire(\"../../lib/Expression.js\");\nrequire(\"../../lib/MutationObserver.js\");\nrequire(\"../../lib/Config.js\");\nrequire(\"../../func/dom/addListener.js\");\nrequire(\"../../func/dom/removeListener.js\");\n\nconst async = require(\"metaphorjs-shared/src/func/async.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    isIE = require(\"../../func/browser/isIE.js\"),\n    isString = require(\"metaphorjs-shared/src/func/isString.js\"),\n    Directive = require(\"../../app/Directive.js\"),\n    emptyFn = require(\"metaphorjs-shared/src/func/emptyFn.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nDirective.registerAttribute(\"model\", 1000, Directive.$extend({\n\n    $class: \"MetaphorJs.app.Directive.attr.Model\",\n    id: \"model\",\n    _apis: [\"node\", \"input\"],\n\n    _binding: null,\n    _inProg: false,\n\n    initDirective: function() {\n\n        var self    = this,\n            expr    = self.config.getExpression(\"value\")\n\n        self.mo = MetaphorJs.lib.MutationObserver.get(\n            self.state, expr, null, null, {\n                setter: true\n            }\n        );\n        self.mo.subscribe(self.onStateChange, self);\n        self.input.onChange(self.onInputChange, self);\n\n        self.optionsChangeDelegate = bind(self.onOptionsChange, self);\n        MetaphorJs.dom.addListener(self.node, \"optionschange\", \n                                    self.optionsChangeDelegate);\n\n        self.$super();\n\n        var inputValue      = self.input.getValue(),\n            stateValue      = self.mo.getValue(),\n            binding         = self.config.get(\"binding\");\n\n        if (stateValue !== inputValue) {\n            // state value takes priority\n            if (binding !== \"input\" && stateValue !== undefined) {\n                self.onStateChange(stateValue);\n            }\n            else if (binding !== \"state\" && inputValue !== undefined) {\n                self.onInputChange(inputValue);\n            }\n        }\n    },\n\n\n    initChange: emptyFn,\n\n    onOptionsChange: function() {\n        this.onStateChange();\n    },\n\n    onInputChange: function(val) {\n\n        var self    = this,\n            config  = self.config,\n            binding = self._binding || config.get(\"binding\");\n\n        if (binding !== \"state\") {\n\n            if (config.has(\"if\") && !config.get(\"if\")) {\n                return;\n            }\n\n            if (val && isString(val) && val.indexOf('\\\\{') !== -1) {\n                val = val.replace(/\\\\{/g, '{');\n            }\n\n            if (self.mo.getValue() == val) {\n                return;\n            }\n\n            self.mo.setValue(val);\n\n            self._inProg = true;\n            self.config.checkState(\"value\");\n            self._inProg = false;\n\n            self.saveStateOnChange(val);\n        }\n    },\n\n\n    onStateChange: function() {\n\n        var self    = this,\n            config  = self.config,\n            val     = self.mo.getValue(), \n            binding = self._binding || config.get(\"binding\"),\n            ie;\n\n        if (binding !== \"input\" && !self._inProg) {\n\n            if (config.has(\"if\") && !config.get(\"if\")) {\n                return;\n            }\n\n            // when state value changed but this field\n            // is not in focus, it should try to\n            // change input's value, but not react\n            // to input's 'change' and 'input' events --\n            // fields like select or radio may not have\n            // this value in its options. that will change\n            // value to undefined and bubble back to state\n            if (window.document.activeElement !== self.node) {\n                self._binding = \"state\";\n            }\n\n            if ((ie = isIE()) && ie < 8) {\n                async(self.input.setValue, self.input, [val]);\n            }\n            else {\n                self.input.setValue(val);\n            }\n\n            self._binding = null;\n            self.saveStateOnChange(val);\n        }\n    },\n\n    onDestroy: function() {\n        var self        = this;\n\n        MetaphorJs.dom.removeListener(\n            self.node, \"optionschange\", \n            self.optionsChangeDelegate);\n\n        self.input.unChange(self.onInputChange, self);\n        self.input.$destroy();\n        self.input = null;\n\n        if (self.mo) {\n            self.mo.unsubscribe(self.onStateChange, self);\n            self.mo.$destroy(true);\n        }\n\n        self.$super();\n    }\n\n\n}, {\n\n    initConfig: function(config) {\n        config.setMode(\"value\", MetaphorJs.lib.Config.MODE_FNSET);\n        config.setType(\"if\", \"bool\");\n        config.setProperty(\"binding\", {\n            defaultValue: \"both\",\n            defaultMode: MetaphorJs.lib.Config.MODE_STATIC\n        });\n    },\n\n    $prebuild: {\n    \n    }\n\n}));","require(\"../../lib/Expression.js\");\nrequire(\"../../lib/Config.js\");\nrequire(\"../../lib/MutationObserver.js\");\nrequire(\"../../func/dom/getInputValue.js\");\nrequire(\"../../func/dom/setInputValue.js\");\nrequire(\"../../func/dom/setAttr.js\");\nrequire(\"../../func/browser/isIE.js\");\nrequire(\"../../func/dom/triggerEvent.js\");\nrequire(\"../../func/app/prebuilt.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    error = require(\"metaphorjs-shared/src/func/error.js\"),\n    Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nDirective.registerAttribute(\"options\", 100, Directive.$extend({\n\n    $class: \"MetaphorJs.app.Directive.attr.Options\",\n    id: \"options\",\n\n    model: null,\n    store: null,\n\n    _getterFn: null,\n    _defOption: null,\n    _prevGroup: null,\n    _groupEl: null,\n    _fragment: null,\n    _initial: false,\n\n    $init: function(state, node, config, renderer, attrSet) {\n        if (!(node instanceof window.HTMLSelectElement)) {\n            throw new Error(\"'options' directive can only work with <select>\");\n        }\n        this.$super(state, node, config, renderer, attrSet);\n    },\n\n    initConfig: function() {\n        var self    = this,\n            config  = self.config,\n            expr;\n\n        \n        config.disableProperty(\"value\");\n        expr = config.getExpression(\"value\");\n\n        config.on(\"placeholderName\", self.onPlaceholderChange, self);\n        config.on(\"placeholderValue\", self.onPlaceholderChange, self);\n\n        self.parseExpr(expr);\n        self.$super();\n    },\n\n    initDirective: function() {\n\n        var self    = this,\n            node    = self.node;\n        \n        self._defOption  = node.options.length ? node.options[0] : null;\n\n        while (node.firstChild) {\n            node.removeChild(node.firstChild);\n        }\n\n        if (self.config.get(\"keepDefault\")) {\n            self._defOption && MetaphorJs.dom.setAttr(self._defOption, \"default-option\", \"\");\n        }\n        else self._defOption = null;\n\n        try {\n            var value = MetaphorJs.lib.Expression.get(self.model, self.state);\n\n            if (cls.isInstanceOf(value, \"MetaphorJs.model.Store\")) {\n                self.bindStore(value, \"on\");\n            }\n            else {\n                self.watcher = MetaphorJs.lib.MutationObserver.get(\n                    self.state, self.model, self.onStateChange, self);\n            }\n        }\n        catch (thrownError) {\n            error(thrownError);\n        }\n\n        if (self.watcher) {\n            self.renderAll();\n        }\n        else if (self.store) {\n            self.renderStore();\n        }\n    },\n\n    bindStore: function(store, mode) {\n        var self = this;\n        store[mode](\"update\", self.renderStore, self);\n        self.store = store;\n    },\n\n    getSourceList: function() {\n        return this.store ? \n            this.store.toArray() :\n            toArray(this.watcher.getValue());\n    },\n\n    renderStore: function() {\n        var self = this;\n        self.render(this.getSourceList());\n        self.dispatchOptionsChange();\n    },\n\n    renderAll: function() {\n        this.render(this.getSourceList());\n        this.dispatchOptionsChange();\n    },\n\n    onStateChange: function() {\n        var self = this;\n        self.renderAll();\n    },\n\n    onPlaceholderChange: function() {\n        var list = this.getSourceList();\n        if (!list || list.length === 0) {\n            this.render(list);\n        }       \n    },\n\n    dispatchOptionsChange: function() {\n        var self = this;\n        if (!self._initial && self.node.dispatchEvent) {\n            MetaphorJs.dom.triggerEvent(self.node, \"optionschange\");\n        }\n        self._initial = false;\n    },\n\n    renderOption: function(item, index, state) {\n\n        var self        = this,\n            parent      = self._groupEl || self._fragment,\n            msie        = MetaphorJs.browser.isIE(),\n            config,\n            option;\n\n        state.item      = item;\n        state.$index    = index;\n        config          = self._getterFn(state);\n        config.group    !== undefined && (config.group = \"\"+config.group);\n\n        if (config.group !== self.prevGroup) {\n\n            if (config.group){\n                self._groupEl = parent = window.document.createElement(\"optgroup\");\n                MetaphorJs.dom.setAttr(parent, \"label\", config.group);\n                if (config.disabledGroup) {\n                    MetaphorJs.dom.setAttr(parent, \"disabled\", \"disabled\");\n                }\n                self._fragment.appendChild(parent);\n            }\n            else {\n                parent = self._fragment;\n                self._groupEl = null;\n            }\n        }\n\n        self._prevGroup  = config.group;\n\n        option  = window.document.createElement(\"option\");\n        MetaphorJs.dom.setAttr(option, \"value\", \"\"+config.value || \"\");\n        option.text = config.name || \"\"+config.value || \"\";\n\n        if (msie && msie < 9) {\n            option.innerHTML = config.name || \"\"+config.value || \"\";\n        }\n        if (config.disabled) {\n            MetaphorJs.dom.setAttr(option, \"disabled\", \"disabled\");\n        }\n\n        parent.appendChild(option);\n    },\n\n    render: function(list) {\n\n        var self        = this,\n            node        = self.node,\n            value       = MetaphorJs.dom.getInputValue(node),\n            def         = self._defOption,\n            tmpState    = self.state.$new(),\n            msie        = MetaphorJs.browser.isIE(),\n            phValue     = self.config.get(\"placeholderValue\"),\n            phName      = self.config.get(\"placeholderName\") || phValue,\n            parent, next,\n            i, len, ph;\n\n        self._fragment   = window.document.createDocumentFragment();\n        self.prevGroup  = null;\n        self.groupEl    = null;\n\n        while(node.firstChild) {\n            node.removeChild(node.firstChild);\n        }\n\n        for (i = 0, len = list.length; i < len; i++) {\n            self.renderOption(list[i], i, tmpState);\n        }\n\n        if (def) {\n            node.insertBefore(def, node.firstChild);\n        }\n\n        if (phValue && !len && !def) {\n            ph = document.createElement(\"option\");\n            ph.value = phValue;\n            ph.text = phName;\n            node.insertBefore(ph, node.firstChild);\n        }\n\n        tmpState.$destroy();\n\n        // ie6 gives \"unspecified error when trying to set option.selected\"\n        // on node.appendChild(fragment);\n        // somehow this get fixed by detaching dom node\n        // and attaching it back\n        if (msie && msie < 8) {\n            next = node.nextSibling;\n            parent = node.parentNode;\n            parent.removeChild(node);\n        }\n\n        node.appendChild(self._fragment);\n        self._fragment = null;\n\n        if (msie && msie < 8) {\n            parent.insertBefore(node, next);\n        }\n\n        MetaphorJs.dom.setInputValue(node, value);\n    },\n\n\n    parseExpr: function(expr) {\n        var parts = this.$self.splitExpression(expr);\n        this.model = parts.model;\n        if (parts.item) {\n            this._getterFn = typeof parts.item === \"function\" ? \n                                parts.item : \n                                MetaphorJs.lib.Expression.getter(parts.item);\n        }\n    },\n\n    onDestroy: function() {\n\n        var self = this;\n\n        if (self.store){\n            self.bindStore(self.store, \"un\");\n        }\n        if (self.watcher) {\n            self.watcher.unsubscribe(self.onStateChange, self);\n            self.watcher.$destroy(true);\n        }\n\n        self.$super();\n\n    }\n\n}, {\n\n    splitExpression: function(expr) {\n\n        var model, item, splitIndex;\n\n        if (MetaphorJs.app.prebuilt.isKey(expr)) {\n            var pb = MetaphorJs.app.prebuilt.get(\"config\", expr);\n            model = pb;\n            //item = MetaphorJs.app.prebuilt.get(\"func\", pb.inflate.item);\n            item = pb.inflate.item;\n        }\n        else {\n            splitIndex  = expr.indexOf(\" in \");\n\n            if (splitIndex === -1) {\n                model   = expr;\n                item    = '{name: this.item, value: this.$index}';\n            }\n            else {\n                model   = expr.substr(splitIndex + 4);\n                item    = expr.substr(0, splitIndex);\n            }\n        }\n\n        return {model: model, item: item};\n    },\n\n    initConfig: function(config) {\n        config.setType(\"keepDefault\", \"bool\", MetaphorJs.lib.Config.MODE_STATIC, true);\n    },\n\n    deepInitConfig: function(config) {\n        var prop = config.getProperty(\"value\")\n            parts = this.splitExpression(prop.expression);\n\n        prop.expression = parts.model;\n        prop.inflate = prop.inflate || {};\n        prop.inflate.item = MetaphorJs.lib.Expression.expression(parts.item);\n    }\n}));\n\n","\nrequire(\"../../func/dom/removeAttr.js\");\nrequire(\"../../func/dom/setAttr.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\n(function(){\n\n    const booleanAttrs = [\"selected\", \"checked\", \"disabled\", \n                        \"readonly\", \"open\", \"required\"];\n    let i, l;\n\n    const PropertyDirective = Directive.$extend({\n\n        $init: function(name, state, node, config, renderer, attrSet) {\n            this.id = name;\n            this.$super(state, node, config, renderer, attrSet);\n        },\n\n        onStateChange: function(val) {\n\n            var name = this.id;\n\n            val = !!val;\n\n            if (val) {\n                MetaphorJs.dom.setAttr(this.node, name, name);\n            }\n            else {\n                MetaphorJs.dom.removeAttr(this.node, name);\n            }\n        }\n    }, {\n        initConfig: function(config) {\n            config.setType(\"value\", \"bool\");\n        }\n    });\n\n    for (i = 0, l = booleanAttrs.length; i < l; i++) {\n        (function(name){\n            var dir = function(state, node, config, renderer, attrSet){\n                return new PropertyDirective(name, state, node, config, renderer, attrSet);\n            };\n            dir.initConfig = PropertyDirective.initConfig;\n            Directive.registerAttribute(\"\" + name, 1000, dir);\n        }(booleanAttrs[i]));\n    }\n\n}());","require(\"../../app/Directive.js\");\nrequire(\"../../func/app/resolve.js\");\nrequire(\"../../lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nMetaphorJs.app.Directive.registerAttribute(\"router\", 200, function(){\n\n    const dir = function router_directive(state, node, config, renderer, attrSet) {\n\n        dir.initConfig(config);\n    \n        var routes = [],\n            r;\n    \n        config.eachProperty(function(k){\n            if (k.indexOf(\"value.\") === 0) {\n                r = config.get(k);\n                r['id'] = k.replace('value.', '');\n                routes.push(r);\n            }\n        });\n    \n        MetaphorJs.app.Directive.resolveNode(node, \"router\", function(node){\n            if (!renderer.$destroyed) {\n                const cfg = { state, node, config };\n    \n                if (routes.length !== 0) {\n                    cfg['route'] = routes;\n                }\n            \n                MetaphorJs.app.resolve(\n                    config.get(\"value\"),\n                    cfg,\n                    node,\n                    [cfg]\n                )\n                .done(function(view){\n                    if (renderer.$destroyed || state.$$destroyed) {\n                        view.$destroy();\n                    }\n                    else {\n                        renderer.on(\"destroy\", view.$destroy, view);\n                        state.$on(\"destroy\", view.$destroy, view);\n                    }\n                });\n            }\n        });\n    \n        renderer.flowControl(\"ignoreInside\", true);\n    }\n\n    dir.initConfig = function(config) {\n        var ms = MetaphorJs.lib.Config.MODE_STATIC;\n        config.setDefaultMode(\"state\", ms);\n        config.setDefaultMode(\"id\", ms);\n        config.setProperty(\"value\", {\n            defaultMode: ms,\n            defaultValue: \"MetaphorJs.app.view.Router\"\n        });\n        config.eachProperty(function(k){\n            if (k.indexOf(\"value.\") === 0) {\n                config.setDefaultMode(k, MetaphorJs.lib.Config.MODE_SINGLE);\n            }\n        });\n    };\n\n    return dir;\n}());\n","\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\nrequire(\"metaphorjs-animate/src/animate/animate.js\");\nrequire(\"../../lib/Config.js\");\n\nconst raf = require(\"metaphorjs-animate/src/func/raf.js\"),\n    Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nDirective.registerAttribute(\"show\", 500, Directive.$extend({\n\n    $class: \"MetaphorJs.app.Directive.attr.Show\",\n    id: \"show\",\n\n    _initial: true,\n\n    runAnimation: function(show) {\n\n        var self    = this,\n            style   = self.node.style,\n            initial = this._initial,\n            done    = function() {\n                if (!show) {\n                    style.display = \"none\";\n                }\n                else {\n                    style.display = self.config.get(\"display\");\n                }\n                if (!initial) {\n                    self.trigger(show?\"show\" : \"hide\", self.node);\n                }\n            };\n\n        initial || !self.config.get(\"animate\") ? \n            (initial ? done() : raf(done)) : \n            MetaphorJs.animate.animate(\n                self.node,\n                show ? \"show\" : \"hide\",\n                function() {\n                    if (show) {\n                        return new MetaphorJs.lib.Promise(function(resolve){\n                            raf(function(){\n                                style.display = self.config.get(\"display\");\n                                resolve();\n                            });\n                        });\n                    }\n                }\n            )\n            .done(done);\n    },\n\n    onStateChange: function(val) {\n        var self    = this;\n        self.runAnimation(val);\n        self._initial = false;\n        self.$super(val);\n    }\n}, {\n    initConfig: function(config) {\n        config.setType(\"display\", \n            \"string\", MetaphorJs.lib.Config.MODE_STATIC, \"\");\n        config.setType(\"animate\", \n            \"bool\", MetaphorJs.lib.Config.MODE_STATIC, false);\n    }\n}));\n","require(\"../../func/dom/select.js\");\nrequire(\"../../func/dom/setAttr.js\");\nrequire(\"../../lib/Config.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nDirective.registerAttribute(\"source-src\", 1000, Directive.$extend({\n\n    $class: \"MetaphorJs.app.Directive.attr.SourceSrc\",\n    id: \"source-src\",\n\n    usePreload: true,\n    attr: null,\n    lastPromise: null,\n    src: null,\n\n    $constructor: function(state, node, config, renderer, attrSet) {\n\n        var self = this;\n\n        self.$self.initConfig(config);\n\n        if (config.get(\"deferred\")) {\n            self.$plugins.push(\"plugin.SrcDeferred\");\n        }\n\n        if (config.get(\"plugin\")) {\n            var tmp = config.get(\"plugin\").split(\",\"),\n                i, l;\n            for (i = 0, l = tmp.length; i < l; i++) {\n                self.$plugins.push(tmp[i].trim());\n            }\n        }\n\n        self.$super(state, node, config, renderer, attrSet);\n    },\n\n    initConfig: function(){},\n\n    onStateChange: function() {\n        this.doChange();\n    },\n\n    doChange: function() {\n        var self = this;\n        \n        if (self.$destroyed || self.$destroying) {\n            return;\n        }\n\n        var src = self.config.get(\"value\");\n\n        if (!src) {\n            return;\n        }\n\n        self.src = src;\n\n        if (self.config.get(\"noCache\")) {\n            src += (src.indexOf(\"?\") !== -1 ? \"&amp;\" : \"?\") + \"_\" + (new Date).getTime();\n        }\n\n        self.doChangeSource(src);\n        self.onSrcChanged();\n    },\n\n    doChangeSource: function(src) {\n        var self = this,\n            node = self.node,\n            srcs = MetaphorJs.dom.select(\"source\", node),\n            source = window.document.createElement(\"source\"),\n            i, l;\n\n        if (srcs.length) {\n            for (i  = 0, l = srcs.length; i < l; i++) {\n                node.removeChild(srcs[i]);\n            }\n        }\n\n        MetaphorJs.dom.setAttr(source, \"src\", src);\n        node.appendChild(source);\n    },\n\n    onSrcChanged: function() {\n\n    }\n}, {\n    initConfig: function(config) {\n        var ms = MetaphorJs.lib.Config.MODE_STATIC;\n\n        config.setType(\"deferred\", \"bool\", ms);\n        config.setType(\"noCache\", \"bool\", ms);\n        config.setDefaultMode(\"plugin\", ms);\n    }\n}));","require(\"metaphorjs-shared/src/lib/Queue.js\");\nrequire(\"../../func/dom/preloadImage.js\");\nrequire(\"../../func/dom/setAttr.js\");\nrequire(\"../../lib/Config.js\");\n\nconst raf = require(\"metaphorjs-animate/src/func/raf.js\"),\n    Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nDirective.registerAttribute(\"src\", 1000, Directive.$extend({\n\n    $class: \"MetaphorJs.app.Directive.attr.Src\",\n\n    queue: null,\n    usePreload: true,\n    noCache: false,\n    attr: null,\n\n    lastPromise: null,\n    src: null,\n\n    $constructor: function(state, node, config, renderer, attrSet) {\n\n        var self = this;\n\n        self.$self.initConfig(config);\n\n        if (config.get(\"deferred\")) {\n            self.$plugins.push(\"MetaphorJs.plugin.SrcDeferred\");\n        }\n        if (config.get(\"preloadSize\")) {\n            self.$plugins.push(\"MetaphorJs.plugin.SrcSize\");\n        }\n        if (config.get(\"plugin\")) {\n            var tmp = config.get(\"plugin\").split(\",\"),\n                i, l;\n            for (i = 0, l = tmp.length; i < l; i++) {\n                self.$plugins.push(tmp[i].trim());\n            }\n        }\n\n        self.$super(state, node, config);\n    },\n\n    initDirective: function(state, node, config, renderer, attrSet) {\n\n        var self = this;\n\n        self.usePreload = !config.get(\"noPreload\");\n\n        if (self.usePreload) {\n            node.style.visibility = \"hidden\"\n        }\n\n        self.queue = new MetaphorJs.lib.Queue({auto: true, async: true, \n                                    mode: MetaphorJs.lib.Queue.REPLACE, thenable: true});\n\n        self.$super(state, node, config, renderer, attrSet);\n    },\n\n\n    onStateChange: function() {\n        var self = this;\n        self.cancelPrevious();\n        if (self.usePreload) {\n            self.node.style.visibility = \"hidden\";\n        }\n        self.queue.add(self.doChange, self);\n    },\n\n    doChange: function() {\n\n        var self = this;\n\n        if (self.$destroyed || self.$destroying) {\n            return;\n        }\n\n        var src = self.config.get(\"value\");\n\n        if (!src) {\n            return;\n        }\n\n        self.src = src;\n\n        if (self.config.get(\"noCache\")) {\n            src += (src.indexOf(\"?\") !== -1 ? \"&amp;\" : \"?\") + \"_\" + (new Date).getTime();\n        }\n\n        if (self.usePreload) {\n            self.lastPromise = MetaphorJs.dom.preloadImage(src);\n            if (self.lastPromise) {\n                self.lastPromise.done(self.onImagePreloaded, self);\n            }\n        }\n        else {\n            if (self.node) {\n                self.node.src = src;\n                MetaphorJs.dom.setAttr(self.node, \"src\", src);\n                self.onSrcChanged();\n            }\n        }\n    },\n\n    cancelPrevious: function() {\n        var self = this;\n\n        if (self.lastPromise) {\n            if (self.lastPromise.isPending()) {\n                self.lastPromise.abort();\n            }\n            self.lastPromise = null;\n        }\n    },\n\n    onImagePreloaded: function() {\n        var self = this,\n            src = self.src;\n\n        if (self && self.node) {\n            raf(function(){\n                if (self.node) {\n                    self.node.src = src;\n                    MetaphorJs.dom.setAttr(self.node, \"src\", src);\n                    self.onSrcChanged();\n                    self.node.style.visibility = \"\";\n                    self.state.$scheduleCheck(50);\n                }\n            });\n        }\n        self.lastPromise = null;\n    },\n\n    onSrcChanged: function() {\n\n    },\n\n    onStateReset: function() {\n        this.cancelPrevious();\n        this.$super();\n    },\n\n    onDestroy: function() {\n\n        var self = this;\n\n        if (!self.$destroyed) {\n            self.cancelPrevious();\n            self.queue.$destroy();\n            self.$super();\n        }\n    }\n}, {\n    initConfig: function(config) {\n        var ms = MetaphorJs.lib.Config.MODE_STATIC;\n\n        config.setType(\"deferred\", \"bool\", ms);\n        config.setType(\"noCache\", \"bool\", ms);\n        config.setType(\"noPreload\", \"bool\", ms);\n        config.setDefaultMode(\"preloadSize\", ms);\n        config.setDefaultMode(\"plugin\", ms);\n    }\n}));","\nrequire(\"../../lib/Config.js\");\nrequire(\"../../lib/State.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nDirective.registerAttribute(\"state\", 1000, function(){\n    const dir = function state_directive(state, node, config, renderer, attrSet) {\n\n        dir.initConfig(config);\n        var newState = MetaphorJs.lib.State.$produce(config.get(\"value\"), state);\n    \n        renderer.flowControl(\"newState\", newState);\n        config.clear();\n    };\n\n    dir.initConfig = function(config) {\n        config.setDefaultMode(\"value\", MetaphorJs.lib.Config.MODE_STATIC);\n    };\n\n    return dir;\n}());\n","require(\"../../func/dom/removeStyle.js\");\nrequire(\"../../lib/Config.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    async = require(\"metaphorjs-shared/src/func/async.js\"),\n    toBool = require(\"metaphorjs-shared/src/func/toBool.js\"),\n    toCamelCase = require(\"metaphorjs-shared/src/func/toCamelCase.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nDirective.registerAttribute(\"style\", 1000, Directive.$extend({\n\n    $class: \"MetaphorJs.app.Directive.attr.Style\",\n    id: \"style\",\n\n    initDirective: function() {\n\n        var self = this,\n            config = self.config;\n\n        config.on(\"value\", self.onStateChange, self);\n        config.eachProperty(function(k){\n            if (k.indexOf(\"value.\") === 0) {\n                config.on(k, self.onStateChange, self);\n            }\n        });\n\n        this.$super();\n    },\n\n    initChange: function() {\n        this.onStateChange();\n    },\n\n    getCurrentValue: function() {\n        var style = this.config.getAllValues();\n\n        if (style[\"\"]) {\n            extend(style, style[\"\"]);\n            delete style[''];\n        }\n\n        return style;\n    },\n\n    _applyStyle: function() {\n        var self    = this,\n            node    = self.node,\n            style   = node.style,\n            props   = self.getCurrentValue(),\n            prev    = self.prev,\n            k, trg;\n\n        for (k in prev) {\n            if (!props || props[k] === undefined) {\n                MetaphorJs.dom.removeStyle(node, k);\n            }\n        }\n\n        if (props) {\n            for (k in props) {\n\n                trg = toCamelCase(k);\n                if (props[k] !== undefined && props[k] !== null) {\n                    style[trg] = props[k];\n                }\n                else {\n                    MetaphorJs.dom.removeStyle(node, k);\n                }\n            }\n        }\n\n        self.prev = props;\n    },\n\n    onStateChange: function() {\n\n        var tmt = this.config.get(\"async\");\n        if (toBool(tmt)) {\n            tmt = parseInt(tmt) == tmt ? parseInt(tmt) : null;\n            async(this._applyStyle, this, [], tmt);\n        }\n        else {\n            this._applyStyle();\n        }\n    }\n}, {\n    initConfig: function(config, instance) {\n        config.setDefaultMode(\"async\", MetaphorJs.lib.Config.MODE_STATIC);\n    }\n}));","require(\"../../func/dom/transclude.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nDirective.registerAttribute(\"transclude\", 1000, \n    function(state, node, config, renderer, attrSet) {\n\n        if (!(node instanceof window.Node)) {\n            throw new Error(\"'transclude' directive can only work with Node\");\n        }\n\n        renderer.flowControl(\"nodes\", MetaphorJs.dom.transclude(\n            node, null, \n            renderer.trigger(\"transclude-sources\")\n        ));\n\n});","require(\"../../app/Directive.js\");\nrequire(\"../../func/app/resolve.js\");\nrequire(\"../../lib/Config.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nMetaphorJs.app.Directive.registerAttribute(\"view\", 200, \n    function(state, node, config, renderer) {\n\n    MetaphorJs.app.Directive.resolveNode(node, \"view\", function(node){\n        if (!renderer.$destroyed) {\n            const cfg = { state, node, config };\n\n            MetaphorJs.app.resolve(\n                \"MetaphorJs.app.view.Component\",\n                cfg,\n                node,\n                [cfg]\n            )\n            .done(function(view){\n                if (renderer.$destroyed || state.$$destroyed) {\n                    view.$destroy();\n                }\n                else {\n                    renderer.on(\"destroy\", view.$destroy, view);\n                    state.$on(\"destroy\", view.$destroy, view);\n                }\n            });\n        }\n    });\n\n    renderer.flowControl(\"ignoreInside\", true);\n});\n","require(\"../../func/dom/transclude.js\");\nconst Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nDirective.registerTag(\"transclude\", function(state, node, config, renderer) {\n    renderer && renderer.flowControl(\"nodes\", MetaphorJs.dom.transclude(node, true));\n});","\nconst Directive = require(\"../../app/Directive.js\");\n\nDirective.registerAttribute(\"break-if\", 500, function(state, node, config, renderer) {\n\n    config.setType(\"value\", \"bool\");\n\n    var res = config.get(\"value\");\n\n    if (res) {\n        node.parentNode.removeChild(node);\n    }\n\n    renderer && renderer.flowControl(\"stop\", !!res);\n});","\n\nconst Directive = require(\"../../app/Directive.js\");\n\nDirective.registerAttribute(\"ignore\", 0, function(state, node, config, renderer){\n    renderer && renderer.flowControl(\"stop\", true);\n});\n","require(\"../../directive/attr/style.js\");\nrequire(\"../../lib/Stylesheet.js\");\n\nconst Directive = require(\"../../app/Directive.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/*\nvalue is always an object in the end\nDO NOT MIX style=\"{}\" with style.prop=\"expression\".\n */\n\n\nDirective.registerAttribute(\"stylesheet\", 1000, \n    MetaphorJs.app.Directive.attr.Style.$extend({\n\n    $class: \"MetaphorJs.app.Directive.attr.Stylesheet\",\n    id: \"stylesheet\",\n\n    initDirective: function() {\n        this.styleId = \"stylesheet_\" + nextUid();\n        this.stylesheet = new MetaphorJs.lib.Stylesheet({\n            id: \"for_\" + this.styleId\n        })\n        this.stylesheet.append();\n        this.$super(arguments);\n    },\n\n    getSelector: function() {\n        var node = this.node;\n        if (!node.id) {\n            node.setAttribute(\"id\", this.styleId);\n        }\n        return '#' + node.id;\n    },\n\n    escapeProperty: function(val, k) {\n        val = \"\" + val;\n        if (k === \"content\") {\n            return '\"' + val + '\"';\n        }\n        return val;\n    },\n\n    getCssText: function() {\n        var props = this.getCurrentValue(),\n            selector = this.getSelector(),\n            state, prop, k,\n            lines = [],\n            css = {\n                \"\": [selector + \" {\"]\n            }\n\n        if (props) {\n            for (k in props) {\n                prop = k.split(\".\", 2);\n                state = prop.length > 1 ? prop[0] || \"\" : \"\";\n                prop = prop[1];\n                if (!css[state]) {\n                    css[state] = [selector + \":\" + state + \" {\"];\n                }\n                css[state].push(prop + \": \" + this.escapeProperty(props[k], prop) + \";\");\n            }\n        }\n\n        for (state in css) {\n            css[state].push(\"}\");\n            lines.push(css[state].join(\"\\n\"));\n        }\n\n        return lines.join(\"\\n\");\n    },\n\n    onStateChange: function() {\n        this.stylesheet.setContent(this.getCssText());\n    },\n\n    onDestroy: function() {\n        this.stylesheet.$destroy();\n        this.$super();\n    }\n}));\n","require(\"../../lib/Expression.js\");\n\nconst Directive = require(\"../../app/Directive.js\");\n\n    /*\n        Update state on given event.\n        Not exactly template's business, but still\n    */\nDirective.registerAttribute(\"update-on\", 1000,\n    function(state, node, config, renderer, attrSet) {\n\n        var toggle = function(mode) {\n            config.eachProperty(function(k){\n                if (k.indexOf(\"value.\") === 0) {\n                    var event = k.replace('value.', ''),\n                        obj = config.get(k);\n                    if (obj.$destroyed || obj.$destroying) {\n                        return;\n                    }\n                    if (obj && (fn = (obj[mode] || obj['$' + mode]))) {\n                        fn.call(obj, event, state.$check, state);\n                    }\n                }\n            });\n        };\n\n        toggle(\"on\");\n\n        return function() {\n            if (toggle) {\n                toggle(\"un\");\n                cfgs = null;\n                toggle = null;\n            }\n        };\n});","\nrequire(\"../../func/dom/toFragment.js\");\nrequire(\"../../func/dom/getAttr.js\");\nrequire(\"../../lib/Expression.js\");\n\nvar Directive = require(\"../../app/Directive.js\"),\n    toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nDirective.registerTag(\"bind-html\", function(state, node, config, renderer) {\n\n    var expr    = MetaphorJs.dom.getAttr(node, \"value\"),\n        text    = MetaphorJs.lib.Expression.get(expr, state),\n        frg     = MetaphorJs.dom.toFragment(text),\n        nodes   = toArray(frg.childNodes);\n\n    node.parentNode.replaceChild(node, frg);\n    renderer && renderer.flowControl(\"nodes\", nodes);\n});","require(\"../../lib/Expression.js\");\nrequire(\"../../func/dom/getAttr.js\");\n\nvar Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nDirective.registerTag(\"bind\", function(state, node, config, renderer) {\n\n    var expr    = MetaphorJs.dom.getAttr(node, \"value\"),\n        text    = MetaphorJs.lib.Expression.get(expr, state),\n        frg     = window.document.createTextNode(text);\n\n    node.parentNode.replaceChild(node, frg);\n    renderer && renderer.flowControl(\"nodes\", [frg]);\n});","\nrequire(\"../../func/dom/toFragment.js\");\nrequire(\"../../func/dom/getAttr.js\");\nrequire(\"../../lib/Config.js\");\n\nvar Directive = require(\"../../app/Directive.js\"),\n    toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nDirective.registerTag(\"if\", Directive.attr.If.$extend({\n    $class: \"MetaphorJs.app.Directive.tag.If\",\n    _autoOnChange: false,\n    children: null,\n    childrenFrag: null,\n\n    initDirective: function(state, node, config, renderer, attrSet) {\n\n        var self    = this;\n\n        self.children = toArray(node.childNodes);\n        self.childrenFrag = MetaphorJs.dom.toFragment(self.children);\n\n        renderer && renderer.flowControl(\"nodes\", self.children);\n\n        self.createCommentWrap();\n        self.$super(state, node, config, renderer, attrSet);   \n\n        if (node.parentNode) {\n            node.parentNode.removeChild(node); \n        }\n    },\n\n    initConfig: function() {\n        this.config.setProperty(\"value\", {\n            expression: MetaphorJs.dom.getAttr(this.node, \"value\")\n        });\n        this.$super();\n    },\n\n    onStateChange: function() {\n        var self    = this,\n            val     = self.config.get(\"value\"),\n            prev    = self.wrapperOpen,\n            next    = self.wrapperClose,\n            parent  = prev.parentNode;\n\n        if (val) {\n            parent.insertBefore(self.childrenFrag, next);\n        }\n        else if (!self.initial) {\n            var children = [],\n                sib;\n\n            self.childrenFrag = window.document.createDocumentFragment();\n            while (prev.nextSibling && prev.nextSibling !== next) {\n                sib = prev.nextSibling;\n                parent.removeChild(sib);\n                children.push(sib);\n                self.childrenFrag.appendChild(sib);\n            }\n            self.children = children;\n        }\n\n        if (self.initial) {\n            self.initial = false;\n        }\n        else {\n            if (self.config.get(\"once\")) {\n                self.$destroy();\n            }\n        }\n    },\n\n    onDestroy: function() {\n        this.children = null;\n        this.childrenFrag = null;\n        this.$super();\n    }\n}, {\n    initConfig: function(config) {\n        config.setType(\"once\", \"bool\", MetaphorJs.lib.Config.MODE_STATIC);\n        config.setType(\"value\", \"bool\");\n    }\n}));\n","require(\"../../func/dom/getAttr.js\");\nrequire(\"../../app/Template.js\");\nrequire(\"../../lib/Config.js\");\n\nvar Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nDirective.registerTag(\"include\", function(){\n    var dir = function tag_include_directive(state, node, config, renderer) {\n\n        dir.initConfig(config);\n    \n        var tpl = new MetaphorJs.app.Template({\n            state,\n            replaceNode: node,\n            config,\n            parentRenderer: renderer\n        });\n    \n        if (renderer) {\n            renderer.on(\"destroy\", function(){\n                tpl.$destroy();\n                tpl = null;\n            });\n    \n            renderer.flowControl(\"ignoreInside\", true);\n        }\n    };\n\n    dir.initConfig = function(config) {\n        config.setType(\"asis\", \"bool\", MetaphorJs.lib.Config.MODE_STATIC);\n        config.setDefaultValue(\"runRenderer\", !config.get(\"asis\"));\n        config.set(\"useComments\", true);\n        config.set(\"passReferences\", true);\n    };\n\n    return dir;\n}());\n","require(\"../../func/dom/getAttr.js\");\nrequire(\"../../func/dom/setAttr.js\");\nrequire(\"../../lib/Expression.js\");\n\nvar Directive = require(\"../../app/Directive.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nDirective.registerTag(\"tag\", function directive_tag_tag(state, node, config, renderer) {\n\n    var expr = getAttr(node, \"value\"),\n        tag = MetaphorJs.lib.Expression.get(expr, state),\n        i, l, a;\n\n    if (!tag) {\n        node.parentNode.removeChild(node);\n        renderer && renderer.flowControl(\"stop\", true);\n    }\n    else {\n        var el = window.document.createElement(tag),\n            next = node.nextSibling,\n            attrs = node.attributes;\n\n        while (node.firstChild) {\n            el.appendChild(node.firstChild);\n        }\n\n        for (i = 0, l = attrs.length; i < l; i++) {\n            a = attrs[i];\n            if (a.name !== \"value\") {\n                MetaphorJs.dom.setAttr(el, a.name, a.value);\n            }\n        }\n\n        node.parentNode.insertBefore(el, next);\n        node.parentNode.removeChild(node);\n\n        renderer && renderer.flowControl(\"nodes\", [el]);\n    }\n\n});","\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\nMetaphorJs.filter = MetaphorJs.filter || {};","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @filter collect\n * @param {array} input Array of objects\n * @param {string} field Field name to collect from objects\n * @returns {array}\n */\nMetaphorJs.filter.collect = function(input, state, prop) {\n\n    var res = [],\n        i, l, val;\n\n    if (!input) {\n        return res;\n    }\n\n    for (i = 0, l = input.length; i < l; i++) {\n        val = input[i][prop];\n        if (val != undefined) {\n            res.push(val);\n        }\n    }\n\n    return res;\n};","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    filterArray = require(\"metaphorjs-shared/src/func/filterArray.js\");\n\n/**\n * @filter filter\n * See <code>filterArray</code> function\n * @param {array} input\n * @param {string|boolean|regexp|function} by\n * @param {string|boolean|null} opt true | false | \"strict\"\n * @returns {array}\n */\nMetaphorJs.filter.filter = function(val, state, by, opt) {\n    return filterArray(val, by, opt);\n};\n","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @filter get\n * @param {object} input\n * @param {string} prop {   \n *  Property name or path to property (\"a.b.c\")\n * }\n * @returns {*}\n */\nMetaphorJs.filter.get = function(val, state, prop) {\n    var tmp = (\"\"+prop).split(\".\"),\n        key;\n\n    while (key = tmp.shift()) {\n        val = val[key];\n        if (val === undefined) {\n            return undefined;\n        }\n    }\n\n    return val;\n};\n\n","\n\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\");\n\n/**\n * @filter join\n * @param {array} input\n * @param {string} separator\n * @returns {string}\n */\nMetaphorJs.filter.join = function(input, state, separator) {\n\n    separator = separator || \", \";\n\n    if (input && input.length) {\n        if (!isArray(input)){\n            input = toArray(input);\n        }\n        return input.join(separator);\n    }\n\n    return \"\";\n};","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @filter l\n * @param {string} input Get text value from MetaphorJs.lib.LocalText\n * @returns {string}\n */\nMetaphorJs.filter.l = function(key, state) {\n    return state.$app.lang.get(key);\n};\n","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    isString = require(\"metaphorjs-shared/src/func/isString.js\");\n\n/**\n * @filter limitTo\n * Limit array size or string length\n * @param {array|string} input\n * @param {int} limit\n * @return {array|string}\n */\nMetaphorJs.filter.limitTo = function(input, state, limit) {\n\n    var isS = isString(input);\n\n    if (!isArray(input) && !isS) {\n        return input;\n    }\n\n    if (Math.abs(Number(limit)) === Infinity) {\n        limit = Number(limit);\n    } else {\n        limit = parseInt(limit, 10);\n    }\n\n    if (isS) {\n        //NaN check on limit\n        if (limit) {\n            return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);\n        } else {\n            return \"\";\n        }\n    }\n\n    var out = [],\n        i, n;\n\n    // if abs(limit) exceeds maximum length, trim it\n    if (limit > input.length)\n        limit = input.length;\n    else if (limit < -input.length)\n        limit = -input.length;\n\n    if (limit > 0) {\n        i = 0;\n        n = limit;\n    } else {\n        i = input.length + limit;\n        n = input.length;\n    }\n\n    for (; i<n; i++) {\n        out.push(input[i]);\n    }\n\n    return out;\n};","\n\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @filter linkify\n * Transform text links into html links\n * @param {string} input Text\n * @param {string} target Optional target parameter\n * @returns {string}\n */\nMetaphorJs.filter.linkify = function(input, state, target){\n    target = target ? ' target=\"'+target+'\"' : \"\";\n    if (input) {\n        var exp = /(\\b(https?|ftp|file):\\/\\/[-A-Z0-9+&@#\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\/%=~_|])/ig;\n        return input.replace(exp, '<a href=\"$1\"'+target+'>$1</a>');\n    }\n    return \"\";\n};","\n\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @filter lowercase\n * Transform to lower case\n * @param {string} input\n * @returns {string}\n */\nMetaphorJs.filter.lowercase = function(val){\n    return (\"\"+val).toLowerCase();\n};","\nrequire(\"./__init.js\");\nrequire(\"../lib/Expression.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    ns = require(\"metaphorjs-namespace/src/var/ns.js\");\n\n/**\n * @filter map\n * @param {array} input\n * @param {string} fnName {\n *  Either a namespace entry, or global function name or \n *  expression to try against current state. In any case\n *  it must resolve into a function that accepts \n *  mapped item as first argument.\n *  @param {*} item\n *  @returns {*}\n * }\n * @returns {array} new array\n */\nMetaphorJs.filter.map = function(array, state, fnName) {\n\n    var i, l,\n        res = [],\n        fn = ns.get(fnName, true) ||\n                window[fnName] ||\n                MetaphorJs.lib.Expression.get(fnName, state);\n    array = array || [];\n\n    if (fn) {\n        for (i = 0, l = array.length; i < l; i++) {\n            res.push(fn(array[i]));\n        }\n    }\n\n    return res;\n};","\nrequire(\"./__init.js\");\nrequire(\"metaphorjs-shared/src/lib/Cache.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @filter moment\n * Pass given input value through moment.js lib\n * @param {string|int|Date} input date value\n * @param {string} format date format\n * @returns {string}\n */\nMetaphorJs.filter.moment = function(val, state, format) {\n    return val ? moment(val).format(\n        MetaphorJs.lib.Cache.global().get(format, format)\n    ) : \"\";\n};","\n\nrequire(\"./__init.js\");\nrequire(\"metaphorjs-shared/src/lib/Cache.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @filter moment\n * Pass given input value through numeral.js lib\n * @param {string|int} input \n * @param {string} format number format\n * @returns {string}\n */\nMetaphorJs.filter.numeral = function(val, state, format) {\n    return numeral(val).format(\n        MetaphorJs.lib.Cache.global().get(format, format)\n    );\n};","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    isString = require(\"metaphorjs-shared/src/func/isString.js\");\n\n/**\n * @filter offset\n * Get slice of array or string starting from offset\n * @param {array|string} input\n * @param {int} offset\n * @returns {array|string}\n */\nMetaphorJs.filter.offset = function(input, state, offset) {\n\n    var isS = isString(input);\n\n    if (!isArray(input) && !isS) {\n        return input;\n    }\n\n    if (Math.abs(Number(offset)) === Infinity) {\n        offset = Number(offset);\n    } else {\n        offset = parseInt(offset, 10);\n    }\n\n    if (isS) {\n        return input.substr(offset);\n    }\n    else {\n        return input.slice(offset);\n    }\n};","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @filter p \n * Get plural text form from LocalText lib\n * @param {string} input Lang key\n * @param {int} number Number to find text form for\n * @returns {string}\n */\nMetaphorJs.filter.p = function(key, state, number) {\n    return state.$app.lang.plural(key, parseInt(number, 10) || 0);\n};\n","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @filter p \n * Get plural text form from LocalText lib\n * @param {int} input Number to find text form for\n * @param {string} key Lang key\n * @returns {string}\n */\nMetaphorJs.filter.pl = function(number, state, key) {\n    return state.$app.lang.plural(key, parseInt(number, 10) || 0);\n};","\nrequire(\"./__init.js\");\nrequire(\"../func/dom/preloadImage.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    isThenable = require(\"metaphorjs-shared/src/func/isThenable.js\");\n\n(function(){\n\n    /**\n     * @filter preloaded\n     * Will return true once image is loaded. It will trigger state check \n     * automatically once the image is loaded.\n     * @param {string} input Image url\n     * @returns {boolean} \n     */\n    var preloaded = MetaphorJs.filter.preloaded = function(val, state) {\n\n        if (!val) {\n            return false;\n        }\n\n        var promise = MetaphorJs.dom.preloadImage.check(val);\n\n        if (promise === true || !promise) {\n            return !!promise;\n        }\n\n        if (isThenable(promise)) {\n            promise.always(function(){\n                state.$check();\n            });\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n\n    preloaded.$undeterministic = true;\n\n    return preloaded;\n}());","require(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @filter r\n * @param {string} input Render text recursively\n * @returns {string}\n */\nMetaphorJs.filter.r = function(input, state) {\n    return state.$app.lang.get(key);\n};\n","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    sortArray = require(\"metaphorjs-shared/src/func/sortArray.js\");\n\n/**\n * @filter sortBy\n * Sort array of objects by object field\n * @param {array} input\n * @param {function|string|object} field {\n *  See <code>sortArray()</code> function\n * }\n * @param {string} dir\n * @returns {array}\n */\nMetaphorJs.filter.sortBy = function(val, state, field, dir) {\n    return sortArray(val, field, dir);\n};","\n\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    getRegExp = require(\"metaphorjs-shared/src/func/getRegExp.js\");\n\n/**\n * @filter split\n * Split string into parts\n * @param {string} input\n * @param {string|RegExp} separator {\n *  Can also pass \"/regexp/\" as a string \n * }\n * @param {int} limit\n * @returns {array}\n */\nMetaphorJs.filter.split = function(input, state, sep, limit) {\n\n    limit       = limit || undefined;\n    sep         = sep || \"/\\\\n|,/\";\n\n    if (!input) {\n        return [];\n    }\n\n    input       = \"\" + input;\n\n    if (sep.substr(0,1) === '/' && sep.substr(sep.length - 1) === \"/\") {\n        sep = getRegExp(sep.substring(1, sep.length-1));\n    }\n\n    var list = input.split(sep, limit),\n        i, l;\n\n    for (i = -1, l = list.length; ++i < l; list[i] = list[i].trim()){}\n\n    return list;\n};\n","\n\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    isPlainObject = require(\"metaphorjs-shared/src/func/isPlainObject.js\");\n\n/**\n * @filter toArray\n * @code src-docs/code/filter/toArray.js\n * @param {*} input\n * @returns {array}\n */\nMetaphorJs.filter.toArray = function(input) {\n\n    if (isPlainObject(input)) {\n        var list = [],\n            k;\n        for (k in input) {\n            if (input.hasOwnProperty(k)) {\n                list.push({key: k, value: input[k]});\n            }\n        }\n        return list;\n    }\n\n    return toArray(input);\n};","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @filter ucfirst\n * Transform first character to upper case\n * @param {string} input\n * @returns {string}\n */\nMetaphorJs.filter.ucfirst = function(val){\n    return val.substr(0, 1).toUpperCase() + val.substr(1);\n};","\n\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @filter uppercase\n * Transform to upper case\n * @param {string} input\n * @returns {string}\n */\nMetaphorJs.filter.uppercase = function(val){\n    return (\"\"+val).toUpperCase();\n};","\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nMetaphorJs.app = MetaphorJs.app || {};","\nrequire(\"./__init.js\");\nrequire(\"./resolve.js\");\nrequire(\"../dom/getAttrSet.js\");\nrequire(\"../dom/removeAttr.js\");\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\n\nconst error = require(\"metaphorjs-shared/src/func/error.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.app.init = function app_init(node, cls, data, autorun) {\n\n    const attrs = MetaphorJs.dom.getAttrSet(node);\n    const cfg = attrs.directives.app || {};\n    attrs.__remove(\"directive\", node, \"app\")\n\n    try {\n        const p = MetaphorJs.app.resolve(\n                    cls || \"MetaphorJs.app.App\", \n                    extend({ state: data }, cfg), \n                    node, \n                    [node, data]\n                );\n\n        if (autorun !== false) {\n            return p.done(function(app){\n                app.run();\n            });\n        }\n        else {\n            return p;\n        }\n    }\n    catch (thrownError) {\n        error(thrownError);\n        return MetaphorJs.lib.Promise.reject(thrownError);\n    }\n};","\nrequire(\"../../lib/Expression.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    isPlainObject = require(\"metaphorjs-shared/src/func/isPlainObject.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\");\n\n\nmodule.exports = MetaphorJs.app.prebuilt = (function() {\n\n    let pb = MetaphorJs.prebuilt || {};\n    const fnMap = {}; // used when building\n\n    const unspace = function(fn) {\n        fn = fn.replace(/[\\n\\r]/g, '');\n        fn = fn.replace(/\\s+/g, ' ');\n        fn = fn.replace(' anonymous', '');\n        return fn;\n    };\n\n    const traverse = function(s, fn) {\n        if (isArray(s)) {\n            let i, l;\n            for (i = 0, l = s.length; i < l; i++) {\n                s[i] = traverse(s[i], fn);\n            }\n        }\n        else if (isPlainObject(s)) {\n            let k;\n            for (k in s) {\n                s[k] = traverse(s[k], fn);\n            }\n        }\n        return fn(s);\n    };\n\n    const extractFuncs = function(s) {\n        if (typeof s === \"function\") {\n            let fnstr = unspace(s.toString());\n            if (!fnMap[fnstr]) {\n                fnMap[fnstr] = api.add(\"func\", s);\n                let descr = MetaphorJs.lib.Expression.describeExpression(fnstr);\n                if (descr) {\n                    api.add(\"funcDescr\", descr, fnMap[fnstr]);\n                }\n            }\n            s = fnMap[fnstr];\n        }\n        return s;\n    };\n\n    const importFuncs = function(s) {\n        return api.isKey(s) ? pb.func[s] : s;\n    };\n\n    const deflate = function(s) {\n        let k,\n            keys = 0;\n\n        for (k in s) {\n            if (!s[k] || k === \"expr\") {\n                delete s[k];\n            }\n            else if (isArray(s[k]) && s[k].length === 0) {\n                delete s[k];\n            }\n            else {\n                keys++;\n            }\n        }\n\n        if (keys === 1 && s.getterFn) {\n            s = s.getterFn;\n        }\n\n        return s;\n    };\n\n    const inflate = function(s) {\n        s = traverse(s, importFuncs);\n        if (typeof s === \"function\") {\n            s = {getterFn: s};\n        }\n        !s.inputPipes && (s.inputPipes = []);\n        !s.pipes && (s.pipes = []);\n        s.inflated = true;\n        return s;\n    };\n\n    const api = {\n\n        /**\n         * @function MetaphorJs.app.prebuilt.deflate\n         * @param {object} data\n         * @returns {object}\n         */\n        deflate: function(s) {\n            return deflate(s);\n        },\n\n        /**\n         * @function MetaphorJs.app.prebuilt.inflate\n         * @param {object} data\n         * @returns {object}\n         */\n        inflate: function(s) {\n            return inflate(s);\n        },\n\n        /**\n         * @function MetaphorJs.app.prebuilt.get\n         * @param {string} type\n         * @param {string} k\n         * @returns {object|undefined}\n         */\n        get: function(type, k) {\n            var data = pb[type] ? pb[type][k] : undefined;\n            if (data) {\n                !data.inflated && (data = inflate(data));\n            }\n            return data;\n        },\n\n        /**\n         * @function MetaphorJs.app.prebuilt.add\n         * @param {string} type\n         * @param {object} data\n         * @param {string} key {\n         *  @optional if not provided, will generate a unique key\n         * }\n         * @returns {string} new (or provided) key\n         */\n        add: function(type, data, k) {\n            k = k || \"~\" + nextUid() + \"~\";\n            !pb[type] && (pb[type] = {});\n            type !== \"func\" && (data = traverse(data, extractFuncs));\n            pb[type][k] = deflate(data);\n            return k;\n        },\n\n        /**\n         * @function MetaphorJs.app.prebuilt.isKey\n         * @param {string} k\n         * @returns {boolean}\n         */\n        isKey: function(k) {\n            return typeof k === \"string\" && k[0] === \"~\" && k[k.length-1] === \"~\";\n        },\n\n        /**\n         * @function MetaphorJs.app.prebuilt.getStorage\n         * @returns {object}\n         */\n        getStorage: function() {\n            return pb;\n        },\n\n        /**\n         * @function MetaphorJs.app.prebuilt.setStorage\n         * @param {object} storage\n         */\n        setStorage: function(storage) {\n            pb = storage;\n        }\n    };\n\n    return api;\n}());","require(\"./__init.js\");\nrequire(\"metaphorjs-shared/src/lib/Provider.js\");\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\nrequire(\"../dom/toFragment.js\");\nrequire(\"../dom/data.js\");\nrequire(\"../dom/addClass.js\");\nrequire(\"../dom/removeClass.js\");\nrequire(\"../../app/Template.js\")\nrequire(\"../../lib/Config.js\");\n\nconst extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    error = require(\"metaphorjs-shared/src/func/error.js\"),\n    ns = require(\"metaphorjs-namespace/src/var/ns.js\"),\n    isString = require(\"metaphorjs-shared/src/func/isString.js\"),\n    isFunction = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.app.resolve = function app_resolve(cmp, cfg, node, args) {\n\n    cfg         = cfg || {};\n    args        = args || [];\n\n    node        = node || cfg.node;\n    let state   = cfg.state; \n    let config  = cfg.config || null;\n\n    cfg.config  = config;\n    cfg.state   = cfg.state || state;\n    cfg.node    = cfg.node || node;\n\n    if (args.length === 0) {\n        args.push(cfg);\n    }\n\n    if (config) {\n        if (!(config instanceof MetaphorJs.lib.Config)) {\n            config = new MetaphorJs.lib.Config(config, \n                                                { state }, \n                                                /*scalarAs: */\"defaultValue\");\n        }\n    }\n\n    var constr      = isString(cmp) ? ns.get(cmp) : cmp;\n    if (!constr) {\n        throw new Error(\"Component \" + cmp + \" not found\");\n    }\n\n    let i;\n    const defers    = [],\n        app         = state ? state.$app : null,\n        gProvider   = MetaphorJs.lib.Provider.global(),\n        injectFn    = app ? app.inject : gProvider.inject,\n        injectCt    = app ? app : gProvider,\n        cloak       = config && config.has(\"cloak\") ? config.get(\"cloak\") : null,\n        inject      = {\n            $node: node || null,\n            $state: state || null,\n            $config: config || null,\n            $args: args || null\n        };\n\n    if (constr.resolve) {\n\n        for (i in constr.resolve) {\n            (function(name){\n                const d = new MetaphorJs.lib.Promise;\n                let fn;\n\n                defers.push(d.done(function(value){\n                    inject[name] = value;\n                    cfg[name] = value;\n                    args.push(value);\n                }));\n\n                fn = constr.resolve[i];\n\n                if (isFunction(fn)) {\n                    d.resolve(fn(state, node, config));\n                }\n                else {\n                    d.resolve(\n                        injectFn.call(\n                            injectCt, fn, null, extend({}, inject, cfg, false, false)\n                        )\n                    );\n                }\n\n                d.fail(function(reason){\n                    if (reason instanceof Error) {\n                        error(reason);\n                    }\n                });\n\n            }(i));\n        }\n    }\n\n    let p;\n\n    if (defers.length) {\n        p = new MetaphorJs.lib.Promise;\n        MetaphorJs.lib.Promise.all(defers)\n            .done(function(values){\n                p.resolve(\n                    injectFn.call(\n                        injectCt, constr, null, extend({}, inject, cfg, false, false), args\n                    )\n                );\n            })\n            .fail(p.reject, p);\n    }\n    else {\n        p = MetaphorJs.lib.Promise.resolve(\n            injectFn.call(\n                injectCt, constr, null, extend({}, inject, cfg, false, false), args\n            )\n        );\n    }\n\n    if (node && p.isPending() && cloak !== null) {\n        cloak !== true ? MetaphorJs.dom.addClass(node, cloak) : node.style.visibility = \"hidden\";\n        p.then(function() {\n            cloak !== true ? MetaphorJs.dom.removeClass(node, cloak) : node.style.visibility = \"\";\n        });\n    }\n\n    if (node) {\n        p.then(function(){\n            MetaphorJs.dom.removeClass(node, \"mjs-cloak\");\n        });\n    }\n\n    return p;\n};\n\n","\nrequire(\"./__init.js\");\nrequire(\"./init.js\");\nrequire(\"../dom/onReady.js\");\nrequire(\"../dom/select.js\");\nrequire(\"../dom/getAttr.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Run application\n * @function MetaphorJs.app.run\n * @param {Window} win\n * @param {object} appData\n */\nmodule.exports = MetaphorJs.app.run = function app_run(w, appData) {\n\n    const win = w || window;\n\n    if (!win) {\n        throw new Error(\"Window object neither defined nor provided\");\n    }\n\n    MetaphorJs.dom.onReady(function() {\n\n        const appNodes = MetaphorJs.dom.select(\"[mjs-app]\", win.document);\n        let i, l, el;\n\n        for (i = -1, l = appNodes.length; ++i < l;){\n            el      = appNodes[i];\n            MetaphorJs.app.init(\n                el,\n                MetaphorJs.dom.getAttr(el, \"mjs-app\"),\n                appData,\n                true\n            );\n        }\n    }, win);\n\n};","\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nMetaphorJs.browser = MetaphorJs.browser || {};","\nrequire(\"./__init.js\");\nrequire(\"./isIE.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Check if current browser supports event\n * @function MetaphorJs.browser.hasEvent\n * @param {string} event\n * @return {boolean}\n */\nmodule.exports = MetaphorJs.browser.hasEvent = function(){\n\n    var eventSupport = {},\n        divElm;\n\n    return function browser_hasEvent(event) {\n        // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have\n        // it. In particular the event is not fired when backspace or delete key are pressed or\n        // when cut operation is performed.\n\n        if (eventSupport[event] === undefined) {\n\n            if (event === 'input' && MetaphorJs.browser.isIE() == 9) {\n                return eventSupport[event] = false;\n            }\n            if (!divElm) {\n                divElm = window.document.createElement('div');\n            }\n\n            eventSupport[event] = !!('on' + event in divElm);\n        }\n\n        return eventSupport[event];\n    };\n}();","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.browser.isAndroid = function(){\n\n    var android = null;\n\n    return function browser_isAndroid() {\n\n        if (android === null) {\n            android = parseInt((/android (\\d+)/i.exec(navigator.userAgent) || [])[1], 10) || false;\n        }\n\n        return android;\n    };\n\n}();","require(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.browser.isIE = function(){\n\n    var msie;\n\n    return function browser_isIE() {\n\n        if (msie === null) {\n            var ua = navigator.userAgent;\n            msie = parseInt((/msie (\\d+)/i.exec(ua) || [])[1], 10);\n            if (isNaN(msie)) {\n                msie = parseInt((/trident\\/.*; rv:(\\d+)/i.exec(ua) || [])[1], 10) || false;\n            }\n        }\n\n        return msie;\n    };\n}();","\n\nmodule.exports = function() {\n\n    var boxSizingReliableVal;\n\n    var computePixelPositionAndBoxSizingReliable = function() {\n\n        var doc = window.document,\n            container = doc.createElement(\"div\"),\n            div = doc.createElement(\"div\"),\n            body = doc.body;\n\n        if (!div.style || !window.getComputedStyle) {\n            return false;\n        }\n\n        container.style.cssText = \"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;\" +\n                                  \"position:absolute\";\n        container.appendChild(div);\n\n        div.style.cssText =\n            // Support: Firefox<29, Android 2.3\n            // Vendor-prefix box-sizing\n        \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n        \"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" +\n        \"border:1px;padding:1px;width:4px;position:absolute\";\n        div.innerHTML = \"\";\n        body.appendChild(container);\n\n        var divStyle = window.getComputedStyle(div, null),\n            ret = divStyle.width === \"4px\";\n\n        body.removeChild(container);\n\n        return ret;\n    };\n\n    return function boxSizingReliable() {\n        if (boxSizingReliableVal === undefined) {\n            boxSizingReliableVal = computePixelPositionAndBoxSizingReliable();\n        }\n\n        return boxSizingReliableVal;\n    };\n}();","\nrequire(\"../__init.js\");\nrequire(\"../getStyle.js\");\n\nconst _boxSizingReliable = require(\"./_boxSizingReliable.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = function(type, name) {\n\n    // from jQuery\n    var rnumnonpx = new RegExp( \"^([+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|))(?!px)[a-z%]+$\", \"i\"),\n        cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ],\n        defaultExtra = !type ? \"content\" : (type === \"inner\" ? \"padding\" : \"\");\n\n    var augmentWidthOrHeight = function(elem, name, extra, isBorderBox, styles) {\n        var i = extra === (isBorderBox ? \"border\" : \"content\") ?\n                // If we already have the right measurement, avoid augmentation\n                4 :\n                // Otherwise initialize for horizontal or vertical properties\n                name === \"width\" ? 1 : 0,\n\n            val = 0;\n\n        for (; i < 4; i += 2) {\n            // Both box models exclude margin, so add it if we want it\n            if (extra === \"margin\") {\n                val += parseFloat(styles[extra + cssExpand[i]]);\n            }\n\n            if (isBorderBox) {\n                // border-box includes padding, so remove it if we want content\n                if (extra === \"content\") {\n                    val -= parseFloat(styles[\"padding\" + cssExpand[i]]);\n                }\n\n                // At this point, extra isn't border nor margin, so remove border\n                if (extra !== \"margin\") {\n                    val -= parseFloat(styles[\"border\" + cssExpand[i] + \"Width\"]);\n                }\n            } else {\n                // At this point, extra isn't content, so add padding\n                val += parseFloat(styles[\"padding\" + cssExpand[i]]);\n\n                // At this point, extra isn't content nor padding, so add border\n                if (extra !== \"padding\") {\n                    val += parseFloat(styles[\"border\" + cssExpand[i] + \"Width\"]);\n                }\n            }\n        }\n\n        return val;\n    };\n\n    var getWidthOrHeight = function(elem, name, extra, styles) {\n\n        // Start with offset property, which is equivalent to the border-box value\n        var valueIsBorderBox = true,\n            val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n            isBorderBox = styles[\"boxSizing\"] === \"border-box\";\n\n        // Some non-html elements return undefined for offsetWidth, so check for null/undefined\n        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n        if ( val <= 0 || val == null ) {\n            val = elem.style[name];\n\n            // Computed unit is not pixels. Stop here and return.\n            if (rnumnonpx.test(val)) {\n                return val;\n            }\n\n            // Check for style in case a browser which returns unreliable values\n            // for getComputedStyle silently falls back to the reliable elem.style\n            valueIsBorderBox = isBorderBox &&\n                               (_boxSizingReliable() || val === elem.style[name]);\n\n            // Normalize \"\", auto, and prepare for extra\n            val = parseFloat(val) || 0;\n        }\n\n        // Use the active box-sizing model to add/subtract irrelevant styles\n        return val +\n                 augmentWidthOrHeight(\n                     elem,\n                     name,\n                     extra || (isBorderBox ? \"border\" : \"content\"),\n                     valueIsBorderBox,\n                     styles\n                 );\n    };\n\n\n    return function dom_getDimensions(elem, margin) {\n\n        if (elem === window) {\n            return elem.document.documentElement[\"client\" + name];\n        }\n\n        // Get document width or height\n        if (elem.nodeType === window.document.DOCUMENT_NODE) {\n            var doc = elem.documentElement;\n\n            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n            // whichever is greatest\n            return Math.max(\n                elem.body[\"scroll\" + name], doc[\"scroll\" + name],\n                elem.body[\"offset\" + name], doc[\"offset\" + name],\n                doc[\"client\" + name]\n            );\n        }\n\n        return getWidthOrHeight(\n            elem,\n            name.toLowerCase(),\n            defaultExtra || (margin === true ? \"margin\" : \"border\"),\n            MetaphorJs.dom.getStyle(elem)\n        );\n    };\n\n};","\n\nmodule.exports = function(vertical) {\n\n    var defaultST,\n        wProp = vertical ? \"pageYOffset\" : \"pageXOffset\",\n        sProp = vertical ? \"scrollTop\" : \"scrollLeft\",\n        doc = window.document,\n        body = doc.body,\n        html = doc.documentElement;\n\n    var ret = function(scroll, allowNegative) {\n        if (scroll < 0 && allowNegative === false) {\n            return 0;\n        }\n        return scroll;\n    };\n\n    if(window[wProp] !== undefined) {\n        //most browsers except IE before #9\n        defaultST = function(){\n            return window[wProp];\n        };\n    }\n    else{\n        if (html.clientHeight) {\n            defaultST = function() {\n                return html[sProp];\n            };\n        }\n        else {\n            defaultST = function() {\n                return body[sProp];\n            };\n        }\n    }\n\n    return function(node, allowNegative) {\n        if (!node || node === window) {\n            return ret(defaultST(), allowNegative);\n        }\n        else if (node && node.nodeType == window.document.ELEMENT_NODE &&\n            node !== body && node !== html) {\n            return ret(node[sProp], allowNegative);\n        }\n        else {\n            return ret(defaultST(), allowNegative);\n        }\n    }\n\n};","\n// from jquery.mousewheel plugin\n\nrequire(\"../normalizeEvent.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = function(e) {\n\n    function shouldAdjustOldDeltas(orgEvent, absDelta) {\n        // If this is an older event and the delta is divisable by 120,\n        // then we are assuming that the browser is treating this as an\n        // older mouse wheel event and that we should divide the deltas\n        // by 40 to try and get a more usable deltaFactor.\n        // Side note, this actually impacts the reported scroll distance\n        // in older browsers and can cause scrolling to be slower than native.\n        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.\n        return orgEvent.type === 'mousewheel' && absDelta % 120 === 0;\n    }\n\n    function nullLowestDelta() {\n        lowestDelta = null;\n    }\n\n    var nullLowestDeltaTimeout, lowestDelta;\n\n    var mousewheelHandler = function(fn) {\n\n        return function mousewheelHandler(e) {\n\n            var event = MetaphorJs.dom.normalizeEvent(e || window.event),\n                args = slice.call(arguments, 1),\n                delta = 0,\n                deltaX = 0,\n                deltaY = 0,\n                absDelta = 0,\n                offsetX = 0,\n                offsetY = 0;\n\n\n            event.type = 'mousewheel';\n\n            // Old school scrollwheel delta\n            if ('detail'      in event) { deltaY = event.detail * -1; }\n            if ('wheelDelta'  in event) { deltaY = event.wheelDelta; }\n            if ('wheelDeltaY' in event) { deltaY = event.wheelDeltaY; }\n            if ('wheelDeltaX' in event) { deltaX = event.wheelDeltaX * -1; }\n\n            // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\n            if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\n                deltaX = deltaY * -1;\n                deltaY = 0;\n            }\n\n            // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy\n            delta = deltaY === 0 ? deltaX : deltaY;\n\n            // New school wheel delta (wheel event)\n            if ('deltaY' in event) {\n                deltaY = event.deltaY * -1;\n                delta = deltaY;\n            }\n            if ('deltaX' in event) {\n                deltaX = event.deltaX;\n                if (deltaY === 0) { delta = deltaX * -1; }\n            }\n\n            // No change actually happened, no reason to go any further\n            if (deltaY === 0 && deltaX === 0) { return; }\n\n            // Store lowest absolute delta to normalize the delta values\n            absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));\n\n            if (!lowestDelta || absDelta < lowestDelta) {\n                lowestDelta = absDelta;\n\n                // Adjust older deltas if necessary\n                if (shouldAdjustOldDeltas(event, absDelta)) {\n                    lowestDelta /= 40;\n                }\n            }\n\n            // Adjust older deltas if necessary\n            if (shouldAdjustOldDeltas(event, absDelta)) {\n                // Divide all the things by 40!\n                delta /= 40;\n                deltaX /= 40;\n                deltaY /= 40;\n            }\n\n            // Get a whole, normalized value for the deltas\n            delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);\n            deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);\n            deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta);\n\n            // Normalise offsetX and offsetY properties\n            if (this.getBoundingClientRect) {\n                var boundingRect = this.getBoundingClientRect();\n                offsetX = event.clientX - boundingRect.left;\n                offsetY = event.clientY - boundingRect.top;\n            }\n\n            // Add information to the event object\n            event.deltaX = deltaX;\n            event.deltaY = deltaY;\n            event.deltaFactor = lowestDelta;\n            event.offsetX = offsetX;\n            event.offsetY = offsetY;\n            // Go ahead and set deltaMode to 0 since we converted to pixels\n            // Although this is a little odd since we overwrite the deltaX/Y\n            // properties with normalized deltas.\n            event.deltaMode = 0;\n\n            // Add event and delta to the front of the arguments\n            args.unshift(event, delta, deltaX, deltaY);\n\n            // Clearout lowestDelta after sometime to better\n            // handle multiple device types that give different\n            // a different lowestDelta\n            // Ex: trackpad = 3 and mouse wheel = 120\n            if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }\n            nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);\n\n\n\n            return fn.apply(this, args);\n        }\n    };\n\n    mousewheelHandler.events = function() {\n        var doc = window.document;\n        return ( 'onwheel' in doc || doc.documentMode >= 9 ) ?\n               ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'];\n    };\n\n    return mousewheelHandler;\n\n}();","\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nMetaphorJs.dom = MetaphorJs.dom || {};","\nrequire(\"./__init.js\");\nrequire(\"./hasClass.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @function MetaphorJs.dom.addClass\n * @param {HTMLElement} el\n * @param {string} cls\n */\nmodule.exports = MetaphorJs.dom.addClass = function dom_addClass(el, cls) {\n    if (cls && !MetaphorJs.dom.hasClass(el, cls)) {\n        if (el.classList) {\n            cls = cls.split(\" \");\n            el.classList.add(...cls);\n        }\n        else el.className += \" \" + cls;\n    }\n};","require(\"./__init.js\");\n\nconst _mousewheelHandler = require(\"./_/_mousewheelHandler.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @function MetaphorJs.dom.addListener\n * @param {HTMLElement} el\n * @param {string} eventName\n * @param {function} func {\n *  @param {object} event\n * }\n */\nmodule.exports = MetaphorJs.dom.addListener = function(){\n\n    var fn = null,\n        prefix = null;\n\n    return function dom_addListener(el, event, func, opt) {\n\n        if (fn === null) {\n            if (el.addEventListener) {\n                fn = \"addEventListener\";\n                prefix = \"\";\n            }\n            else {\n                fn = \"attachEvent\";\n                prefix = \"on\";\n            }\n            //fn = el.attachEvent ? \"attachEvent\" : \"addEventListener\";\n            //prefix = el.attachEvent ? \"on\" : \"\";\n        }\n\n        opt = opt || {};\n        opt.capture = opt.capture || false;\n\n        if (event === \"mousewheel\") {\n            func = _mousewheelHandler(func);\n            var events = _mousewheelHandler.events(),\n                i, l;\n            for (i = 0, l = events.length; i < l; i++) {\n                el[fn](prefix + events[i], func, opt);\n            }\n        }\n        else {\n            el[fn](prefix + event, func, opt);\n        }\n\n        return func;\n    }\n\n}();","\nrequire(\"./__init.js\");\n\nconst isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Clone dom node (or array of nodes)\n * @function MetaphorJs.dom.clone\n * @param {[]|Element} node\n * @returns {[]|Element}\n */\nmodule.exports = MetaphorJs.dom.clone = function dom_clone(node) {\n\n    var i, len, cloned;\n\n    if (isArray(node)) {\n        cloned = [];\n        for (i = 0, len = node.length; i < len; i++) {\n            cloned.push(dom_clone(node[i]));\n        }\n        return cloned;\n    }\n    else if (node) {\n        switch (node.nodeType) {\n            // element\n            case window.document.ELEMENT_NODE:\n                return node.cloneNode(true);\n            // text node\n            case window.document.TEXT_NODE:\n                return window.document.createTextNode(node.innerText || node.textContent);\n            // document fragment\n            case window.document.DOCUMENT_FRAGMENT_NODE:\n                return node.cloneNode(true);\n\n            default:\n                return null;\n        }\n    }\n\n    return null;\n};\n","\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dom.commentWrap = function commentWrap(node, name) {\n    name = name || \"\";\n\n    var before = window.document.createComment(\"<\" + name),\n        after = window.document.createComment(name + \">\"),\n        parent = node.parentNode;\n\n    parent.insertBefore(before, node);\n\n    if (node.nextSibling) {\n        parent.insertBefore(after, node.nextSibling);\n    }\n    else {\n        parent.appendChild(after);\n    }\n\n    return [before, after];\n};","\nrequire(\"./__init.js\");\n\nconst nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get dom data value\n * @function MetaphorJs.dom.data\n * @param {HTMLElement} el\n * @param {string} key\n */\n\n/**\n * Set dom data value\n * @function MetaphorJs.dom.data\n * @param {HTMLElement} el\n * @param {string} key\n * @param {*} value\n * @param {string|null} action Pass \"remove\" to delete one data key or all keys\n * @returns {*}\n */\nmodule.exports = MetaphorJs.dom.data = function(){\n//dataCache   = {},\n    var getNodeKey  = function(key) {\n            return '$$mjs-' + key;\n        }/*,\n\n        getNodeId   = function(el) {\n            return el._mjsid || (el._mjsid = nextUid());\n        }*/;\n\n\n    return function dom_data(el, key, value, action) {\n        //var id  = getNodeId(el),\n        //    obj = dataCache[id];\n        var nodekey = getNodeKey(key);\n\n        if (action === 'remove') {\n            if (key) {\n                //obj && (delete obj[key]);\n                delete el[nodekey];\n            }\n            else {\n                //delete dataCache[id];\n            }\n            return;\n        }\n\n        if (value !== undefined) {\n            /*if (!obj) {\n                obj = dataCache[id] = {};\n            }\n            obj[key] = value;*/\n            el[nodekey] = value;\n            return value;\n        }\n        else {\n            //return obj ? obj[key] : undefined;\n            return el[nodekey];\n        }\n    };\n\n}();","\nrequire(\"./__init.js\");\nrequire(\"metaphorjs-shared/src/lib/Cache.js\");\nrequire(\"./is.js\");\nrequire(\"./addListener.js\");\nrequire(\"./normalizeEvent.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Delegate dom event\n * @function MetaphorJs.dom.delegate\n * @param {HTMLElement} el Dom node to add event listener to\n * @param {string} selector Event target selector\n * @param {string} event Event name\n * @param {function} fn {\n *  Event handler\n *  @param {object} event\n * }\n */\nmodule.exports = MetaphorJs.dom.delegate = function dom_delegate(el, selector, event, fn) {\n\n    var delegates = MetaphorJs.lib.Cache.global().get(\"dom/delegates\", []);\n\n    var key = selector + \"-\" + event,\n        listener    = function(e) {\n            e = MetaphorJs.dom.normalizeEvent(e);\n            var trg = e.target;\n            while (trg) {\n                if (MetaphorJs.dom.is(trg, selector)) {\n                    return fn(e);\n                }\n                trg = trg.parentNode;\n            }\n            return null;\n        };\n\n    if (!delegates[key]) {\n        delegates[key] = [];\n    }\n\n    delegates[key].push({el: el, ls: listener, fn: fn});\n\n    MetaphorJs.dom.addListener(el, event, listener);\n};","require(\"./__init.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Walk dom tree\n * @function MetaphorJs.dom.eachNode\n * @param {HTMLElement} el\n * @param {function} fn {\n *  @param {HTMLElement} el\n * }\n * @param {object} context fn's context\n */\nmodule.exports = MetaphorJs.dom.eachNode = function dom_eachNode(el, fn, context) {\n    var i, len,\n        children = el.childNodes;\n\n    if (fn.call(context, el) !== false) {\n        for(i =- 1, len = children.length>>>0;\n            ++i !== len;\n            dom_eachNode(children[i], fn, context)){}\n    }\n};\n","\nrequire(\"./__init.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get node attribute value\n * @function MetaphorJs.dom.getAttr\n * @param {HTMLElement} node\n * @returns {string}\n */\nmodule.exports = MetaphorJs.dom.getAttr = function dom_getAttr(el, name) {\n    return el.getAttribute ? el.getAttribute(name) : null;\n};","\nrequire(\"./__init.js\");\nrequire(\"./removeAttr.js\");\nrequire(\"../../lib/Config.js\");\n\nconst toCamelCase = require(\"metaphorjs-shared/src/func/toCamelCase.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get node attributes classified by directive\n * @function MetaphorJs.dom.getAttrSet\n * @param {HTMLElement} node\n * @returns {object}\n */\nmodule.exports = MetaphorJs.dom.getAttrSet = (function() {\n\n    // regular expression seems to be a few milliseconds faster\n    // than plain parsing\n    var reg = /^([\\[({#$@!])([^)\\]}\"':\\*!]+)[\\])}]?([:\\*!]?)$/;\n\n    var removeDirective = function removeDirective(node, directive) {\n        var ds = this.__directives,\n            i, l, d, j, jl, ns;\n\n        if (!this.inflated && ds[directive]) {\n\n            for (i = 0, l = ds[directive].length; i < l; i++) {\n                d = ds[directive][i];\n                if (d.original) {\n                    MetaphorJs.dom.removeAttr(node, d.original);\n                }\n                if (ns = d.names) {\n                    for (j = 0, jl = ns.length; j < jl; j++) {\n                        MetaphorJs.dom.removeAttr(node, ns[j]);\n                    }\n                }\n            }\n        }\n        //delete ds[directive];\n    };\n\n    var removeAttributes = function(node, what, param) {\n        var names, i, l;\n        if (what === \"all\") {\n            removeAttributes(node, \"directives\");\n            removeAttributes(node, \"attributes\");\n            removeAttributes(node, \"config\");\n        }\n        else if (what === \"directives\") {\n            for (i in this.__directives) {\n                removeDirective.call(this, node, i);    \n            }\n            return;\n        }\n        else if (what === \"directive\") {\n            removeDirective.call(this, node, param);\n            return;\n        }\n        else if (what === \"attributes\") {\n            names = this.__attributes;\n        }\n        else if (what === \"attribute\" && this.__attributes[param]) {\n            names = [this.__attributes[param]];\n        }\n        else if (what === \"config\") {\n            names = this.__config;\n        }\n        else if (what === \"reference\") {\n            names = [\"#\" + param];\n        }\n        else if (what === \"references\") {\n            names = [];\n            for (i = 0, l = this.references.length; i < l; i++) {\n                names.push(\"#\" + this.references[i]);\n            }\n        }\n        else if (what === \"at\") {\n            names = [\"@\" + this.at];\n        }\n\n        if (names) {\n            if (isArray(names)) {\n                for (i = 0, l = names.length; i < l; i++) {\n                    MetaphorJs.dom.removeAttr(node, names[i]);\n                }\n            }\n            else {\n                for (i in names) {\n                    MetaphorJs.dom.removeAttr(node, names[i]);\n                }\n            }\n        }\n    };\n\n    var execModes = {\n        '*': MetaphorJs.lib.Config.MODE_DYNAMIC,\n        ':': MetaphorJs.lib.Config.MODE_STATIC,\n        '!': MetaphorJs.lib.Config.MODE_SINGLE,\n        '': null\n    };\n\n    var dtypes = {\n        '{': \"dir\",\n        '(': \"event\",\n        '[': \"attr\",\n        '$': \"cfg\",\n        '!': \"renderer\"\n    };\n\n    var getEmpty = function() {\n        return {\n            directives: {},\n            attributes: {},\n            config: {},\n            rest: {},\n            references: [],\n            renderer: {},\n            at: null,\n\n            __plain: true,\n            __directives: {},\n            __attributes: {},\n            __config: [],\n            __remove: removeAttributes\n        };\n    };\n\n    var inflate = function(set) {\n        extend(set, getEmpty(), false, false);\n        set.inflated = true;\n        return set;\n    };\n\n    var ccName = function(name) {\n        return name.indexOf('--') !== -1 ? name : toCamelCase(name);\n    };\n\n    return function dom_getAttrSet(node) {\n\n        var set = getEmpty(),\n            i, l, \n            name, value,\n            indexName,\n            match, parts,\n            ds = set.directives, \n            __ds = set.__directives, \n            plain = true,\n            mode,\n            subname,\n            prop, execMode,\n            attrs = isArray(node) ? node : node.attributes;\n\n        /**\n         * mjs=\"<id>\" - attribute always present, even after cloning \n         * data-mjscfg - copy of original config, id always present\n         * node._mjscfg - equals data-mjscfg. After cloning, this property\n         *  disappears and we must make a new copy of config\n         *  from data-mjscfg version\n         */\n\n        if (node.nodeType && node.hasAttribute && node.hasAttribute(\"mjs\")) {\n            set = MetaphorJs.prebuilt.configs[node.getAttribute(\"mjs\")];\n            //MetaphorJs.dom.removeAttr(node, \"mjs\");\n            return inflate(set);\n        }\n\n        for (i = 0, l = attrs.length; i < l; i++) {\n\n            indexName = null;\n            name = attrs[i].name;\n            value = attrs[i].value;\n            mode = null;\n            execMode = null;\n            match = name.match(reg);\n\n            if (match) {\n                plain = false;\n                name = match[2];\n                mode = match[1];\n                execMode = execModes[match[3]];\n\n                if (mode === '#') {\n                    set.references.push(name);\n                    continue;\n                }\n                if (mode === '@') {\n                    set.at = name;\n                    continue;\n                }\n                if (mode === \"!\") {\n                    set.renderer[ccName(name)] = true;\n                    continue;\n                }\n            }\n            else {\n                if (name.substr(0, 4) === \"mjs-\") {\n                    name = name.substr(4);\n                    mode = '{';\n                    plain = false;\n                }\n                else {\n                    set['rest'][name] = value;\n                    continue;\n                }\n            }\n\n\n            if (mode === '$') {\n                if (value === \"\") {\n                    value = true;\n                }\n\n                set['config'][ccName(name)] = {\n                    expression: value,\n                    mode: execMode\n                };\n                set.__config.push(attrs[i].name);\n            }\n            else if (mode === '(' || mode === '{') { \n\n                parts = name.split(\".\");\n                name = parts.shift();\n                subname = parts.length ? parts.join(\".\") : null;\n                value === \"\" && (value = true);\n\n                if (!ds[name]) {\n                    ds[name] = {};\n                    __ds[name] = {\n                        type: dtypes[mode],\n                        original: null,\n                        names: []\n                    };\n                }\n\n                if (!subname) {\n                    __ds[name].original = attrs[i].name;\n                }\n\n                if (subname && subname[0] === '$') {\n                    \n                    prop = ccName(subname.substr(1));\n                    ds[name][prop] = {\n                        mode: execMode,\n                        expression: value,\n                        attr: attrs[i].name\n                    };\n                    __ds[name].names.push(attrs[i].name);\n                }\n                else {\n                    if (subname) {\n                        prop = \"value.\" + parts.join(\".\");\n                        // directive value keys are not camelcased\n                        // do this inside directive if needed\n                        // ('class' directive needs originals)\n                        ds[name][prop] = {\n                            mode: execMode,\n                            expression: value,\n                            attr: attrs[i].name\n                        };\n                        __ds[name].names.push(attrs[i].name);\n                    }\n                    else {\n                        ds[name]['value'] = {\n                            mode: execMode,\n                            expression: value,\n                            attr: attrs[i].name\n                        };\n                    }\n                }\n            }\n            else if (mode === '[') {\n                set.attributes[name] = value;\n                set.__attributes[name] = attrs[i].name;\n            }\n        }\n\n        for (name in ds) {\n            if (name.indexOf('|') !== -1) {\n                parts = name.split('|');\n                indexName = parts[1];\n            \n                if (name !== indexName && indexName) {\n\n                    if (ds[indexName]) {\n                        if (!isArray(ds[indexName])) {\n                            ds[indexName] = [ds[indexName]]\n                            __ds[indexName] = [__ds[indexName]]\n                        }\n                    }\n                    else {\n                        ds[indexName] = [];\n                        __ds[indexName] = [];\n                    }\n\n                    if (isArray(ds[indexName])) {\n                        ds[indexName].push(ds[name])\n                        __ds[indexName].push(__ds[name])\n                        delete ds[name];\n                        delete __ds[name];\n                    }\n                }\n            }\n\n            if (ds[name] && !isArray(ds[name])) {\n                ds[name] = [ds[name]]\n                __ds[name] = [__ds[name]]\n            }\n        }\n\n        set.directives = ds;\n        set.__directives = __ds;\n        set.__plain = plain;\n        \n\n        return set;\n    }\n\n}());","\nrequire(\"./__init.js\");\n\nconst getRegExp = require(\"metaphorjs-shared/src/func/getRegExp.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @param {String} cls\n * @returns {RegExp}\n */\nmodule.exports = MetaphorJs.dom.getClsReg = function(cls) {\n    return getRegExp('(?:^|\\\\s)'+cls+'(?!\\\\S)');\n};","\nrequire(\"./__init.js\");\nconst _dom_getDimensions = require(\"./_/_getDimensions.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get element height\n * @function MetaphorJs.dom.getHeight\n * @param {HTMLElement} el\n * @returns {int}\n */\nmodule.exports = MetaphorJs.dom.getHeight = _dom_getDimensions(\"\", \"Height\");","\nrequire(\"./__init.js\");\nconst _dom_getDimensions = require(\"./_/_getDimensions.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get element inner height\n * @function MetaphorJs.dom.getInnerHeight\n * @param {HTMLElement} el\n * @returns {int}\n */\nmodule.exports = MetaphorJs.dom.getInnerHeight = _dom_getDimensions(\"inner\", \"Height\");","\nrequire(\"./__init.js\");\nconst _dom_getDimensions = require(\"./_/_getDimensions.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get element inner width\n * @function MetaphorJs.dom.getInnerWidth\n * @param {HTMLElement} el\n * @returns {int}\n */\nmodule.exports = MetaphorJs.dom.getInnerWidth = _dom_getDimensions(\"inner\", \"Width\");","\nrequire(\"./__init.js\");\n\nconst isNull = require(\"metaphorjs-shared/src/func/isNull.js\"),\n    isString = require(\"metaphorjs-shared/src/func/isString.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @function MetaphorJs.dom.getInputValue\n * @param {HTMLElement} elem\n * @returns {string}\n */\nmodule.exports = MetaphorJs.dom.getInputValue = function(){\n\n\n    var rreturn = /\\r/,\n\n        hooks = {\n\n        option: function(elem) {\n            var val = elem.getAttribute(\"value\") || elem.value;\n\n            return val !== undefined ?\n                   val :\n                   ( elem.innerText || elem.textContent ).trim();\n        },\n\n        select: function(elem) {\n\n            var value, option,\n                options = elem.options,\n                index = elem.selectedIndex,\n                one = elem.type === \"select-one\" || index < 0,\n                values = one ? null : [],\n                max = one ? index + 1 : options.length,\n                disabled,\n                i = index < 0 ?\n                    max :\n                    one ? index : 0;\n\n            // Loop through all the selected options\n            for ( ; i < max; i++ ) {\n                option = options[ i ];\n\n                disabled = option.disabled ||\n                           option.parentNode.disabled;\n\n                // IE6-9 doesn't update selected after form reset (#2551)\n                if ((option.selected || i === index) && !disabled ) {\n                    // Get the specific value for the option\n                    value = MetaphorJs.dom.getInputValue(option);\n\n                    // We don't need an array for one selects\n                    if ( one ) {\n                        return value;\n                    }\n\n                    // Multi-Selects return an array\n                    values.push( value );\n                }\n            }\n\n            return values;\n        },\n\n        radio: function( elem ) {\n            return isNull(elem.getAttribute(\"value\")) ? \"on\" : elem.value;\n        },\n\n        checkbox: function( elem ) {\n            return isNull(elem.getAttribute(\"value\")) ? \"on\" : elem.value;\n        }\n    };\n\n    return function dom_getInputValue(elem) {\n\n        var hook, ret;\n\n        hook = hooks[elem.type] || hooks[elem.nodeName.toLowerCase()];\n\n        if (hook && (ret = hook(elem, \"value\")) !== undefined) {\n            return ret;\n        }\n\n        ret = elem.value;\n\n        return isString(ret) ?\n            // Handle most common string cases\n               ret.replace(rreturn, \"\") :\n            // Handle cases where value is null/undef or number\n               ret == null ? \"\" : ret;\n\n    };\n}();","\nrequire(\"./__init.js\");\nrequire(\"./isAttached.js\");\nrequire(\"./getScrollTop.js\");\nrequire(\"./getScrollLeft.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get element's offset\n * @function MetaphorJs.dom.getOffet\n * @param {HTMLElement} node\n * @returns {object} {\n *  @type {int} top\n *  @type {int} left\n * }\n */\nmodule.exports = MetaphorJs.dom.getOffset = function dom_getOffset(node) {\n\n    var box = {top: 0, left: 0},\n        html = window.document.documentElement;\n\n    // Make sure it's not a disconnected DOM node\n    if (!MetaphorJs.dom.isAttached(node) || node === window) {\n        return box;\n    }\n\n    // Support: BlackBerry 5, iOS 3 (original iPhone)\n    // If we don't have gBCR, just use 0,0 rather than error\n    if (node.getBoundingClientRect ) {\n        box = node.getBoundingClientRect();\n    }\n\n    return {\n        top: box.top + MetaphorJs.dom.getScrollTop() - html.clientTop,\n        left: box.left + MetaphorJs.dom.getScrollLeft() - html.clientLeft\n    };\n};","\nrequire(\"./__init.js\");\nrequire(\"./getStyle.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get element's offset parent\n * @function MetaphorJs.dom.getOffsetParent\n * @param {HTMLElement} node \n * @returns {HTMLElement}\n */\nmodule.exports = MetaphorJs.dom.getOffsetParent = function dom_getOffsetParent(node) {\n\n    var html = window.document.documentElement,\n        offsetParent = node.offsetParent || html;\n\n    while (offsetParent && \n            (offsetParent != html &&\n                MetaphorJs.dom.getStyle(offsetParent, \"position\") === \"static\")) {\n        offsetParent = offsetParent.offsetParent;\n    }\n\n    return offsetParent || html;\n};\n","\nrequire(\"./__init.js\");\nconst _dom_getDimensions = require(\"./_/_getDimensions.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get element outer height\n * @function MetaphorJs.dom.getOuterHeight\n * @param {HTMLElement} el\n * @returns {int}\n */\nmodule.exports = MetaphorJs.dom.getOuterHeight = _dom_getDimensions(\"outer\", \"Height\");","\nrequire(\"./__init.js\");\nconst _dom_getDimensions = require(\"./_/_getDimensions.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get element outer width\n * @function MetaphorJs.dom.getOuterWidth\n * @param {HTMLElement} el\n * @returns {int}\n */\nmodule.exports = MetaphorJs.dom.getOuterWidth = _dom_getDimensions(\"outer\", \"Width\");","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dom.getParentDocument = function dom_getParentDocument(node) {\n    var fragType = window.document.DOCUMENT_FRAGMENT_NODE,\n        parent = node.parentNode;\n    while (parent) {\n        if (parent.nodeType === fragType) {\n            return parent;\n        }\n        parent = parent.parentNode;\n    }\n    return node.ownerDocument;\n};","\nrequire(\"./__init.js\");\nrequire(\"./getStyle.js\");\nrequire(\"./getOffsetParent.js\");\nrequire(\"./getOffset.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get node position relative to offset parent or specific node\n * @function MetaphorJs.dom.getPosition\n * @param {HTMLElement} node \n * @param {HTMLElement} to \n * @return {object} {\n *  @type {int} top\n *  @type {int} left\n * }\n */\nmodule.exports = MetaphorJs.dom.getPosition = function dom_getPosition(node, to) {\n\n    var offsetParent, offset,\n        parentOffset = {top: 0, left: 0},\n        html = window.document.documentElement;\n\n    if (node === window || node === html) {\n        return parentOffset;\n    }\n\n    // Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n    // because it is its only offset parent\n    if (MetaphorJs.dom.getStyle(node, \"position\" ) == \"fixed\") {\n        // Assume getBoundingClientRect is there when computed position is fixed\n        offset = node.getBoundingClientRect();\n    }\n    else if (to) {\n        var thisOffset = MetaphorJs.dom.getOffset(node),\n            toOffset = MetaphorJs.dom.getOffset(to),\n            position = {\n                left: thisOffset.left - toOffset.left,\n                top: thisOffset.top - toOffset.top\n            };\n\n        if (position.left < 0) {\n            position.left = 0;\n        }\n        if (position.top < 0) {\n            position.top = 0;\n        }\n        return position;\n    }\n    else {\n        // Get *real* offsetParent\n        offsetParent = MetaphorJs.dom.getOffsetParent(node);\n\n        // Get correct offsets\n        offset = MetaphorJs.dom.getOffset(node);\n\n        if (offsetParent !== html) {\n            parentOffset = MetaphorJs.dom.getOffset(offsetParent);\n        }\n\n        // Add offsetParent borders\n        parentOffset.top += MetaphorJs.dom.getStyle(offsetParent, \"borderTopWidth\", true);\n        parentOffset.left += MetaphorJs.dom.getStyle(offsetParent, \"borderLeftWidth\", true);\n    }\n\n    // Subtract parent offsets and element margins\n    return {\n        top: offset.top - parentOffset.top - MetaphorJs.dom.getStyle(node, \"marginTop\", true),\n        left: offset.left - parentOffset.left - MetaphorJs.dom.getStyle(node, \"marginLeft\", true)\n    };\n};","\nrequire(\"./__init.js\");\nconst _getScrollTopOrLeft = require(\"./_/_getScrollTopOrLeft.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get element's horizontal scroll position\n * @function MetaphorJs.dom.getScrollLeft\n * @param {HTMLElement} element\n * @returns {int}\n */\nmodule.exports = MetaphorJs.dom.getScrollLeft = _getScrollTopOrLeft(false);\n","\nrequire(\"./__init.js\");\nrequire(\"./getStyle.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get element's scrolling parent\n * @function MetaphorJs.dom.getScrollParent\n * @param {HTMLElement} node\n * @returns {HTMLElement}\n */\nmodule.exports = MetaphorJs.dom.getScrollParent = function() {\n\n    var rOvf        = /(auto|scroll)/,\n        body,\n\n        overflow    = function (node) {\n            var style = MetaphorJs.dom.getStyle(node);\n            return style ? style[\"overflow\"] + style[\"overflowY\"] + style[\"overflowY\"] : \"\";\n        },\n\n        scroll      = function (node) {\n            return rOvf.test(overflow(node));\n        };\n\n    return function dom_getScrollParent(node) {\n\n        if (!body) {\n            body = window.document.body;\n        }\n\n        var parent = node;\n\n        while (parent) {\n            if (parent === body) {\n                return window;\n            }\n            if (scroll(parent)) {\n                return parent;\n            }\n            parent = parent.parentNode;\n        }\n\n        return window;\n    };\n}();","\nrequire(\"./__init.js\");\nconst _getScrollTopOrLeft = require(\"./_/_getScrollTopOrLeft.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get element's vertical scroll position\n * @function MetaphorJs.dom.getScrollTop\n * @param {HTMLElement} element\n * @returns {int}\n */\nmodule.exports = MetaphorJs.dom.getScrollTop = _getScrollTopOrLeft(true);\n","\nrequire(\"./__init.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get element's style object\n * @function MetaphorJs.dom.getStyle\n * @param {HTMLElement} node\n * @returns {DomStyle}\n */\n\n /**\n * Get element's style property\n * @function MetaphorJs.dom.getStyle\n * @param {HTMLElement} node\n * @param {string} prop\n * @param {boolean} numeric return as number\n * @returns {string|int}\n */\nmodule.exports = MetaphorJs.dom.getStyle = function dom_getStyle(node, prop, numeric) {\n\n    var style, val;\n\n    if (window.getComputedStyle) {\n        if (node === window) {\n            return prop? (numeric ? 0 : null) : {};\n        }\n        style = window.getComputedStyle(node, null);\n        val = prop ? style[prop] : style;\n    }\n    else {\n        style = node.currentStyle || node.style || {};\n        val = prop ? style[prop] : style;\n    }\n\n    return numeric ? parseFloat(val) || 0 : val;\n};\n","\nrequire(\"./__init.js\");\nconst _dom_getDimensions = require(\"./_/_getDimensions.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Get element width\n * @function MetaphorJs.dom.getWidth\n * @param {HTMLElement} el\n * @returns {int}\n */\nmodule.exports = MetaphorJs.dom.getWidth = _dom_getDimensions(\"\", \"Width\");","require(\"./__init.js\");\nrequire(\"./getClsReg.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @function MetaphorJs.dom.hasClass\n * @param {HTMLElement} el\n * @param {String} cls\n * @returns {boolean}\n */\nmodule.exports = MetaphorJs.dom.hasClass = function(el, cls) {\n    return cls ? \n            el.classList ? \n                el.classList.contains(cls) : \n                MetaphorJs.dom.getClsReg(cls).test(el.className) : \n            false;\n};","\nrequire(\"./__init.js\");\nrequire(\"./select.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Check if given element matches selector\n * @function MetaphorJs.dom.is\n * @param {HTMLElement} el\n * @param {string} selector\n * @returns {boolean}\n */\nmodule.exports = MetaphorJs.dom.is = function(el, selector) {\n\n    if (!selector) {\n        return false;\n    }\n\n    if (typeof selector === \"function\") {\n        return el instanceof selector;\n    }\n\n    var els = MetaphorJs.dom.select(selector, el.parentNode),\n        i, l;\n\n    for (i = -1, l = els.length; ++i < l;) {\n        if (els[i] === el) {\n            return true;\n        }\n    }\n\n    return false;\n};","\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Is node attached to DOM\n * @function MetaphorJs.dom.isAttached\n * @param {HTMLElement} node\n * @returns {boolean}\n */\nmodule.exports = MetaphorJs.dom.isAttached = function dom_isAttached(node) {\n\n    if (node === window) {\n        return true;\n    }\n    if (node.nodeType == window.document.TEXT_NODE) {\n        if (node.parentElement) {\n            return dom_isAttached(node.parentElement);\n        }\n        else {\n            return true;\n        }\n    }\n\n    var html = window.document.documentElement;\n\n    return node === html ? true : html.contains(node);\n};\n","require(\"./__init.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Is given element a field\n * @function MetaphorJs.dom.isField\n * @param {HTMLElement} node\n * @returns {boolean}\n */\nmodule.exports = MetaphorJs.dom.isField = function dom_isField(el) {\n    var tag\t= el && el.nodeName ? el.nodeName.toLowerCase() : null,\n        type = el.type;\n    if (tag == 'input' || tag == 'textarea' || tag == 'select') {\n        if (type != \"submit\" && type != \"reset\" && type != \"button\") {\n            return true;\n        }\n    }\n    return false;\n};","\nrequire(\"./__init.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Is element visible on the page\n * @function MetaphorJs.dom.isVisible\n * @param {HTMLElement} el\n * @returns {boolean}\n */\nmodule.exports = MetaphorJs.dom.isVisible = function dom_isVisible(el) {\n    return el && !(el.offsetWidth <= 0 || el.offsetHeight <= 0);\n};\n","require(\"./__init.js\");\nrequire(\"../../lib/DomEvent.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dom.normalizeEvent = function(originalEvent) {\n    return originalEvent instanceof MetaphorJs.lib.DomEvent ? \n            originalEvent : \n            new MetaphorJs.lib.DomEvent(originalEvent);\n};\n","\nrequire(\"./__init.js\");\nrequire(\"./removeListener.js\");\nrequire(\"./addListener.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Execute callback when window is ready\n * @function MetaphorJs.dom.onReady\n * @param {function} fn {\n *  @param {Window} win\n * }\n * @param {Window} w optional window object\n */\nmodule.exports = MetaphorJs.dom.onReady = function dom_onReady(fn, w) {\n\n    var done    = false,\n        top     = true,\n        win     = w || window,\n        root, doc,\n\n        init    = function(e) {\n            if (e.type == 'readystatechange' && doc.readyState != 'complete') {\n                return;\n            }\n\n            MetaphorJs.dom.removeListener(e.type == 'load' ? win : doc, e.type, init);\n\n            if (!done && (done = true)) {\n                fn.call(win, e.type || e);\n            }\n        },\n\n        poll = function() {\n            try {\n                root.doScroll('left');\n            } \n            catch(thrownError) {\n                setTimeout(poll, 50);\n                return;\n            }\n\n            init('poll');\n        };\n\n    doc     = win.document;\n    root    = doc.documentElement;\n\n    if (doc.readyState == 'complete') {\n        fn.call(win, 'lazy');\n    }\n    else {\n        if (doc.createEventObject && root.doScroll) {\n            try {\n                top = !win.frameElement;\n            } \n            catch(thrownError) {}\n\n            top && poll();\n        }\n        MetaphorJs.dom.addListener(doc, 'DOMContentLoaded', init);\n        MetaphorJs.dom.addListener(doc, 'readystatechange', init);\n        MetaphorJs.dom.addListener(win, 'load', init);\n    }\n};","\nrequire(\"./__init.js\");\nrequire(\"./addListener.js\");\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dom.preloadImage = function() {\n\n    var cache = {},\n        loading = {},\n        cacheCnt = 0;\n\n    function dom_preloadImage(src) {\n\n        if (cache[src] !== undefined) {\n            if (cache[src] === false) {\n                return MetaphorJs.lib.Promise.reject(src);\n            }\n            else {\n                return MetaphorJs.lib.Promise.resolve(cache[src]);\n            }\n        }\n\n        if (loading[src]) {\n            return loading[src];\n        }\n\n        if (cacheCnt > 1000) {\n            cache = {};\n            cacheCnt = 0;\n        }\n\n        var doc = window.document,\n            img = doc.createElement(\"img\"),\n            style = img.style,\n            deferred = new MetaphorJs.lib.Promise;\n\n        loading[src] = deferred;\n\n        deferred.always(function(){\n            delete loading[src];\n        });\n\n        MetaphorJs.dom.addListener(img, \"load\", function() {\n            if (!cache[src]) {\n                cache[src] = {\n                    src:    src,\n                    width:  img ? img.width : null,\n                    height: img ? img.height : null\n                };\n                cacheCnt++;\n            }\n            if (deferred) {\n                deferred.resolve(cache[src]);\n            }\n            if (img && img.parentNode) {\n                img.parentNode.removeChild(img);\n            }\n            img = null;\n            style = null;\n            deferred = null;\n        });\n\n        MetaphorJs.dom.addListener(img, \"error\", function() {\n            cache[src] = false;\n            if (img && img.parentNode) {\n                img.parentNode.removeChild(img);\n            }\n            if (deferred) {\n                deferred.reject(src);\n            }\n        });\n\n        deferred.abort = function() {\n            if (img && img.parentNode) {\n                img.parentNode.removeChild(img);\n            }\n            if (deferred) {\n                deferred.reject(src);\n            }\n            img = null;\n            style = null;\n            deferred = null;\n        };\n\n        style.position = \"absolute\";\n        style.visibility = \"hidden\";\n        style.left = \"-10000px\";\n        style.top = \"0\";\n        doc.body.appendChild(img);\n        img.src = src;\n\n        return deferred;\n    };\n\n    dom_preloadImage.check = function(src) {\n        if (cache[src] !== undefined) {\n            return cache[src];\n        }\n        return loading[src] || null;\n    };\n\n    return dom_preloadImage;\n\n}();","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Remove element's attribute\n * @function MetaphorJs.dom.removeAttr\n * @param {HTMLElement} node \n * @param {string} name\n */\nmodule.exports = MetaphorJs.dom.removeAttr = function dom_removeAttr(el, name) {\n    return el.removeAttribute(name);\n};","\nrequire(\"./__init.js\");\n\nrequire(\"./__init.js\");\nrequire(\"./getClsReg.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Remove element's class\n * @function MetaphorJs.dom.removeClass\n * @param {HTMLElement} el\n * @param {string} cls\n */\nmodule.exports = MetaphorJs.dom.removeClass = function(el, cls) {\n    if (cls) {\n        if (el.classList) {\n            cls = cls.split(\" \");\n            el.classList.remove(...cls);\n        }\n        else el.className = el.className.replace(MetaphorJs.dom.getClsReg(cls), '');\n    }\n};","require(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Remove listeners from element's events\n * @function MetaphorJs.dom.removeListener\n * @param {HTMLElement} el \n * @param {string} eventName\n * @param {function} fn\n */\nmodule.exports = MetaphorJs.dom.removeListener = function(){\n\n    var fn = null,\n        prefix = null;\n\n    return function dom_removeListener(el, event, func) {\n\n        if (fn === null) {\n            if (el.removeEventListener) {\n                fn = \"removeEventListener\";\n                prefix = \"\";\n            }\n            else {\n                fn = \"detachEvent\";\n                prefix = \"on\";\n            }\n            //fn = el.detachEvent ? \"detachEvent\" : \"removeEventListener\";\n            //prefix = el.detachEvent ? \"on\" : \"\";\n        }\n\n        el[fn](prefix + event, func);\n    }\n}();","\nrequire(\"./__init.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Remove specific style from element\n * @function MetaphorJs.dom.removeStyle\n * @param {HTMLElement} node\n * @param {string} name Style property name\n */\nmodule.exports = MetaphorJs.dom.removeStyle = (function() {\n\n    var div = window.document.createElement(\"div\");\n\n    if (div.style && div.style.removeProperty) {\n        return function(node, name) {\n            node.style.removeProperty(name);\n        };\n    }\n    else {\n        return function(node, name) {\n            node.style.removeAttribute(name);\n        };\n    }\n\n}());","require(\"./__init.js\");\n\nconst toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Returns array of nodes or an empty array\n * @function MetaphorJs.dom.select\n * @param {string} selector\n * @param {HTMLElement} root to look into\n */\nmodule.exports = MetaphorJs.dom.select = function dom_select(selector, root) {\n    root = root || window.document;\n    return toArray(root.querySelectorAll(selector));\n}","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dom.setAttr = function(el, name, value) {\n    return el.setAttribute(name, value);\n};","\nrequire(\"./__init.js\");\nrequire(\"./getInputValue.js\");\nrequire(\"./getAttr.js\");\nrequire(\"./setAttr.js\");\nrequire(\"./removeAttr.js\");\n\nconst toArray     = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    isArray     = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    isNumber    = require(\"metaphorjs-shared/src/func/isNumber.js\"),\n    isNull      = require(\"metaphorjs-shared/src/func/isNull.js\"),\n    MetaphorJs  = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @function MetaphorJs.dom.setInputValue\n * @param {HTMLElement} el\n * @param {*} val\n */\nmodule.exports = MetaphorJs.dom.setInputValue = function() {\n\n    var hooks = {\n        select:  function(elem, value) {\n\n            var optionSet, option,\n                options     = elem.options,\n                values      = toArray(value),\n                i           = options.length,\n                selected,\n                setIndex    = -1;\n\n            while ( i-- ) {\n                option      = options[i];\n                selected    = values.indexOf(option.value) !== -1;\n\n                if (selected) {\n                    MetaphorJs.dom.setAttr(option, \"selected\", \"selected\");\n                    option.selected = true;\n                    optionSet = true;\n                }\n                else {\n                    MetaphorJs.dom.removeAttr(option, \"selected\");\n                }\n\n                if (!selected && !isNull(MetaphorJs.dom.getAttr(option, \"default-option\"))) {\n                    setIndex = i;\n                }\n            }\n\n            // Force browsers to behave consistently when non-matching value is set\n            if (!optionSet) {\n                elem.selectedIndex = setIndex;\n            }\n\n            return values;\n        }\n    };\n\n    hooks[\"radio\"] = hooks[\"checkbox\"] = function(elem, value) {\n        if (isArray(value) ) {\n            return (elem.checked = value.indexOf(\n                MetaphorJs.dom.getInputValue(elem)\n                ) !== -1);\n        }\n    };\n\n\n    return function(el, val) {\n\n        if (el.nodeType !== window.document.ELEMENT_NODE) {\n            return;\n        }\n\n        // Treat null/undefined as \"\"; convert numbers to string\n        if (isNull(val)) {\n            val = \"\";\n        }\n        else if (isNumber(val)) {\n            val += \"\";\n        }\n\n        var hook = hooks[el.type] || hooks[el.nodeName.toLowerCase()];\n\n        // If set returns undefined, fall back to normal setting\n        if (!hook || hook(el, val, \"value\") === undefined) {\n            el.value = val;\n        }\n    };\n}();","require(\"./__init.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Set element's style\n * @function MetaphorJs.dom.setStyle\n * @param {HTMLElement} el\n * @param {string} name\n * @param {*} value\n */\nmodule.exports = MetaphorJs.dom.setStyle = function dom_setStyle(el, name, value) {\n\n    if (!el || !el.style) {\n        return;\n    }\n\n    var props,\n        style = el.style,\n        k;\n\n    if (typeof name === \"string\") {\n        props = {};\n        props[name] = value;\n    }\n    else {\n        props = name;\n    }\n\n    for (k in props) {\n        style[k] = props[k];\n    }\n};","\nrequire(\"./__init.js\");\nconst isString = require(\"metaphorjs-shared/src/func/isString.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dom.toFragment = function dom_toFragment(nodes, doc) {\n\n    const fragment = (doc || window.document).createDocumentFragment();\n    let i, l;\n\n    if (isString(nodes)) {\n        const tmp = window.document.createElement('div');\n        tmp.innerHTML = nodes;\n        nodes = tmp.childNodes;\n    }\n\n    if (!nodes) {\n        return fragment;\n    }\n\n    if (nodes.nodeType) {\n        fragment.appendChild(nodes);\n    }\n    else {\n        // due to a bug in jsdom, we turn NodeList into array first\n        if (nodes.item) {\n            const tmpNodes = nodes;\n            nodes = [];\n            for (i = -1, l = tmpNodes.length >>> 0; ++i !== l; nodes.push(tmpNodes[i])) {}\n        }\n\n        for (i = -1, l = nodes.length; ++i !== l; fragment.appendChild(nodes[i])) {}\n    }\n\n    return fragment;\n};","\nrequire(\"./__init.js\");\nrequire(\"./data.js\");\nrequire(\"./toFragment.js\");\nrequire(\"./clone.js\");\nrequire(\"metaphorjs-shared/src/func/toArray.js\");\n\nconst toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dom.transclude = (function(){\n\n    var getTranscludeFrom = function(parent) {\n        var contents;\n        while (parent) {\n            contents = MetaphorJs.dom.data(parent, 'mjs-transclude');\n            if (contents !== undefined) {\n                return contents;\n            }\n            parent  = parent.parentNode;\n        }\n        return undefined;\n    };\n\n    return function dom_transclude(node, replace, parents) {\n\n        parents = parents || [];\n        parents.unshift(node.parentNode);\n\n        var i, l,\n            contents;\n    \n        for (i = 0, l = parents.length; i < l; i++) {\n            contents = getTranscludeFrom(parents[i]);\n            if (contents) {\n                break;\n            }\n        }\n    \n        if (contents) {\n    \n            if (node.firstChild) {\n                MetaphorJs.dom.data(node, \"mjs-transclude\", MetaphorJs.dom.toFragment(node.childNodes));\n            }\n    \n            var parent      = node.parentNode,\n                //next        = node.nextSibling,\n                cloned      = MetaphorJs.dom.clone(contents),\n                children    = toArray(cloned.childNodes);\n    \n            if (replace) {\n                parent.replaceChild(node, cloned);\n                //parent.removeChild(node);\n                //parent.insertBefore(cloned, next);\n            }\n            else {\n                node.appendChild(cloned);\n            }\n    \n            return children;\n        }\n    \n        return null;\n    };\n}());","\nrequire(\"./__init.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Trigger DOM event on element\n * @function MetaphorJs.dom.triggerEvent\n * @param {HTMLElement} el\n * @param {string} event\n */\nmodule.exports = MetaphorJs.dom.triggerEvent = function dom_triggerEvent(el, event) {\n\n    var isStr   = typeof event === \"string\",\n        type    = isStr ? event : event.type;\n\n    if (el.fireEvent) {\n        return el.fireEvent(\"on\" + type);\n    }\n    else {\n        if (isStr) {\n            if (document.createEvent) {\n                event = document.createEvent(\"Event\");\n                event.initEvent(type, true, true);\n            }\n            else {\n                event = new Event(event);\n            }\n        }\n        \n        return el.dispatchEvent(event);\n    }\n};","require(\"./__init.js\");\nrequire(\"./removeListener.js\");\nrequire(\"metaphorjs-shared/src/lib/Cache.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = function undelegate(el, selector, event, fn) {\n\n    var key = selector + \"-\" + event,\n        i, l,\n        ds,\n        delegates = MetaphorJs.lib.Cache.global().get(\"dom/delegates\", []);\n\n    if (ds = delegates[key]) {\n        for (i = -1, l = ds.length; ++i < l;) {\n            if (ds[i].el === el && ds[i].fn === fn) {\n                MetaphorJs.dom.removeListener(el, event, ds[i].ls);\n            }\n        }\n    }\n};","\nrequire(\"./isAttached.js\");\nrequire(\"metaphorjs-promise/src/lib/Promise.js\");\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dom.whenAttached = (function(){\n\n    var nodes = [],\n        promises = [],\n        observer,\n        html;\n\n    var check = function() {\n        var i, l, inx, sub = 0, remove = [];\n        for (i = 0, l = nodes.length; i < l; i++) {\n            if (html.contains(nodes[i])) {\n                promises[i].resolve();\n                remove.push(i);   \n            }\n        }\n\n        for (i = 0, l = remove.length; i < l; i++) {\n            inx = remove[i] - sub++;\n            nodes.splice(inx, 1);\n            promises.splice(inx, 1);\n        }\n\n        if (nodes.length === 0) {\n            if (window.MutationObserver) {\n                observer.disconnect();\n                observer = null;\n            }\n            else {\n                window.clearInterval(observer);\n                observer = null;\n            }\n        }\n    };\n\n    var initObserver = window.MutationObserver ? \n        function() {\n            html = window.document.documentElement;\n            observer = new window.MutationObserver(check);\n            observer.observe(html, {childList: true, subtree: true});\n        } :\n        function() {\n            html = window.document.documentElement;\n            observer = window.setInterval(check, 1000);\n        };\n    \n\n    return function when_attached(node) {\n\n        if (MetaphorJs.dom.isAttached(node)) {\n            return MetaphorJs.lib.Promise.resolve();\n        }\n\n        !observer && initObserver();\n\n        var inx;\n\n        if ((inx = nodes.indexOf(node)) === -1) {\n            nodes.push(node);\n            promises.push(new MetaphorJs.lib.Promise);\n            inx = nodes.length - 1;\n        };\n\n        if (promises[inx].isCancelled()){\n            promises[inx] = new MetaphorJs.lib.Promise;\n        }\n\n        return promises[inx];\n    };\n\n}());","require(\"metaphorjs-observable/src/lib/Observable.js\");\nrequire(\"./Expression.js\");\nrequire(\"./MutationObserver.js\");\nrequire(\"../func/app/prebuilt.js\");\n\nconst extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    toBool = require(\"metaphorjs-shared/src/func/toBool.js\"),\n    toArray = require(\"metaphorjs-shared/src/func/toArray.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    isPrimitive = require(\"metaphorjs-shared/src/func/isPrimitive.js\"),\n    emptyFn = require(\"metaphorjs-shared/src/func/emptyFn.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * @class MetaphorJs.lib.Config\n */\nmodule.exports = MetaphorJs.lib.Config = (function(){\n\n    const   $$observable = new MetaphorJs.lib.Observable;\n\n    const   MODE_STATIC = 1,\n            MODE_DYNAMIC = 2,\n            MODE_SINGLE = 3,\n            MODE_GETTER = 4,\n            MODE_SETTER = 5,\n            MODE_FUNC = 6,\n            MODE_FNSET = 7,\n            MODE_LISTENER = 8;\n\n\n    /**\n     * @constructor\n     * @method\n     * @param {object} properties Attribute expressions/properties map\n     * @param {object} cfg {\n     *  @type {object} state Data object\n     *  @type {object} setTo set all values to this object\n     * }\n     * @param {string} scalarAs {\n     *  expression|defaultValue|value -- \n     *  if property comes as scalar value {name: value}, this\n     *  option helps determine what to do with it, make an expression\n     *  out of it, or use as default value.\n     * }\n     */\n    var Config = function(properties, cfg, scalarAs) {\n\n        var self = this;\n\n        self.id = nextUid();\n        self.values = {};\n        self.properties = {};\n        self.cfg = cfg || {};\n        self.keys = [];\n\n        if (properties) {\n            self.addProperties(properties, scalarAs);\n        }\n    };\n\n    extend(Config.prototype, {\n\n        id: null,\n        properties: null,\n        values: null,\n        keys: null,\n        cfg: null,\n\n        _initMo: function(name, pb) {\n            var self = this,\n                prop = self.properties[name];\n            prop.mo = MetaphorJs.lib.MutationObserver.get(\n                prop.state || self.cfg.state, \n                pb || prop.expression\n            );\n            prop.mo.subscribe(self._onPropMutated, self, {\n                append: [name]\n            });\n        }, \n\n        _unsetMo: function(name) {\n            var self = this, prop = self.properties[name];\n            if (prop.mo) {\n                prop.mo.unsubscribe(self._onPropMutated, self);\n                prop.mo.$destroy(true);\n                prop.mo = null;\n            }\n        },\n\n        storeAsCode: function(name) {\n\n            var self = this,\n                prop = self.getProperty(name),\n                mode, expr, res, descr;\n\n            if (!prop || !prop.expression) {\n                return null;\n            }\n\n            mode = prop.mode || prop.defaultMode || MODE_DYNAMIC;\n            expr = prop.expression;\n\n            if (mode !== MODE_STATIC) {\n                descr = MetaphorJs.lib.Expression.describeExpression(expr);\n            }\n\n            switch (mode) {\n                case MODE_STATIC: {\n                    if (typeof expr === \"string\") {\n                        expr = expr.replace(/\\\\([\\s\\S])|(\")/g,\"\\\\$1$2\")\n                    }\n                    res = {\n                        getterFn: new Function(\"\", \"return \\\"\" + expr + \"\\\"\"),\n                        mode: MODE_STATIC\n                    };\n                    break;\n                }\n                case MODE_SINGLE:\n                case MODE_DYNAMIC:\n                case MODE_FUNC: \n                case MODE_GETTER: \n                case MODE_SETTER:\n                case MODE_FNSET: {\n                    res = MetaphorJs.lib.Expression.deconstruct(expr, {\n                        noReturn: mode === MODE_FUNC || mode === MODE_SETTER,\n                        setter: mode === MODE_SETTER || mode === MODE_FNSET\n                    });\n                    break;\n                }\n\n                case MODE_LISTENER: {\n                    var delegate = expr.indexOf('(') === -1 && \n                                    expr.indexOf('=') === -1;\n                    res = MetaphorJs.lib.Expression.expression(expr, {\n                        noReturn: delegate === false\n                    });\n                    res.delegate = delegate;\n                    break;\n                }\n            }\n\n            prop.inflate && (res.inflate = prop.inflate);\n            res.descr = descr;\n\n            return res;\n        },\n\n        _calcProperty: function(name) {\n\n            var self = this,\n                prop = self.getProperty(name),\n                value,\n                pb,\n                setTo;\n\n            if (!prop || prop.disabled) {\n                return null;\n            }\n\n            if (prop.expression || prop.prebuilt) {\n\n                pb = prop.prebuilt;\n\n                if (!pb && MetaphorJs.app.prebuilt.isKey(prop.expression)) {\n                    prop.prebuilt = pb = \n                        MetaphorJs.app.prebuilt.get(\"config\", prop.expression);\n                }\n\n                if (!prop.mode) {\n                    prop.mode = self.cfg.defaultMode || MODE_DYNAMIC;\n                }\n\n                if (prop.mode === MODE_STATIC) {\n                    if (pb) {\n                        value = pb.getterFn();\n                    }\n                    else {\n                        value = prop.expression;\n                    }\n                }\n                else if (prop.mode === MODE_SINGLE) {\n                    if (pb) {\n                        value = (pb.getterFn || pb.fn)(prop.state || self.cfg.state);\n                    }\n                    else {\n                        value = MetaphorJs.lib.Expression.get(\n                            prop.expression, \n                            prop.state || self.cfg.state\n                        );\n                    }\n                }\n                else if (prop.mode === MODE_DYNAMIC) {\n                    !prop.mo && self._initMo(name, pb);\n                    value = prop.mo.getValue();\n                }\n                else if (prop.mode === MODE_GETTER || \n                         prop.mode === MODE_SETTER) {\n                    \n                    if (pb) {\n                        value = MetaphorJs.lib.Expression.construct(\n                            pb,\n                            {\n                                setterOnly: prop.mode === MODE_SETTER,\n                                getterOnly: prop.mode === MODE_GETTER\n                            }\n                        );\n                    }\n                    else {\n                        value = MetaphorJs.lib.Expression.parse(\n                            prop.expression,\n                            {\n                                setter: prop.mode === MODE_SETTER,\n                                setterOnly: prop.mode === MODE_SETTER,\n                                getterOnly: prop.mode === MODE_GETTER\n                            }\n                        );\n                    }\n                }\n                else if (prop.mode === MODE_FNSET) {\n                    if (pb) {\n                        value = {\n                            getter: MetaphorJs.lib.Expression.construct(\n                                pb, {getterOnly: true}\n                            ),\n                            setter: MetaphorJs.lib.Expression.construct(\n                                pb, {setterOnly: true}\n                            )\n                        }\n                    }\n                    else {\n                        value = {\n                            getter: MetaphorJs.lib.Expression.getter(prop.expression),\n                            setter: MetaphorJs.lib.Expression.setter(prop.expression)\n                        };\n                    }\n                }\n                else if (prop.mode === MODE_FUNC) {\n                    if (pb) {\n                        value = pb.fn || pb.getterFn;\n                    }\n                    else {\n                        value = MetaphorJs.lib.Expression.func(prop.expression);\n                    }\n                }\n                else if (prop.mode === MODE_LISTENER) {\n                    if (pb) {\n                        if (pb.delegate) {\n                            value = pb.getterFn(prop.state || self.cfg.state);\n                        }\n                        else {\n                            value = self._wrapListener(\n                                pb.fn || pb.getterFn, \n                                prop.state || self.cfg.state,\n                                prop\n                            );\n                        }\n                    }\n                    else {\n                        if (prop.expression.indexOf('(') === -1 && \n                            prop.expression.indexOf('=') === -1) {\n                            value = MetaphorJs.lib.Expression.get(\n                                prop.expression, \n                                prop.state || self.cfg.state\n                            );\n                        }\n                        else {\n                            value = MetaphorJs.lib.Expression.func(prop.expression);\n                            if (value && typeof(value) === \"function\") {\n                                value = self._wrapListener(\n                                    value, \n                                    prop.state || self.cfg.state,\n                                    prop\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (value === undefined) {\n                value = prop.defaultValue;\n            }\n\n            var retValue = self._prepareValue(value, prop);\n\n            if (value !== undefined) {\n                self.values[name] = retValue;\n            }\n\n            setTo = self.cfg.setTo || prop.setTo;\n            if (setTo) {\n                setTo[name] = retValue;\n            }\n\n            return retValue;\n        },\n\n        _wrapListener: function(ls, state, prop) {\n            return function() {\n                var args = toArray(arguments),\n                    i, l;\n                for (i = 0, l = args.length; i < l; i++) {\n                    state[\"$\" + (i+1)] = args[i];\n                }\n                ls(state);\n                for (i = 0, l = args.length; i < l; i++) {\n                    delete state[\"$\" + (i+1)];\n                }\n            };\n        },\n\n\n        _prepareValue: function(value, prop) {\n\n            if (!prop.type) {\n                return value;\n            }\n\n            if (value === true && \n                prop.type !== \"bool\" && \n                prop.type !== \"boolean\" && \n                prop.defaultValue) {\n                value = prop.defaultValue;\n            }\n\n            switch (prop.type) {\n                case 'int':\n                    return parseInt(value);\n                case 'float':\n                case 'number':\n                    return parseFloat(value);\n                case 'bool':\n                case 'boolean':\n                    return toBool(value);\n                case 'array':\n                case 'list':\n                    return !isArray(value) ? [value] : value;\n                case 'string':\n                case 'str':\n                    return value === null || value === undefined ? \"\" : \"\" + value;\n            }\n\n            return value;\n        },\n\n        _onPropMutated: function(val, prev, name) {\n\n            var self = this,\n                prop = self.properties[name],\n                setTo = prop.setTo || self.cfg.setTo,\n                value;\n\n            value = self._prepareValue(val, prop);\n\n            self.values[name] = value;\n            if (setTo) {\n                setTo[name] = value;\n            }\n\n            $$observable.trigger(this.id, name, value, prev);\n            $$observable.trigger(this.id +'-'+ name, value, prev);\n        },\n\n        /**\n         * Set Config's option\n         * @method\n         * @param {string} name \n         * @param {*} value \n         */\n        setOption: function(name, value) {\n            this.cfg[name] = value;\n        },\n\n        /**\n         * Get config's option\n         * @param {string} name \n         * @returns {*}\n         */\n        getOption: function(name) {\n            return this.cfg[name];\n        },\n\n        /**\n         * Add multiple properties to the config.\n         * @param {object} properties {name: {cfg}}\n         * @param {string} scalarAs {\n         *  expression|defaultValue|value -- \n         *  if property comes as scalar value {name: value}, this\n         *  option helps determine what to do with it, make an expression\n         *  out of it, or use as default value.\n         * }\n         * @param {bool} override {\n         *  Override existing settings\n         *  @default true\n         * }\n         */\n        addProperties: function(properties, scalarAs, override) {\n\n\n            var prop, k, val, pb;\n            for (k in properties) {\n                val = properties[k];\n\n                if (val === null || val === undefined) {\n                    continue;\n                }\n\n                if (MetaphorJs.app.prebuilt.isKey(val)) {\n                    pb = MetaphorJs.app.prebuilt.get(\"config\", val);\n                    prop = {\n                        expression: val,\n                        prebuilt: pb\n                    };\n                }\n                // string can be a value or expression\n                else if (typeof val === \"string\") {\n                    prop = {};\n                    prop[scalarAs || \"expression\"] = val;\n                }\n                // bool and int can only be a value\n                else if (isPrimitive(val)) {\n                    prop = {defaultValue: val};\n                }\n                // objects can only describe properties\n                else {\n                    prop = val;\n                    if (prop.expression && \n                        typeof prop.expression === \"string\" && \n                        !prop.mode && scalarAs === \"defaultValue\" && \n                        (!this.properties[k] || !this.properties[k].mode)) {\n                        \n                        prop.mode = MODE_DYNAMIC;\n                    }\n                }\n                this.setProperty(k, prop, undefined, override);\n            }\n        },\n\n        /**\n         * Set or update property\n         * @method\n         * @param {string} name \n         * @param {object} cfg {\n         *  @type {string} type int|float|array|bool|string\n         *  @type {object} setTo\n         *  @type {object} state\n         *  @type {boolean} disabled\n         *  @type {*} defaultValue\n         *  @type {*} value\n         *  @type {int} defaultMode\n         *  @type {int} mode MetaphorJs.lib.Config.MODE_***\n         * }\n         */\n\n        /**\n         * Set or update property\n         * @method\n         * @param {string} name \n         * @param {string} cfg \n         * @param {*} val \n         * @param {bool} override {\n         *  @default true\n         * }\n         */\n        setProperty: function(name, cfg, val, override) {\n\n            var self = this,\n                props = self.properties,\n                prop,\n                changed = false,\n                newProp = false,\n                changes = {},\n                value;\n\n            if (override === undefined) {\n                override = true;\n            }\n\n            if (!props[name]) {\n                props[name] = {};\n                self.keys.push(name);\n                changed = true;\n                newProp = true;\n            }\n\n            if (!cfg) {\n                cfg = {};\n            }\n\n            prop = props[name];\n\n            if (prop.final === true) {\n                return false;\n            }\n\n            if (val === undefined || val === null) {\n                var k;\n\n                for (k in cfg) {\n                    if (k === \"value\") {\n                        value = cfg[k];\n                        continue;\n                    }\n                    else if (prop[k] === undefined || \n                            (cfg[k] !== prop[k] && override)) {\n                        changes[k] = true;\n                        prop[k] = cfg[k];\n                    }\n                }\n            }\n            else {\n                if (cfg === \"value\") {\n                    value = val;\n                }\n                else if (prop[cfg] === undefined || \n                        (prop[cfg] !== val && override)) {\n                    changes[cfg] = true;\n                    prop[cfg] = val;\n                }\n            }\n\n            if (!prop.mode) {\n                if (prop.defaultMode) {\n                    prop.mode = prop.defaultMode;\n                    changed = true;\n                }\n                else if (prop.expression === true || \n                        prop.expression === false) {\n                    prop.mode = MODE_STATIC;\n                    changed = true;\n                }\n                else if (self.cfg.defaultMode) {\n                    prop.mode = self.cfg.defaultMode;\n                    changed = true;\n                }\n                else if (newProp && value !== undefined && value !== null) {\n                    prop.mode = MODE_STATIC;\n                }\n            }\n\n            if (!prop.state) {\n                prop.state = self.cfg.state;\n            }\n\n            if (prop.mode === MODE_DYNAMIC && \n                prop.expression && \n                !prop.mo && \n                !prop.disabled) {\n                self._initMo(name);\n            }\n\n            if (value !== undefined && value !== null) {\n                self.values[name] = value;\n            }\n            else if (self.values[name] !== undefined) {\n                if (changes.mode || changes.expression || (\n                    !prop.mode && changes.defaultMode\n                )) {\n                    delete self.values[name];\n                }\n            }\n        },\n\n        /**\n         * Get property config\n         * @method\n         * @param {string} name \n         * @returns {object}\n         */\n        getProperty: function(name) {\n            return this.properties[name] || null;\n        },\n\n        /**\n         * Create prop definition copy (without mutation observer)\n         * @param {string} name \n         */\n        copyProperty: function(name) {\n            var prop = this.properties[name],\n                cp;\n\n            if (prop) {\n                cp = extend({}, prop, false, false);\n                cp.state = cp.state || this.cfg.state;\n                delete cp['mo'];\n\n                if (cp.mode === MODE_STATIC || \n                    (!cp.mode && cp.defaultMode === cp.mode === MODE_STATIC) ||\n                    (!cp.mode && !cp.defaultMode)) {\n                    if (this.values[name] !== undefined) {\n                        cp.value = this.values[name];\n                    }\n                }\n                return cp;\n            }\n            else return null;\n        },\n\n        /**\n         * Get property mode (or null, if not defined)\n         * @method\n         * @param {string} name \n         * @returns {int|null}\n         */\n        getMode: function(name) {\n            var prop = this.getProperty(name);\n            return prop ? prop.mode || null : null;\n        },\n\n        /**\n         * Get property expression\n         * @method\n         * @param {string} name \n         */\n        getExpression: function(name) {\n            var prop = this.getProperty(name);\n            return prop ? (prop.expression || null) : null;\n        },\n\n        /**\n         * Get all config values\n         * @method\n         * @returns {object}\n         */\n        getAll: function() {\n            var self = this, k, vs = {};\n            for (k in self.properties) {\n                if (!self._isValue(self.values[k])) {\n                    vs[k] = self._calcProperty(k);\n                }\n                else vs[k] = self.values[k];\n            }\n            return vs;\n        },\n\n        _isValue: function(v) {\n            return v !== undefined && \n                    v !== null && \n                    !(typeof v === \"number\" && isNaN(v));\n        },\n\n        /**\n         * Iterate over properties\n         * @method\n         * @param {function} fn {\n         *  @param {string} key\n         *  @param {object} property\n         *  @param {MetaphorJs.lib.Config} self\n         * } \n         * @param {object} context \n         */\n        eachProperty: function(fn, context) {\n            var k, self = this;\n            for (k in self.properties) {\n                fn.call(context, k, self.properties[k], self);\n            }\n        },\n\n        /**\n         * Does this config has a property\n         * @method\n         * @param {string} name \n         * @returns {bool}\n         */\n        hasProperty: function(name) {\n            return !!this.properties[name];\n        },\n\n        /**\n         * Does this config has a property with expression\n         * @method\n         * @param {string} name \n         * @returns {bool}\n         */\n        hasExpression: function(name) {\n            return !!(\n                this.properties[name] && \n                (this.properties[name].expression || this.properties[name].prebuilt)\n            );\n        },\n\n        /**\n         * Does this config has a value for given key\n         * @param {string} name \n         * @returns {bool}\n         */\n        hasValue: function(name) {\n            return this.values[name] !== undefined;\n        },\n\n        /**\n         * Does this config has an expression to calc value or \n         * already calculated value or default value\n         * @method\n         * @param {string} name \n         * @returns {boolean}\n         */\n        has: function(name) {\n            var self = this;\n            return (self._isValue(self.values[name])) || (\n                    self.properties[name] && \n                    (\n                        self.properties[name].defaultValue !== undefined ||\n                        self.properties[name].expression !== undefined || \n                        self.properties[name].prebuilt !== undefined\n                    )\n                );\n        },\n\n        _toggleProperty: function(name, val) {\n            var self = this,\n                prop = self.properties[name],\n                prev = prop ? prop.disabled || false : false;\n\n            if (!prop) {\n                prop = self.setProperty(name, {\n                    disabled: val\n                });\n            }\n            else if (prev !== val) {\n                prop.mode === MODE_DYNAMIC && self[!val ? \"_initMo\" : \"_unsetMo\"](name);\n                prop.disabled = val;\n            }\n        },\n\n        /**\n         * Disable MutationObserver on a property\n         * @method\n         * @param {string} name \n         */\n        disableProperty: function(name) {\n            this._toggleProperty(name, true);\n        },\n\n        /**\n         * Enable MutationObserver on a property\n         * @method\n         * @param {string} name \n         */\n        enableProperty: function(name) {\n            this._toggleProperty(name, false);\n        },\n\n        /**\n         * Remove config property and its value\n         * @param {string} name \n         */\n        removeProperty: function(name) {\n            if (this.properties[name]) {\n                this._toggleProperty(name, true);\n                delete this.properties[name];\n                delete this.values[name];\n                var inx = this.keys.indexOf(name);\n                if (inx !== -1) {\n                    this.keys.splice(inx, 1);\n                }\n            }\n        },\n\n        /**\n         * Set property mode\n         * @method\n         * @param {string} name \n         * @param {int} mode \n         * @param {string|*} expression\n         */\n        setMode: function(name, mode, expression) {\n            var prop = {mode: mode};\n            if (expression !== undefined) {\n                prop.expression = expression;\n            }\n            this.setProperty(name, prop);\n        },\n\n        /**\n         * Set property type\n         * @method\n         * @param {string} name \n         * @param {string} type \n         * @param {int} defaultMode {\n         *  @optional\n         * }\n         * @param {*} defaultValue {\n         *  @optional\n         * }\n         * @param {bool} override {\n         * @default true\n         * }\n         */\n        setType: function(name, type, defaultMode, defaultValue, override) {\n            if (type) {\n                this.setProperty(name, \"type\", type, override);\n            }\n            if (defaultMode) {\n                this.setProperty(name, \"defaultMode\", defaultMode, override);\n            }\n            if (defaultValue !== undefined) {\n                this.setProperty(name, \"defaultValue\", defaultValue, override);\n            }\n        },\n\n        /**\n         * Set default mode\n         * @method\n         * @param {string} name \n         * @param {int} mode \n         * @param {bool} override {\n         * @default true\n         * }\n         */\n        setDefaultMode: function(name, mode, override) {\n            this.setProperty(name, \"defaultMode\", mode, override);\n        },\n\n        /**\n         * Set default value\n         * @method\n         * @param {string} name \n         * @param {*} val \n         * @param {bool} override {\n         * @default true\n         * }\n         */\n        setDefaultValue: function(name, val, override) {\n            this.setProperty(name, \"defaultValue\", val, override);\n        },\n\n        /**\n         * Transform property to dynamic mode if it is static\n         * @param {string} name \n         * @param {string} expression \n         * @param {object|null} state {\n         *  @optional\n         * }\n         */\n        makeLocalDynamic: function(name, expression, state) {\n            var self = this,\n                prop, val;\n            state = state || self.cfg.state;\n            if (prop = self.properties[name]) {\n                if (prop.final) {\n                    return;\n                }\n                if (!prop.mode || prop.mode === MODE_STATIC || prop.mode === MODE_SINGLE) {\n                    val = self.get(name);\n                    self.setProperty(name, {\n                        expression,\n                        mode: MODE_DYNAMIC,\n                        state\n                    });\n                    self.values[name] = val;\n                    self.set(name, val);\n                }\n            }\n            else {\n                self.setProperty(name, {\n                    expression,\n                    mode: MODE_DYNAMIC,\n                    state\n                });\n            }\n        },\n\n        /**\n         * Force property to static mode with given value\n         * @param {string} name \n         * @param {*} val \n         */\n        setStatic: function(name, val) {\n            var self = this;\n            if (self.properties[name] && self.properties[name].final) {\n                return;\n            }\n            var prev = self.values[val];\n            self.setMode(name, MODE_STATIC);\n            self.values[name] = val;\n            if (prev != val) {\n                $$observable.trigger(self.id, name, val, prev);\n                $$observable.trigger(self.id +'-'+ name, val, prev) ;\n            }\n        },\n\n        /**\n         * Lock the property\n         * @param {string} name \n         */\n        setFinal: function(name) {\n            this.setProperty(name, \"final\", true);\n        },\n\n        /**\n         * Try to set value based on property mode\n         * @param {string} name \n         * @param {*} val \n         */\n        set: function(name, val) {\n            var self = this,\n                prop;\n            if (!self.properties[name]) {\n                self.setProperty(name);\n            }\n            prop = self.properties[name];\n            switch (prop.mode) {\n                case MODE_DYNAMIC: {\n                    !prop.mo && self._initMo(name);\n                    prop.mo.setValue(val);\n                    break;\n                }\n                case MODE_GETTER:\n                case MODE_FUNC:\n                case MODE_SETTER:\n                case MODE_FNSET: {\n                    throw new Error(\"Incompatible property mode\");\n                }\n                case MODE_SINGLE:\n                case MODE_STATIC: {\n                    self.setStatic(name, val);\n                    break;\n                }\n                default: {\n                    self.setStatic(name, val);\n                    break;\n                }\n            }\n        },\n\n        /**\n         * Get property keys\n         * @method\n         * @returns {array}\n         */\n        getKeys: function() {\n            return this.keys;\n        },\n\n        /**\n         * Get all keys starting with \"value\"\n         * @method\n         */\n        getAllValues: function() {\n            var self = this,\n                i, l, k, name,\n                vs = {};\n\n            for (i = 0, l = self.keys.length; i < l; i++) {\n                k = self.keys[i];\n                if (k === \"value\") {\n                    name = \"\";\n                }\n                else if (k.indexOf(\"value.\") === 0) {\n                    name = k.replace(\"value.\", \"\");\n                }\n                else continue;\n                vs[name] = self.get(k);\n            }\n\n            return vs;\n        },\n\n        /**\n         * Get property value\n         * @method\n         * @param {string} name \n         * @returns {*}\n         */\n        get: function(name) {\n            if (!this._isValue(this.values[name])) {\n                return this._calcProperty(name);\n            }\n            return this.values[name];\n        },\n\n        /**\n         * @method on\n         * @param {string} name \n         * @param {function} fn {\n         *  @param {*} currentValue\n         *  @param {*} prevValue\n         * }\n         * @param {object} context fn's context\n         * @param {object} opt MetaphorJs.lib.Observable.on() options\n         */\n\n         /**\n         * @method on\n         * @param {function} fn {\n         *  @param {string} name\n         *  @param {*} currentValue\n         *  @param {*} prevValue\n         * }\n         * @param {object} context fn's context\n         * @param {object} opt MetaphorJs.lib.Observable.on() options\n         */\n        on: function(name, fn, context, opt) {\n            if (typeof name === \"string\") {\n                $$observable.on(this.id +'-'+ name, fn, context, opt);\n            }\n            else {\n                $$observable.on(this.id, name, fn, context);\n            }\n        },\n\n        /**\n         * @method un\n         * @param {string} name \n         * @param {function} fn\n         * @param {object} context \n         */\n\n         /**\n         * @method un\n         * @param {function} fn \n         * @param {object} context \n         */\n        un: function(name, fn, context) {\n            if (typeof name === \"string\") {\n                $$observable.on(this.id +'-'+ name, fn, context);\n            }\n            else {\n                $$observable.on(this.id, name, fn);\n            }\n        },\n\n        /**\n         * Set property values to this object\n         * @method\n         * @param {object} obj \n         */\n        setTo: function(obj) {\n            this.cfg.setTo = obj;\n        },\n\n        /**\n         * Import properties and values from another config\n         * @method\n         * @param {MetaphorJs.lib.Config} config \n         */\n        importConfig: function(config, overwrite) {\n            var name,\n                ps = this.properties,\n                vs = this.values;\n\n            for (name in config.properties) {\n                if (config.properties.hasOwnProperty(name)) {\n\n                    if (ps[name] && !overwrite) {\n                        continue;\n                    }\n                    ps[name] = extend({}, config.properties[name]);\n                    vs[name] = config.values[name];\n                }\n            }\n        },\n\n        /**\n         * Create a new config with given properties\n         * @method\n         * @param {array} props\n         * @param {object} cfg override new config cfg with these values\n         * @returns MetaphorJs.lib.Config\n         */\n        slice: function(props, overrideCfg) {\n            var map = {}, self = this, \n                name, i, l,\n                values = {},\n                existing = self.properties;\n            for (i = 0, l = props.length; i < l; i++) {\n                name = props[i];\n                if (existing[name]) {\n                    map[name] = extend({}, existing[name], false, false);\n                    values[name] = self.values[name];\n                    delete map[name].mo;\n                }\n            }\n            var newCfg = new Config(\n                map,\n                extend({}, self.cfg, overrideCfg, true, false)\n            );\n            newCfg.values = values;\n            return newCfg;\n        },\n\n        /**\n         * Check for changes of specific property\n         * @method\n         * @param {string} name \n         * @returns {bool}\n         */\n\n        /**\n         * Check for changes\n         * @method\n         * @returns {int} number of changed properties\n         */\n        check: function(name) {\n            var self = this,\n                keys = name ? [name] : self.keys,\n                i, l, key, prop,\n                res = name ? 0 : false;\n\n            for (i = 0, l = keys.length; i < l; i++) {\n                key = keys[i];\n                prop = self.properties[key];\n                if (prop.mo) {\n                    if (name) {\n                        return prop.mo.check();\n                    }\n                    res += prop.mo.check() ? 1 : 0;\n                }\n            }\n\n            return res;\n        },\n\n        /**\n         * Check state based on property opts \n         * (does it require checking parent or root)\n         * @method\n         * @param {string} propName \n         */\n        checkState: function(propName) {\n\n            const prop = this.properties[propName];\n\n            if (!prop) {\n                return;\n            }\n\n            const   state = prop.state || this.cfg.state,\n                    descr = prop.prebuilt ? \n                            (prop.prebuilt.descr||\"\") : \n                            MetaphorJs.lib.Expression.describeExpression(\n                                this.getExpression(propName)\n                            );\n\n            if (descr.indexOf(\"r\") !== -1) {\n                return state.$root.$check();\n            }\n            else if (descr.indexOf(\"p\") !== -1) {\n                return state.$parent ? \n                        state.$parent.$check() : \n                        state.$root.$check();\n            }\n            else {\n                return state.$check();\n            }\n        },\n\n        /**\n         * Stop all observers, clear data, remove listeners.\n         * But keep values and properties\n         * @method\n         */\n        clear: function() {\n            var self = this,\n            id = self.id,\n            k;\n\n            if (self.properties === null) {\n                return;\n            }\n\n            for (k in self.properties) {\n                self._unsetMo(k);\n                $$observable.destroyEvent(id +'-'+ k);\n            }\n\n            $$observable.destroyEvent(id);\n\n            self.subscribe = emptyFn;\n            self.unsubscribe = emptyFn;\n        },\n\n        /**\n         * @method\n         * @returns {bool}\n         */\n        $isDestroyed: function() {\n            return this.properties === null;\n        },\n\n        /**\n         * @method\n         */\n        $destroy: function() {\n            var self = this;\n\n            if (self.properties !== null) {\n                self.clear();\n            }\n\n            self.properties = null;\n            self.values = null;\n            self.cfg = null;\n        }\n    });\n\n    /**\n     * @property MetaphorJs.lib.Config.MODE_STATIC\n     * @static\n     * Do not calculate value, use whatever provided or default value\n     */\n    Config.MODE_STATIC = MODE_STATIC;\n\n    /**\n     * @property MetaphorJs.lib.Config.MODE_DYNAMIC\n     * @static\n     * Calculate value and watch for changes\n     */\n    Config.MODE_DYNAMIC = MODE_DYNAMIC;\n\n    /**\n     * @property MetaphorJs.lib.Config.MODE_SINGLE\n     * @static\n     * Calculate value once \n     */\n    Config.MODE_SINGLE = MODE_SINGLE;\n\n    /**\n     * @property MetaphorJs.lib.Config.MODE_GETTER\n     * @static\n     * Treat value as expression, return a function that executes expression\n     * that returns value\n     */\n    Config.MODE_GETTER = MODE_GETTER;\n\n    /**\n     * @property MetaphorJs.lib.Config.MODE_SETTER\n     * @static\n     * Treat value as expression, return a setter function that executes expression\n     * that sets value\n     */\n    Config.MODE_SETTER = MODE_SETTER;\n\n    /**\n     * @property MetaphorJs.lib.Config.MODE_FUNC\n     * @static\n     * Treat value as expression, return a function that executes expression\n     */\n    Config.MODE_FUNC = MODE_FUNC;\n\n    /**\n     * @property MetaphorJs.lib.Config.MODE_FNSET\n     * @static\n     * Treat value as expression, return an object with\n     * both setter and getter functions\n     */\n    Config.MODE_FNSET = MODE_FNSET;\n\n    /**\n     * @property MetaphorJs.lib.Config.MODE_LISTENER\n     * @static\n     * Treat value as expression. If expression is a reference to a function, \n     * return this function. Else, return a wrapper function that is executed\n     * in current state (config's or property's) and has all passed arguments\n     * as this.$1, this.$2, etc.\n     */\n    Config.MODE_LISTENER = MODE_LISTENER;\n\n\n    Config.create = function(properties, cfg, scalarAs) {\n        if (properties instanceof Config) {\n            return properties;\n        }\n        return new Config(properties, cfg, scalarAs);\n    }\n\n    return Config;\n\n}());","\nconst returnFalse = require(\"metaphorjs-shared/src/func/returnFalse.js\"),\n    returnTrue = require(\"metaphorjs-shared/src/func/returnTrue.js\"),\n    isNull = require(\"metaphorjs-shared/src/func/isNull.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n// from jQuery\n\n/**\n * Dom event wrapper.\n * @class MetaphorJs.lib.DomEvent\n */\n\n/**\n * @method DomEvent\n * @constructor\n * @param {Event} src Native event\n */\nmodule.exports = MetaphorJs.lib.DomEvent = function(){\n\nvar DomEvent = function DomEvent(src) {\n\n    if (src instanceof DomEvent) {\n        return src;\n    }\n\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof DomEvent)) {\n        return new DomEvent(src);\n    }\n\n\n    var self    = this;\n\n    for (var i in src) {\n        if (!self[i]) {\n            try {\n                self[i] = src[i];\n            }\n            catch (thrownError){}\n        }\n    }\n\n\n    // Event object\n    self.originalEvent = src;\n    self.type = src.type;\n\n    if (!self.target && src.srcElement) {\n        self.target = src.srcElement;\n    }\n\n\n    var eventDoc, doc, body,\n        button = src.button;\n\n    // Calculate pageX/Y if missing and clientX/Y available\n    if (self.pageX === undefined && !isNull(src.clientX)) {\n        eventDoc = self.target ? self.target.ownerDocument || window.document : window.document;\n        doc = eventDoc.documentElement;\n        body = eventDoc.body;\n\n        self.pageX = src.clientX +\n                      ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -\n                      ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n        self.pageY = src.clientY +\n                      ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -\n                      ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n    }\n\n    // Add which for click: 1 === left; 2 === middle; 3 === right\n    // Note: button is not normalized, so don't use it\n    if ( !self.which && button !== undefined ) {\n        self.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n    }\n\n    // Events bubbling up the document may have been marked as prevented\n    // by a handler lower down the tree; reflect the correct value.\n    self.isDefaultPrevented = src.defaultPrevented ||\n                              src.defaultPrevented === undefined &&\n                                  // Support: Android<4.0\n                              src.returnValue === false ?\n                              returnTrue :\n                              returnFalse;\n\n\n    // Create a timestamp if incoming event doesn't have one\n    self.timeStamp = src && src.timeStamp || (new Date).getTime();\n};\n\n// Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\nextend(DomEvent.prototype, {\n\n    /**\n     * @method isDefaultPrevented\n     * @returns {boolean}\n     */\n    isDefaultPrevented: returnFalse,\n\n    /**\n     * @method isPropagationStopped\n     * @returns {boolean}\n     */\n    isPropagationStopped: returnFalse,\n\n    /**\n     * @method isImmediatePropagationStopped\n     * @returns {boolean}\n     */\n    isImmediatePropagationStopped: returnFalse,\n\n    /**\n     * @method\n     */\n    preventDefault: function() {\n        var e = this.originalEvent;\n\n        this.isDefaultPrevented = returnTrue;\n        e.returnValue = false;\n\n        if ( e && e.preventDefault ) {\n            e.preventDefault();\n        }\n    },\n\n    /**\n     * @method\n     */\n    stopPropagation: function() {\n        var e = this.originalEvent;\n\n        this.isPropagationStopped = returnTrue;\n        e.cancelBubble = true;\n\n        if ( e && e.stopPropagation ) {\n            e.stopPropagation();\n        }\n    },\n\n    /**\n     * @method\n     */\n    stopImmediatePropagation: function() {\n        var e = this.originalEvent;\n\n        this.isImmediatePropagationStopped = returnTrue;\n\n        if ( e && e.stopImmediatePropagation ) {\n            e.stopImmediatePropagation();\n        }\n\n        this.stopPropagation();\n    }\n}, true, false);\n\nreturn DomEvent;\n\n}();","require(\"metaphorjs-observable/src/lib/Observable.js\");\nrequire(\"../func/dom/addListener.js\");\nrequire(\"../func/dom/removeListener.js\");\nrequire(\"../func/dom/getWidth.js\");\nrequire(\"../func/dom/getHeight.js\");\nrequire(\"../func/dom/getScrollTop.js\");\nrequire(\"../func/dom/getScrollLeft.js\");\n\nconst bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    raf = require(\"metaphorjs-animate/src/func/raf.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Allows you to subscribe to a dom event and call handler\n * no sooner than given interval;<br>\n * Also you can subscribe to a specific change: like media query in css.\n * @class MetaphorJs.lib.EventBuffer\n */\nmodule.exports = MetaphorJs.lib.EventBuffer = function(){\n\n    var bufferKey = function(event, interval) {\n        return '$$' + event + \"_\" + interval;\n    };\n\n    /**\n     * @method EventBuffer\n     * @constructor\n     * @param {HTMLElement} node \n     * @param {string} event Dom event name\n     * @param {int} interval \n     * @param {object} eventOptions\n     */\n    var EventBuffer = function(node, event, interval, eventOpts) {\n\n        var self = this,\n            key = bufferKey(event, interval);\n\n        if (node[key]) {\n            return node[key];\n        }\n\n        node[key] = self;\n\n        self.eventOptions = eventOpts || {};\n        self.id = key;\n        self.breaks = {};\n        self.watchers = {};\n        self.node = node;\n        self.event = event;\n        self.observable = new MetaphorJs.lib.Observable;\n        self.interval = interval || 0;\n        self.handlerDelegate = bind(self.handler, self);\n        self.triggerDelegate = bind(self.trigger, self);\n\n        self.up();\n    };\n\n    extend(EventBuffer.prototype, {\n\n        observable: null,\n        handlerDelegate: null,\n        triggerDelegate: null,\n        watchers: null,\n        breaks: null,\n        running: false,\n        lastEvent: null,\n        currentEvent: null,\n        interval: null,\n        id: null,\n\n        handler: function(e) {\n            var self = this;\n            if (self.running) {\n                if (e) {\n                    self.lastEvent = e;\n                }\n            }\n            else {\n                self.next(e);\n            }\n        },\n\n        next: function(e) {\n\n            var self = this,\n                itv = self.interval;\n\n            e = e || self.lastEvent;\n\n            if (!e) {\n                return;\n            }\n\n            self.lastEvent = null;\n            self.running = true;\n            self.currentEvent = e;\n\n            if (itv === \"raf\") {\n                raf(self.triggerDelegate);\n            }\n            else {\n                setTimeout(self.triggerDelegate, itv);\n            }\n        },\n\n        /**\n         * Shorthand for adding width watcher\n         * @method\n         */\n        watchWidth: function() {\n            this.addWatcher(\"width\", MetaphorJs.dom.getWidth);\n        },\n\n        /**\n         * Shorthand for adding height watcher\n         * @method\n         */\n        watchHeight: function() {\n            this.addWatcher(\"height\", MetaphorJs.dom.getHeight);\n        },\n\n        /**\n         * Shorthand for adding scrolltop watcher\n         * @method\n         */\n        watchScrollTop: function() {\n            this.addWatcher(\"scrollTop\", MetaphorJs.dom.getScrollTop);\n        },\n\n        /**\n         * Shorthand for adding scrollleft watcher\n         * @method\n         */\n        watchScrollLeft: function() {\n            this.addWatcher(\"scrollLeft\", MetaphorJs.dom.getScrollLeft);\n        },\n\n        /**\n         * Add your own watcher\n         * @method\n         * @param {string} name Watcher name\n         * @param {function} fn {\n         *  @param {HTMLElement} node\n         * }\n         * @param {object} context fn's context\n         */\n        addWatcher: function(name, fn, context) {\n            if (!this.watchers[name]) {\n                this.watchers[name] = {\n                    fn:      fn,\n                    context: context,\n                    prev:    null,\n                    current: parseInt(fn.call(context, this.node), 10)\n                };\n            }\n        },\n\n        /**\n         * Remove watcher\n         * @method\n         * @param {string} name\n         */\n        removeWatcher: function(name) {\n            delete this.watchers[name];\n        },\n\n        breakFilter: function(l, args, event) {\n\n            if (!this.watchers[event.watcher]) {\n                return false;\n            }\n\n            var self        = this,\n                breakValue  = l.breakValue,\n                luft        = l.breakLuft || 0,\n                lowLuft     = l.breakLowLuft || luft,\n                highLuft    = l.breakHighLuft || luft,\n                lowBreak    = breakValue - lowLuft,\n                highBreak   = breakValue + highLuft,\n                w           = self.watchers[event.watcher],\n                current     = w.current,\n                prev        = w.prev,\n                min         = Math.min(prev, current),\n                max         = Math.max(prev, current);\n\n            if (breakValue === \"!=\") {\n                return prev != current;\n            }\n\n            args[0].breakPosition = current < lowBreak ? -1 :  (current >= highBreak ? 1 : 0);\n\n            return (min <= lowBreak && lowBreak <= max) ||\n                    (min <= highBreak && highBreak <= max);\n        },\n\n\n        /**\n         * Add break listener (media query stop)\n         * @method\n         * @param {string} watcher Watcher name\n         * @param {int} breakValue \n         * @param {function} fn {\n         *  Listener function\n         *  @param {Event} event Native dom event\n         * }\n         * @param {object} context fn's context\n         * @param {object} options Options are passed to \n         * MetaphorJs.lib.Observable.on()\n         */\n        onBreak: function(watcher, breakValue, fn, context, options) {\n            var self = this,\n                name = watcher + \"_\" + breakValue;\n\n            options = options || {};\n            options.breakValue = breakValue;\n\n            if (!self.breaks[name]) {\n                self.breaks[name] = self.observable.createEvent(name, {\n                    watcher: watcher,\n                    triggerFilter: self.breakFilter,\n                    filterContext: self\n                });\n            }\n\n            self.breaks[name].on(fn, context, options);\n        },\n\n        /**\n         * Unsubscribe from a break\n         * @method\n         * @param {string} watcher Watcher name\n         * @param {int} breakValue \n         * @param {function} fn\n         * @param {object} context fn's context\n         * @param {boolean} destroy Destroy if there are no more listeners\n         */\n        unBreak: function(watcher, breakValue, fn, context, destroy) {\n            var self = this,\n                name = watcher + \"_\" + breakValue;\n            if (self.breaks[name]) {\n                self.breaks[name].un(fn, context);\n                if (!self.breaks[name].hasListener()) {\n                    self.observable.destroyEvent(name);\n                    self.breaks[name] = null;\n                    delete self.breaks[name];\n                }\n            }\n            if (destroy) {\n                self.destroyIfIdle();\n            }\n        },\n\n        /**\n         * Subscribe to dom event\n         * @method\n         * @param {function} fn {\n         *  @param {Event} event \n         * }\n         * @param {object} context fn's context\n         * @param {object} options Observable's options\n         */\n        on: function(fn, context, options) {\n            this.observable.on(this.event, fn, context, options);\n        },\n\n        /**\n         * Ubsubscribe from dom event\n         * @method\n         * @param {function} fn \n         * @param {object} context fn's context\n         * @param {boolean} destroy Destroy if there are no more listeners\n         */\n        un: function(fn, context, destroy) {\n            var self = this;\n            self.observable.un(self.event, fn, context);\n            if (destroy) {\n                self.destroyIfIdle();\n            }\n        },\n\n        trigger: function() {\n            var self = this,\n                e = self.currentEvent,\n                ws = self.watchers,\n                bs = self.breaks,\n                node = self.node,\n                w, b;\n\n            self.observable.trigger(self.event, e);\n\n            for (w in ws) {\n                ws[w].prev = ws[w].current;\n                ws[w].current = parseInt(ws[w].fn.call(ws[w].context, node, e), 10);\n            }\n\n            for (b in bs) {\n                bs[b].trigger(e);\n            }\n\n            self.running = false;\n            self.currentEvent = null;\n\n            self.next();\n        },\n\n        /**\n         * Start listening to DOM event. (Called automatically from constructor)\n         * @method\n         */\n        up: function() {\n            var self = this;\n            MetaphorJs.dom.addListener(\n                self.node, self.event, \n                self.handlerDelegate,\n                self.eventOptions\n            );\n        },\n\n        /**\n         * Stop listening to DOM event\n         * @method\n         */\n        down: function() {\n            var self = this;\n            MetaphorJs.dom.removeListener(self.node, self.event, self.handlerDelegate);\n        },\n\n        /**\n         * Destroy if there are no listeners\n         * @method\n         */\n        destroyIfIdle: function() {\n            if (this.observable && !this.observable.hasListener()) {\n                this.$destroy();\n                return true;\n            }\n        },\n\n        /**\n         * @method\n         */\n        $destroy: function() {\n\n            var self = this;\n\n            delete self.node[self.id];\n\n            self.down();\n            self.observable.$destroy();\n\n        }\n    });\n\n\n    /**\n     * Get existing event buffer\n     * @method get\n     * @static\n     * @param {HTMLElement} node \n     * @param {string} event \n     * @param {int} interval \n     * @param {object} eventOptions\n     * @returns {MetaphorJs.lib.EventBuffer}\n     */\n    EventBuffer.get = function(node, event, interval, eventOpts) {\n        var key = bufferKey(event, interval);\n\n        if (node[key]) {\n            return node[key];\n        }\n\n        return node[key] = new EventBuffer(node, event, interval, eventOpts);\n    \n    };\n\n    return EventBuffer;\n}();\n\n","\nrequire(\"../func/dom/addListener.js\");\nrequire(\"../func/dom/removeListener.js\");\nrequire(\"../func/dom/normalizeEvent.js\");\nrequire(\"../func/dom/is.js\");\nrequire(\"./EventBuffer.js\");\nrequire(\"./Expression.js\");\nrequire(\"./MutationObserver.js\");\n\nconst extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    async = require(\"metaphorjs-shared/src/func/async.js\"),\n    isPlainObject = require(\"metaphorjs-shared/src/func/isPlainObject.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n/**\n * Handles events as they come defined in html templates\n * @class MetaphorJs.lib.EventHandler\n */\n\n/**\n * @method EventHandler\n * @constructor\n * @param {string} event Dom event name\n * @param {MetaphorJs.lib.State} state \n * @param {HTMLElement} node \n * @param {MetaphorJs.lib.Config} cfg MetaphorJs.lib.Config\n */\nMetaphorJs.lib.EventHandler = function(event, state, node, cfg) {\n\n    var self = this;\n\n    self.config     = cfg;\n    self.event      = event;\n    self.prevEvent  = {};\n    self.state      = state;\n    self.node       = node;\n    self.handler    = null;\n    self.buffer     = null;\n\n    if (cfg.hasExpression(\"if\")) {\n        cfg.on(\"if\", self.onIfChange, self);\n    }\n\n    self.up();\n};\n\nextend(MetaphorJs.lib.EventHandler.prototype, {\n\n    $destroyed: false,\n    $destroying: false,\n\n    onIfChange: function(val) {\n        this[val?\"up\":\"down\"]();\n    },\n\n    createHandler: function() {\n\n        var self        = this,\n            state       = self.state,\n            config      = self.config,\n            asnc;\n\n        var handler = function(e) {\n\n            if (self.$destroyed || self.$destroying) {\n                return;\n            }\n\n            var keyCode,\n                preventDefault = false,\n                returnValue = undefined,\n                stopPropagation = false,\n                stopImmediate = false,\n                res,\n                cfg = config.getAll(),\n                not = cfg.not,\n                handlers = [],\n                names = [],\n                skipHandler = false,\n                handler, i, l;\n\n            config.eachProperty(function(name){\n                if (name.indexOf(\"value\") === 0) {\n                    handlers.push(config.get(name));\n                    names.push(name);\n                }\n            });\n\n            cfg.preventDefault !== undefined && (preventDefault = cfg.preventDefault);\n            cfg.stopPropagation !== undefined && (stopPropagation = cfg.stopPropagation);\n            cfg.stopImmediatePropagation !== undefined && \n                (stopImmediate = cfg.stopImmediatePropagation);\n            cfg.returnValue !== undefined && (returnValue = cfg.returnValue);\n            cfg.keyCode !== undefined && (keyCode = cfg.keyCode);\n\n            e = MetaphorJs.dom.normalizeEvent(e || window.event);\n\n            if (not) {\n                if (!isArray(not)) {\n                    not = [not];\n                }\n                var prnt;\n                nt:\n                for (i = 0, l = not.length; i < l; i++) {\n                    prnt = e.target;\n                    while (prnt && prnt !== self.node) {\n                        if (MetaphorJs.dom.is(prnt, not[i])) {\n                            skipHandler = true;\n                            break nt;\n                        }\n                        prnt = prnt.parentNode;\n                    }\n                }\n            }\n\n            if (keyCode) {\n                if (typeof keyCode === \"number\" && keyCode !== e.keyCode) {\n                    return null;\n                }\n                else if (keyCode.indexOf(e.keyCode) === -1) {\n                    return null;\n                }\n            }\n\n            state.$event = e;\n            state.$eventNode = self.node;\n            state.$prevEvent = self.prevEvent[e.type];\n            state.$eventCmp = config.get(\"targetComponent\");\n\n            if (!skipHandler && handlers.length > 0) {\n                for (i = 0, l = handlers.length; i < l; i++) {\n                    handler = handlers[i];\n                    res = handler.call(cfg.context || null, state);\n\n                    if (res && isPlainObject(res)) {\n                        res.preventDefault !== undefined && \n                            (preventDefault = res.preventDefault);\n                        res.stopPropagation !== undefined && \n                            (stopPropagation = res.stopPropagation);\n                        res.returnValue !== undefined && \n                            (returnValue = res.returnValue);\n                    }\n                }\n            }\n\n            stopPropagation && e.stopPropagation();\n            stopImmediate && e.stopImmediatePropagation && e.stopImmediatePropagation();\n            preventDefault && e.preventDefault();\n\n            if (self.$destroyed || self.$destroying) {\n                return returnValue !== undefined ? returnValue : undefined;\n            }\n\n            state.$event = null;\n            state.$eventNode = null;\n            state.$eventCmp = null;\n\n            self.prevEvent[e.type] = e;\n\n            for (i = 0, l = names.length; i < l; i++) {\n                config.checkState(names[i]);\n            }\n\n            if (returnValue !== undefined) {\n                return returnValue;\n            }\n        };\n\n        if (asnc = self.config.get(\"async\")) {\n            return function(e) {\n                async(handler, null, [e], \n                        typeof asnc == \"number\" ? asnc : null);\n            };\n        }\n        else {\n            return handler;\n        }\n    },\n\n    /**\n     * Start listening to event\n     * @method\n     */\n    up: function() {\n\n        var self    = this,\n            cfg     = self.config,\n            buffer  = cfg.get(\"buffer\");\n\n        if (!cfg.hasExpression(\"if\") || cfg.get('if')) {\n            self.handler = self.createHandler();\n\n            if (buffer) {\n                self.buffer = MetaphorJs.lib.EventBuffer.get(\n                    self.node, self.event, buffer,\n                    self._getEventConfig()\n                );\n                self.buffer.on(self.handler);\n            }\n            else {\n                MetaphorJs.dom.addListener(\n                    self.node, \n                    self.event, \n                    self.handler,\n                    self._getEventConfig()\n                );\n            }\n        }\n    },\n\n    /**\n     * Stop listening to event\n     * @method\n     */\n    down: function() {\n\n        var self    = this;\n\n        if (self.buffer) {\n            self.buffer.un(self.handler);\n            self.buffer.destroyIfIdle();\n            self.buffer = null;\n        }\n        else {\n            MetaphorJs.dom.removeListener(self.node, self.event, self.handler);\n        }\n    },\n\n    _getEventConfig: function() {\n        var opts = {};\n        if (this.config.hasExpression(\"passive\")) {\n            opts.passive = this.config.get(\"passive\");\n        }\n        return opts;\n    },\n\n    /**\n     * @method\n     */\n    $destroy: function() {\n        var self = this;\n        if (self.$destroyed || self.$destroying) {\n            return;\n        }\n        self.$destroying = true;\n        self.down();\n        self.config.clear();\n        self.$destroying = false;\n        self.$destroyed = true;\n    }\n});\n\nmodule.exports = MetaphorJs.lib.EventHandler;","\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    error = require(\"metaphorjs-shared/src/func/error.js\"),\n    isFunction = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    isString = require(\"metaphorjs-shared/src/func/isString.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    emptyFn = require(\"metaphorjs-shared/src/func/emptyFn.js\"),\n    split = require(\"metaphorjs-shared/src/func/split.js\");\n\nrequire(\"../filter/__init.js\");\n\nmodule.exports = MetaphorJs.lib.Expression = (function () {\n\n    var REG_REPLACE_EXPR = /((^|[^a-z0-9_$\\]\\)'\"])|(this))(\\.)([^0-9])/ig,\n        REG_REPLACER = \"$2____.$5\",\n        fnBodyStart = '',\n        fnBodyEnd = '',\n        //fnBodyStart = 'try {',\n        //fnBodyEnd = ';} catch (thrownError) { ' +\n            //'/*DEBUG-START*/console.log(\"expr\");console.log(thrownError);/*DEBUG-END*/' +\n            //'return undefined; }',\n        cache = {},\n        cacheEnabled = true,\n        descrCache = {},\n        filterSources = [],\n\n        isPrebuiltKey = function (expr) {\n            return typeof expr === \"string\" && expr.substring(0, 2) === '--';\n        },\n\n        isAtom = function (expr) {\n            return !expr.trim().match(/[^a-zA-Z0-9_$'\"\\(\\)\\[\\]\\.;]/);\n        },\n\n        isProperty = function (expr) {\n            var match = expr.match(/^this\\.([a-zA-Z0-9_$]+)$/);\n            return match ? match[1] : false;\n        },\n\n        isStatic = function (val) {\n\n            if (!isString(val)) {\n                return {\n                    value: val\n                };\n            }\n\n            var first = val.substr(0, 1),\n                last = val.length - 1,\n                num;\n\n            if (first === '\"' || first === \"'\") {\n                if (val.indexOf(first, 1) === last) {\n                    return { \n                        value: val.substring(1, last) \n                    };\n                }\n            }\n            else if (val === 'true' || val === 'false') {\n                return { value: val === 'true' };\n            }\n            else if ((num = parseFloat(val)) == val) {\n                return { value: num };\n            }\n\n            return false;\n        },\n\n        getFilter = function (name, filters) {\n            if (filters) {\n                if (isArray(filters)) {\n                    filters = filters.concat(filterSources);\n                }\n                else if (filters.hasOwnProperty(name) &&\n                    typeof (filters[name]) === \"function\") {\n                    return filters[name];\n                }\n                else {\n                    filters = filterSources;\n                }\n            }\n            else {\n                filters = filterSources;\n            }\n            var i, l = filters.length;\n            for (i = 0; i < l; i++) {\n                if (filters[i] && filters[i].hasOwnProperty(name)) {\n                    return filters[i][name];\n                }\n            }\n\n            return null;\n        },\n\n\n        expression = function (expr, opt) {\n            opt = opt || {};\n\n            if (typeof opt === \"string\" && opt === \"setter\") {\n                opt = {\n                    setter: true\n                };\n            }\n\n            if (!cacheEnabled) {\n                cache = {};\n            }\n\n            var asCode = opt.asCode === true,\n                isSetter = opt.setter === true,\n                noReturn = opt.noReturn === true,\n                cacheKey;\n\n            if (isStatic(expr)) {\n\n                cacheKey = expr + \"_static\";\n                noReturn && (cacheKey += \"_noret\");\n\n                if (cache[cacheKey] && !asCode) {\n                    return cache[cacheKey];\n                }\n\n                if (isSetter) {\n                    throw new Error(\"Static value cannot work as setter\");\n                }\n\n                if (asCode) {\n                    return \"\".concat(\n                        \"function() {\",\n                        \"return \",\n                        expr,\n                        \"}\"\n                    );\n                }\n\n                //expr = expr.replace(/\\\\([\\s\\S])|(\")/g,\"\\\\$1$2\")\n                return cache[cacheKey] = new Function(\"\", \"return \" + expr);\n            }\n            try {\n\n                var atom = isAtom(expr);\n                cacheKey = expr + \"_\" + (\n                    isSetter ? \"setter\" :\n                        (noReturn ? \"func\" : \"getter\")\n                );\n                noReturn && (cacheKey += \"_noret\");\n\n                if (!atom && isSetter) {\n                    throw new Error(\"Complex expression cannot work as setter\");\n                }\n\n                if (!cache[cacheKey] || asCode) {\n\n                    var code = expr.replace(REG_REPLACE_EXPR, REG_REPLACER),\n                        body =\n                            !atom || !isSetter ?\n                                \"\".concat(\n                                    fnBodyStart,\n                                    noReturn ? '' : 'return ',\n                                    code,\n                                    fnBodyEnd\n                                ) :\n                                \"\".concat(\n                                    fnBodyStart,\n                                    //noReturn ? '' : 'return ', \n                                    code, ' = $$$$',\n                                    fnBodyEnd\n                                );\n\n                    /*DEBUG-START*/\n                    var esc = expr.replace(/\\n/g, '\\\\n');\n                    esc = esc.replace(/\\r/g, '\\\\r');\n                    esc = esc.replace(/'/g, \"\\\\'\");\n                    esc = esc.replace(/\"/g, '\\\\\"');\n                    body = body.replace('\"expr\"', '\"' + esc + '\"');\n                    /*DEBUG-END*/\n\n                    if (asCode) {\n                        return \"function(____, $$$$) {\" + body + \"}\";\n                    }\n                    else {\n                        cache[cacheKey] = new Function(\n                            '____',\n                            '$$$$',\n                            body\n                        );\n                    }\n                }\n                return cache[cacheKey];\n            }\n            catch (thrownError) {\n                error(new Error(\"Error parsing expression: \" + expr + \"; \\n\\n\\n\" + body));\n                error(thrownError);\n                return emptyFn;\n            }\n        },\n\n        preparePipe = function (pipe, filters) {\n\n            var name = pipe.shift(),\n                fn = isFunction(name) ? name : null,\n                params = [],\n                exprs = [],\n                fchar = fn ? null : name.substr(0, 1),\n                opt = {\n                    neg: false,\n                    dblneg: false,\n                    undeterm: false,\n                    name: name\n                },\n                i, l;\n\n            if (!fn) {\n                if (name.substr(0, 2) === \"!!\") {\n                    name = name.substr(2);\n                    opt.dblneg = true;\n                }\n                else {\n                    if (fchar === \"!\") {\n                        name = name.substr(1);\n                        opt.neg = true;\n                    }\n                    else if (fchar === \"?\") {\n                        name = name.substr(1);\n                        opt.undeterm = true;\n                    }\n                }\n\n                opt.name = name;\n            }\n            else {\n                opt.name = fn.name;\n            }\n\n            !fn && (fn = getFilter(name, filters));\n\n            if (isFunction(fn)) {\n\n                for (i = -1, l = pipe.length; ++i < l;\n                    params.push(expressionFn(pipe[i]))) {\n                    if (!isStatic(pipe[i])) {\n                        exprs.push(pipe[i]);\n                    }\n                }\n\n                if (fn.$undeterministic) {\n                    opt.undeterm = true;\n                }\n\n                return {\n                    fn: fn,\n                    origArgs: pipe,\n                    params: params,\n                    expressions: exprs,\n                    opt: opt\n                };\n            }\n\n            return null;\n        },\n\n        parsePipes = function (expr, isInput, filters) {\n\n            var separator = isInput ? \">>\" : \"|\";\n\n            if (expr.indexOf(separator) === -1) {\n                return expr;\n            }\n\n            var parts = split(expr, separator),\n                ret = isInput ? parts.pop() : parts.shift(),\n                pipes = [],\n                pipe,\n                i, l;\n\n            for (i = 0, l = parts.length; i < l; i++) {\n                pipe = split(parts[i].trim(), ':');\n                pipe = preparePipe(pipe, filters);\n                pipe && pipes.push(pipe);\n            }\n\n            return {\n                expr: ret.trim(),\n                pipes: pipes\n            }\n        },\n\n\n        _initSetter = function (struct) {\n            struct.setterFn = expressionFn(struct.expr, {\n                setter: true\n            });\n        },\n\n        deconstructor = function (expr, opt) {\n\n            opt = opt || {};\n\n            var isNormalPipe = expr.indexOf(\"|\") !== -1,\n                isInputPipe = expr.indexOf(\">>\") !== -1,\n                res,\n                struct = {\n                    fn: null,\n                    getterFn: null,\n                    setterFn: null,\n                    expr: expr,\n                    pipes: [],\n                    inputPipes: []\n                };\n\n            if (!isNormalPipe && !isInputPipe && opt.setter !== true) {\n                struct[opt.noReturn ? \"fn\" : \"getterFn\"] = expressionFn(expr, opt);\n                return struct;\n            }\n\n            if (isNormalPipe) {\n                res = parsePipes(expr, false, opt.filters);\n                expr = res.expr;\n                struct.pipes = res.pipes;\n            }\n\n            if (isInputPipe) {\n                res = parsePipes(expr, true, opt.filters);\n                expr = res.expr;\n                struct.inputPipes = res.pipes;\n                opt.setter = true;\n            }\n\n            if (opt.setter === true) {\n                struct.setterFn = expressionFn(expr, opt);\n                opt.setter = false;\n            }\n\n            struct[opt.noReturn ? \"fn\" : \"getterFn\"] = expressionFn(expr, opt);\n            return struct;\n        },\n\n        runThroughPipes = function (val, pipes, dataObj) {\n            var j,\n                args,\n                pipe,\n\n                jlen = pipes.length,\n                z, zl;\n\n            for (j = 0; j < jlen; j++) {\n                pipe = pipes[j];\n                !pipe.fn && pipe.opt.name && (pipe.fn = getFilter(pipe.opt.name));\n                args = [];\n                for (z = -1, zl = pipe.params.length; ++z < zl;\n                    args.push(pipe.params[z](dataObj))) { }\n\n                args.unshift(dataObj);\n                args.unshift(val);\n\n                val = pipe.fn.apply(dataObj, args);\n\n                if (pipe.opt.neg) {\n                    val = !val;\n                }\n                else if (pipe.opt.dblneg) {\n                    val = !!val;\n                }\n            }\n\n            return val;\n        },\n\n\n        constructor = function (struct, opt) {\n\n            opt = opt || {};\n\n            if (struct.pipes.length === 0 &&\n                struct.inputPipes.length === 0) {\n                if (opt.setterOnly) {\n                    !struct.setterFn && _initSetter(struct);\n                    return struct.setterFn;\n                }\n                return struct.getterFn || struct.fn;\n            }\n\n            return function (dataObj, inputVal) {\n\n                var val;\n\n                if (struct.inputPipes.length && !opt.getterOnly) {\n                    val = inputVal;\n                    val = runThroughPipes(val, struct.inputPipes, dataObj);\n                    !struct.setterFn && _initSetter(struct);\n                    struct.setterFn(dataObj, val);\n                }\n\n                if (struct.pipes && !opt.setterOnly) {\n                    val = struct.getterFn(dataObj);\n                    val = runThroughPipes(val, struct.pipes, dataObj);\n                }\n\n                return val;\n            };\n        },\n\n        expressionFn,\n        parserFn,\n        deconstructorFn,\n        constructorFn,\n\n        parser = function (expr, opt) {\n            return constructorFn(\n                typeof expr === \"string\" ? deconstructorFn(expr, opt) : expr, \n                opt\n            );\n        },\n\n        reset = function () {\n            parserFn = parser;\n            deconstructorFn = deconstructor;\n            constructorFn = constructor;\n            expressionFn = expression;\n        };\n\n\n    if (MetaphorJs.filter) {\n        filterSources.push(MetaphorJs.filter)\n    }\n    if (typeof window !== \"undefined\") {\n        filterSources.push(window);\n    }\n    \n\n    reset();\n\n    /**\n     * @object MetaphorJs.expression\n     */\n    return {\n\n        /**\n         * Set your code parser\n         * @property {function} setExpressionFn {\n         *  @param {function} expression {\n         *      @param {string} expression A single piece of code that \n         *              gets or sets data and doesn't contain pipes\n         *      @param {object} options {\n         *          @type {boolean} asCode return code as string\n         *      }\n         *      @returns {function} {\n         *          @param {object} dataObj Data object to execute expression against\n         *          @param {*} value Optional value which makes function a setter\n         *          @returns {*} value of expression on data object\n         *      }\n         *  }\n         * }\n         */\n        setExpressionFn: function (expression) {\n            expressionFn = expression;\n        },\n\n        /**\n         * Get expression parser\n         * @property {function} getExpressionFn {\n         *  @returns {function} See setExpressionFn\n         * }\n         */\n        getExpressionFn: function () {\n            return expressionFn;\n        },\n\n        /**\n         * Set deconstructor function that returns set of prepared pipes\n         * @property {function} setDeconstructorFn {\n         *  @param {function} deconstructor {\n         *      @param {string} expression\n         *      @param {object} filters {\n         *          Optional set of filters (pipes)\n         *      }\n         *      @returns {object} {\n         *          @type {function} expr {\n         *              @param {object} dataObj Data object to execute expression against\n         *              @param {*} value Optional value which makes function a setter\n         *              @returns {*} value of expression on data object\n         *          }\n         *          @type {array} pipes {\n         *              @type {function} fn {\n         *                  Filter function\n         *                  @param {*} inputValue\n         *                  @param {object} dataObj \n         *                  @param {...} argN pipe arguments\n         *                  @returns {*} processed input value\n         *              }\n         *              @type {array} origArgs List of strings describing the pipe\n         *              @type {array} params {\n         *                  @param {object} dataObj\n         *                  @returns {*} pipe argument value\n         *              }\n         *              @type {object} opt {\n         *                  Pipe options\n         *                  @type {boolean} neg Return !value\n         *                  @type {boolean} dblneg Return !!value\n         *                  @type {boolean} undeterm This pipe's result is undetermined\n         *                  @type {string} name Filter name\n         *              }\n         *          }\n         *          @type {array} inputPipes same as pipes\n         *      }\n         *  }\n         * }\n         */\n        setDeconstructorFn: function (deconstructor) {\n            deconstructorFn = deconstructor;\n        },\n\n        /**\n         * @property {function} getDeconstructorFn {\n         *  @returns {function} See setDeconstructorFn\n         * }\n         */\n        getDeconstructorFn: function () {\n            return deconstructorFn;\n        },\n\n        /**\n         * @property {function} setConstructorFn {\n         *  Takes result of <code>deconstructor</code> and \n         *  returns function with the same api as <code>expression</code>\n         *  @param {function} constructor {\n         *      @param {object} struct As returned from deconstructorFn\n         *      @param {object} opt {\n         *          @type {boolean} getterOnly\n         *          @type {boolean} setterOnly\n         *      }\n         *      @returns {function} Same that expressionFn and parserFn returns\n         *  }\n         * }\n         */\n        setConstructorFn: function (constructor) {\n            constructorFn = constructor;\n        },\n\n        /**\n         * @property {function} getConstructorFn {\n         *  @returns {function}\n         * }\n         */\n        getConstructorFn: function () {\n            return constructorFn;\n        },\n\n        /**\n         * @property {function} setParserFn {\n         *  @param {function} parser {\n         *      @param {string} expression Code expression with or without pipes\n         *      @returns {function} {\n         *          @param {object} dataObj Data object to execute expression against\n         *          @param {*} value Optional value which makes function a setter\n         *          @returns {*} value of expression on data object\n         *      }\n         *  }\n         * }\n         */\n        setParserFn: function (parser) {\n            parserFn = parser;\n        },\n\n        /**\n         * @property {function} getParserFn {\n         *  @returns {function} See setParserFn\n         * }\n         */\n        getParserFn: function () {\n            return parserFn;\n        },\n\n        /**\n         * Add filters collection\n         * @param {object} filters {\n         *  name:function collection of filters (pipes)\n         * }\n         */\n        addFilterSource: function (filters) {\n            filterSources.push(filters);\n        },\n\n        /**\n         * Reset to default parser\n         * @property {function} reset\n         */\n        reset: reset,\n\n        /**\n         * Get executable function out of code string (no pipes)\n         * @property {function} expression\n         * @param {string} expr \n         * @param {object|string} opt See <code>parse</code>\n         * @returns {function} {\n         *  @param {object} dataObj Data object to execute expression against\n         *  @param {*} value Optional value which makes function a setter\n         *  @returns {*} value of expression on data object\n         * }\n         */\n        expression: function (expr, opt) {\n            return expressionFn(expr, opt);\n        },\n\n        /**\n         * @property {function} deconstruct {\n         *  See setDeconstructorFn\n         *  @param {string} expr \n         *  @param {object|string} opt See <code>parse</code>\n         *  @returns {function} \n         * }\n         */\n        deconstruct: function (expr, opt) {\n            return deconstructorFn(expr, opt);\n        },\n\n        /**\n         * Get a expression function out of deconstructed parts\n         * @property {function} construct {\n         *  @param {object} struct Result of <code>deconstruct(expr)</code>\n         *  @param {object} opt {\n         *      @type {boolean} setterOnly\n         *      @type {boolean} getterOnly\n         *  }\n         *  @returns {function} {\n         *      @param {object} dataObj Data object to execute expression against\n         *      @param {*} value Optional value which makes function a setter\n         *      @returns {*} value of expression on data object\n         * }\n         * }\n         */\n        construct: function (struct, opt) {\n            return constructorFn(struct, opt);\n        },\n\n        /**\n         * @property {function} parse {\n         *  See setParserFn\n         *  @param {string} expr \n         *  @param {object|string} opt {\n         *      @type {object} filters\n         *      @type {boolean} setter {    \n         *          @default false\n         *      }\n         *  }\n         *  @returns {function}\n         * }\n         */\n        parse: function (expr, opt) {\n            return parserFn(expr, opt);\n        },\n\n        /**\n         * @property {function} func {\n         *  @param {string} expr \n         *  @param {object} opt {\n         *      @type {boolean} noReturn {    \n         *          @default true\n         *      }\n         *  }\n         *  @returns {function}\n         * }\n         */\n        func: function (expr, opt) {\n            opt = opt || {};\n            opt.noReturn = true;\n            opt.getterOnly = true;\n            return parserFn(expr, opt);\n        },\n\n        /**\n         * @property {function} setter {\n         *  @param {string} expr \n         *  @param {object} opt {\n         *      @type {boolean} setter {    \n         *          @default true\n         *      }\n         *  }\n         *  @returns {function}\n         * }\n         */\n        setter: function (expr, opt) {\n            opt = opt || {};\n            opt.setter = true;\n            opt.setterOnly = true;\n            return parserFn(expr, opt);\n        },\n\n        /**\n         * @property {function} getter {\n         *  @param {string} expr \n         *  @param {object} opt {\n         *      @type {boolean} setter {    \n         *          @default false\n         *      }\n         *      @type {boolean} getterOnly {\n         *          @default true\n         *      }\n         *  }\n         *  @returns {function}\n         * }\n         */\n        getter: function (expr, opt) {\n            opt = opt || {};\n            opt.setter = false;\n            opt.getterOnly = true;\n            return parserFn(expr, opt);\n        },\n\n        /**\n         * Execute code on given data object\n         * @property {function} run\n         * @param {string} expr \n         * @param {object} dataObj \n         * @param {*} inputValue\n         * @param {object} opt See <code>parse</code>\n         */\n        run: function (expr, dataObj, inputValue, opt) {\n            opt = opt || {};\n            opt.noReturn = true;\n            parserFn(expr, opt)(dataObj, inputValue);\n        },\n\n        /**\n         * Execute code on given data object\n         * @property {function} run\n         * @param {string} expr \n         * @param {object} dataObj \n         * @param {*} inputValue\n         * @param {object} opt See <code>parse</code>\n         */\n        get: function (expr, dataObj, inputValue, opt) {\n            opt = opt || {};\n            opt.getterOnly = true;\n            return parserFn(expr, opt)(dataObj, inputValue);\n        },\n\n        /**\n         * Execute code on given data object as a setter\n         * @property {function} run\n         * @param {string} expr \n         * @param {object} dataObj \n         * @param {*} inputValue\n         * @param {object} opt See <code>parse</code>\n         */\n        set: function (expr, dataObj, inputValue, opt) {\n            opt = opt || {};\n            opt.setter = true;\n            opt.setterOnly = true;\n            return parserFn(expr, opt)(dataObj, inputValue);\n        },\n\n\n\n        /**\n         * Check if given expression is a static string or number\n         * @property {function} isStatic\n         * @param {string} expr\n         * @returns {boolean|object} {  \n         *  Static value can be 0 or false, so it must be returned contained.<br>\n         *  So it is either false or ret.value\n         *  @type {*} value \n         * }\n         */\n        isStatic: isStatic,\n\n        /**\n         * Checks if given expression is simple getter (no function or operations)\n         * @property {function} isAtom {\n         *  @param {string} expr\n         *  @returns {boolean}\n         * }\n         */\n        isAtom: isAtom,\n\n        /**\n         * Checks if given expression is a property getter\n         * @property {function} isProperty {\n         *  @param {string} expr \n         *  @returns {string|boolean} property name or false\n         * }\n         */\n        isProperty: isProperty,\n\n        /**\n         * Is this a key in prebuilt cache\n         * @property {function} isPrebuiltKey {\n         *  @param {string} key\n         *  @returns {boolean}\n         * }\n         */\n        isPrebuiltKey: isPrebuiltKey,\n\n        /**\n         * Does the expression has pipes\n         * @property {function} expressionHasPipes {\n         *  @param {string} expr\n         *  @returns {boolean}\n         * }\n         */\n        expressionHasPipes: function (expr) {\n            return split(expr, '|').length > 1 ||\n                split(expr, '>>').length > 1;\n        },\n\n        /**\n         * Get a small string containing expression features:\n         * p: updates parent, r: updates root, i: has input pipes,\n         * o: has output pipes\n         * @property {function} describeExpression {\n         *  @param {string} expr \n         *  @returns {string}\n         * }\n         */\n        describeExpression: function (expr) {\n\n            if (!expr || typeof expr !== \"string\")\n                return \"\";\n\n            if (!cacheEnabled) {\n                descrCache = {};\n            }\n\n            if (descrCache[expr]) {\n                return descrCache[expr];\n            }\n\n            var descr = \"\" +\n                (expr.indexOf(\"$parent\") !== -1 ? \"p\" : \"\") +\n                (expr.indexOf(\"$root\") !== -1 ? \"r\" : \"\") +\n                (split(expr, '|').length > 1 ? \"o\" : \"\") +\n                (split(expr, '>>').length > 1 ? \"i\" : \"\");\n\n            descrCache[expr] = descr;\n\n            return descr;\n        },\n\n        /**\n         * Clear expressions cache\n         * @property {function} clearCache\n         */\n        clearCache: function () {\n            cache = {};\n        },\n\n        disableCache: function() {\n\n        },\n\n        enableCache: function() {\n\n        }\n    }\n}());\n","\nrequire(\"metaphorjs-observable/src/lib/Observable.js\");\nrequire(\"../func/dom/getAttr.js\");\nrequire(\"../func/dom/addListener.js\");\nrequire(\"../func/dom/normalizeEvent.js\");\nrequire(\"metaphorjs-shared/src/func/browser/parseLocation.js\");\nrequire(\"metaphorjs-shared/src/func/browser/joinLocation.js\");\n\nconst extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    emptyFn = require(\"metaphorjs-shared/src/func/emptyFn.js\"),\n    async = require(\"metaphorjs-shared/src/func/async.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nmodule.exports = MetaphorJs.lib.History = function() {\n\n    var win,\n        history,\n        location,\n        observable      = new MetaphorJs.lib.Observable,\n        api             = {},\n        programId       = nextUid(),\n        stateKeyId      = \"$$\" + programId,\n        currentId       = nextUid(),\n\n        hashIdReg       = new RegExp(\"#\" + programId + \"=([A-Z0-9]+)\"),\n\n        pushState,\n        replaceState,\n\n        windowLoaded    = typeof window == \"undefined\",\n\n        prevLocation    = null,\n\n        pushStateSupported,\n        hashChangeSupported,\n        useHash;\n\n\n    observable.createEvent(\"before-location-change\", false);\n    observable.createEvent(\"void-click\", false);\n\n    var initWindow = function() {\n        win                 = window;\n        history             = win.history;\n        location            = win.location;\n        pushStateSupported  = !!history.pushState;\n        hashChangeSupported = \"onhashchange\" in win;\n        useHash             = false; //pushStateSupported && (navigator.vendor || \"\").match(/Opera/);\n        prevLocation        = extend({}, location, true, false);\n    };\n\n    var preparePushState = function(state) {\n        state = state || {};\n        if (!state[stateKeyId]) {\n            state[stateKeyId] = nextUid();\n        }\n        currentId = state[stateKeyId];\n\n        return state;\n    };\n\n    var prepareReplaceState = function(state) {\n        state = state || {};\n        if (!state[stateKeyId]) {\n            state[stateKeyId] = currentId;\n        }\n        return state;\n    };\n\n\n    var hostsDiffer = function(prev, next) {\n\n        if (typeof prev == \"string\") {\n            prev = MetaphorJs.browser.parseLocation(prev);\n        }\n        if (typeof next == \"string\") {\n            next = MetaphorJs.browser.parseLocation(next);\n        }\n\n        var canBeEmpty = [\"protocol\", \"host\", \"port\"],\n            i, l,\n            k;\n\n        for (i = 0, l = canBeEmpty.length; i < l; i++) {\n            k = canBeEmpty[i];\n            if (prev[k] && next[k] && prev[k] != next[k]) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    var pathsDiffer = function(prev, next) {\n\n        if (typeof prev == \"string\") {\n            prev = MetaphorJs.browser.parseLocation(prev);\n        }\n        if (typeof next == \"string\") {\n            next = MetaphorJs.browser.parseLocation(next);\n        }\n\n        return hostsDiffer(prev, next) || prev.pathname != next.pathname ||\n            prev.search != next.search || prev.hash != next.hash;\n    };\n\n\n\n\n\n\n\n\n\n    var preparePath = function(url) {\n\n        var loc = MetaphorJs.browser.parseLocation(url);\n\n        if (!pushStateSupported || useHash) {\n            return loc.path;\n        }\n\n        return MetaphorJs.browser.joinLocation(loc, {onlyPath: true});\n    };\n\n\n\n\n\n\n    var getCurrentStateId = function() {\n\n\n        if (pushStateSupported) {\n            return history.state ? history.state[stateKeyId] : null;\n        }\n        else {\n            return parseOutHashStateId(location.hash).id;\n        }\n\n    };\n\n    var parseOutHashStateId = function(hash) {\n\n        var id = null;\n\n        hash = hash.replace(hashIdReg, function(match, idMatch){\n            id = idMatch;\n            return \"\";\n        });\n\n        return {\n            hash: hash,\n            id: id\n        };\n    };\n\n    var setHash = function(hash, state) {\n\n        if (hash) {\n            if (hash.substr(0,1) != '#') {\n                hash = parseOutHashStateId(hash).hash;\n                hash = \"!\" + hash + \"#\" + programId + \"=\" + currentId;\n            }\n            location.hash = hash;\n        }\n        else {\n            location.hash = \"\";\n        }\n    };\n\n    var getCurrentUrl = function() {\n        var loc,\n            tmp;\n\n        if (pushStateSupported) {\n            //loc = location.pathname + location.search + location.hash;\n            loc = MetaphorJs.browser.joinLocation(location);\n        }\n        else {\n            loc = location.hash.substr(1);\n            tmp = extend({}, location, true, false);\n\n            if (loc) {\n\n                loc = parseOutHashStateId(loc).hash;\n\n                if (loc.substr(0, 1) == \"!\") {\n                    loc = loc.substr(1);\n                }\n                var p = decodeURIComponent(loc).split(\"?\");\n                tmp.pathname = p[0];\n                tmp.search = p[1] ? \"?\" + p[1] : \"\";\n            }\n\n            loc = MetaphorJs.browser.joinLocation(tmp);\n        }\n\n        return loc;\n    };\n\n\n    var onLocationPush = function(url) {\n        prevLocation = extend({}, location, true, false);\n        triggerEvent(\"location-change\", url);\n    };\n\n    var onLocationPop = function() {\n        if (pathsDiffer(prevLocation, location)) {\n\n            var url     = getCurrentUrl(),\n                state   = history.state || {};\n\n            triggerEvent(\"before-location-pop\", url);\n\n            currentId       = getCurrentStateId();\n            prevLocation    = extend({}, location, true, false);\n\n            triggerEvent(\"location-change\", url);\n        }\n    };\n\n    var triggerEvent = function triggerEvent(event, data, anchor) {\n        var url     = data || getCurrentUrl(),\n            loc     = MetaphorJs.browser.parseLocation(url),\n            path    = loc.pathname + loc.search + loc.hash;\n        return observable.trigger(event, path, anchor, url);\n    };\n\n    var init = function() {\n\n        initWindow();\n\n        // normal pushState\n        if (pushStateSupported) {\n\n            //history.origPushState       = history.pushState;\n            //history.origReplaceState    = history.replaceState;\n\n            MetaphorJs.dom.addListener(win, \"popstate\", onLocationPop);\n\n            pushState = function(url, anchor, state) {\n                if (triggerEvent(\"before-location-change\", url, anchor) === false) {\n                    return false;\n                }\n                history.pushState(preparePushState(state), null, preparePath(url));\n                onLocationPush(url);\n            };\n\n\n            replaceState = function(url, anchor, state) {\n                history.replaceState(prepareReplaceState(state), null, preparePath(url));\n                onLocationPush(url);\n            };\n\n            async(function(){\n                replaceState(getCurrentUrl());\n            });\n        }\n        else {\n\n            // onhashchange\n            if (hashChangeSupported) {\n\n                pushState = function(url, anchor, state) {\n                    if (triggerEvent(\"before-location-change\", url, anchor) === false) {\n                        return false;\n                    }\n                    async(setHash, null, [preparePath(url), preparePushState(state)]);\n                };\n\n                replaceState = function(url, anchor, state) {\n                    async(setHash, null, [preparePath(url), prepareReplaceState(state)]);\n                };\n\n                MetaphorJs.dom.addListener(win, \"hashchange\", onLocationPop);\n            }\n            // iframe\n            else {\n                /*\n                var frame   = null,\n                    initialUpdate = false;\n\n                var createFrame = function() {\n                    frame   = window.document.createElement(\"iframe\");\n                    frame.src = 'about:blank';\n                    frame.style.display = 'none';\n                    window.document.body.appendChild(frame);\n                };\n\n                win.onIframeHistoryChange = function(val) {\n                    if (!initialUpdate) {\n                        async(function(){\n                            setHash(val);\n                            onLocationPop();\n                        });\n                    }\n                };\n\n                var pushFrame = function(value) {\n                    var frameDoc;\n                    if (frame.contentDocument) {\n                        frameDoc = frame.contentDocument;\n                    }\n                    else {\n                        frameDoc = frame.contentWindow.document;\n                    }\n                    frameDoc.open();\n                    //update iframe content to force new history record.\n                    frameDoc.write('<html><head><title>' + document.title +\n                                   '</title><script type=\"text/javascript\">' +\n                                   'var hashValue = \"'+value+'\";'+\n                                   'window.top.onIframeHistoryChange(hashValue);' +\n                                   '</script>' +\n                                   '</head><body>&nbsp;</body></html>'\n                    );\n                    frameDoc.close();\n                };\n\n                var replaceFrame = function(value) {\n                    frame.contentWindow.hashValue = value;\n                };\n\n\n                pushState = function(url, anchor, state) {\n                    if (triggerEvent(\"before-location-change\", url, anchor) === false) {\n                        return false;\n                    }\n                    pushFrame(preparePath(url));\n                };\n\n                replaceState = function(url, anchor, state) {\n                    if (triggerEvent(\"before-location-change\", url, anchor) === false) {\n                        return false;\n                    }\n                    replaceFrame(preparePath(url));\n                };\n\n                var initFrame = function(){\n                    createFrame();\n                    initialUpdate = true;\n                    pushFrame(preparePath(location.hash.substr(1)));\n                    initialUpdate = false;\n                };\n\n                if (windowLoaded) {\n                    initFrame();\n                }\n                else {\n                    MetaphorJs.dom.addListener(win, \"load\", initFrame);\n                }\n                */\n            }\n        }\n\n        MetaphorJs.dom.addListener(window.document.documentElement, \"click\", function(e) {\n\n            e = MetaphorJs.dom.normalizeEvent(e || win.event);\n\n            var a = e.target,\n                href;\n\n            while (a && a.nodeName.toLowerCase() != \"a\") {\n                a = a.parentNode;\n            }\n\n            if (a && !e.isDefaultPrevented()) {\n\n                href = MetaphorJs.dom.getAttr(a, \"href\");\n\n                if (href == \"#\") {\n\n                    var res = observable.trigger(\"void-click\", a);\n\n                    if (!res) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                        return false;\n                    }\n                }\n\n                if (href && href.substr(0,1) != \"#\" && !MetaphorJs.dom.getAttr(a, \"target\")) {\n\n                    var prev = extend({}, location, true, false),\n                        next = MetaphorJs.browser.parseLocation(href);\n\n                    if (hostsDiffer(prev, next)) {\n                        return null;\n                    }\n\n                    if (pathsDiffer(prev, next)) {\n                        pushState(href, a);\n                    }\n                    else {\n                        triggerEvent(\"same-location\", null, a);\n                    }\n\n                    e.preventDefault();\n                    e.stopPropagation();\n                    return false;\n                }\n            }\n\n            return null;\n        });\n\n        init = emptyFn;\n    };\n\n\n    MetaphorJs.dom.addListener(window, \"load\", function() {\n        windowLoaded = true;\n    });\n\n\n    /**\n     * Browser pushState wrapper and polyfill. \n     * @object MetaphorJs.lib.History\n     */\n    return extend(api, {\n\n        /**\n         * @property {function} on {\n         * @param {string} event\n         * @param {function} listener \n         * @param {object} callback context\n         * @param {object} options\n         * }\n         */\n        on: function() {\n            return observable.on.apply(observable, arguments);\n        },\n\n        /**\n         * @property {function} un {\n         * @param {string} event\n         * @param {function} listener \n         * @param {object} callback context\n         * }\n         */\n        un: function() {\n            return observable.un.apply(observable, arguments);\n        },\n\n        /**\n         * @property {function} once {\n         * @param {string} event\n         * @param {function} listener \n         * @param {object} callback context\n         * }\n         */\n        once: function() {\n            return observable.once.apply(observable, arguments);\n        },\n\n        /**\n         * @property {function} push {\n         *  Push new url\n         *  @param {string} url\n         *  @param {object} state\n         * }\n         */\n        push: function(url, state) {\n            init();\n\n            var prev = extend({}, location, true, false),\n                next = MetaphorJs.browser.parseLocation(url);\n\n            if (hostsDiffer(prev, next)) {\n                return null;\n            }\n\n            if (pathsDiffer(prev, next)) {\n                pushState(url, null, state);\n            }\n        },\n\n        /**\n         * @property {function} replace {\n         *  Replace current url with another url\n         *  @param {string} url\n         *  @param {object} state\n         * }\n         */\n        replace: function(url, state) {\n            init();\n            var prev = extend({}, location, true, false),\n                next = MetaphorJs.browser.parseLocation(url);\n\n            if (hostsDiffer(prev, next)) {\n                return null;\n            }\n\n            if (pathsDiffer(prev, next)) {\n                replaceState(url, null, state);\n            }\n        },\n\n        /**\n         * Update state of current url\n         * @property {function} saveState {\n         *  @param {object} state\n         * }\n         */\n        saveState: function(state) {\n            init();\n            replaceState(getCurrentUrl(), null, state);\n        },\n\n        /**\n         * Merge new state into current state \n         * @property {function} mergeState {\n         *  @param {object} state\n         * }\n         */\n        mergeState: function(state) {\n            this.saveState(extend({}, history.state, state, true, false));\n        },\n\n        /**\n         * Get current state\n         * @property {function} getState {\n         *  @returns {object}\n         * }\n         */\n        getState: function() {\n            return history.state;\n        },\n\n        /**\n         * Get current instance id\n         * @property {functrion} getCurrentStateId {\n         *  @returns {string}\n         * }\n         */\n        getCurrentStateId: function() {\n            return currentId;\n        },\n\n        /**\n         * Get current url\n         * @property {function} current {\n         *  @returns {string} url\n         * }\n         */\n        current: function() {\n            init();\n            return getCurrentUrl();\n        },\n\n        /**\n         * Initialize instance \n         * @property {function} init\n         */\n        init: function() {\n            return init();\n        },\n\n        /**\n         * Polyfill window.pushState and replaceState\n         * @property {function} polyfill\n         */\n        polyfill: function() {\n            init();\n            window.history.pushState = function(state, title, url) {\n                pushState(url, null, state);\n            };\n            window.history.replaceState = function(state, title, url) {\n                replaceState(url, null, state);\n            };\n        }\n    });\n\n}();\n","\nrequire(\"metaphorjs-observable/src/lib/Observable.js\");\nrequire(\"../func/dom/getInputValue.js\");\nrequire(\"../func/dom/setInputValue.js\");\nrequire(\"../func/dom/addListener.js\");\nrequire(\"../func/dom/removeListener.js\");\nrequire(\"../func/dom/isAttached.js\");\nrequire(\"../func/browser/isAndroid.js\");\nrequire(\"../func/browser/hasEvent.js\");\nrequire(\"../func/dom/getAttr.js\");\nrequire(\"../func/dom/normalizeEvent.js\");\nrequire(\"../func/dom/select.js\");\n\nconst bind    = require(\"metaphorjs-shared/src/func/bind.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.lib.Input = function(){\n\nvar observable = new MetaphorJs.lib.Observable,\n    id = 0;\n\n/**\n * @class MetaphorJs.lib.Input\n * \n * @constructor\n * @param {Node} el \n * @param {function} changeFn \n * @param {object} changeFnContext \n * @param {object} cfg \n */\nvar Input = function(el, changeFn, changeFnContext, cfg) {\n\n    if (el.$$input) {\n        if (changeFn) {\n            el.$$input.on(\"change\", changeFn, changeFnContext);\n        }\n        return el.$$input;\n    }\n\n    var self    = this;\n\n    cfg = cfg || {};\n\n    //self.observable     = new MetaphorJs.lib.Observable;\n    self.el             = el;\n    self.id             = ++id;\n    self.inputType      = el.type ? el.type.toLowerCase() : \"none\";\n    self.dataType       = cfg.type || MetaphorJs.dom.getAttr(el, \"data-type\") || self.inputType;\n    self.listeners      = [];\n\n    if (changeFn) {\n        self.on(\"change\", changeFn, changeFnContext);\n    }\n};\n\nextend(Input.prototype, {\n\n    el: null,\n    inputType: null,\n    dataType: null,\n    listeners: null,\n    radio: null,\n    keydownDelegate: null,\n    changeInitialized: false,\n\n    /**\n     * @method\n     */\n    $destroy: function() {\n\n        var self        = this,\n            i;\n\n        //self.observable.$destroy();\n        observable.destroyEvent(\"change-\" + self.id);\n        observable.destroyEvent(\"key-\" + self.id);\n        self._addOrRemoveListeners(MetaphorJs.dom.removeListener, true);\n\n        self.el.$$input = null;\n\n        for (i in self) {\n            if (self.hasOwnProperty(i)) {\n                self[i] = null;\n            }\n        }\n    },\n\n    _addOrRemoveListeners: function(fn, onlyUsed) {\n\n        var self        = this,\n            type        = self.inputType,\n            listeners   = self.listeners,\n            radio       = self.radio,\n            el          = self.el,\n            used,\n            i, ilen,\n            j, jlen;\n\n        for (i = 0, ilen = listeners.length; i < ilen; i++) {\n\n            used = !!listeners[i][2];\n\n            if (used === onlyUsed) {\n                if (type === \"radio\") {\n                    for (j = 0, jlen = radio.length; j < jlen; j++) {\n                        fn(radio[j], listeners[i][0], listeners[i][1]);\n                    }\n                }\n                else {\n                    fn(el, listeners[i][0], listeners[i][1]);\n                }\n                listeners[i][2] = !onlyUsed;\n            }\n        }\n    },\n\n    initInputChange: function() {\n\n        var self = this,\n            type = self.inputType;\n\n        if (type === \"radio\") {\n            self.initRadioInput();\n        }\n        else if (type === \"checkbox\") {\n            self.initCheckboxInput();\n        }\n        else {\n            self.initTextInput();\n        }\n\n        self._addOrRemoveListeners(MetaphorJs.dom.addListener, false);\n\n        self.changeInitialized = true;\n    },\n\n    initRadioInput: function() {\n\n        var self    = this,\n            el      = self.el,\n            name    = el.name,\n            parent;\n\n        if (MetaphorJs.dom.isAttached(el)) {\n            parent  = el.ownerDocument;\n        }\n        else {\n            parent = el;\n            while (parent.parentNode) {\n                parent = parent.parentNode;\n            }\n        }\n\n        self.radio  = MetaphorJs.dom.select(\"input[name=\"+name+\"]\", parent);\n\n        self.onRadioInputChangeDelegate = bind(self.onRadioInputChange, self);\n        self.listeners.push([\"click\", self.onRadioInputChangeDelegate, false]);\n    },\n\n    initCheckboxInput: function() {\n\n        var self    = this;\n\n        self.clicked = false;\n\n        self.onCheckboxInputChangeDelegate = bind(self.onCheckboxInputChange, self);\n        self.onCheckboxInputClickDelegate = bind(self.onCheckboxInputClick, self);\n        self.listeners.push([\"click\", self.onCheckboxInputClickDelegate, false]);\n        self.listeners.push([\"change\", self.onCheckboxInputChangeDelegate, false]);\n    },\n\n    initTextInput: function() {\n\n        var composing   = false,\n            self        = this,\n            listeners   = self.listeners,\n            timeout;\n\n        // In composition mode, users are still inputing intermediate text buffer,\n        // hold the listener until composition is done.\n        // More about composition events:\n        // https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent\n        if (!MetaphorJs.browser.isAndroid() && self.inputType !== \"none\") {\n\n            var compositionStart    = function() {\n                composing = true;\n            };\n\n            var compositionEnd  = function() {\n                composing = false;\n                listener();\n            };\n\n            listeners.push([\"compositionstart\", compositionStart, false]);\n            listeners.push([\"compositionend\", compositionEnd, false]);\n        }\n\n        var listener = self.onTextInputChangeDelegate = function(ev) {\n            if (composing) {\n                return;\n            }\n            self.onTextInputChange(ev);\n        };\n\n        var deferListener = function(ev) {\n            if (!timeout) {\n                timeout = setTimeout(function() {\n                    listener(ev);\n                    timeout = null;\n                }, 0);\n            }\n        };\n\n        var keydown = function(event) {\n            event = event || window.event;\n            var key = event.keyCode;\n\n            // ignore\n            //    command            modifiers                   arrows\n            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) {\n                return;\n            }\n\n            deferListener(event);\n        };\n\n        // if the browser does support \"input\" event, we are fine - except on\n        // IE9 which doesn't fire the\n        // input event on backspace, delete or cut\n        if (MetaphorJs.browser.hasEvent('input') && self.inputType !== \"none\") {\n\n            listeners.push([\"input\", listener, false]);\n\n        } else {\n\n            listeners.push([\"keydown\", keydown, false]);\n\n            // if user modifies input value using context menu in IE,\n            // we need \"paste\" and \"cut\" events to catch it\n            if (MetaphorJs.browser.hasEvent('paste') && self.inputType !== \"none\") {\n                listeners.push([\"paste\", deferListener, false]);\n                listeners.push([\"cut\", deferListener, false]);\n            }\n        }\n\n\n        // if user paste into input using mouse on older browser\n        // or form autocomplete on newer browser, we need \"change\" event to catch it\n\n        if (self.inputType !== \"none\") {\n            listeners.push([\"change\", listener, false]);\n        }\n    },\n\n    processValue: function(val) {\n\n        switch (this.dataType) {\n            case \"number\":\n            case \"float\":\n            case \"double\":\n                if (val === \"\" || isNaN(val = parseFloat(val))) {\n                    val = undefined;\n                }\n                break;\n            case \"int\":\n            case \"integer\":\n                if (val === \"\" || isNaN(val = parseInt(val, 10))) {\n                    val = undefined;\n                }\n                break;\n            case \"bool\":\n            case \"boolean\":\n                return !(val === \"false\" || val === \"0\" || val === 0 ||\n                        val === \"off\" || val === false || val === \"\");\n\n        }\n\n        return val;\n    },\n\n    onTextInputChange: function(ev) {\n\n        var self    = this,\n            val     = self.getValue();\n\n        observable.trigger(\"change-\"+self.id, self.processValue(val));\n    },\n\n\n    _checkboxChange: function() {\n        var self    = this,\n            node    = self.el;\n\n        observable.trigger(\"change-\"+self.id, self.processValue(\n            node.checked ? (MetaphorJs.dom.getAttr(node, \"value\") || true) : false)\n        );\n    },\n\n    onCheckboxInputChange: function() {\n        if (!this.clicked) {\n            this._checkboxChange();\n        }\n        this.clicked = false;\n    },\n\n    onCheckboxInputClick: function() {\n        this._checkboxChange();\n        this.clicked = true;\n    },\n\n    onRadioInputChange: function(e) {\n\n        e = e || window.event;\n\n        var self    = this,\n            trg     = e.target || e.srcElement;\n\n        observable.trigger(\"change-\"+self.id, self.processValue(trg.value));\n    },\n\n    /**\n     * @method\n     * @param {*} val \n     */\n    setValue: function(val) {\n\n        var self    = this,\n            type    = self.inputType,\n            radio,\n            i, len;\n\n        val = self.processValue(val);\n\n        if (type === \"radio\") {\n\n            radio = self.radio;\n\n            for (i = 0, len = radio.length; i < len; i++) {\n                radio[i].checked = self.processValue(radio[i].value) == val;\n            }\n        }\n        else if (type === \"checkbox\") {\n            var node        = self.el;\n            node.checked    = val === true || val == self.processValue(node.value);\n        }\n        else {\n\n            if (val === undefined) {\n                val = \"\";\n            }\n\n            MetaphorJs.dom.setInputValue(self.el, val);\n        }\n\n        self.triggerChange();\n    },\n\n    /**\n     * @method\n     * @returns {*}\n     */\n    getValue: function() {\n\n        var self    = this,\n            type    = self.inputType,\n            radio,\n            i, l;\n\n        if (type === \"radio\") {\n            radio = self.radio;\n            for (i = 0, l = radio.length; i < l; i++) {\n                if (radio[i].checked) {\n                    return self.processValue(radio[i].value);\n                }\n            }\n            return null;\n        }\n        else if (type === \"checkbox\") {\n            return self.processValue(self.el.checked ? (MetaphorJs.dom.getAttr(self.el, \"value\") || true) : false);\n        }\n        else {\n            return self.processValue(MetaphorJs.dom.getInputValue(self.el));\n        }\n    },\n\n    /**\n     * @method\n     * @param {string} event change|key\n     * @param {function} fn event listener\n     * @param {object} ctx event listener context\n     * @param {object} opt MetaphorJs.lib.Observable's on() options\n     */\n    on: function(event, fn, ctx, opt) {\n        var self = this;\n        if (event === \"change\" && !self.changeInitialized) {\n            self.initInputChange();\n        }\n        else if (event === \"key\" && !self.keydownDelegate) {\n            self.keydownDelegate = bind(self.keyHandler, self);\n            self.listeners.push([\"keydown\", self.keydownDelegate, false]);\n            MetaphorJs.dom.addListener(self.el, \"keydown\", self.keydownDelegate);\n            observable.createEvent(\"key-\"+self.id, {\n                returnResult: false,\n                triggerFilter: self.keyEventFilter\n            });\n        }\n        return observable.on(event+\"-\"+self.id, fn, ctx, opt);\n    },\n\n    /**\n     * @method\n     * @param {string} event \n     * @param {function} fn \n     * @param {object} ctx \n     */\n    un: function(event, fn, ctx) {\n        return observable.un(event+\"-\"+this.id, fn, ctx);\n    },\n\n    /**\n     * @method\n     * @param {function} fn \n     * @param {object} context \n     */\n    onChange: function(fn, context) {\n        return this.on(\"change\", fn, context);\n    },\n\n    /**\n     * @method\n     * @param {function} fn \n     * @param {object} context \n     */\n    unChange: function(fn, context) {\n        return this.un(\"change\", fn, context);\n    },\n\n    /**\n     * @method\n     * @param {int} key \n     * @param {function} fn \n     * @param {object} context \n     * @param {object} opt\n     */\n    onKey: function(key, fn, context, opt) {\n        return this.on(\"key\", fn, context, extend({}, opt, {\n            key: key\n        }));\n    },\n\n    /**\n     * @method\n     * @param {int} key \n     * @param {function} fn \n     * @param {object} context \n     */\n    unKey: function(key, fn, context) {\n        this.un(\"key\", fn, context);\n    },\n\n    keyEventFilter: function(l, args) {\n\n        var key = l.key,\n            e = args[0];\n\n        if (typeof key !== \"object\") {\n            return key === e.keyCode;\n        }\n        else {\n            if (key.ctrlKey !== undefined && key.ctrlKey !== e.ctrlKey) {\n                return false;\n            }\n            if (key.shiftKey !== undefined && key.shiftKey !== e.shiftKey) {\n                return false;\n            }\n            return !(key.keyCode !== undefined && key.keyCode !== e.keyCode);\n        }\n    },\n\n    keyHandler: function(event) {\n        observable.trigger(\n            \"key-\"+this.id, \n            MetaphorJs.dom.normalizeEvent(event || window.event)\n        );\n    },\n\n    triggerChange: function() {\n        if (\"createEvent\" in document) {\n            var evt = document.createEvent(\"HTMLEvents\");\n            evt.initEvent(\"change\", false, true);\n            this.el.dispatchEvent(evt);\n        }\n        else {\n            this.el.fireEvent(\"onchange\");\n        }\n    }\n\n\n}, true, false);\n\n\n/**\n * @method\n * @static\n * @param {Node} node\n * @param {MetaphorJs.lib.State} state\n * @returns {MetaphorJs.lib.Input}\n */\nInput.get = function(node, state) {\n    if (node.$$input) {\n        return node.$$input;\n    }\n    if (state && state.$app && !node.type) {\n        var cmp = state.$app.getParentCmp(node, true);\n        if (cmp && cmp.getInputApi) {\n            return cmp.getInputApi();\n        }\n    }\n    return new Input(node);\n};\n\n/**\n * @method\n * @static\n * @param {Node} node\n * @returns {string}\n */\nInput.getValue = MetaphorJs.dom.getInputValue;\n\n/**\n * @method\n * @static\n * @param {Node} node\n * @param {string} value\n */\nInput.setValue = MetaphorJs.dom.setInputValue;\n\n\n\nreturn Input;\n\n}();","\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    isFunction = require(\"metaphorjs-shared/src/func/isFunction.js\"),\n    isArray = require(\"metaphorjs-shared/src/func/isArray.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    equals = require(\"metaphorjs-shared/src/func/equals.js\"),\n    copy = require(\"metaphorjs-shared/src/func/copy.js\");\n\nrequire(\"metaphorjs-observable/src/lib/Observable.js\");\nrequire(\"./Expression.js\");\n\n/**\n * @class MetaphorJs.lib.MutationObserver\n */\nmodule.exports = MetaphorJs.lib.MutationObserver = (function(){\n\n    var observable = new MetaphorJs.lib.Observable;\n\n    var checkAll = function() {\n        var k, changes = 0;\n\n        for (k in this) {\n            if (this.hasOwnProperty(k) && k !== \"$checkAll\") {\n                if (this[k].check()){\n                    changes++;\n                }\n            }\n        }\n\n        return changes;\n    };\n\n    /**\n     * @constructor\n     * @method\n     * @param {object} dataObj Data object to run expression against\n     * @param {string|function} expr Code expression or property name or getter function\n     * @param {function} listener {\n     *  @param {*} currentValue\n     *  @param {*} prevValue\n     * }\n     * @param {object} context Listener's context\n     * @param {object} opt {\n     *  @type {array|object} filters {\n     *      Either one filter source or array of filter sources\n     *  }\n     * }\n     */\n    const MutationObserver = function(dataObj, expr, listener, context, opt) {\n\n        var self    = this,\n            id      = nextUid(),\n            type    = \"expr\",\n            propertyName,\n            statc,\n            pb,\n            tp = typeof expr;\n\n\n        if (MetaphorJs.app.prebuilt.isKey(expr)) {\n            pb = MetaphorJs.app.prebuilt.get(\"config\", expr);\n        }\n        else if (tp !== \"string\" && tp !== \"function\") {\n            pb = expr;\n            expr = pb.id || nextUid();\n        }\n\n        opt = opt || {};\n\n        if (listener) {\n            observable.on(id, listener, context, {\n                allowDupes: true\n            });\n        }\n\n        self.id = id;\n        self.origExpr = expr;\n        self.propertyName = null;\n        self.staticValue = null;\n        self.dataObj = dataObj;\n        self.currentValue = null;\n        self.prevValue = null;\n        self.rawInput = null;\n        self.setterFn = null;\n        self.getterFn = null;\n        self.exprStruct = null;\n        self.sub = [];\n        self.localFilter = opt.localFilter || null;\n\n        if (pb) {\n            type = \"prebuilt\";\n            self.exprStruct = pb;\n            self.getterFn = MetaphorJs.lib.Expression.construct(pb, {getterOnly: true});\n            if (pb.setterFn) {\n                self.setterFn = MetaphorJs.lib.Expression.construct(\n                                    pb, {setterOnly: true}\n                                );\n                self._initSetter();\n            }\n        }\n        else {\n            if (isFunction(expr)) {\n                self.getterFn = expr;\n            }\n            else if (statc = MetaphorJs.lib.Expression.isStatic(expr)) {\n                type = \"static\";\n                self.staticValue = statc.value;\n                self.getterFn = bind(self._staticGetter, self);\n            }\n            else if (dataObj) {\n                propertyName = expr;\n                if (dataObj.hasOwnProperty(propertyName) || \n                    ((propertyName = MetaphorJs.lib.Expression.isProperty(expr)) &&\n                    dataObj.hasOwnProperty(propertyName))) {\n                        type = \"attr\";\n                        self.propertyName = propertyName;\n                        self.getterFn = bind(self._propertyGetter, self);\n                    }\n            }\n        }\n        \n        if (!self.getterFn && type === \"expr\") {\n\n            if (!opt.filters) {\n                opt.filters = dataObj;\n            }\n            else {\n                if (!isArray(opt.filters)) {\n                    opt.filters = [opt.filters];\n                }\n                else {\n                    opt.filters.push(dataObj);\n                }\n            }\n\n            var struct = MetaphorJs.lib.Expression.deconstruct(expr, {\n                filters: opt.filters\n            });\n            self.exprStruct = struct;\n\n            self.getterFn = MetaphorJs.lib.Expression.construct(\n                struct, {getterOnly: true}\n            );\n\n            if (struct.inputPipes.length || opt.setter) {\n                self._initSetter();\n            }\n        }\n\n        if (dataObj) {\n            if (!dataObj[\"$$mo\"]) {\n                dataObj.$$mo = {\n                    $checkAll: checkAll\n                };\n            }\n            if (!dataObj.$$mo[expr]) {\n                dataObj.$$mo[expr] = self;\n            }\n        }\n\n        self.currentValue = self._getValue();\n        self.currentValueCopy = copy(self.currentValue);\n        self.type = type;\n    };\n\n    extend(MutationObserver.prototype, {\n\n        _propertyGetter: function() {\n            return this.dataObj[this.propertyName];\n        },\n\n        _propertySetter: function(dataObj, newValue) {\n            this.dataObj[this.propertyName] = newValue;\n        },\n\n        _staticGetter: function() {\n            return this.staticValue;\n        },\n\n        /**\n         * Check for changes\n         * @method\n         * @returns {boolean} true for changes\n         */\n        check: function() {\n\n            var self = this,\n                curr = self.currentValueCopy,\n                val = self._getValue();\n\n            if (!equals(val, curr)) {\n                self.prevValue = curr;\n                self.currentValue = val;\n                self.currentValueCopy = copy(val);\n                observable.trigger(self.id, self.currentValue, self.prevValue);\n                return true;\n            }\n\n            return false;\n        },\n\n        _initSetter: function() {\n            var self = this, struct = self.exprStruct;\n\n            if (self.type === \"attr\") {\n                self.setterFn = bind(self._propertySetter, self);\n            }\n            else {\n                if (!struct) {\n                    throw new Error(\"Unable to make setter out of \" + this.expr);\n                }\n\n                if (!self.setterFn) {\n                    self.setterFn = MetaphorJs.lib.Expression.construct(\n                        struct, {setterOnly: true}\n                    );\n                }\n                self._initInputPipes();\n            }\n        },\n\n        _initInputPipes: function() {\n            var self = this, struct = self.exprStruct;\n            var i, l, p, j, jl;\n            if (struct.inputPipes) {\n                for (i = 0, l = struct.inputPipes.length; i < l; i++) {\n                    p = struct.inputPipes[i];\n                    for (j = 0, jl = p.expressions.length; j < jl; j++) {\n                        self.sub.push(\n                            MetaphorJs.lib.MutationObserver.get(\n                                self.dataObj, p.expressions[j],\n                                self._onSubChange, self\n                            )\n                        );\n                    }\n                }  \n            }\n        },\n\n        _getValue: function() {\n            const self = this;\n            const val = self.getterFn(self.dataObj || {});\n            \n            return self.localFilter ? self.localFilter(val, self) : val;\n        },\n\n        _onSubChange: function() {\n            this.setValue(this.rawInput);\n        },\n\n        /**\n         * Get current value of expression\n         * @method\n         * @returns {*}\n         */\n        getValue: function() {\n            return this.currentValue;\n        },\n\n        /**\n         * Get copy of current value of expression\n         * @method\n         * @returns {*}\n         */\n        getCopy: function() {\n            return this.currentValueCopy;\n        },\n\n        /**\n         * If the expression uses input pipes, use this method to trigger them\n         * @method\n         * @param {*} newValue \n         * @returns {*} resulting value\n         */\n        setValue: function(newValue) {  \n            var self = this;\n            self.rawInput = newValue;\n            if (!self.setterFn) {\n                self._initSetter();\n            }\n            self.setterFn(self.dataObj, newValue);\n        },\n\n        /**\n         * Get previous value\n         * @method\n         * @returns {*}\n         */\n        getPrevValue: function() {\n            return this.prevValue;\n        },\n\n        /**\n         * \n         * @param {function} fn {\n         *  @param {*} currentValue\n         *  @param {*} prevValue\n         * }\n         * @param {object} context fn's context\n         * @param {object} opt See MetaphorJs.lib.Observable.on()\n         * @returns {MetaphorJs.lib.MutationObserver} self\n         */\n        subscribe: function(fn, context, opt) {\n            opt = opt || {};\n            opt.allowDupes = true;\n            observable.on(this.id, fn, context, opt);\n            return this;\n        },\n\n        /**\n         * Unsubscribe from changes event\n         * @param {function} fn \n         * @param {object} context \n         * @returns {MetaphorJs.lib.MutationObserver} self\n         */\n        unsubscribe: function(fn, context) {\n            observable.un(this.id, fn, context);\n            return this;\n        },\n\n        /**\n         * Does the expression have input pipes\n         * @method\n         * @returns {boolean}\n         */\n        hasInputPipes: function() {\n            return this.exprStruct && this.exprStruct.inputPipes.length > 0;\n        },\n\n        /**\n         * Does the expression have output pipes\n         * @method\n         * @returns {boolean}\n         */\n        hasOutputPipes: function() {\n            return this.exprStruct && this.exprStruct.pipes.length > 0;\n        },\n\n        /**\n         * Destroy observer\n         * @param {boolean} ifUnobserved \n         * @returns {boolean} true for destroyed\n         */\n        $destroy: function(ifUnobserved) {\n            var self = this, i, l, s;\n            if (ifUnobserved && observable.hasListener(self.id)) {\n                return false;\n            }\n            for (i = 0, l = self.sub.length; i < l; i++) {\n                s = self.sub[i];\n                s.unsubscribe(self._onSubChange, self);\n                s.$destroy(true);\n            }\n            observable.destroyEvent(self.id);\n            if (self.dataObj && self.dataObj['$$mo']) {\n                if (self.dataObj['$$mo'][self.origExpr] === self) {\n                    delete self.dataObj['$$mo'][self.origExpr];\n                }\n            }\n            for (var key in self) {\n                if (self.hasOwnProperty(key)) {\n                    self[key] = null;\n                }\n            }\n            return true;\n        }\n    });\n\n\n    /**\n     * Check data object for changes\n     * @static\n     * @method\n     * @param {object} dataObj\n     * @param {string} expr {\n     *  Optional expression \n     *  @optional\n     * }\n     * @returns {bool|int} Either true|false for specific expression or number of changes\n     */\n    MutationObserver.check = function(dataObj, expr)  {\n        var mo;\n        if (expr) {\n            mo = MutationObserver.exists(dataObj, expr);\n            if (!mo) {\n                throw new Error(\"MutationObserver not found for expression: \" + expr);\n            }\n            return mo.check();\n        }\n        if (!dataObj.$$mo) {\n            return false;\n        }\n        return dataObj.$$mo.$checkAll();\n    };\n\n    /**\n     * See the constructor parameters\n     * @static\n     * @method\n     */\n    MutationObserver.get = function(dataObj, expr, listener, context, opt) {\n\n        var pbOrExpr = expr;\n\n        if (typeof expr !== \"string\") {\n            expr = pbOrExpr.expr;\n        }\n\n        if (expr) {\n            expr = expr.trim();\n            var mo = MutationObserver.exists(dataObj, expr);\n\n            if (mo) {\n                if (listener) {\n                    mo.subscribe(listener, context);\n                }\n                return mo;\n            }\n        }\n\n        return new MutationObserver(dataObj, pbOrExpr, listener, context, opt);\n    };\n\n    /**\n     * Check if mutation observer exists on the object and return it or false\n     * @static\n     * @method\n     * @param {object} dataObj\n     * @param {string} expr\n     * @returns {MetaphorJs.lib.MutationObserver|boolean}\n     */\n    MutationObserver.exists = function(dataObj, expr) {\n        expr = expr.trim();\n\n        if (dataObj && dataObj.$$mo && dataObj.$$mo[expr]) {\n            return dataObj.$$mo[expr];\n        }\n\n        return false;\n    };\n\n    /**\n     * Destroy an observer\n     * @static\n     * @method\n     * @param {object} dataObj\n     * @param {string|null} expr If null, destroy all observers on this object\n     * @param {boolean} ifUnobserved Destroy only if unobserved\n     */\n    MutationObserver.$destroy = function(dataObj, expr, ifUnobserved) {\n\n        var key, all = true;\n\n        if (dataObj && dataObj.$$mo) {\n            for (key in dataObj.$$mo) {\n                if (dataObj.$$mo.hasOwnProperty(key) && \n                    (!expr || key === expr) &&\n                    key[0] !== '$') {\n                    if (dataObj.$$mo[key].$destroy(ifUnobserved)) {\n                        delete dataObj.$$mo[key];\n                    }\n                    else all = false;\n                }\n            }\n\n            if (all) {\n                delete dataObj.$$mo;\n            }\n        }\n    }\n\n    return MutationObserver;\n\n}());","require(\"metaphorjs-observable/src/lib/Observable.js\");\nrequire(\"./MutationObserver.js\");\n\nconst extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    async = require(\"metaphorjs-shared/src/func/async.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\n/**\n * The state object is what templates see as \"this\" when executing expressions.\n * (Actually, this is more like a Context)\n * @class MetaphorJs.lib.State\n */\nmodule.exports = MetaphorJs.lib.State = (function(){\n\n\nconst publicStates = {};\n\n/**\n * @method State\n * @constructor\n * @param {object} cfg Whatever data should be visible in template\n */\nconst State = function(cfg) {\n\n    this.$$observable       = new MetaphorJs.lib.Observable;\n    this.$$historyWatchers  = {};\n    extend(this, cfg, true, false);\n\n    if (this.$parent) {\n        /**\n         * @event check\n         * @param {array} changes \n         */\n        this.$parent.$on(\"check\", this.$$onParentCheck, this);\n        /**\n         * @event changed\n         */\n        /**\n         * @event destroy\n         */\n        this.$parent.$on(\"destroy\", this.$$onParentDestroy, this);\n        /**\n         * @event freeze\n         * @param {MetaphorJs.lib.State}\n         */\n        this.$parent.$on(\"freeze\", this.$freeze, this);\n        /**\n         * @event unfreeze\n         * @param {MetaphorJs.lib.State}\n         */\n        this.$parent.$on(\"unfreeze\", this.$unfreeze, this);\n    }\n    else {\n        this.$root  = this;\n        this.$isRoot= true;\n    }\n\n    if (this.$$publicName) {\n        if (publicStates[this.$$publicName]) {\n            this.$$publicName = null;\n        }\n        publicStates[this.$$publicName] = this;\n    }\n};\n\nextend(State.prototype, {\n\n    /**\n     * @property {MetaphorJs.app.App}\n     */\n    $app: null,\n\n    /**\n     * @property {MetaphorJs.lib.State}\n     */\n    $parent: null,\n\n    /**\n     * @property {MetaphorJs.lib.State}\n     */\n    $root: null,\n\n    /**\n     * @property {boolean}\n     */\n    $isRoot: false,\n\n    /**\n     * @property {int}\n     */\n    $level: 0,\n\n    $static: false,\n    $$frozen: false,\n    $$observable: null,\n    $$watchers: null,\n    $$historyWatchers: null,\n    $$checking: false,\n    $$destroyed: false,\n    $$changing: false,\n    $$publicName: null,\n\n    $$tmt: null,\n\n    /**\n     * Create child state\n     * @method\n     * @param {object} data Child state data\n     * @returns {MetaphorJs.lib.State}\n     */\n    $new: function(data) {\n        return new State(extend({}, data, {\n            $parent: this,\n            $root: this.$root,\n            $app: this.$app,\n            $level: this.$level + 1,\n            $static: this.$static\n        }, true, false));\n    },\n\n    /**\n     * Create child state with no relation to this state (no $parent)\n     * but with $app propery set.\n     * @method\n     * @param {object} data Child state data\n     * @returns {MetaphorJs.lib.State}\n     */\n    $newIsolated: function(data) {\n        return new State(extend({}, data, {\n            $app: this.$app,\n            $level: this.$level + 1,\n            $static: this.$static\n        }, true, false));\n    },\n\n    /**\n     * Freeze the state. It will not perfom checks and trigger change events\n     * @method\n     */\n    $freeze: function() {\n        if (!this.$$frozen) {\n            this.$$frozen = true;\n            this.$$observable.trigger(\"freeze\", this);\n        }\n    },\n\n    /**\n     * Unfreeze state. Resume checking for changes\n     * @method\n     */\n    $unfreeze: function() {\n        if (this.$$frozen) {\n            this.$$frozen = false;\n            this.$$observable.trigger(\"unfreeze\", this);\n        }\n    },\n\n    /**\n     * Subsrcibe to state events\n     * @method \n     * @param {string} event\n     * @param {function} fn\n     * @param {object} context \n     */\n    $on: function(event, fn, context) {\n        return this.$$observable.on(event, fn, context);\n    },\n\n    /**\n     * Unsubsrcibe from state events\n     * @method \n     * @param {string} event\n     * @param {function} fn\n     * @param {object} context \n     */\n    $un: function(event, fn, context) {\n        return this.$$observable.un(event, fn, context);\n    },\n\n    /**\n     * Create a watcher on js expression\n     * @method\n     * @param {string} expr js expression\n     * @param {function} fn {\n     *  @param {*} value\n     * }\n     * @param {object} context\n     * @returns {MetaphorJs.lib.MutationObserver}\n     */\n    $watch: function(expr, fn, context) {\n        return MetaphorJs.lib.MutationObserver.get(this, expr, fn, context);\n    },\n\n    /**\n     * Stop watching js expression\n     * @method\n     * @param {string} expr js expression\n     * @param {function} fn \n     * @param {object} context\n     */\n    $unwatch: function(expr, fn, context) {\n        var mo = MetaphorJs.lib.MutationObserver.exists(this, expr);\n        if (mo) {\n            mo.unsubscribe(fn, context);\n            mo.$destroy(true);\n        }\n    },\n\n    /**\n     * Watch changes in page url. Triggers regular change event\n     * @method\n     * @param {string} prop State property name\n     * @param {string} param Url param name\n     */\n    $watchHistory: function(prop, param) {\n        if (!this.$$historyWatchers[param]) {\n            this.$$historyWatchers[param] = prop;\n            MetaphorJs.lib.History.on(\"change-\" + param, this.$$onHistoryChange, this);\n        }\n    },\n\n    /**\n     * Stop watching changes in page url.\n     * @method\n     * @param {string} param Url param name\n     */\n    $unwatchHistory: function(param) {\n        if (!this.$$historyWatchers[param]) {\n            delete this.$$historyWatchers[param];\n            MetaphorJs.lib.History.un(\"change-\" + param, this.$$onHistoryChange, this);\n        }\n    },\n\n\n    /**\n     * Set state value and check for changes.\n     * @method\n     * @param {string} key\n     * @param {*} value\n     */\n     /**\n     * Set state value and check for changes.\n     * @method\n     * @param {object} obj Key:value pairs\n     */\n    /**\n     * Batch value update and check for changes.\n     * @method\n     * @param {function} fn fn(state)\n     */\n    $set: function(key, value) {\n        if (typeof key === \"string\") {\n            this[key] = value;\n        }\n        else if (typeof key === \"function\") {\n            key(this);\n        }\n        else {\n            for (let k in key) {\n                this[k] = key[k];\n            }\n        }\n        this.$check();\n    },\n\n    /**\n     * Update state with object and check for changes\n     * @param {object} data \n     */\n    /**\n     * Update state with object and check for changes\n     * @param {string} key\n     * @param {object} data \n     */\n    $extend: function(key, data) {\n        if (arguments.length === 2) {\n            this[key] = extend(this[key], data, true, true);    \n        }\n        else {\n            extend(this, key, true, true);\n        }\n        this.$check();\n    },\n\n    $$onParentDestroy: function() {\n        this.$destroy();\n    },\n\n    $$onParentCheck: function() {\n        this.$check();\n    },\n\n    $$onHistoryChange: function(val, prev, name) {\n        let prop;\n        if (this.$$historyWatchers[name]) {\n            prop = this.$$historyWatchers[name];\n            this[prop] = val;\n            this.$check();\n        }\n    },\n\n    /**\n     * Schedule a delayed check\n     * @method\n     * @param {int} timeout\n     */\n    $scheduleCheck: function(timeout) {\n        if (!this.$$tmt) {\n            this.$tmt = async(this.$check, this, null, timeout);\n        }\n    },\n\n    /**\n     * Check for changes and trigger change events.<br>\n     * If changes are found, the check will run again\n     * until no changes is found.\n     * @method\n     */\n    $check: function() {\n        let changes;\n\n        if (this.$$checking || this.$static || this.$$frozen) {\n            return;\n        }\n        this.$$checking = true;\n\n        if (this.$$tmt) {\n            clearTimeout(this.$$tmt);\n            this.$$tmt = null;\n        }\n\n        if (this.$$mo) {\n            changes = this.$$mo.$checkAll();\n        }\n\n        this.$$checking = false;\n\n        if (!this.$$destroyed) {\n            this.$$observable.trigger(\"check\", changes);\n        }\n\n        if (changes > 0) {\n            this.$$changing = true;\n            this.$check();\n        }\n        else {\n            // finished changing after all iterations\n            if (this.$$changing) {\n                this.$$changing = false;\n                this.$$observable.trigger(\"changed\");\n            }\n        }\n    },\n\n    /**\n     * Register this state as public\n     * @method\n     * @param {string} name \n     */\n    $registerPublic: function(name) {\n        if (this.$$publicName || publicStates[name]) {\n            return;\n        }\n        this.$$publicName = name;\n        publicStates[name] = this;\n    },\n\n    /**\n     * Register this state as default public\n     * @method\n     * @param {string} name \n     */\n    $makePublicDefault: function() {\n        this.$registerPublic(\"__default\");\n    },\n\n    /**\n     * Unregister public state\n     * @method\n     */\n    $unregisterPublic: function() {\n        const name = this.$$publicName;\n        if (!name || !publicStates[name]) {\n            return;\n        }\n        delete publicStates[name];\n        this.$$publicName = null;\n    },\n\n    /**\n     * Destroy state\n     * @method\n     */\n    $destroy: function() {\n\n        let param, i;\n\n        if (this.$$destroyed) {\n            return;\n        }\n\n        this.$$destroyed = true;\n        this.$$observable.trigger(\"destroy\");\n        this.$$observable.$destroy();\n\n        if (this.$parent && this.$parent.$un) {\n            this.$parent.$un(\"check\", this.$$onParentCheck, this);\n            this.$parent.$un(\"destroy\", this.$$onParentDestroy, this);\n            this.$parent.$un(\"freeze\", this.$freeze, this);\n            this.$parent.$un(\"unfreeze\", this.$unfreeze, this);\n        }\n\n        if (this.$$mo) {\n            MetaphorJs.lib.MutationObserver.$destroy(this);\n        }\n\n        for (param in this.$$historyWatchers) {\n            this.$unwatchHistory(param);\n        }\n\n        this.$unregisterPublic();\n\n        for (i in this) {\n            if (this.hasOwnProperty(i)) {\n                this[i] = null;\n            }\n        }\n\n        this.$$destroyed = true;\n    }\n\n}, true, false);\n\n/**\n * Check if public state exists\n * @static\n * @method $exists\n * @param {string} name\n * @returns MetaphorJs.lib.State\n */\nState.$exists = function(name) {\n    return !!publicStates[name];    \n};\n\n/**\n * Get public state\n * @static\n * @method $get\n * @param {string} name - skip to get public default\n * @returns MetaphorJs.lib.State\n */\nState.$get = function(name) {\n    return publicStates[name || \"__default\"];\n};\n\n/**\n * Produce a state either by getting a public state,\n * or creating a child of public state or\n * creating a new state\n * @static\n * @method\n * @param {string|MetaphorJs.lib.State} name {\n *  @optional\n * }\n * @param {MetaphorJs.lib.State} parent {\n *  @optional\n * }\n * @returns MetaphorJs.lib.State\n */\nState.$produce = function(name, parent) {\n\n    if (name instanceof State) {\n        return name;\n    }\n\n    if (!name) {\n        if (parent) {\n            return parent;\n        }\n        const def = publicStates['__default'];\n        return def ? def.$new() : new State;\n    }\n    else {\n        let action = \"self\";\n\n        if (name.indexOf(\":\") !== -1) {\n            let parts = name.split(\":\");\n            name = parts[0];\n            action = parts[1] || \"self\";\n        }\n\n        if (name) {\n            parent = this.$get(name);\n            if (!parent) {\n                throw new Error(\"State with name \" + name + \" not found\");\n            }\n        }\n\n        switch (action) {\n            case \"self\":\n                return parent;\n            case \"new\":\n                return parent.$new();\n            case \"parent\":\n                return parent.$parent || parent.$root;\n            case \"root\":\n                return parent.$root;\n            case \"app\":\n                if (!parent.$app) {\n                    throw new Error(\"App not found in state\");\n                }\n                return parent.$app.state;\n            default:\n                throw new Error(\"Unknown state action: \" + action);\n        }\n    }\n};\n\nreturn State;\n\n}());\n","\nconst extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.lib.Stylesheet = function() {\n\n    var Stylesheet = function(cfg) {\n\n        var self = this;\n\n        extend(self, cfg);\n\n        !self.id && (self.id = nextUid());\n        self.appended = false;\n\n        if (self.content) {\n            var content = self.content;\n            self.content = null;\n            self.setContent(content);\n        }\n    };\n\n    extend(Stylesheet.prototype, {\n\n        _initStylesheet: function() {\n            var self = this;\n            self.stylesheet = window.document.createElement(\"style\");\n            self.stylesheet.type = \"text/css\";\n            self.stylesheet.id = \"for_\" + self.id;\n            self.head = window.document.head || \n                            window.document.getElementsByTagName('head')[0] ||\n                            window.document.body;        \n        },\n\n        setContent: function(cssContent) {\n            var self = this;\n            if (cssContent != self.content) {\n                self.content = cssContent;\n                if (!self.stylesheet) {\n                    self._initStylesheet();\n                }\n\n                var style = self.stylesheet;\n\n                if (style.styleSheet) {\n                    // This is required for IE8 and below.\n                    style.styleSheet.cssText = self.content;\n                } \n                else {\n                    while (style.firstChild) {\n                        style.removeChild(style.firstChild);\n                    }\n                    style.appendChild(window.document.createTextNode(self.content));\n                }\n\n                if (!self.appended) {\n                    self.append();\n                }\n            } \n        },\n\n        append: function() {\n            var self = this;\n            if (!self.stylesheet) {\n                self._initStylesheet();\n            }\n            if (!self.appended) {\n                self.head.appendChild(self.stylesheet);\n                self.appended = true;\n            }\n        },\n        \n        remove: function() {\n            var self = this;\n            if (self.appended) {\n                self.head.removeChild(self.stylesheet);\n                self.appended = false;\n            }\n        },\n\n        $destroy: function() {\n            if (this.appended) {\n                this.remove();\n            }\n        }\n\n    });\n\n    return Stylesheet;\n\n}();","\nrequire(\"metaphorjs-observable/src/lib/Observable.js\");\nrequire(\"../lib/MutationObserver.js\");\nrequire(\"../lib/Expression.js\");\nrequire(\"../func/app/prebuilt.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    nextUid = require(\"metaphorjs-shared/src/func/nextUid.js\"),\n    async = require(\"metaphorjs-shared/src/func/async.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\");\n\n/**\n * Text renderer\n * @class MetaphorJs.lib.Text\n */\nmodule.exports = MetaphorJs.lib.Text = (function(){\n\n    var startSymbol             = '{{',\n        endSymbol               = '}}',\n        startSymbolLength       = 2,\n        endSymbolLength         = 2,\n\n        events                  = new MetaphorJs.lib.Observable,\n\n        _procExpr               = function(expr, state, observers) {\n            if (observers) {\n                var w = MetaphorJs.lib.MutationObserver.get(state, expr);\n                observers.push(w);\n                return w.getValue();\n            }\n            else {\n                if (MetaphorJs.app.prebuilt.isKey(expr)) {\n                    expr = MetaphorJs.app.prebuilt.get(\"config\", expr);\n                }\n                return MetaphorJs.lib.Expression.get(expr, state);\n            }\n        },\n\n        eachText                = function(text, fn) {\n\n            var index       = 0,\n                textLength  = text.length,\n                startIndex,\n                endIndex,\n                expr,\n                result      = \"\";\n\n            while (index < textLength) {\n                if (((startIndex = text.indexOf(startSymbol, index)) !== -1) &&\n                    ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) !== -1) &&\n                    text.substr(startIndex - 1, 1) !== '\\\\') {\n\n                    result += text.substring(index, startIndex);\n\n                    if (endIndex !== startIndex + startSymbolLength) {\n                        expr = text.substring(startIndex + startSymbolLength, endIndex);\n                        expr = expr.trim();\n                        result += fn(expr);\n                    }\n\n                    index = endIndex + endSymbolLength;\n\n                } else {\n                    // we did not find an interpolation\n                    if (index !== textLength) {\n                        result += text.substring(index);\n                    }\n                    break;\n                }\n            }\n\n            return result;\n        },\n\n        render = function(text, state, observers, recursive, fullExpr) {\n\n            var result,\n                prev = text,\n                iter = 0;\n\n            if (text === false) {\n                return false;\n            }\n\n            while (true) {\n                if (iter > 100) {\n                    throw new Error(\n                        \"Got more than 100 iterations on template: \" + self.origin);\n                }\n\n                if (fullExpr) {\n                    result = _procExpr(text, state, observers);\n                    fullExpr = false;\n                }\n                else {\n                    result = eachText(prev, function(expr){\n                        return _procExpr(expr, state, observers);\n                    });\n                }\n                \n                if (!recursive || result === prev) {\n                    return result;\n                }\n\n                prev = result;\n                iter++;\n            }\n        };\n\n\n    /**\n     * @constructor\n     * @method\n     * @param {object} dataObj\n     * @param {string} text \n     * @param {object} opt {\n     *  @type {bool} recursive\n     * }\n     */\n    var Text = function(state, text, opt) {\n        opt = opt || {};\n\n        var self        = this;\n\n        self.id         = nextUid();\n        self.origin     = text;\n        self.text       = \"\";\n        self.state      = state;\n        self.$destroyed  = false;\n        self.fullExpr   = false;\n        self.recursive  = false;\n        self.once       = false;\n\n        if (opt.recursive === true || opt.recursive === false) {\n            self.recursive = opt.recursive;\n        }\n        if (opt.fullExpr === true || opt.fullExpr === false) {\n            self.fullExpr = opt.fullExpr;\n        }\n        if (opt.once === true || opt.once === false) {\n            self.once = opt.once;\n        }\n\n        self._processDelegate = bind(self._process, self);\n        self.observers  = [];\n\n        self._process(true);\n    };\n\n    extend(Text.prototype, {\n\n        _process: function(initial) {\n\n            if (this.$destroyed) {\n                return;\n            }\n\n            var self = this,\n                obs = self.observers.slice();\n\n            self._observeData(obs, \"unsubscribe\");\n            self.observers = [];\n\n            self.text = render(self.origin, self.state, \n                                self.observers, \n                                self.recursive, \n                                self.fullExpr);\n\n            self._observeData(self.observers, \"subscribe\");\n            self._destroyObservers(obs);\n\n            if (!initial) {\n                events.trigger(self.id, self);\n            }\n        },\n\n        _onDataChange: function() {\n            async(this._processDelegate);\n        },\n\n        _observeData: function(obs, mode) {\n            var i, l,\n                self = this;\n            for (i = 0, l = obs.length; i < l; i++) {\n                // subscribe/unsubscribe\n                obs[i][mode](self._onDataChange, self);\n            }\n        },\n\n        _destroyObservers: function(obs) {\n            var i, l;\n            for (i = 0, l = obs.length; i < l; i++) {\n                obs[i].$destroy(true);\n            }\n        },\n\n        /**\n         * Get processed text\n         * @method\n         * @returns {string}\n         */\n        getString: function() {\n            return this.text;\n        },\n\n        /**\n         * Subscribe to changes in text\n         * @param {function} fn \n         * @param {object} context \n         * @param {object} opt {\n         *  MetaphorJs.lib.Observable.on() options\n         * }\n         */\n        subscribe: function(fn, context, opt) {\n            return events.on(this.id, fn, context, opt);\n        },\n\n        /**\n         * Unsubscribe from changes in text\n         * @param {function} fn \n         * @param {object} context \n         */\n        unsubscribe: function(fn, context) {\n            return events.un(this.id, fn, context);\n        },\n\n        /**\n         * Used only in standalone mode. When part of an app, \n         * use state.$check()\n         * @method\n         * @returns {int}\n         */\n        check: function() {\n            return MetaphorJs.lib.MutationObserver.check(this.state);\n        },\n\n        /**\n         * Destroy text container\n         * @method\n         */\n        $destroy: function() {\n            var self = this;\n            self.$destroyed  = true;\n            events.destroyEvent(self.id);\n            self._observeData(self.observers, \"unsubscribe\");\n            self._destroyObservers(self.observers);\n        }\n    });\n\n    /**\n     * Statically process text without subscribing to changes\n     * @static\n     * @method\n     * @param {string} text Text template\n     * @param {object} dataObj Data object (app.State) to read variables from\n     * @param {array|null} observers {\n     *  Pass empty array \n     *  @type {MetaphorJs.lib.MutationObserver} observer\n     * }\n     * @param {bool} recursive Recursively process text template\n     * @returns {string}\n     */\n    Text.render = render;\n\n    /**\n     * @static\n     * @method\n     * @param {string} text Text template\n     * @param {function} fn {\n     *  @param {string} expression\n     *  @returns {string} replacement\n     * }\n     * @returns {string} processed template\n     */\n    Text.eachText = eachText;\n\n    /**\n     * Does the text have expressions\n     * @static\n     * @method\n     * @param {string} text\n     * @returns {boolean}\n     */\n    Text.applicable = function(text) {\n        return MetaphorJs.app.prebuilt.isKey(text) || \n                !text || !text.indexOf ||\n                text.indexOf(startSymbol) === -1 ? false : true;\n    };\n\n    return Text;\n}());","\nrequire(\"./History.js\");\nrequire(\"metaphorjs-shared/src/func/browser/parseLocation.js\");\nrequire(\"metaphorjs-observable/src/mixin/Observable.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\"),\n    isString = require(\"metaphorjs-shared/src/func/isString.js\"),\n    extend = require(\"metaphorjs-shared/src/func/extend.js\"),\n    getRegExp = require(\"metaphorjs-shared/src/func/getRegExp.js\");    \n\n\nmodule.exports = MetaphorJs.lib.UrlParam = (function(){\n\n    var cache = {};\n\n    /**\n     * Url param watcher\n     * @class MetaphorJs.lib.UrlParam\n     */\n    var UrlParam = cls({\n\n        $mixins: [MetaphorJs.mixin.Observable],\n\n        id: null,\n        name: null,\n        extractor: null,\n        context: null,\n        regexp: null,\n        valueIndex: 1,\n        prev: null,\n        value: null,\n        enabled: true,\n\n        /**\n         * @method\n         * @constructor\n         * @param {object} cfg {\n         *  @type {string} id unique param id\n         *  @type {string|RegExp} regexp\n         *  @type {string} name\n         *  @type {function} extractor {\n         *      @param {string} url     \n         *      @returns {*} value\n         *  }\n         *  @type {object} context extractor's context\n         *  @type {int} valueIndex {\n         *      Index in regexp match array\n         *      @default 1\n         *  }\n         * }\n         */\n        $init: function(cfg) {\n\n            var self = this;\n\n            extend(self, cfg, true, false);\n\n            if (self.regexp && isString(self.regexp)) {\n                self.regexp = getRegExp(self.regexp);\n            }\n\n            if (self.name && !self.regexp && !self.extractor) {\n                self.regexp = getRegExp(self.name + \"=([^&]+)\");\n            }\n\n            if (!self.regexp && !self.extractor) {\n                throw new Error(\"Invalid UrlParam config, missing regexp or extractor\");\n            }\n\n            if (self.enabled) {\n                self.enabled = false;\n                self.enable();\n            }\n        },\n\n        /**\n         * Enable watcher (enabled by default)\n         * @method \n         */\n        enable: function() {\n            var self = this;\n            if (!self.enabled) {\n                self.enabled = true;\n                MetaphorJs.lib.History.on(\"location-change\", self.onLocationChange, self);\n                var url = MetaphorJs.lib.History.current(),\n                    loc = MetaphorJs.browser.parseLocation(url);\n                self.onLocationChange(loc.pathname + loc.search + loc.hash);\n            }\n        },\n\n        /**\n         * Disable watcher\n         * @method\n         */\n        disable: function() {\n            var self = this;\n            if (self.enabled) {\n                self.enabled = false;\n                MetaphorJs.lib.History.un(\"location-change\", self.onLocationChange, self);\n            }\n        },\n\n        onLocationChange: function(url) {\n\n            var self = this,\n                value = self.extractValue(url);\n\n            if (self.value != value) {\n                self.prev = self.value;\n                self.value = value;\n                self.trigger(\"change\", value, self.prev);\n            }\n        },\n\n        /**\n         * Extract param value from url\n         * @method\n         * @param {string} url\n         * @returns {string}\n         */\n        extractValue: function(url) {\n            var self = this;\n            if (self.regexp) {\n                var match = url.match(self.regexp);\n                return match ? match[self.valueIndex] : null;\n            }\n            else if (self.extractor) {\n                return self.extractor.call(self.context, url);\n            }\n        },\n\n        /**\n         * Get current param value\n         * @method\n         * @returns {string|null}\n         */\n        getValue: function() {\n            return this.value;\n        },\n\n        /**\n         * Get previous value\n         * @method\n         * @returns {string|null}\n         */\n        getPrev: function() {\n            return this.prev;\n        },\n\n        /**\n         * Destroy param watcher if there are no listeners\n         * @method\n         */\n        destroyIfIdle: function() {\n            var self = this;\n            if (!self.$$observable.hasListener()) {\n                self.$destroy();\n            }\n        },\n\n        onDestroy: function() {\n            var self = this;\n            self.disable();\n        }\n\n    }, {\n\n        /**\n         * Get already initialized instance based on cfg.id\n         * @static\n         * @method\n         * @param {object} cfg See constructor\n         * @returns {MetaphorJs.lib.UrlParam}\n         */\n        get: function(cfg) {\n            if (cfg.id && cache[cfg.id]) {\n                return cache[cfg.id];\n            }\n            else {\n                return new UrlParam(cfg);\n            }\n        }\n\n    });\n\n    return UrlParam;\n}());","require(\"metaphorjs-promise/src/lib/Promise.js\");\nrequire(\"metaphorjs-animate/src/animate/animate.js\");\nrequire(\"metaphorjs-animate/src/animate/stop.js\");\nrequire(\"metaphorjs-animate/src/animate/getPrefixes.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    raf = require(\"metaphorjs-animate/src/func/raf.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = (function(){\n\n\n    var methods = {\n        getNodePositions: function(tmp, items, oldItems) {\n\n            var nodes = [],\n                i, l, el, r,\n                tmpNode,\n                positions = {};\n\n            while(tmp.firstChild) {\n                tmp.removeChild(tmp.firstChild);\n            }\n            for (i = 0, l = items.length; i < l; i++) {\n                if (oldItems && oldItems[i]) {\n                    tmpNode = oldItems[i].el.cloneNode(true);\n                    tmp.appendChild(tmpNode);\n                }\n                tmpNode = items[i].el.cloneNode(true);\n                tmp.appendChild(tmpNode);\n                nodes.push(tmpNode);\n            }\n            for (i = 0, l = nodes.length; i < l; i++) {\n                el = nodes[i];\n                r = items[i].renderer;\n                if (r) {\n                    positions[r.id] = {left: el.offsetLeft, top: el.offsetTop};\n                }\n            }\n\n\n            return positions;\n        },\n\n        calculateTranslates: function(newRenderers, origRenderers, withDeletes) {\n\n            var self        = this,\n                parent      = self._nextEl.parentNode,\n                pp          = parent.parentNode,\n                tmp         = parent.cloneNode(true),\n                ofsW        = parent.offsetWidth,\n                translates  = [],\n                fl          = 0,\n                ft          = 0,\n                oldPositions,\n                insertPositions,\n                newPositions,\n                r, i, len, id,\n                style,\n                el;\n\n            style = tmp.style;\n            style.position = \"absolute\";\n            style.left = \"-10000px\";\n            style.visibility = \"hidden\";\n            style.width = ofsW + 'px';\n\n            pp.insertBefore(tmp, parent);\n            // correct width to compensate for padding and stuff\n            style.width = ofsW - (tmp.offsetWidth - ofsW) + \"px\";\n\n            // positions before change\n            oldPositions = self.getNodePositions(tmp, origRenderers);\n            // positions when items reordered but deleted items are still in place\n            insertPositions = self.getNodePositions(tmp, newRenderers, withDeletes);\n            // positions after old items removed from dom\n            newPositions = self.getNodePositions(tmp, newRenderers);\n\n            pp.removeChild(tmp);\n            tmp = null;\n\n            for (i = 0, len = newRenderers.length; i < len; i++) {\n                el = newRenderers[i].el;\n                r = newRenderers[i].renderer;\n                id = r.id;\n\n                if (i === 0) {\n                    fl = el.offsetLeft;\n                    ft = el.offsetTop;\n                }\n\n                translates.push([\n                    // to\n                    {\n                        left: (newPositions[id].left - fl) - (insertPositions[id].left - fl),\n                        top: (newPositions[id].top - ft) - (insertPositions[id].top - ft)\n                    },\n                    // from\n                    oldPositions[id] ? //insertPositions[id] &&\n                    {\n                        left: (oldPositions[id].left - fl) - (insertPositions[id].left - fl),\n                        top: (oldPositions[id].top - ft) - (insertPositions[id].top - ft)\n                    } : null\n                ]);\n            }\n\n            return translates;\n        },\n\n        moveAnimation: function(el, to, from, startCallback, applyFrom) {\n\n            var style = el.style;\n\n            applyFrom.done(function(){\n                if (from) {\n                    var prefixes = MetaphorJs.animate.getPrefixes();\n                    style[prefixes.transform] = \"translateX(\"+from.left+\"px) translateY(\"+from.top+\"px)\";\n                }\n            });\n\n            return MetaphorJs.animate.animate(\n                el,\n                \"move\",\n                startCallback,\n                function(el, position, stage){\n                    if (position === 0 && stage !== \"start\" && to) {\n                        var prefixes = MetaphorJs.animate.getPrefixes();\n                        style[prefixes.transform] = \"translateX(\"+to.left+\"px) translateY(\"+to.top+\"px)\";\n                    }\n                });\n        },\n\n        reflectChanges: function(vars) {\n\n            var self            = this,\n                oldRenderers    = vars.oldItems,\n                newRenderers    = vars.newItems,\n                translates,\n                i, len, r;\n\n            self.renderOrUpdate();\n            //self.renderOrUpdate(vars.updateStart, null, \"enter\");\n\n            if (vars.doesMove) {\n                translates = self.calculateTranslates(vars.newItems, vars.origItems, vars.oldItems);\n            }\n\n            var animPromises    = [],\n                startAnimation  = new MetaphorJs.lib.Promise,\n                applyFrom       = new MetaphorJs.lib.Promise,\n                donePromise     = new MetaphorJs.lib.Promise,\n                animReady       = MetaphorJs.lib.Promise.counter(newRenderers.length),\n                startCallback   = function(){\n                    animReady.countdown();\n                    return startAnimation;\n                };\n\n            // destroy old renderers and remove old elements\n            for (i = 0, len = oldRenderers.length; i < len; i++) {\n                r = oldRenderers[i];\n                if (r) {\n                    r.state.$destroy();\n\n                    MetaphorJs.animate.stop(r.el);\n                    animPromises.push(MetaphorJs.animate.animate(r.el, \"leave\")\n                        .done(function(el){\n                            el.style.visibility = \"hidden\";\n                        }));\n                }\n            }\n\n            for (i = 0, len = newRenderers.length; i < len; i++) {\n                r = newRenderers[i];\n                MetaphorJs.animate.stop(r.el);\n\n                r.action === \"enter\" ?\n                animPromises.push(MetaphorJs.animate.animate(r.el, \"enter\", startCallback)) :\n                animPromises.push(\n                    self.moveAnimation(\n                        r.el,\n                        vars.doesMove ? translates[i][0] : null,\n                        vars.doesMove ? translates[i][1] : null,\n                        startCallback,\n                        applyFrom\n                    )\n                );\n            }\n\n            animReady.done(function(){\n                raf(function(){\n                    applyFrom.resolve();\n                    self.applyDomPositions(oldRenderers);\n                    if (!vars.doesMove) {\n                        self.renderOrUpdate(vars.updateStart, null, \"move\");\n                    }\n                    raf(function(){\n                        startAnimation.resolve();\n                    });\n                    self.trigger(\"change\", self);\n                });\n            });\n\n            MetaphorJs.lib.Promise.all(animPromises).always(function(){\n                raf(function(){\n                    var prefixes = MetaphorJs.animate.getPrefixes();\n                    self.renderOrUpdate(vars.updateStart || 0);\n                    self.removeOldElements(oldRenderers);\n                    if (vars.doesMove) {\n                        self.renderOrUpdate(vars.updateStart, null, \"move\");\n                        for (i = 0, len = newRenderers.length; i < len; i++) {\n                            r = newRenderers[i];\n                            if (r && r.el) {\n                                r.el.style[prefixes.transform] = null;\n                                r.el.style[prefixes.transform] = \"\";\n                            }\n                        }\n                    }\n                    donePromise.resolve();\n                });\n            });\n\n            return donePromise;\n\n        }\n    };\n\n\n\n    return cls({\n\n        $class: \"MetaphorJs.plugin.ListAnimated\",\n\n        $init: function(list) {\n\n            list.$implement(methods);\n        }\n\n    });\n\n\n}());","require(\"metaphorjs-promise/src/lib/Promise.js\");\nrequire(\"../func/dom/addListener.js\");\nrequire(\"../func/dom/removeListener.js\");\nrequire(\"../func/dom/getScrollParent.js\");\nrequire(\"../func/dom/addClass.js\");\nrequire(\"../func/dom/getPosition.js\");\nrequire(\"../func/dom/getScrollLeft.js\");\nrequire(\"../func/dom/getScrollTop.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    raf = require('metaphorjs-animate/src/func/raf.js'),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = cls({\n\n    $class: \"MetaphorJs.plugin.ListBuffered\",\n\n    list: null,\n    enabled: true,\n\n    itemSize: null,\n    itemsOffsite: 5,\n    bufferState: null,\n    scrollOffset: 0,\n    horizontal: false,\n    dynamicOffset: false,\n    bufferEventDelegate: null,\n    topStub: null,\n    botStub: null,\n\n    $init: function(list) {\n\n        var self    = this;\n\n        self.list = list;\n\n        list.$intercept(\"afterInit\", this.afterInit, this, \"before\");\n        list.$intercept(\"doRender\", this.doRender, this, \"instead\");\n\n        list.$implement({\n\n            scrollTo: self.$bind(self.scrollTo),\n\n            reflectChanges: function(vars) {\n\n                if (!self.enabled) {\n                    self.$super(vars);\n                }\n                else {\n                    self.getScrollOffset();\n                    list.removeOldElements(vars.oldRenderers);\n                    list.queue.append(self.updateScrollBuffer, self, [true]);\n                    list.trigger(\"change\", list);\n                }\n            }\n        });\n    },\n\n    afterInit: function() {\n\n        var self    = this,\n            attr    = self.list.attr,\n            cfg     = attr ? attr.config : {};\n\n        self.itemSize       = cfg.itemSize;\n        self.itemsOffsite   = parseInt(cfg.itemsOffsite || 5, 10);\n        self.horizontal     = cfg.horizontal || false;\n        self.dynamicOffset  = cfg.dynamicOffset || false;\n\n        self.initScrollParent(cfg);\n        self.initScrollStubs(cfg);\n\n        self.bufferEventDelegate = bind(self.bufferUpdateEvent, self);\n\n        self.up();\n\n        self.list.state.$on(\"freeze\", self.down, self);\n        self.list.state.$on(\"unfreeze\", self.up, self);\n    },\n\n    doRender: function() {\n        this.getScrollOffset();\n        this.updateScrollBuffer();\n    },\n\n    up: function() {\n        var self = this;\n        MetaphorJs.dom.addListener(self.scrollEl, \"scroll\", self.bufferEventDelegate);\n        MetaphorJs.dom.addListener(window, \"resize\", self.bufferEventDelegate);\n    },\n\n    down: function() {\n        var self = this;\n        MetaphorJs.dom.removeListener(self.scrollEl, \"scroll\", self.bufferEventDelegate);\n        MetaphorJs.dom.removeListener(window, \"resize\", self.bufferEventDelegate);\n    },\n\n    initScrollParent: function(cfg) {\n        var self = this;\n        self.scrollEl = MetaphorJs.dom.getScrollParent(self.list.parentEl);\n    },\n\n    initScrollStubs: function(cfg) {\n\n        var self    = this,\n            list    = self.list,\n            parent  = list.parentEl,\n            prev    = list.prevEl,\n            ofsTop,\n            ofsBot,\n            i,\n            style = {\n                fontSize: 0,\n                lineHeight: 0,\n                padding: 0,\n                paddingTop: 0,\n                paddingLeft: 0,\n                paddingBottom: 0,\n                paddingRight: 0,\n                margin: 0,\n                marginLeft: 0,\n                marginTop: 0,\n                marginRight: 0,\n                marginBottom: 0\n            };\n\n        self.topStub       = ofsTop = window.document.createElement(cfg.stub || \"div\");\n        self.botStub       = ofsBot = window.document.createElement(cfg.stub || \"div\");\n\n        MetaphorJs.dom.addClass(ofsTop, \"mjs-buffer-top\");\n        MetaphorJs.dom.addClass(ofsBot, \"mjs-buffer-bottom\");\n        for (i in style) {\n            ofsTop.style[i] = style[i];\n            ofsBot.style[i] = style[i];\n        }\n\n        parent.insertBefore(ofsTop, prev ? prev.nextSibling : parent.firstChild);\n        parent.insertBefore(ofsBot, list.nextEl);\n\n        list.prevEl     = ofsTop;\n        list.nextEl     = ofsBot;\n    },\n\n    getItemsPerRow: function() {\n        return 1;\n    },\n\n    getRowHeight: function() {\n        return this.itemSize;\n    },\n\n    getScrollOffset: function() {\n\n        var self        = this,\n            position    = MetaphorJs.dom.getPosition(self.topStub, self.scrollEl),\n            ofs         = self.horizontal ? position.left : position.top;\n\n        return self.scrollOffset = ofs;\n    },\n\n    getBufferState: function(updateScrollOffset) {\n\n        var self        = this,\n            scrollEl    = self.scrollEl,\n            hor         = self.horizontal,\n            html        = window.document.documentElement,\n            size        = scrollEl === window ?\n                          (window[hor ? \"innerWidth\" : \"innerHeight\"] ||\n                           html[hor ? \"clientWidth\" : \"clientHeight\"]):\n                          scrollEl[hor ? \"offsetWidth\" : \"offsetHeight\"],\n            scroll      = hor ? MetaphorJs.dom.getScrollLeft(scrollEl) : \n                                MetaphorJs.dom.getScrollTop(scrollEl),\n            sh          = scrollEl.scrollHeight,\n            perRow      = self.getItemsPerRow(),\n            isize       = self.getRowHeight(),\n            off         = self.itemsOffsite,\n            offset      = updateScrollOffset ? self.getScrollOffset() : self.scrollOffset,\n            cnt         = Math.ceil(self.list.renderers.length / perRow),\n            viewFirst,\n            viewLast,\n            first,\n            last;\n\n        //scroll  = Math.max(0, scroll - offset);\n        first   = Math.ceil((scroll - offset) / isize);\n\n        if (first < 0) {\n            first = 0;\n        }\n\n        viewFirst = first;\n\n        last    = viewLast = first + Math.ceil(size / isize);\n        first   = first > off ? first - off : 0;\n        last   += off;\n\n        if (last > cnt - 1) {\n            last = cnt - 1;\n        }\n\n        if (sh && scroll + size >= sh && self.bufferState) {\n            if (self.bufferState.last == last * perRow) {\n                last += off;\n            }\n        }\n\n        if (first > last) {\n            return self.bufferState;\n        }\n\n        return self.bufferState = {\n            first: first * perRow,\n            viewFirst: viewFirst * perRow,\n            last: last * perRow,\n            viewLast: viewLast * perRow,\n            ot: first * isize,\n            ob: (cnt - last - 1) * isize\n        };\n    },\n\n    updateStubs: function(bs) {\n        var self        = this,\n            hor         = self.horizontal;\n\n        self.topStub.style[hor ? \"width\" : \"height\"] = bs.ot + \"px\";\n        self.botStub.style[hor ? \"width\" : \"height\"] = bs.ob + \"px\";\n    },\n\n    bufferUpdateEvent: function() {\n        var self = this;\n        self.list.queue.add(self.updateScrollBuffer, self);\n    },\n\n\n    updateScrollBuffer: function(reset) {\n\n        var self        = this,\n            list        = self.list,\n            prev        = self.bufferState,\n            parent      = list.parentEl,\n            rs          = list.renderers,\n            bot         = self.botStub,\n            bs          = self.getBufferState(self.dynamicOffset),\n            promise     = new MetaphorJs.lib.Promise,\n            doc         = window.document,\n            fragment,\n            i, x, r;\n\n        if (!bs) {\n            return null;\n        }\n\n        if (!prev || bs.first != prev.first || bs.last != prev.last) {\n            list.trigger(\"buffer-change\", self, bs, prev);\n        }\n\n        raf(function(){\n\n            if (self.$isDestroyed()) {\n                return;\n            }\n\n            //TODO: account for tag mode\n\n            if (reset || !prev || bs.last < prev.first || bs.first > prev.last){\n\n                //remove old and append new\n                if (prev) {\n                    for (i = prev.first, x = prev.last; i <= x; i++) {\n                        r = rs[i];\n                        if (r && r.attached) {\n                            parent.removeChild(r.el);\n                            r.attached = false;\n                        }\n                    }\n                }\n                fragment = doc.createDocumentFragment();\n                for (i = bs.first, x = bs.last; i <= x; i++) {\n                    r = rs[i];\n                    if (r) {\n                        if (!r.rendered) {\n                            list.renderItem(i);\n                        }\n                        fragment.appendChild(r.el);\n                        r.attached = true;\n                    }\n                }\n\n                parent.insertBefore(fragment, bot);\n\n            }\n            else {\n\n                if (prev.first < bs.first) {\n                    for (i = prev.first, x = bs.first; i < x; i++) {\n                        r = rs[i];\n                        if (r && r.attached) {\n                            parent.removeChild(r.el);\n                            r.attached = false;\n                        }\n                    }\n                }\n                else if (prev.first > bs.first) {\n                    fragment = doc.createDocumentFragment();\n                    for (i = bs.first, x = prev.first; i < x; i++) {\n                        r = rs[i];\n                        if (r) {\n                            if (!r.rendered) {\n                                list.renderItem(i);\n                            }\n                            fragment.appendChild(r.el);\n                            r.attached = true;\n                        }\n                    }\n                    parent.insertBefore(fragment, rs[prev.first].el);\n                }\n\n                if (prev.last < bs.last) {\n                    fragment = doc.createDocumentFragment();\n                    for (i = prev.last + 1, x = bs.last; i <= x; i++) {\n                        r = rs[i];\n                        if (r) {\n                            if (!r.rendered) {\n                                list.renderItem(i);\n                            }\n                            fragment.appendChild(r.el);\n                            r.attached = true;\n                        }\n                    }\n                    parent.insertBefore(fragment, bot);\n                }\n                else if (prev.last > bs.last) {\n                    for (i = bs.last + 1, x = prev.last; i <= x; i++) {\n                        r = rs[i];\n                        if (r && r.attached) {\n                            parent.removeChild(r.el);\n                            r.attached = false;\n                        }\n                    }\n                }\n            }\n\n            self.updateStubs(bs);\n            list.trigger(\"buffer-update\", self);\n            self.onBufferStateChange(bs, prev);\n\n            promise.resolve();\n        });\n\n        return promise;\n    },\n\n    // not finished: todo unbuffered and animation\n    scrollTo: function(index) {\n\n        var self    = this,\n            list    = self.list,\n            isize   = self.itemSize,\n            sp      = self.scrollEl || MetaphorJs.dom.getScrollParent(list.parentEl),\n            hor     = self.horizontal,\n            prop    = hor ? \"scrollLeft\" : \"scrollTop\",\n            promise = new MetaphorJs.lib.Promise,\n            pos;\n\n\n        list.queue.append(function(){\n\n            raf(function(){\n                pos     = isize * index;\n                if (sp === window) {\n                    window.scrollTo(\n                        hor ? pos : MetaphorJs.dom.getScrollLeft(),\n                        !hor ? pos : MetaphorJs.dom.getScrollTop()\n                    );\n                }\n                else {\n                    sp[prop] = pos;\n                }\n                promise.resolve();\n            });\n            return promise;\n        });\n\n\n        return promise;\n    },\n\n    onBufferStateChange: function(bs, prev) {},\n\n\n    $beforeHostDestroy: function() {\n\n        var self = this,\n            parent = self.list.parentEl;\n\n        parent.removeChild(self.topStub);\n        parent.removeChild(self.botStub);\n        self.down();\n    }\n});","\nrequire(\"./ListBuffered.js\");\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\n\nmodule.exports = MetaphorJs.plugin.ListBuffered.$extend({\n\n    $class: \"MetaphorJs.plugin.ListPullNext\",\n    buffered: false,\n\n    $init: function(list, args) {\n\n        var attr = list.attr,\n            cfg = attr ? attr.config : {};\n\n        if (cfg.bufferedPullNext) {\n            this.buffered = cfg.bufferedPullNext;\n            list.buffered = true;\n        }\n\n        this.$super(list, args);\n    },\n\n    afterInit: function() {\n\n        this.$super();\n        this.getScrollOffset();\n    },\n\n    updateScrollBuffer: function(reset) {\n\n        var self = this;\n\n        if (self.buffered) {\n            return self.$super(reset);\n        }\n        else {\n            var prev    = self.bufferState,\n                bs      = self.getBufferState(self.dynamicOffset);\n\n            if (!prev || bs.first != prev.first || bs.last != prev.last) {\n                self.list.trigger(\"buffer-change\", self, bs, prev);\n                self.onBufferStateChange(bs, prev);\n            }\n        }\n    },\n\n    onBufferStateChange: function(bs, prev) {\n\n        var self = this,\n            list = self.list,\n            cnt = list.store.getLength();\n\n        self.$super(bs, prev);\n\n        if (cnt - bs.last < (bs.last - bs.first) / 3 && !list.store.loading && !list.store.$destroyed) {\n            list.store.addNextPage();\n            list.trigger(\"pull\", self);\n        }\n    }\n\n\n});","require(\"metaphorjs-shared/src/lib/Queue.js\");\nrequire(\"../func/dom/getScrollParent.js\");\nrequire(\"../func/dom/getPosition.js\");\nrequire(\"../func/dom/getScrollTop.js\");\nrequire(\"../func/dom/getScrollLeft.js\");\nrequire(\"../func/dom/getWidth.js\");\nrequire(\"../func/dom/getHeight.js\");\nrequire(\"../func/dom/addListener.js\");\nrequire(\"../func/dom/removeListener.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    bind = require(\"metaphorjs-shared/src/func/bind.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = cls({\n\n    $class: \"MetaphorJs.plugin.SrcDeferred\",\n\n    directive: null,\n\n    queue: null,\n    scrollEl: null,\n    scrollDelegate: null,\n    resizeDelegate: null,\n    position: null,\n    sw: null,\n    sh: null,\n    checkVisibility: true,\n\n    $init: function(directive) {\n\n        var self = this;\n        self.directive = directive;\n        directive.$intercept(\"onStateChange\", self.onStateChange, self, \"instead\");\n        directive.$intercept(\"initDirective\", self.$initDirective, self, \"before\");\n        self.queue = \n            directive.queue || \n            new MetaphorJs.lib.Queue({auto: true, async: true, \n                            mode: MetaphorJs.lib.Queue.REPLACE, thenable: true});\n    },\n\n    $initDirective: function() {\n\n        var self = this;\n\n        self.scrollEl = MetaphorJs.dom.getScrollParent(self.directive.node);\n        self.scrollDelegate = bind(self.onScroll, self);\n        self.resizeDelegate = bind(self.onResize, self);\n\n        MetaphorJs.dom.addListener(self.scrollEl, \"scroll\", self.scrollDelegate);\n        MetaphorJs.dom.addListener(window, \"resize\", self.resizeDelegate);\n    },\n\n    isVisible: function() {\n\n        if (!this.checkVisibility) {\n            return true;\n        }\n\n        var self = this,\n            sEl = self.scrollEl,\n            st = MetaphorJs.dom.getScrollTop(sEl),\n            sl = MetaphorJs.dom.getScrollLeft(sEl),\n            w = self.sw,\n            h = self.sh,\n            t,l;\n\n        if (!self.position) {\n            self.position = MetaphorJs.dom.getPosition(self.directive.node, sEl);\n        }\n        if (!w) {\n            w = self.sw = MetaphorJs.dom.getWidth(sEl);\n            h = self.sh = MetaphorJs.dom.getHeight(sEl);\n        }\n\n        t = self.position.top;\n        l = self.position.left;\n\n        return (t > st && t < (st + h)) &&\n               (l > sl && l < (sl + w));\n    },\n\n    onScroll: function() {\n        var self = this;\n        self.queue.add(self.changeIfVisible, self);\n    },\n\n    onResize: function() {\n        var self = this;\n        self.position = null;\n        self.sw = null;\n        self.queue.add(self.changeIfVisible, self);\n    },\n\n    onStateChange: function() {\n        var self = this;\n        self.queue.add(self.changeIfVisible, self);\n    },\n\n    changeIfVisible: function() {\n        var self    = this;\n\n        if (self.isVisible()) {\n            self.stopWatching();\n            return self.directive.doChange();\n        }\n    },\n\n    stopWatching: function() {\n        var self = this;\n        if (self.scrollEl) {\n            MetaphorJs.dom.removeListener(self.scrollEl, \"scroll\", self.scrollDelegate);\n            MetaphorJs.dom.removeListener(window, \"resize\", self.resizeDelegate);\n            self.scrollEl = null;\n            self.checkVisibility = false;\n        }\n    },\n\n    $beforeHostDestroy: function(){\n        this.stopWatching();\n        this.queue.$destroy();\n    }\n\n});","\nrequire(\"../lib/Expression.js\");\nrequire(\"../func/dom/getAttr.js\");\nrequire(\"../func/dom/removeStyle.js\");\n\nconst cls = require(\"metaphorjs-class/src/cls.js\"),\n    MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = cls({\n\n    $class: \"MetaphorJs.plugin.SrcSize\",\n    directive: null,\n\n    width: null,\n    height: null,\n\n    origOnChange: null,\n\n    $init: function(directive) {\n\n        var self = this;\n        self.directive = directive;\n\n        directive.$intercept(\"initDirective\", self.$initDirective, self, \"after\");\n        self.origOnChange = directive.$intercept(\"onSrcChanged\", self.onSrcChanged, self, \"after\");\n    },\n\n    $initDirective: function() {\n\n        var attr    = self.directive.attr,\n            node    = self.directive.node,\n            state   = self.directive.state,\n            cfg     = attr ? attr.config : {},\n            size    = cfg.preloadSize,\n            style   = node.style;\n\n        if (size !== \"attr\") {\n            size    = MetaphorJs.lib.Expression.parse(size)(state);\n        }\n\n        var width   = size === \"attr\" ? parseInt(MetaphorJs.dom.getAttr(node, \"width\"), 10) : size.width,\n            height  = size === \"attr\" ? parseInt(MetaphorJs.dom.getAttr(node, \"height\"), 10) : size.height;\n\n        if (width || height) {\n            style.display = \"block\";\n        }\n\n        if (width) {\n            style.width = width + \"px\";\n        }\n        if (height) {\n            style.height = height + \"px\";\n        }\n    },\n\n    onSrcChanged: function() {\n\n        var self        = this,\n            directive   = self.directive,\n            node        = directive.node;\n\n        directive.onSrcChanged = self.origOnChange;\n\n        MetaphorJs.dom.removeStyle(node, \"width\");\n        MetaphorJs.dom.removeStyle(node, \"height\");\n        MetaphorJs.dom.removeStyle(node, \"display\");\n\n        self.$destroy();\n    }\n\n});","\n\nconst MetaphorJs = require(\"metaphorjs-shared/src/MetaphorJs.js\");\n\nmodule.exports = MetaphorJs.dom.htmlTags = [\n    \"a\",\n    \"abbr\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"base\",\n    \"bdi\",\n    \"bdo\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"em\",\n    \"embed\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"iframe\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"keygen\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"link\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"math\",\n    \"menu\",\n    \"menuitem\",\n    \"meta\",\n    \"meter\",\n    \"nav\",\n    \"noscript\",\n    \"object\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"param\",\n    \"picture\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rb\",\n    \"rp\",\n    \"rt\",\n    \"rtc\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"script\",\n    \"section\",\n    \"select\",\n    \"slot\",\n    \"small\",\n    \"source\",\n    \"span\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"svg\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"template\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"title\",\n    \"tr\",\n    \"track\",\n    \"u\",\n    \"ul\",\n    \"var\",\n    \"video\",\n    \"wbr\"\n];","const MetaphorJs = require(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-shared/src/MetaphorJs.js\");\nMetaphorJs.prebuilt = {\"templates\":{\"ui/button/button-container.html\":\"<div ##main><!--##before--> <span {bind}=\\\"this.$cfg.text\\\"></span><!--##after--></div>\",\"ui/button/button-plain.html\":\"<a ##main><!--##before--> <span {bind}=\\\"this.$cfg.text\\\"></span><!--##after--></a>\",\"ui/button/button.html\":\"<!--<main ##button\\n    ##body\\n    class=\\\"ui button\\\" \\n    {class.active}=\\\"this.$cfg.active\\\"\\n    {class.loading}=\\\"this.$cfg.loading\\\"\\n    {class.disabled}=\\\"this.$cfg.disabled\\\"\\n    {class.dropdown}=\\\"this.button.hasDropdown()\\\"\\n    (click)=\\\"this.button.onClick(this.$event)\\\"\\n    (click.$if)=\\\"!this.$cfg.disabled && !this.$cfg.loading\\\">--><mjs-include $name*=\\\"this.button.hasDropdown() ? \\n                    'ui/button/button-container.html' : \\n                    'ui/button/button-plain.html'\\\"></mjs-include>\",\"ui/button/group.html\":\"<div class=\\\"ui buttons\\\" ##body></div>\",\"ui/dialog/color-picker.html\":\"<div class=\\\"section\\\"></div>\",\"ui/field/checkbox.html\":\"<div ##main class=\\\"ui checkbox\\\" {class.active}=\\\"this.$cfg.active\\\"><input type=\\\"checkbox\\\" [name]=\\\"this.$cfg.name\\\" {model}=\\\"this.checked\\\"> <label {bind}=\\\"this.$cfg.label\\\"></label></div>\",\"ui/field/input.html\":\"<div class=\\\"ui input\\\" ##main ##body><!--##before--> <input ##input [type]=\\\"this.$cfg.type\\\" [placeholder]=\\\"this.$cfg.placeholder\\\"><!--##after--></div>\",\"ui/field/select.html\":\"<div ##main class=\\\"ui dropdown selection\\\" (click)=\\\"this.$view.onSelfClick(this.$event)\\\" {init}=\\\"this.emptyShown = false; this.selectedShown = false;\\\" {class.loading}=\\\"this.loading\\\" {class.active}=\\\"this.opened\\\" {class.disabled}=\\\"this.$cfg.disabled\\\" {class.search}=\\\"this.$cfg.searchable\\\" {class.fluid}=\\\"this.$cfg.fluid\\\" {class.multiple}=\\\"this.field.isMultiSelection()\\\"><!--##before--> <input type=\\\"hidden\\\" ##hidden_field [name]=\\\"this.$cfg.name\\\" [value]=\\\"this.field.$$selection | join:','\\\"> <i ##icon_down class=\\\"dropdown icon\\\" (click)=\\\"this.$view.onDropdownIconClick(this.$event)\\\"></i> <a class=\\\"ui label transition\\\" {each}=\\\"item in this.field.getMultiSelection()\\\">{{ this.$parent.field.getItemName(this.item) }} <i class=\\\"delete icon\\\" (click)=\\\"this.$parent.$view.onItemDeleteClick(this.item, this.$event)\\\"></i> </a><input type=\\\"text\\\" ##search class=\\\"search\\\" [placeholder]=\\\"this.$cfg.placeholder\\\" {readonly}=\\\"this.$cfg.readonly\\\" {disabled}=\\\"this.$cfg.disabled\\\" {show}=\\\"this.$cfg.searchable\\\" {show.$display}=\\\"inline-block\\\" (focus)=\\\"this.$view.onSearchFocus(this.$event)\\\" (blur)=\\\"this.$view.onSearchBlur(this.$event)\\\" (key.backspace)=\\\"this.$view.onSearchBackspace(this.$event)\\\" {model}=\\\"this.searchQuery\\\"> <span class=\\\"sizer\\\" ##sizer {if}=\\\"this.field.isMultiSelection() && this.$cfg.searchable\\\" {bind}=\\\"this.searchQuery\\\"></span><div class=\\\"default text\\\" ##default_text (click)=\\\"this.$view.onValueTextClick(this.$event)\\\" {show}=\\\"!this.searchQuery && !this.field.hasSelection() &&\\n                    !!this.$cfg.emptyText\\\" {show.$display}=\\\"inline-block\\\" {show.$on--change}=\\\"this.emptyShown = this.$1\\\" {bind}=\\\"this.$cfg.emptyText\\\"></div><div class=\\\"text\\\" ##text (click)=\\\"this.$view.onValueTextClick(this.$event)\\\" {class.default}=\\\"this.focused && this.searchQuery == ''\\\" {show}=\\\"!this.searchQuery && !this.field.isMultiSelection() && \\n                    this.field.hasSelection()\\\" {show.$on--change}=\\\"this.selectedShown = this.$1\\\" {show.$display}=\\\"inline-block\\\" {bind-html}=\\\"this.field.getSelectedName() || '&nbsp;'\\\"></div><i class=\\\"delete icon\\\" ##icon_delete {if}=\\\"this.$cfg.showSingleClear && !this.field.isMultiSelection() && this.field.hasSelection()\\\" (click)=\\\"this.$view.onItemDeleteClick(this.field.getSelection(0), this.$event)\\\"></i><!-- replaces two previous text blocks with invisible placeholder --><div style=\\\"display: none\\\" class=\\\"default text\\\" {show}=\\\"!this.emptyShown && !this.selectedShown && !this.$cfg.searchable\\\" {show.$display}=\\\"inline-block\\\">&nbsp;</div><select ##hidden_select (click)=\\\"this.$view.onHiddenSelectClick(this.$event)\\\" (change)=\\\"this.$view.onHiddenSelectChange(this.$event)\\\" {if}=\\\"this.$cfg.useHiddenSelect\\\" {options}=\\\"this.field._getSelectOptions()\\\"></select><div class=\\\"menu transition\\\" ##menu_items><div class=\\\"disabled item\\\" ##menu_disabled {if}=\\\"this.$cfg.showNotFound && this.field.store.isEmpty()\\\" (click.$stop-propagation) {bind-html}=\\\"this.$cfg.notFoundText\\\"></div><a class=\\\"empty item\\\" href=\\\"#\\\" ##menu_empty {if}=\\\"this.$cfg.showEmptyItem && !this.field.store.isEmpty()\\\" (click)=\\\"this.$view.onItemClick(null, this.$event)\\\" {bind-html}=\\\"this.$cfg.emptyItemText\\\"></a> <a class=\\\"item\\\" href=\\\"#\\\" {each}=\\\"item in this.field.store\\\" (click)=\\\"this.$parent.$view.onItemClick(this.item, this.$event)\\\" {bind}=\\\"this.$parent.field.getItemName(this.item)\\\"></a><!--##pagination--></div><!--##after--></div>\",\"ui/menu/container.html\":\"<div ##main class=\\\"ui item\\\" {class.active}=\\\"this.$cfg.active\\\" {class.dropdown}=\\\"this.item.hasDropdown()\\\"><!--##before--><!--##body--><!--##after--></div>\",\"ui/menu/divider.html\":\"<div class=\\\"divider\\\" ##main></div>\",\"ui/menu/item-with-sub.html\":\"<div ##main class=\\\"ui item\\\" {class.active}=\\\"this.$cfg.active\\\" {class.dropdown}=\\\"this.item.hasDropdown()\\\" (click)=\\\"this.item.onClick(this.$event)\\\"><!--##before--> <span {bind}=\\\"this.$cfg.text\\\"></span><!--##body--><!--##after--></div>\",\"ui/menu/item.html\":\"<a ##main class=\\\"item\\\" {class.active}=\\\"this.$cfg.active\\\" (click)=\\\"this.item.onClick(this.$event)\\\"><!--##before--> <span {bind}=\\\"this.$cfg.text\\\"></span><!--##body--><!--##after--></a>\",\"ui/menu/menu.html\":\"<div ##main class=\\\"ui menu\\\"><!--##before--><!--##body--><!--##after--></div>\",\"ui/panel/panel.html\":\"<div class=\\\"ui segment\\\"><!--##tbar--><!--##bbar--></div>\",\"ui/toolbar/container.html\":\"<!--{includes: true}--><!-- include ui/menu/container.html -->\",\"ui/toolbar/divider.html\":\"<!--{includes: true}--><!-- include ui/menu/divider.html -->\",\"ui/toolbar/item-with-sub.html\":\"<!--{includes: true}--><!-- include ui/menu/item-with-sub.html -->\",\"ui/toolbar/item.html\":\"<!--{includes: true}--><!-- include ui/menu/item.html -->\",\"ui/toolbar/toolbar.html\":\"<!--{includes: true}--><!-- include ui/menu/menu.html -->\",\"ui/util/canvas.html\":\"<canvas ##main ##canvas {style.width}=\\\"this.$cfg.width + 'px'\\\" {style.height}=\\\"this.$cfg.height + 'px'\\\"></canvas>\",\"ui/util/color-picker.html\":\"<div ##main><div style=\\\"width:50px; height: 30px;\\\" {style.background-color}=\\\"'#'+this.sv\\\"></div><ui-color-sv $ref=\\\"sv\\\" $width=\\\"150\\\" $height=\\\"150\\\" $cursor=\\\"crosshair\\\" $color!=\\\"this.color\\\" {model}=\\\"this.sv\\\" {model.$binding}=\\\"input\\\" {bind}=\\\"this.hue\\\"></ui-color-sv><ui-color-hue $ref=\\\"hue\\\" $width=\\\"30\\\" $height=\\\"150\\\" $cursor=\\\"crosshair\\\" $color!=\\\"this.color\\\" {model}=\\\"this.hue\\\" {model.$binding}=\\\"input\\\"></ui-color-hue><div style=\\\"clear:both\\\">HEX: <input type=\\\"text\\\" {bind}=\\\"this.color.getHEX()\\\" {bind.$preserve-input} {model}=\\\"this.input.hex\\\" {model.$binding}=\\\"input\\\" {model.$focus-only}><br>R: <input type=\\\"number\\\" {model}=\\\"this.input.r\\\" {model.$binding}=\\\"input\\\" {model.$focus-only} {bind}=\\\"this.color.getRGBA()[0]\\\" {bind.$preserve-input} min=\\\"0\\\" max=\\\"255\\\"> G: <input type=\\\"number\\\" {model}=\\\"this.input.g\\\" {model.$binding}=\\\"input\\\" {model.$focus-only} {bind}=\\\"this.color.getRGBA()[1]\\\" {bind.$preserve-input} min=\\\"0\\\" max=\\\"255\\\"> B: <input type=\\\"number\\\" {model}=\\\"this.input.b\\\" {model.$binding}=\\\"input\\\" {model.$focus-only} {bind}=\\\"this.color.getRGBA()[2]\\\" {bind.$preserve-input} min=\\\"0\\\" max=\\\"255\\\"><br>H: <input type=\\\"number\\\" {model}=\\\"this.input.h\\\" {model.$binding}=\\\"input\\\" {model.$focus-only} {bind}=\\\"this.color.getHSVA()[0]\\\" {bind.$preserve-input} min=\\\"0\\\" max=\\\"360\\\"> S: <input type=\\\"number\\\" {model}=\\\"this.input.s\\\" {model.$binding}=\\\"input\\\" {model.$focus-only} {bind}=\\\"this.color.getHSVA()[1]\\\" {bind.$preserve-input} min=\\\"0\\\" max=\\\"100\\\"> V: <input type=\\\"number\\\" {model}=\\\"this.input.v\\\" {model.$binding}=\\\"input\\\" {model.$focus-only} {bind}=\\\"this.color.getHSVA()[2]\\\" {bind.$preserve-input} min=\\\"0\\\" max=\\\"100\\\"><br></div></div>\",\"ui/util/color.html\":\"<div ##main style=\\\"position:relative\\\" {style.width}=\\\"this.$cfg.width + 'px'\\\" {style.height}=\\\"this.$cfg.height + 'px'\\\"><i ##pointer {style.left}=\\\"this.pointerLeft\\\" {style.top}=\\\"this.pointerTop\\\"></i><canvas ##canvas {style.width}=\\\"this.$cfg.width + 'px'\\\" {style.height}=\\\"this.$cfg.height + 'px'\\\" {style.cursor}=\\\"this.$cfg.cursor\\\"></canvas></div>\",\"ui/util/pagination.html\":\"<div class=\\\"pagination\\\" ##main><!--##before--><div class=\\\"item\\\" {if}=\\\"!this.$cfg.simple\\\">{{ this.page }} of {{ this.pages }}</div><div class=\\\"item\\\" {if}=\\\"!!this.$cfg.simple\\\">{{ this.start + 1 }} &nbsp;&mdash;&nbsp;{{ this.end }}</div><a href=\\\"#\\\" class=\\\"arrow item\\\" ##arrow_left {class.disabled}=\\\"!this.hasPrev || this.loading\\\" [disabled]=\\\"!this.hasPrev || this.loading\\\" (click)=\\\"this.pgn.onPrevClick()\\\"></a><div class=\\\"item\\\" {if}=\\\"!this.$cfg.simple\\\">Page&nbsp; <input type=\\\"text\\\" ##input {model}=\\\"this.changePage\\\" (key.enter)=\\\"this.pgn.onPageKeyDown()\\\"></div><a href=\\\"#\\\" class=\\\"arrow item\\\" ##arrow_right {class.disabled}=\\\"!this.hasNext || this.loading\\\" [disabled]=\\\"!this.hasNext || this.loading\\\" (click)=\\\"this.pgn.onNextClick()\\\"></a><!--##after--></div>\",\"ui/window/window.html\":\"<div class=\\\"ui modal\\\" ##body></div>\",\"container1.html\":\"<div class=\\\"toolbar\\\" ##toolbar>Toolbar here</div><div class=\\\"body\\\">This is a body wrapper<div class=\\\"items\\\" ##body>This is the body</div></div><div class=\\\"fbar\\\" ##footer>Footer here</div>\",\"container2.html\":\"<div ##main>This is parent 3 (container2.html)<div ##body></div></div>\"}}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const MetaphorJs = require(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-shared/src/MetaphorJs.js\");\nrequire(\"/tmp/wp-prebuilt-1656071342820.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-shared/src/MetaphorJs.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/__init.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/App.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/Component.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/component/View.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/Container.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/Controller.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/Directive.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/ListRenderer.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/Renderer.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/StoreRenderer.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/Template.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/view/Base.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/view/Component.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/app/view/Router.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/app.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/autofocus.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/bind-html.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/bind.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/class.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/cmp.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/controller.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/each.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/events.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/focused.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/hide.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/if.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/include.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/init.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/input.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/key.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/model.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/options.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/properties.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/router.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/show.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/source-src.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/src.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/state.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/style.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/transclude.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/attr/view.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/directive/tag/transclude.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/__init.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/collect.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/filter.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/get.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/join.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/l.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/limitTo.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/linkify.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/lowercase.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/map.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/moment.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/numeral.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/offset.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/p.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/pl.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/preloaded.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/r.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/sortBy.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/split.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/toArray.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/ucfirst.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/filter/uppercase.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/bootstrap/apps.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-model/src/__init.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-model/src/directive/attr/each.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-model/src/model/Model.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-model/src/model/Record.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-model/src/model/Store.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-validator/src/directive/form.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-validator/src/directive/validate.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/plugin/ListAnimated.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/plugin/ListBuffered.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/plugin/ListPullNext.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/plugin/SrcDeferred.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/plugin/SrcSize.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/extra-directives/attr/break-if.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/extra-directives/attr/ignore.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/extra-directives/attr/stylesheet.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/extra-directives/attr/update-on.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/extra-directives/tag/bind-html.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/extra-directives/tag/bind.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/extra-directives/tag/if.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/extra-directives/tag/include.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs/src/extra-directives/tag/tag.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/button/Button.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/button/Group.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/button/Split.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/dialog/Alert.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/dialog/ColorPicker.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/dialog/Confirm.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/dialog/Popup.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/dialog/Window.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/field/Checkbox.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/field/Field.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/field/Input.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/field/Radio.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/field/Select.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/field/view/Select.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/menu/Divider.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/menu/Item.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/menu/Menu.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/mixin/Selectable.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/mixin/WithActiveState.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/mixin/WithDisabledState.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/mixin/WithDropdown.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/mixin/WithLoadingState.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/mixin/WithText.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/panel/Panel.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/toolbar/Divider.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/toolbar/Item.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/toolbar/Toolbar.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/util/Canvas.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/util/Color.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/util/ColorAlpha.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/util/ColorHue.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/util/ColorPicker.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/util/ColorSV.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/util/Pagination.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/src/ui/window/Window.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-dialog/src/directive/dropdown.js\");\nrequire(\"/Users/kuindji/Projects/metaphorjs/metaphorjs-ui/dev-test/container.js\");\n"],"names":[],"sourceRoot":""}