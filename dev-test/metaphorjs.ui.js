/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../metaphorjs-animate/src/animate/__init.js":
/*!***************************************************!*\
  !*** ../metaphorjs-animate/src/animate/__init.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

MetaphorJs.animate = MetaphorJs.animate || {};

/***/ }),

/***/ "../metaphorjs-animate/src/animate/animate.js":
/*!****************************************************!*\
  !*** ../metaphorjs-animate/src/animate/animate.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs-animate/src/animate/__init.js");

__webpack_require__(/*! ./getDuration.js */ "../metaphorjs-animate/src/animate/getDuration.js");

__webpack_require__(/*! ./isCssSupported.js */ "../metaphorjs-animate/src/animate/isCssSupported.js");

__webpack_require__(/*! ./easing.js */ "../metaphorjs-animate/src/animate/easing.js");

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

__webpack_require__(/*! metaphorjs/src/func/dom/data.js */ "../metaphorjs/src/func/dom/data.js");

__webpack_require__(/*! metaphorjs/src/func/dom/addClass.js */ "../metaphorjs/src/func/dom/addClass.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeClass.js */ "../metaphorjs/src/func/dom/removeClass.js");

const isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      isThenable = __webpack_require__(/*! metaphorjs-shared/src/func/isThenable.js */ "../metaphorjs-shared/src/func/isThenable.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isPlainObject = __webpack_require__(/*! metaphorjs-shared/src/func/isPlainObject.js */ "../metaphorjs-shared/src/func/isPlainObject.js"),
      raf = __webpack_require__(/*! ../func/raf.js */ "../metaphorjs-animate/src/func/raf.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.animate.animate = function () {
  var types = {
    "show": ["mjs-show"],
    "hide": ["mjs-hide"],
    "enter": ["mjs-enter"],
    "leave": ["mjs-leave"],
    "move": ["mjs-move"]
  },
      animId = 0,
      dataParam = "mjsAnimationQueue",
      callTimeout = function (fn, startTime, duration) {
    var tick = function () {
      var time = new Date().getTime();

      if (time - startTime >= duration) {
        fn();
      } else {
        raf(tick);
      }
    };

    raf(tick);
  },
      nextInQueue = function (el) {
    var queue = MetaphorJs.dom.data(el, dataParam),
        next;

    if (queue.length) {
      next = queue[0];
      animationStage(next.el, next.stages, 0, next.start, next.deferred, false, next.id, next.step);
    } else {
      MetaphorJs.dom.data(el, dataParam, null);
    }
  },
      animationStage = function animationStage(el, stages, position, startCallback, deferred, first, id, stepCallback) {
    var stopped = function () {
      var q = MetaphorJs.dom.data(el, dataParam);

      if (!q || !q.length || q[0].id != id) {
        deferred.reject(el);
        return true;
      }

      return false;
    };

    var finishStage = function () {
      if (stopped()) {
        return;
      }

      var thisPosition = position;
      position++;

      if (position === stages.length) {
        deferred.resolve(el);
        MetaphorJs.dom.data(el, dataParam).shift();
        nextInQueue(el);
      } else {
        MetaphorJs.dom.data(el, dataParam)[0].position = position;
        animationStage(el, stages, position, null, deferred, false, id, stepCallback);
      }

      MetaphorJs.dom.removeClass(el, stages[thisPosition]);
      MetaphorJs.dom.removeClass(el, stages[thisPosition] + "-active");
    };

    var setStage = function () {
      if (!stopped()) {
        MetaphorJs.dom.addClass(el, stages[position] + "-active");
        MetaphorJs.lib.Promise.resolve(stepCallback && stepCallback(el, position, "active")).done(function () {
          if (!stopped()) {
            var duration = MetaphorJs.animate.getDuration(el);

            if (duration) {
              callTimeout(finishStage, new Date().getTime(), duration);
            } else {
              raf(finishStage);
            }
          }
        });
      }
    };

    var start = function () {
      if (!stopped()) {
        MetaphorJs.dom.addClass(el, stages[position]);
        MetaphorJs.lib.Promise.waterfall([stepCallback && stepCallback(el, position, "start"), function () {
          return startCallback ? startCallback(el) : null;
        }]).done(function () {
          !stopped() && raf(setStage);
        });
      }
    };

    first ? raf(start) : start();
  },
      jsAnimation = function (el, animation, deferred, startCallback, stepCallback) {
    var duration = animation.duration || 500,
        timingFn = animation.timing || "linear",
        from = animation.from,
        to = animation.to,
        draw = animation.draw;
    timingFn = typeof timingFn === "string" ? MetaphorJs.animate.easing[timingFn] : timingFn;

    if (!timingFn) {
      throw new Error("Missing easing function " + animation.timing);
    }

    typeof from === "function" && (from = from(el));
    typeof to === "function" && (to = to(el));

    var calc = animation.calc || function (from, to, frac) {
      return from + (to - from) * frac;
    };

    var apply = function (progress) {
      var res;

      if (isPlainObject(to)) {
        res = {};

        for (var k in to) {
          res[k] = calc(from[k], to[k], progress, k);
        }
      } else {
        res = calc(from, to, progress);
      }

      draw(el, res);
      stepCallback && stepCallback(el, res);
    };

    var step = function () {
      // timeFraction goes from 0 to 1
      var time = new Date().getTime();
      var timeFraction = (time - start) / duration;
      if (timeFraction > 1) timeFraction = 1; // calculate the current animation state

      var progress = timingFn(timeFraction);
      apply(progress); // draw it

      if (timeFraction < 1) {
        raf(step);
      } else {
        deferred.resolve(el);
      }
    };

    var start = new Date().getTime();
    startCallback && startCallback(el);
    step(start);
  };
  /**
   * @function MetaphorJs.animate.animate
   * @param {HTMLElement} el Element being animated
   * @param {string|function|[]|object} animation {
   *  'string' - registered animation name,<br>
   *  'function' - fn(el, callback) - your own animation<br>
   *  'array' - array or stages (class names)<br>
   *  'array' - [{before}, {after}] - jquery animation<br>
   *  'object' - {stages, fn, before, after, options, context, duration, start}
   * }
   * @param {function} startCallback call this function before animation begins
   * @param {function} stepCallback call this function between stages
   * @returns {MetaphorJs.lib.Promise}
   */


  var animate = function animate(el, animation, startCallback, stepCallback) {
    var deferred = new MetaphorJs.lib.Promise(),
        queue = MetaphorJs.dom.data(el, dataParam) || [],
        id = ++animId,
        stages,
        jsFn,
        before,
        after,
        options,
        context,
        duration;

    if (animation) {
      if (isString(animation)) {
        stages = types[animation];
      } else if (isFunction(animation)) {
        jsFn = animation;
      } else if (isArray(animation)) {
        if (isString(animation[0])) {
          stages = animation;
        } else {
          before = animation[0];
          after = animation[1];
        }
      } else if (isPlainObject(animation)) {
        stages = animation.stages;
        jsFn = animation.fn;
        before = animation.before;
        after = animation.after;
        options = animation.options ? extend({}, animation.options) : {};
        context = animation.context || null;
        duration = animation.duration || null;
        startCallback = startCallback || options.start;
      }

      if (MetaphorJs.animate.isCssSupported() && stages) {
        queue.push({
          el: el,
          stages: stages,
          start: startCallback,
          step: stepCallback,
          deferred: deferred,
          position: 0,
          id: id
        });
        MetaphorJs.dom.data(el, dataParam, queue);

        if (queue.length === 1) {
          animationStage(el, stages, 0, startCallback, deferred, true, id, stepCallback);
        }

        return deferred;
      } else if (animation.draw) {
        jsAnimation(el, animation, deferred, startCallback, stepCallback);
        return deferred;
      } else {
        options = options || {};
        startCallback && (options.start = function () {
          startCallback(el);
        });

        options.complete = function () {
          deferred.resolve(el);
        };

        duration && (options.duration = duration);

        if (jsFn && isFunction(jsFn)) {
          if (before) {
            extend(el.style, before, true, false);
          }

          startCallback && startCallback(el);
          MetaphorJs.dom.data(el, dataParam, jsFn.call(context, el, function () {
            deferred.resolve(el);
          }));
          return deferred;
        } else if (window.jQuery) {
          var j = $(el);
          before && j.css(before);
          MetaphorJs.dom.data(el, dataParam, "stop");

          if (jsFn && isString(jsFn)) {
            j[jsFn](options);
            return deferred;
          } else if (after) {
            j.animate(after, options);
            return deferred;
          }
        }
      }
    } // no animation happened


    if (startCallback) {
      var promise = startCallback(el);

      if (isThenable(promise)) {
        promise.done(function () {
          deferred.resolve(el);
        });
      } else {
        deferred.resolve(el);
      }
    } else {
      deferred.resolve(el);
    }

    return deferred;
  };
  /**
   * @function MetaphorJs.animate.animate.addAnimationType
   * @param {string} name 
   * @param {array} stages 
   */


  animate.addAnimationType = function (name, stages) {
    types[name] = stages;
  };

  return animate;
}();

/***/ }),

/***/ "../metaphorjs-animate/src/animate/easing.js":
/*!***************************************************!*\
  !*** ../metaphorjs-animate/src/animate/easing.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs-animate/src/animate/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"); //https://gist.github.com/gre/1650294


module.exports = MetaphorJs.animate.easing = {
  // no easing, no acceleration
  linear: function (t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function (t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function (t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function (t) {
    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function (t) {
    return t * t * t;
  },
  // decelerating to zero velocity 
  easeOutCubic: function (t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function (t) {
    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function (t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function (t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function (t) {
    return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function (t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function (t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function (t) {
    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};

/***/ }),

/***/ "../metaphorjs-animate/src/animate/getDuration.js":
/*!********************************************************!*\
  !*** ../metaphorjs-animate/src/animate/getDuration.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs-animate/src/animate/__init.js");

__webpack_require__(/*! ./getPrefixes.js */ "../metaphorjs-animate/src/animate/getPrefixes.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.animate.getDuration = function () {
  var parseTime = function (str) {
    if (!str) {
      return 0;
    }

    var time = parseFloat(str);

    if (str.indexOf("ms") === -1) {
      time *= 1000;
    }

    return time;
  },
      getMaxTimeFromPair = function (max, dur, delay) {
    var i,
        sum,
        len = dur.length;

    for (i = 0; i < len; i++) {
      sum = parseTime(dur[i]) + parseTime(delay[i]);
      max = Math.max(sum, max);
    }

    return max;
  },
      pfx = false,
      animationDuration = null,
      animationDelay = null,
      transitionDuration = null,
      transitionDelay = null;
  /**
   * Get duration in milliseconds from html 
   * element based on current computed style
   * @function MetaphorJs.animate.getDuration
   * @param {HTMLElement} el
   * @returns {number}
   */


  return function (el) {
    if (pfx === false) {
      pfx = MetaphorJs.animate.getPrefixes();
      animationDuration = pfx ? pfx.animationDuration : null;
      animationDelay = pfx ? pfx.animationDelay : null;
      transitionDuration = pfx ? pfx.transitionDuration : null;
      transitionDelay = pfx ? pfx.transitionDelay : null;
    }

    if (!pfx) {
      return 0;
    }

    var style = window.getComputedStyle ? window.getComputedStyle(el, null) : el.style,
        duration = 0,
        animDur = (style[animationDuration] || '').split(','),
        animDelay = (style[animationDelay] || '').split(','),
        transDur = (style[transitionDuration] || '').split(','),
        transDelay = (style[transitionDelay] || '').split(',');
    duration = Math.max(duration, getMaxTimeFromPair(duration, animDur, animDelay));
    duration = Math.max(duration, getMaxTimeFromPair(duration, transDur, transDelay));
    return duration;
  };
}();

/***/ }),

/***/ "../metaphorjs-animate/src/animate/getPrefixes.js":
/*!********************************************************!*\
  !*** ../metaphorjs-animate/src/animate/getPrefixes.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs-animate/src/animate/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.animate.getPrefixes = function () {
  var domPrefixes = ['Moz', 'Webkit', 'ms', 'O', 'Khtml'],
      animationDelay = "animationDelay",
      animationDuration = "animationDuration",
      transitionDelay = "transitionDelay",
      transitionDuration = "transitionDuration",
      transform = "transform",
      transitionend = null,
      prefixes = null,
      probed = false,
      detectCssPrefixes = function () {
    var el = window.document.createElement("div"),
        animation = false,
        pfx,
        i,
        len;

    if (el.style && el.style['animationName'] !== undefined) {
      animation = true;
    } else {
      for (i = 0, len = domPrefixes.length; i < len; i++) {
        pfx = domPrefixes[i];

        if (el.style && el.style[pfx + 'AnimationName'] !== undefined) {
          animation = true;
          animationDelay = pfx + "AnimationDelay";
          animationDuration = pfx + "AnimationDuration";
          transitionDelay = pfx + "TransitionDelay";
          transitionDuration = pfx + "TransitionDuration";
          transform = pfx + "Transform";
          break;
        }
      }
    }

    if (animation) {
      if ('ontransitionend' in window) {
        // Chrome/Saf (+ Mobile Saf)/Android
        transitionend = 'transitionend';
      } else if ('onwebkittransitionend' in window) {
        // Chrome/Saf (+ Mobile Saf)/Android
        transitionend = 'webkitTransitionEnd';
      }
    }

    return animation;
  };
  /**
   * Get css prefixes used in current browser
   * @function MetaphorJs.animate.getPrefixes
   * @returns {object} {
   *  @type {string} animationDelay
   *  @type {string} animationDuration
   *  @type {string} transitionDelay
   *  @type {string} transitionDuration
   *  @type {string} transform
   *  @type {string} transitionend
   * }
   */


  return function () {
    if (!probed) {
      if (detectCssPrefixes()) {
        prefixes = {
          animationDelay: animationDelay,
          animationDuration: animationDuration,
          transitionDelay: transitionDelay,
          transitionDuration: transitionDuration,
          transform: transform,
          transitionend: transitionend
        };
      } else {
        prefixes = {};
      }

      probed = true;
    }

    return prefixes;
  };
}();

/***/ }),

/***/ "../metaphorjs-animate/src/animate/isCssSupported.js":
/*!***********************************************************!*\
  !*** ../metaphorjs-animate/src/animate/isCssSupported.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs-animate/src/animate/__init.js");

__webpack_require__(/*! ./getPrefixes.js */ "../metaphorjs-animate/src/animate/getPrefixes.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Is css animation supported in current browser
 * @function MetaphorJs.animate.isCssSupported
 * @returns {bool}
 */


module.exports = MetaphorJs.animate.isCssSupported = function () {
  var cssAnimations = null;
  return function () {
    if (cssAnimations === null) {
      cssAnimations = !!MetaphorJs.animate.getPrefixes();
    }

    return cssAnimations;
  };
}();

/***/ }),

/***/ "../metaphorjs-animate/src/animate/stop.js":
/*!*************************************************!*\
  !*** ../metaphorjs-animate/src/animate/stop.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs-animate/src/animate/__init.js");

__webpack_require__(/*! metaphorjs/src/func/dom/data.js */ "../metaphorjs/src/func/dom/data.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeClass.js */ "../metaphorjs/src/func/dom/removeClass.js");

const isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Stop ongoing animation for given element
 * @function MetaphorJs.animate.stop
 * @param {HTMLElement} el
 */


module.exports = MetaphorJs.animate.stop = function (el) {
  var queue = MetaphorJs.dom.data(el, "mjsAnimationQueue"),
      current,
      position,
      stages;

  if (isArray(queue) && queue.length) {
    current = queue[0];

    if (current) {
      if (current.stages) {
        position = current.position;
        stages = current.stages;
        MetaphorJs.dom.removeClass(el, stages[position]);
        MetaphorJs.dom.removeClass(el, stages[position] + "-active");
      }

      if (current.deferred) {
        current.deferred.reject(current.el);
      }
    }
  } else if (isFunction(queue)) {
    queue(el);
  } else if (queue === "stop") {
    $(el).stop(true, true);
  }

  MetaphorJs.dom.data(el, "mjsAnimationQueue", null);
};

/***/ }),

/***/ "../metaphorjs-animate/src/func/raf.js":
/*!*********************************************!*\
  !*** ../metaphorjs-animate/src/func/raf.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const async = __webpack_require__(/*! metaphorjs-shared/src/func/async.js */ "../metaphorjs-shared/src/func/async.js");

module.exports = function () {
  var raf, cancel;

  if (typeof window !== "undefined") {
    var w = window;
    raf = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.mozRequestAnimationFrame;
    cancel = w.cancelAnimationFrame || w.webkitCancelAnimationFrame || w.mozCancelAnimationFrame || w.webkitCancelRequestAnimationFrame;

    if (raf) {
      return function (fn, context, args) {
        var id = raf(context || args ? function () {
          fn.apply(context, args || []);
        } : fn);
        return function () {
          cancel(id);
        };
      };
    }
  }

  return function (fn, context, args) {
    var id = async(fn, context, args, 0);
    return function () {
      clearTimeout(id);
    };
  };
}();

/***/ }),

/***/ "../metaphorjs-class/src/classManagerFactory.js":
/*!******************************************************!*\
  !*** ../metaphorjs-class/src/classManagerFactory.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-namespace/src/lib/Namespace.js */ "../metaphorjs-namespace/src/lib/Namespace.js");

const isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js"),
      instantiate = __webpack_require__(/*! metaphorjs-shared/src/func/instantiate.js */ "../metaphorjs-shared/src/func/instantiate.js"),
      intercept = __webpack_require__(/*! metaphorjs-shared/src/func/intercept.js */ "../metaphorjs-shared/src/func/intercept.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = function () {
  var proto = "prototype",
      constr = "$constructor",
      $constr = function $constr() {
    var self = this;

    if (self.$super && self.$super !== emptyFn) {
      self.$super.apply(self, arguments);
    }
  },
      collectMixinEvents = function (events, pConstr) {
    var pp;

    while (pConstr) {
      pp = pConstr[proto];

      if (pp.$mixinEvents) {
        events = events.concat(pp.$mixinEvents);
      }

      pConstr = pConstr.$parent;
    }

    return events;
  },
      wrapPrototypeMethod = function wrapPrototypeMethod(parent, k, fn) {
    var $super = parent[proto][k] || (k === constr ? parent : emptyFn) || emptyFn;
    return function () {
      var ret,
          self = this,
          prev = self.$super;

      if (self.$destroyed) {
        self.$super = null;
        return null;
      }

      self.$super = $super;
      ret = fn.apply(self, arguments);
      self.$super = prev;
      return ret;
    };
  },
      preparePrototype = function preparePrototype(prototype, cls, parent, onlyWrap, mixEvents) {
    var k,
        ck,
        pk,
        pp = parent[proto],
        i,
        l,
        name;

    for (k in cls) {
      if (cls.hasOwnProperty(k)) {
        pk = pp[k];
        ck = cls[k];
        prototype[k] = isFunction(ck) && (!pk || isFunction(pk)) ? wrapPrototypeMethod(parent, k, ck) : ck;
      }
    }

    if (onlyWrap) {
      return;
    }

    prototype.$plugins = null;
    prototype.$pluginMap = null;

    if (mixEvents) {
      for (i = 0, l = mixEvents.length; i < l; i++) {
        name = mixEvents[i];

        if (pp[name]) {
          if (typeof pp[name] === 'function') {
            throw new Error("Cannot override method " + name + " with mixin event");
          }

          prototype[name] = pp[name].slice();
        } else {
          prototype[name] = [];
        }
      }
    }
  },
      mixinToPrototype = function (prototype, mixin, events) {
    var k;

    for (k in mixin) {
      if (mixin.hasOwnProperty(k)) {
        if (events.indexOf(k) !== -1) {
          prototype[k].push(mixin[k]);
        } else if (!prototype[k]) {
          prototype[k] = mixin[k];
        }
      }
    }
  };
  /**
   * Instantiate class system with namespace.
   * @group api
   * @function
   * @param {MetaphorJs.lib.Namespace} ns {
   *  Provide your own namespace or a new private ns will be 
   *  constructed automatically. 
   *  @optional
   * }
   * @returns {object} Returns cls() function/object. 
   */


  var classManagerFactory = function (ns) {
    if (!ns) {
      ns = new MetaphorJs.lib.Namespace();
    }

    var createConstructor = function (className) {
      return function () {
        var self = this,
            before = [],
            after = [],
            args = arguments,
            newArgs,
            i,
            l,
            plugins,
            plugin,
            pmap,
            plCls;

        if (!self) {
          throw new Error("Must instantiate via new: " + className);
        }

        self.$plugins = [];
        newArgs = self[constr].apply(self, arguments);

        if (newArgs && isArray(newArgs)) {
          args = newArgs;
        }

        plugins = self.$plugins;
        pmap = self.$pluginMap = {};
        if (self.$beforeInit) for (i = -1, l = self.$beforeInit.length; ++i < l; before.push([self.$beforeInit[i], self])) {}
        if (self.$afterInit) for (i = -1, l = self.$afterInit.length; ++i < l; after.push([self.$afterInit[i], self])) {}

        if (plugins && plugins.length) {
          for (i = 0, l = plugins.length; i < l; i++) {
            plugin = plugins[i];

            if (isString(plugin)) {
              plCls = plugin;
              plugin = ns ? ns.get(plugin) : null;

              if (!plugin) {
                throw plCls + " not found";
              }
            }

            plugin = new plugin(self, args);
            pmap[plugin.$class] = plugin;

            if (plugin.$beforeHostInit) {
              before.push([plugin.$beforeHostInit, plugin]);
            }

            plugins[i] = plugin;
          }
        }

        for (i = -1, l = before.length; ++i < l; before[i][0].apply(before[i][1], args)) {}

        if (self.$init) {
          self.$init.apply(self, args);
        } // we look for $afterHostInit in a separate loop
        // for plugins can be added inside $beforeHostInit
        // or in $init


        if (plugins && plugins.length) {
          for (i = 0, l = plugins.length; i < l; i++) {
            plugin = plugins[i];

            if (plugin.$afterHostInit) {
              after.push([plugin.$afterHostInit, plugin]);
            }
          }
        }

        for (i = -1, l = after.length; ++i < l; after[i][0].apply(after[i][1], args)) {}
      };
    };
    /**
     * All classes defined with <code>cls</code> extend this class.
     * Basically,<code>cls({});</code> is the same as 
     * <code>BaseClass.$extend({})</code>.
     * @group api
     * @class MetaphorJs.cls.BaseClass
     */


    var BaseClass = function () {};

    extend(BaseClass.prototype, {
      /**
       * Class name
       * @property {string} 
       */
      $class: null,
      $extends: null,

      /**
       * List of plugin names or constructors before class 
       * is initialised, list of plugin instances after initialisation
       * @property {array} 
       */
      $plugins: null,
      $pluginMap: null,
      $mixins: null,
      $mixinEvents: ["$beforeInit", "$afterInit", "$beforeDestroy", "$afterDestroy"],
      $destroyed: false,
      $destroying: false,
      $constructor: emptyFn,
      $init: emptyFn,
      $beforeInit: [],
      $afterInit: [],
      $beforeDestroy: [],
      $afterDestroy: [],

      /**
       * Call mixins for a specified mixin event
       * @param {string} eventName 
       */
      $callMixins: function (eventName) {
        var self = this,
            fns = self[eventName],
            i,
            l,
            args = toArray(arguments);
        args.shift();

        for (i = 0, l = fns.length; i < l; i++) {
          fns[i].apply(self, args);
        }
      },

      /**
       * Get this instance's class name
       * @method
       * @returns {string}
       */
      $getClass: function () {
        return this.$class;
      },

      /**
       * Is this object instance of <code>cls</code>
       * @param {string} cls
       * @returns {boolean}
       */
      $is: function (cls) {
        return isInstanceOf(this, cls);
      },

      /**
       * Get parent class name
       * @method
       * @returns {string | null}
       */
      $getParentClass: function () {
        return this.$extends;
      },

      /**
       * Intercept method
       * @method
       * @param {string} method Intercepted method name
       * @param {function} fn function to call before or after intercepted method
       * @param {object} newContext optional interceptor's "this" object
       * @param {string} when optional, when to call interceptor 
       *                         before | after | instead; default "before"
       * @param {bool} replaceValue optional, return interceptor's return value 
       *                  or original method's; default false
       * @returns {function} original method
       */
      $intercept: function (method, fn, newContext, when, replaceValue) {
        var self = this,
            orig = self[method];
        self[method] = intercept(orig || emptyFn, fn, newContext || self, self, when, replaceValue);
        return orig || emptyFn;
      },

      /**
       * Implement new methods or properties on instance
       * @method
       * @param {object} methods
       */
      $implement: function (methods) {
        var $self = this.constructor;

        if ($self && $self.$parent) {
          preparePrototype(this, methods, $self.$parent, true);
        }
      },

      /**
       * Add a plugin to class instance
       * @param {string|function} plugin 
       */
      $addPlugin: function (plugin) {
        var plCls,
            self = this,
            pmap = self.$pluginMap;

        if (isString(plugin)) {
          plCls = plugin;
          plugin = ns ? ns.get(plugin) : null;

          if (!plugin) {
            throw plCls + " not found";
          }
        } else {
          plCls = plugin.$class;
        }

        if (pmap[plCls]) {
          throw plCls + " already initialized on this instance";
        }

        plugin = new plugin(self);
        pmap[plCls] = plugin;
        self.$plugins.push(plugin);
      },

      /**
       * Does this instance have a plugin
       * @method
       * @param cls
       * @returns {boolean}
       */
      $hasPlugin: function (cls) {
        return cls ? !!this.$pluginMap[cls] : false;
      },

      /**
       * Get plugin instance
       * @method
       * @param {string} cls Plugin class name
       * @returns {object|null}
       */
      $getPlugin: function (cls) {
        return cls ? this.$pluginMap[cls] || null : null;
      },

      /**
       * Get a bound to this object function
       * @method
       * @param {function} fn
       * @returns {Function}
       */
      $bind: function (fn) {
        var self = this;
        return function () {
          if (!self.$isDestroyed()) {
            return fn.apply(self, arguments);
          }
        };
      },

      /**
       * Is this object destroyed
       * @method
       * @return {boolean}
       */
      $isDestroyed: function () {
        return this.$destroying || this.$destroyed;
      },

      /**
       * Destroy this instance. Also destroys plugins and
       * calls all beforeDestroy and afterDestroy handlers.
       * Also calls onDestroy.<br>
       * Safe to call multiple times.
       * @method
       */
      $destroy: function () {
        var self = this,
            before = self.$beforeDestroy,
            after = self.$afterDestroy,
            plugins = self.$plugins,
            i,
            l,
            res;

        if (self.$destroying || self.$destroyed) {
          return;
        }

        self.$destroying = true;

        for (i = -1, l = before.length; ++i < l; before[i].apply(self, arguments)) {}

        for (i = 0, l = plugins.length; i < l; i++) {
          if (plugins[i].$beforeHostDestroy) {
            plugins[i].$beforeHostDestroy.call(plugins[i], arguments);
          }
        }

        res = self.onDestroy.apply(self, arguments);

        for (i = -1, l = after.length; ++i < l; after[i].apply(self, arguments)) {}

        for (i = 0, l = plugins.length; i < l; i++) {
          plugins[i].$destroy.apply(plugins[i], arguments);
        }

        if (res !== false) {
          for (i in self) {
            if (self.hasOwnProperty(i)) {
              self[i] = null;
            }
          }
        }

        self.$destroying = false;
        self.$destroyed = true;
      },

      /**
       * Overridable method. Put your destructor here
       * @method
       */
      onDestroy: function () {}
    });
    BaseClass.$self = BaseClass;
    /**
     * Create an instance of current class. Same as <code>cls.factory(name)</code>
     * @method
     * @static
     * @code var myObj = My.Class.$instantiate(arg1, arg2, ...);
     * @returns {object} class instance
     */

    BaseClass.$instantiate = function () {
      var cls = this,
          args = arguments,
          cnt = args.length; // lets make it ugly, but without creating temprorary classes and leaks.
      // and fallback to normal instantiation.

      switch (cnt) {
        case 0:
          return new cls();

        case 1:
          return new cls(args[0]);

        case 2:
          return new cls(args[0], args[1]);

        case 3:
          return new cls(args[0], args[1], args[2]);

        case 4:
          return new cls(args[0], args[1], args[2], args[3]);

        default:
          return instantiate(cls, args);
      }
    };
    /**
     * Override class methods (on prototype level, not on instance level)
     * @method
     * @static
     * @param {object} methods
     */


    BaseClass.$override = function (methods) {
      var $self = this.$self,
          $parent = this.$parent;

      if ($self && $parent) {
        preparePrototype($self.prototype, methods, $parent);
      }
    };
    /**
     * Create new class extending current one
     * @static
     * @method
     * @param {object} definition
     * @param {object} statics
     * @returns {function}
     */


    BaseClass.$extend = function (definition, statics) {
      return defineClass(definition, statics, this);
    };
    /**
     * Destroy class (not the instance)
     * @method
     * @static
     */


    BaseClass.$destroy = function () {
      var self = this,
          k;

      for (k in self) {
        self[k] = null;
      }
    };
    /**
     * @end-class
     */

    /**
     * Constructed class system. Also this is a function, same as 
     * <code>cls.define</code>
     * @group api
     * @object cls
     */

    /**
     * @property {function} define {
     *  @param {object} definition {
     *      @type {string} $class optional class name
     *      @type {string} $extends optional parent class
     *      @type {array} $mixins optional list of mixins
     *      @type {function} $constructor optional low-level constructor
     *      @type {function} $init optional constructor
     *      @type {function} onDestroy your own destroy function
     *  }
     *  @param {object} statics any statis properties or methods
     * }
     * @code var Name = cls({$class: "Name"});
     */


    var defineClass = function defineClass(definition, statics, $extends) {
      definition = definition || {};
      var name = definition.$class,
          parentClass = $extends || definition.$extends,
          mixins = definition.$mixins,
          mixEvents = definition.$mixinEvents || [],
          alias = definition.$alias,
          pConstructor,
          allMixEvents,
          i,
          l,
          k,
          prototype,
          c,
          mixin;

      if (parentClass) {
        if (isString(parentClass)) {
          pConstructor = ns.get(parentClass);
        } else {
          pConstructor = parentClass;
          parentClass = pConstructor.$class || "";
        }
      } else {
        pConstructor = BaseClass;
        parentClass = "";
      }

      if (parentClass && !pConstructor) {
        throw parentClass + " not found";
      }

      definition.$class = name;
      definition.$extends = parentClass;
      delete definition.$mixins;
      delete definition.$mixinEvents;
      allMixEvents = collectMixinEvents(mixEvents, pConstructor);
      prototype = Object.create(pConstructor[proto]);
      definition[constr] = definition[constr] || $constr;
      preparePrototype(prototype, definition, pConstructor, false, allMixEvents);

      if (mixins) {
        for (i = 0, l = mixins.length; i < l; i++) {
          mixin = mixins[i];

          if (isString(mixin)) {
            if (!ns) {
              throw new Error("Mixin " + mixin + " not found");
            }

            mixin = ns.get(mixin, true);
          }

          mixinToPrototype(prototype, mixin, allMixEvents);
        }
      }

      c = createConstructor(name);
      prototype.constructor = c;
      prototype.$self = c;
      prototype.$mixinEvents = mixEvents;
      c[proto] = prototype;

      for (k in BaseClass) {
        if (k !== proto && BaseClass.hasOwnProperty(k)) {
          c[k] = BaseClass[k];
        }
      }

      for (k in pConstructor) {
        if (k !== proto && pConstructor.hasOwnProperty(k)) {
          c[k] = pConstructor[k];
        }
      }

      if (statics) {
        for (k in statics) {
          if (k !== proto && statics.hasOwnProperty(k)) {
            c[k] = statics[k];
          }
        }
      }

      c.$parent = pConstructor;
      c.$self = c;

      if (ns) {
        if (name) {
          ns.register(name, c);
        }

        if (alias) {
          ns.register(alias, c);
        }
      }

      return c;
    };
    /**
     * Instantiate class. Pass constructor parameters after "name"
     * @property {function} factory {
     * @code cls.factory("My.Class.Name", arg1, arg2, ...);
     * @param {string} name Full name of the class
     * @returns {object} class instance
     * }
     */


    var factory = function (name) {
      var cls = ns ? ns.get(name) : null,
          args = toArray(arguments).slice(1);

      if (!cls) {
        throw name + " not found";
      }

      return cls.$instantiate.apply(cls, args);
    };
    /**
     * Is given object instance of class
     * @property {function} isInstanceOf {
     * @code cls.instanceOf(myObj, "My.Class");
     * @code cls.instanceOf(myObj, My.Class);
     * @param {object} cmp
     * @param {string|object} name
     * @returns {boolean}
     * }
     */


    var isInstanceOf = function (cmp, name) {
      var _cls = isString(name) && ns ? ns.get(name) : name;

      return _cls ? cmp instanceof _cls : false;
    };
    /**
     * Is one class subclass of another class
     * @property {function} isSubclassOf {
     * @code cls.isSubclassOf("My.Subclass", "My.Class");
     * @code cls.isSubclassOf(myObj, "My.Class");
     * @code cls.isSubclassOf("My.Subclass", My.Class);
     * @code cls.isSubclassOf(myObj, My.Class);
     * @param {string|object} childClass
     * @param {string|object} parentClass
     * @return {boolean}
     * }
     */


    var isSubclassOf = function (childClass, parentClass) {
      var p = childClass,
          g = ns ? ns.get : function () {};

      if (!isString(parentClass)) {
        parentClass = parentClass.prototype.$class;
      }

      if (isString(childClass)) {
        p = g(childClass);
      }

      while (p && p.prototype) {
        if (p.prototype.$class === parentClass) {
          return true;
        }

        p = p.$parent;
      }

      return false;
    };
    /**
     * Reference to the managerFactory
     * @property {function} classManagerFactory
     */


    defineClass.classManagerFactory = classManagerFactory;
    defineClass.factory = factory;
    defineClass.isSubclassOf = isSubclassOf;
    defineClass.isInstanceOf = isInstanceOf;
    defineClass.define = defineClass;
    /**
     * @property {function} Namespace Namespace constructor
     */

    defineClass.Namespace = MetaphorJs.lib.Namespace;
    /**
     * @property {class} BaseClass
     */

    defineClass.BaseClass = BaseClass;
    /**
     * @property {object} ns Namespace instance
     */

    defineClass.ns = ns;
    /**
     * @property {function} $destroy Destroy class system and namespace
     */

    defineClass.$destroy = function () {
      BaseClass.$destroy();
      BaseClass = null;

      if (ns) {
        ns.$destroy();
        ns = null;
      }
    };

    return defineClass;
  };

  return classManagerFactory;
}();

/***/ }),

/***/ "../metaphorjs-class/src/cls.js":
/*!**************************************!*\
  !*** ../metaphorjs-class/src/cls.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classManagerFactory = __webpack_require__(/*! ./classManagerFactory.js */ "../metaphorjs-class/src/classManagerFactory.js"),
      ns = __webpack_require__(/*! metaphorjs-namespace/src/var/ns.js */ "../metaphorjs-namespace/src/var/ns.js");

module.exports = classManagerFactory(ns);

/***/ }),

/***/ "../metaphorjs-dialog/src/__init.js":
/*!******************************************!*\
  !*** ../metaphorjs-dialog/src/__init.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

MetaphorJs.dialog = MetaphorJs.dialog || {
  pointer: {},
  position: {}
};

/***/ }),

/***/ "../metaphorjs-dialog/src/dialog/Container.js":
/*!****************************************************!*\
  !*** ../metaphorjs-dialog/src/dialog/Container.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs-dialog/src/__init.js");

__webpack_require__(/*! ../mixin/Dialog.js */ "../metaphorjs-dialog/src/mixin/Dialog.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dialog.Container = MetaphorJs.app.Container.$extend({
  $mixins: [MetaphorJs.mixin.Dialog]
});

/***/ }),

/***/ "../metaphorjs-dialog/src/dialog/Dialog.js":
/*!*************************************************!*\
  !*** ../metaphorjs-dialog/src/dialog/Dialog.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isNumber = __webpack_require__(/*! metaphorjs-shared/src/func/isNumber.js */ "../metaphorjs-shared/src/func/isNumber.js"),
      isBool = __webpack_require__(/*! metaphorjs-shared/src/func/isBool.js */ "../metaphorjs-shared/src/func/isBool.js"),
      ucfirst = __webpack_require__(/*! metaphorjs-shared/src/func/ucfirst.js */ "../metaphorjs-shared/src/func/ucfirst.js"),
      raf = __webpack_require__(/*! metaphorjs-animate/src/func/raf.js */ "../metaphorjs-animate/src/func/raf.js"),
      async = __webpack_require__(/*! metaphorjs-shared/src/func/async.js */ "../metaphorjs-shared/src/func/async.js"),
      error = __webpack_require__(/*! metaphorjs-shared/src/func/error.js */ "../metaphorjs-shared/src/func/error.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

__webpack_require__(/*! ../__init.js */ "../metaphorjs-dialog/src/__init.js");

__webpack_require__(/*! metaphorjs/src/lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! metaphorjs/src/func/dom/addClass.js */ "../metaphorjs/src/func/dom/addClass.js");

__webpack_require__(/*! metaphorjs/src/func/dom/hasClass.js */ "../metaphorjs/src/func/dom/hasClass.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeClass.js */ "../metaphorjs/src/func/dom/removeClass.js");

__webpack_require__(/*! metaphorjs/src/func/dom/setStyle.js */ "../metaphorjs/src/func/dom/setStyle.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! metaphorjs/src/func/dom/setAttr.js */ "../metaphorjs/src/func/dom/setAttr.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeAttr.js */ "../metaphorjs/src/func/dom/removeAttr.js");

__webpack_require__(/*! metaphorjs/src/func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

__webpack_require__(/*! metaphorjs/src/func/dom/normalizeEvent.js */ "../metaphorjs/src/func/dom/normalizeEvent.js");

__webpack_require__(/*! metaphorjs/src/func/dom/isVisible.js */ "../metaphorjs/src/func/dom/isVisible.js");

__webpack_require__(/*! metaphorjs/src/func/dom/isAttached.js */ "../metaphorjs/src/func/dom/isAttached.js");

__webpack_require__(/*! metaphorjs/src/func/dom/whenAttached.js */ "../metaphorjs/src/func/dom/whenAttached.js");

__webpack_require__(/*! metaphorjs/src/func/dom/select.js */ "../metaphorjs/src/func/dom/select.js");

__webpack_require__(/*! metaphorjs/src/func/dom/is.js */ "../metaphorjs/src/func/dom/is.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getOuterWidth.js */ "../metaphorjs/src/func/dom/getOuterWidth.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getOuterHeight.js */ "../metaphorjs/src/func/dom/getOuterHeight.js");

__webpack_require__(/*! metaphorjs/src/func/dom/delegate.js */ "../metaphorjs/src/func/dom/delegate.js");

__webpack_require__(/*! metaphorjs/src/func/dom/undelegate.js */ "../metaphorjs/src/func/dom/undelegate.js");

__webpack_require__(/*! metaphorjs/src/func/dom/data.js */ "../metaphorjs/src/func/dom/data.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/animate.js */ "../metaphorjs-animate/src/animate/animate.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/stop.js */ "../metaphorjs-animate/src/animate/stop.js");

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");

__webpack_require__(/*! ./position/Abstract.js */ "../metaphorjs-dialog/src/dialog/position/Abstract.js");

__webpack_require__(/*! ./position/Target.js */ "../metaphorjs-dialog/src/dialog/position/Target.js");

__webpack_require__(/*! ./position/Mouse.js */ "../metaphorjs-dialog/src/dialog/position/Mouse.js");

__webpack_require__(/*! ./position/Window.js */ "../metaphorjs-dialog/src/dialog/position/Window.js");

__webpack_require__(/*! ./position/Custom.js */ "../metaphorjs-dialog/src/dialog/position/Custom.js");

__webpack_require__(/*! ./position/None.js */ "../metaphorjs-dialog/src/dialog/position/None.js");

__webpack_require__(/*! ./position/Draggable.js */ "../metaphorjs-dialog/src/dialog/position/Draggable.js");

__webpack_require__(/*! ./pointer/Abstract.js */ "../metaphorjs-dialog/src/dialog/pointer/Abstract.js");

__webpack_require__(/*! ./pointer/Html.js */ "../metaphorjs-dialog/src/dialog/pointer/Html.js");

__webpack_require__(/*! ./Overlay.js */ "../metaphorjs-dialog/src/dialog/Overlay.js");

__webpack_require__(/*! ./Manager.js */ "../metaphorjs-dialog/src/dialog/Manager.js");

module.exports = MetaphorJs.dialog.Dialog = function () {
  var manager = new MetaphorJs.dialog.Manager();

  var defaultEventProcessor = function (dlg, e, type, returnMode) {
    if (type === "show" || !returnMode) {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }
  };

  var getEventConfig = function (e, action, dlgEl) {
    var type = e.type,
        trg = e.target,
        cfg = null,
        data;

    while (trg && trg !== dlgEl) {
      data = MetaphorJs.dom.getAttr(trg, "data-" + action + "-" + type);

      if (data) {
        cfg = MetaphorJs.lib.Expression.parse(data)({});
        break;
      }

      trg = trg.parentNode;
    }

    return cfg;
  };
  /*
   * Shorthands
   */


  var fixShorthand = function (options, level1, level2, type) {
    var value = options[level1],
        yes = false;

    if (value === undefined) {
      return;
    }

    switch (type) {
      case "string":
        {
          yes = isString(value);
          break;
        }

      case "function":
        {
          yes = isFunction(value);
          break;
        }

      case "number":
        {
          yes = isNumber(value) || value == parseInt(value);
          break;
        }

      case "dom":
        {
          yes = value && (value.tagName || value.nodeName) ? true : false;
          break;
        }

      case "jquery":
        {
          yes = value && value.jquery ? true : false;

          if (yes) {
            value = value.get(0);
          }

          break;
        }

      case "boolean":
        {
          if (value === true || value === false) {
            yes = true;
          }

          break;
        }

      default:
        {
          if (type === true && value === true) {
            yes = true;
          }

          if (type === false && value === false) {
            yes = true;
          }
        }
    }

    if (yes) {
      options[level1] = {};
      options[level1][level2] = value;
    }
  };

  var fixShorthands = function (options) {
    if (!options) {
      return {};
    }

    fixShorthand(options, "content", "value", "string");
    fixShorthand(options, "content", "value", "boolean");
    fixShorthand(options, "content", "fn", "function");
    fixShorthand(options, "remote", "url", "string");
    fixShorthand(options, "cls", "dialog", "string");
    fixShorthand(options, "render", "tpl", "string");
    fixShorthand(options, "render", "fn", "function");
    fixShorthand(options, "render", "el", "dom");
    fixShorthand(options, "render", "el", "jquery");
    fixShorthand(options, "show", "events", false);
    fixShorthand(options, "show", "events", "string");
    fixShorthand(options, "hide", "events", false);
    fixShorthand(options, "hide", "events", "string");
    fixShorthand(options, "toggle", "events", false);
    fixShorthand(options, "toggle", "events", "string");
    fixShorthand(options, "position", "type", "string");
    fixShorthand(options, "position", "type", false);
    fixShorthand(options, "position", "get", "function");
    fixShorthand(options, "overlay", "enabled", "boolean");
    fixShorthand(options, "pointer", "position", "string");
    fixShorthand(options, "pointer", "size", "number");
    return options;
  };
  /**
   * @object MetaphorJs.dialog.Dialog.defaults
   */


  var defaults = {
    /**
     * Target element(s) which trigger dialog's show and hide.<br>
     * If {HTMLElement}: will be used as a single target,<br>
     * if selector: will be used as dynamic target.<br>
     * Dynamic targets work like this:<br>
     * you provide delegates: {someElem: {click: someClass}} -- see "show" function<br>
     * when show() is called, target will be determined from the event using
     * the selector.
     * @property {string|Element} target
     */
    target: null,

    /**
     * One or more group names.
     * @property {string|array} group
     */
    group: null,

    /**
     * If dialog is modal, overlay will be forcefully enabled.
     * @property {bool} modal
     */
    modal: false,

    /**
     * Use link's href attribute as remote.url or as render.el
     * @property {bool} useHref
     */
    useHref: false,

    /**
     * If neither content value nor remote url are provided,
     * plugin will try to read target's attribute values: 'tooltip', 'title' and 'alt'.
     * (unless attr is specified).<br>
     * <em>shorthand</em>: string -> content.value<br>
     * <em>shorthand</em>: false -> content.value<br>
     * <em>shorthand</em>: function -> content.fn<br>
     * @object content
     */
    content: {
      /**
       * Dialog's text content. Has priority before readContent/loadContent.
       * If set to false, no content will be automatically set whether via fn() or attributes.
       * @property {string|boolean} value
       */
      value: '',

      /**
       * Must return content value
       * @property {function} fn
       * @param {HTMLElement} target
       * @param {MetaphorJs.dialog.Dialog} dialog
       * @returns {string}
       */
      fn: null,

      /**
       * This function receives new content and returns string value (processed content).
       * @property {function} prepare
       * @param {MetaphorJs.dialog.Dialog} dialog
       * @param {string} mode
       *      empty string - content has come from content.value or setContent()<br>
       *      'attribute' - content has been read from target attributes<br>
       *      'remote' - data returned by fetch request
       *      @default '' | 'attribute' | 'remote'
       *
       * @param {string} content
       * @returns {string}
       */
      prepare: null,

      /**
       * Get content from this attribute (belongs to target)
       * @property {string} attr
       */
      attr: null
      /**
       * @end-object
       */

    },

    /**
     * All these options are passed to fetch().
     * You can provide more options in this section
     * but 'success' will be overriden (use content.prepare for data processing).<br>
     * <em>shorthand</em>: string -> remote.url
     * @object remote
     */
    remote: {
      /**
       * Url to load content from.
       * @property {string} url
       */
      url: null,

      /**
       * Use Metaphor.remote.fetch library
       * @property {boolean} useMetaphor
       */
      useMetaphor: false
      /*
       * Pass this data along with xhr.
       * @property {object} data
       *
      data: 			null,
       /*
       * @property {string} dataType
       *
      dataType: 		'text',
       /*
       * @property {string} method
       *
      method: 		'GET'*/

      /**
       * @end-object
       */

    },

    /**
     * Classes to apply to the dialog.
     * <em>shorthand</em>: string -> cls.dialog
     * @object cls
     */
    cls: {
      /**
       * Base class.
       * @property {string} dialog
       */
      dialog: null,

      /**
       * Only applied when dialog is visible.
       * @property {string} visible
       */
      visible: null,

      /**
       * Only applied when dialog is hidden.
       * @property {string} hidden
       */
      hidden: null,

      /**
       * Only applied when dialog is fetching remote data.
       * @property {string} loading
       */
      loading: null
      /**
       * @end-object
       */

    },

    /**
     * <p>Selector is used when dialog has inner structure and you
     * want to change its content.</p>
     * <pre><code class="language-javascript">
     * {
     *      render: {
     *          tpl: '&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt;'
     *      },
     *      selector: {
     *          content: '.content'
     *      }
     * }
     * </code></pre>
     * <p>If no selector provided, setContent will replace all inner html.
     * Another thing relates to structurally complex content:</p>
     *
     * <pre><code class="language-javascript">
     * setContent({title: "...", body: "..."});
     * selector: {
     *      title:  ".title",
     *      body:   ".body"
     * }
     * </code></pre>
     * @object selector
     */
    selector: {
      /**
       * Dialog's content selector.
       * @property {string} content
       */
      content: null
      /**
       * @end-object
       */

    },

    /**
     * Object {buttonId: selector}
     * @property {object|null} buttons
     */
    buttons: null,

    /**
     * <p><em>shorthand</em>: string -> render.tpl<br>
     * <em>shorthand</em>: function -> render.fn<br>
     * <em>shorthand</em>: dom element -> render.el<br>
     * @object render
     */
    render: {
      /**
       * Dialog's template 
       * @property {string} tpl
       */
      tpl: '<div></div>',

      /**
       * Call this function to get dialog's template.
       * @property {function} fn
       * @param {MetaphorJs.dialog.Dialog} dialog
       * @returns {string|Element}
       */
      fn: null,

      /**
       * Selector or existing element instead of template.
       * @property {string|Element} el
       */
      el: null,

      /**
       * Apply this zIndex.
       * @property {number} zIndex
       */
      zIndex: null,

      /**
       * false - render immediately, true - wait for the first event.
       * @property {bool} lazy
       */
      lazy: true,

      /**
       * Object to pass to elem.css()
       * @property {object} style
       */
      style: null,

      /**
       * If set, the element will be appended to specified container.<br>
       * If set to false, element will not be appended anywhere (works with "el").
       * @property {string|Element|bool} appendTo
       */
      appendTo: null,

      /**
       * Dialog's id attribute.
       * @property {string} id
       */
      id: null,

      /**
       * If set to true, element's show() and hide() will never be called. Use
       * "visible" and "hidden" classes instead.
       * @property {boolean} keepVisible
       */
      keepVisible: false,

      /**
       * When destroying dialog's elem, keep it in DOM.
       * Useful when you return it in fn() on every show()
       * and have lifetime = 0.
       * @property {boolean} keepInDOM
       */
      keepInDOM: false,

      /**
       * Number of ms for the rendered object to live
       * after its been hidden. 0 to destroy elem immediately.
       * @property {number} lifetime
       */
      lifetime: null
      /**
       * @end-object
       */

    },

    /**
     * Event actions.
     * @object events
     */
    events: {
      /**
       * @object show
       */
      show: {
        /**
         * You can also add any event you use to show/hide dialog 
         * (mouseup, mousedown, etc)
         * @object * 
         */
        "*": {
          /**
           * @property {boolean} preventDefault
           */
          preventDefault: false,

          /**
           * @property {boolean} stopPropagation
           */
          stopPropagation: false,

          /**
           * @property {boolean} returnValue
           */
          returnValue: null,

          /**
           * @property {function} process
           * @param {Dialog} dialog
           * @param {Event} event
           * @param {string} type show|hide
           * @param {string} returnMode
           */
          process: defaultEventProcessor
          /**
           * @end-object
           */

        }
        /**
         * @end-object
         */

      },

      /**
       * @object hide
       */
      hide: {
        /**
         * You can also add any event you use to show/hide dialog.
         * @object *
         */
        "*": {
          /**
           * @property {boolean} preventDefault
           */
          preventDefault: false,

          /**
           * @property {boolean} stopPropagation
           */
          stopPropagation: false,

          /**
           * @property {boolean} returnValue
           */
          returnValue: null,

          /**
           * Must return "returnValue" which will be in its turn
           * returned from event handler. If you provide this function
           * preventDefault and stopPropagation options are ignored.
           * @property {function}
           * @param {Dialog} dialog
           * @param {Event} event
           * @param {string} type show|hide
           * @param {string} returnMode
           */
          process: defaultEventProcessor
          /**
           * @end-object
           */

        }
        /**
         * @end-object
         */

      }
      /**
       * @end-object
       */

    },

    /**
     * <p><em>shorthand</em>: false -> show.events<br>
     * <em>shorthand</em>: string -> show.events._target</p>
     * @object show
     */
    show: {
      /**
       * Delay dialog's appearance. Milliseconds.
       * @property {number} delay
       */
      delay: null,

      /**
       * True to hide all other tooltips.
       * If "group" specified, will hide only
       * those dialogs that belong to that group.
       * @property {bool} single
       */
      single: false,

      /**
       * Works for show, hide and toggle
       * <pre><code class="language-javascript">
       * events: false // disable all
       *
       * events: eventName || [eventName, eventName, ...]
       * // same as events: {"_target": ...}
       *
       * events: {
       *  "body":         eventName || [eventName, eventName, ...],
       *  "_self":        same, // dialog itself
       *  "_target":      same, // target element
       *  "_document":    same,
       *  "_window":      same,
       *  "_html":        same,
       *  "_overlay":     same, // overlay element (works with hiding)
       *  ">.selector":   same // selector inside dialog
       * }
       *
       * events: {
       *  "(body|_self|_target|...)": {
       *      eventName: ".selector"
       *  }
       *  // $("body|_self|_target|...").delegate(".selector", eventName)
       *  // this one is for dynamic targets
       * }
       * </code></pre>
       * @property {string|bool|object} events
       */
      events: null,

      /**
       * <p>true -- ["mjs-show"] or ["mjs-hide"]<br>
       * string -- class name -> [class]<br>
       * array -- [{properties before}, {properties after}]<br>
       * array -- [class, class]<br>
       * object --
       * .fn -- string: "fadeIn", "fadeOut", etc. (optional) requires jQuery<br>
       * .fn -- function(Element, completeCallback)
       * .stages -- [class, class] (optional)
       * .before -- {} apply css properties before animation (optional)
       * .after -- {} animate these properties (optional) requires jQuery
       * .options - {} jQuery's .animate() options
       * .context -- fn's this object
       * .duration -- used when .fn is string
       * .skipDisplayChange -- do not set style.display = "" on start
       * function(){}<br>
       * function must return any of the above:</p>
       * <pre><code class="language-javascript">
       * animate: function(dlg, e) {
       *      return {
       *          before: {
       *             width: '200px'
       *          },
       *          after: {
       *              width: '400px'
       *          },
       *          options: {
       *             step: function() {
       *               dlg.reposition();
       *             }
       *          }
       *      };
       * }
       * </code></pre>
       * @property {bool|string|array|function} animate
       */
      animate: false,

      /**
       * Ignore {show: {single: true}} on other dialogs.
       * @property {bool} ignoreHideAll
       */
      ignoreHideAll: false,

      /**
       * true - automatically set focus on input fields on buttons;
       * string - selector
       * @property {bool|string} focus
       */
      focus: false,

      /**
       * Prevent scrolling on given element
       * true = "body"
       * @property {bool|string|Element} preventScroll
       */
      preventScroll: false,

      /**
       * When showing, set css display to this value
       * @property {string} display
       */
      display: "block"
      /**
       * @end-object
       */

    },

    /**
     * <p><em>shorthand</em>: false -> hide.events<br>
     * <em>shorthand</em>: string -> hide.events._target</p>
     * @object hide
     */
    hide: {
      /**
       * Milliseconds. Delay hiding for this amount of time.
       * @property {number} delay
       */
      delay: null,

      /**
       * Milliseconds. Dialog will be shown no longer than for that time.
       * @property {number} timeout
       */
      timeout: null,

      /**
       * See show.events
       * @property {string|bool|object} events
       */
      events: null,

      /**
       * Destroy dialog after hide.
       * @property {bool} destroy
       */
      destroy: false,

      /**
       * Remove element from DOM after hide
       * @property {bool} remove
       */
      remove: false,

      /**
       * See show.animate
       * @property {bool|string|array|function} animate
       */
      animate: false,

      /**
       * true: hide anyway even if showing is delayed,<br>
       * false: ignore hide events until tooltip is shown.
       * @property {bool} cancelShowDelay
       */
      cancelShowDelay: true
      /**
       * @end-object
       */

    },

    /**
     * This option is required when you want to show and hide on the same event.<br>
     * <em>shorthand</em>: false -> toggle.events<br>
     * <em>shorthand</em>: string -> toggle.events._target
     * @object toggle
     */
    toggle: {
      /**
       * See show.events
       * @property {string|bool|object} events
       */
      events: null
      /**
       * @end-object
       */

    },

    /**
     * <p><em>shorthand</em>: false -> position.type<br>
     * <em>shorthand</em>: string -> position.type<br>
     * <em>shorthand</em>: function -> position.get
     * @object position
     */
    position: {
      /**
       * false -- do not apply position<br>
       * function(api) - must return one of the following:<br>
       * "auto" - detect position automatically<br>
       *
       * <b>relative to target:</b><br>
       * t | r | b | l -- simple positions aligned by center<br>
       * tr | rt | rb | br | bl | lb | lt | tl -- aligned by side<br>
       * trc | brc | blc | tlc -- corner positions<br>
       *
       * <b>relative to mouse:</b><br>
       * m -- works only with get(). get() function will be called on mousemove<br>
       * mt | mr | mb | ml -- following the mouse, aligned by center<br>
       * mrt | mrb | mlb | mlt -- following the mouse, corner positions<br>
       *
       * <b>window positions:</b><br>
       * wc | wt | wr | wb | wl<br>
       * wrt | wrb | wlt | wlb
       *
       * Defaults to 't'
       * @property {bool|string} type
       */
      type: 't',

      /**
       * @property {string} preferredType
       */
      preferredType: null,

      /**
       * Add this offset to dialog's x position
       * @property {number} offsetX
       */
      offsetX: 0,

      /**
       * Add this offset to dialog's y position
       * @property {number} offsetY
       */
      offsetY: 0,

      /**
       * Follow the mouse only by this axis;
       * second coordinate will be relative to target
       * @property {string} axis
       */
      axis: null,

      /**
       * Overrides position.type<br>
       * If this function is provided, offsets are not applied.
       * @property {function} get
       * @param {MetaphorJs.dialog.Dialog} dialog
       * @param {Event} event
       * @returns {object} {
       *      @type {number} x If object contains only one coordinate - x or y -
       *                       the other one will not be updated.
       *      @type {number} y
       *      @type {number} top If object does not contain x and y, it will be applied
       *                          as is.
       *      @type {number} right
       *      @type {number} bottom
       *      @type {number} left
       * }
       */
      get: null,

      /**
       * Prevent from rendering off the screen.<br>
       * Set to maximum distance between tooltip and window edge.
       * @property {number|bool} screenX
       */
      screenX: false,

      /**
       * Prevent from rendering off the screen.<br>
       * Set to maximum distance between tooltip and window edge.
       * @property {number|bool} screenY
       */
      screenY: false,

      /**
       * Calculate position relative to this element (defaults to window)
       * @property {string|Element} base
       */
      base: null,

      /**
       * Monitor window/selector/element scroll and reposition on scroll.
       * @property {bool|string|Element} scroll
       */
      scroll: false,

      /**
       * Monitor window resize and reposition on resize
       * @property {bool} resize
       */
      resize: true
      /**
       * @end-object
       */

    },

    /**
     * Pointer will only work if size > 0 or el is not null<br>
     * <em>shorthand</em>: string -> pointer.position<br>
     * <em>shorthand</em>: number -> pointer.size
     * @object pointer
     */
    pointer: {
      /**
       * t / r / b / l<br>
       * tr / lt / lb / br / bl / lb / lt<br>
       * null - opposite to dialog's position
       * @property {string} position
       */
      position: null,

      /**
       * t / r / b / l<br>
       * null - opposite to primary position
       * @property {string} direction
       */
      direction: null,

      /**
       * Number of pixels (triangle's height)
       * @property {number} size
       */
      size: 0,

      /**
       * Number of pixels (triangle's width), by default equals to size.
       * @property {number} width
       */
      width: null,

      /**
       * '#xxxxxx'
       * @property {string} color
       */
      color: null,

      /**
       * Shift pointer's position by this number of pixels.
       * Shift direction will depend on position:<br>
       * t / tl / b / bl - right shift<br>
       * tr / br - left shift<br>
       * r / l / rt / lt - top shift<br>
       * rb / lb - bottom shift
       * @property {number} offset
       */
      offset: 0,

      /**
       * Number of pixels.
       * @property {number} border
       */
      border: 0,

      /**
       * '#xxxxxx'
       * @property {string} borderColor
       */
      borderColor: null,

      /**
       * Custom pointer.<br>
       * If you provide custom pointer el,
       * border, direction and color will not be applied.<br>
       * pointer.cls will be applied.
       * @property {string|Element} el
       */
      el: null,

      /**
       * Apply this class to pointer.
       * @property {string} cls
       */
      cls: null,

      /**
       * Apply this class to pointerBorder element.
       * @property {string} borderCls
       */
      borderCls: null
      /**
       * @end-object
       */

    },

    /**
     * <p><em>shorthand</em>: boolean -> overlay.enabled<br></p>
     * @object overlay
     */
    overlay: {
      /**
       * Enable overlay.
       * @property {bool} enabled
       */
      enabled: false,

      /**
       * @property {string} color
       */
      color: '#000',

      /**
       * @property {number} opacity
       */
      opacity: .5,

      /**
       * @property {string} cls
       */
      cls: null,

      /**
       * Same animation rules as in show.animate.
       * @property {bool} animateShow
       */
      animateShow: false,

      /**
       * Same animation rules as in show.animate.
       * @property {bool} animateHide
       */
      animateHide: false
      /**
       * @end-object
       */

    },

    /**
     * Callbacks are case insensitive.<br>
     * You can use camel case if you like.
     * @object callback
     */
    callback: {
      /**
       * 'this' object for all callbacks, including render.fn, position.get, etc.
       * @property {object} context
       */
      context: null,

      /**
       * When content has changed.
       * @property {function} contentChange
       * @param {MetaphorJs.dialog.Dialog} dialog
       * @param {string} content
       */
      "content-change": null,

      /**
       * Before dialog appeared.<br>
       * Return false to cancel showing.
       * @property {function} beforeShow
       * @param {MetaphorJs.dialog.Dialog} dialog
       * @param {Event} event
       */
      "before-show": null,

      /**
       * Immediately after dialog appeared.
       * @property {function} show
       * @param {MetaphorJs.dialog.Dialog} dialog
       * @param {Event} event
       */
      show: null,

      /**
       * Before dialog disappears.<br>
       * Return false to cancel hiding.
       * @property {function} beforeHide
       * @param {MetaphorJs.dialog.Dialog} dialog
       * @param {Event} event
       */
      "before-hide": null,

      /**
       * Immediately after dialog has been hidden.
       * @property {function} hide
       * @param {MetaphorJs.dialog.Dialog} dialog
       * @param {Event} event
       */
      hide: null,

      /**
       * After dialog has been rendered.
       * @property {function} render
       * @param {MetaphorJs.dialog.Dialog} dialog
       */
      render: null,

      /**
       * After dialog's html element has been removed.
       * @property {function} lifetime
       * @param {MetaphorJs.dialog.Dialog} dialog
       */
      lifetime: null,

      /**
       * Called when dynamic target changes (on hide it always changes to null).
       * Also called from setTarget().
       * @property {function} targetChange
       * @param {MetaphorJs.dialog.Dialog} dialog
       * @param {HTMLElement} newTarget
       * @param {Element|null} prevTarget
       */
      "target-change": null,

      /**
       * One handler for all configured buttons. Called on click, enter and space.
       * @property {function} button
       * @param {MetaphorJs.dialog.Dialog} dialog
       * @param {string} buttonId
       * @param {Event} event
       */
      button: null
      /**
       * @end-object
       */

    }
    /**
     * @end-object
     */

  };
  /**
   * @class MetaphorJs.dialog.Dialog
   * @mixes MetaphorJs.mixin.Observable
   */

  var Dialog = cls({
    $mixins: [MetaphorJs.mixin.Observable],
    id: null,
    node: null,
    overlay: null,
    pointer: null,
    cfg: null,
    position: null,
    target: null,
    dynamicTarget: false,
    dynamicTargetEl: null,
    visible: false,
    enabled: true,
    frozen: false,
    rendered: false,
    bindSelfOnRender: false,
    hideTimeout: null,
    hideDelay: null,
    showDelay: null,
    destroyDelay: null,
    images: 0,
    positionGetType: null,
    positionClass: null,
    positionAttempt: 0,
    $constructor: function () {
      this.$$events = {
        "before-show": {
          returnResult: false
        },
        "before-hide": {
          returnResult: false
        }
      };
      this.$super.apply(this, arguments);
    },

    /**
     * @method
     * @constructor
     * @param {object} cfg See MetaphorJs.dialog.Dialog.defaults
     */
    $init: function (cfg) {
      cfg = cfg || {};
      var preset = cfg.preset,
          self = this;
      cfg.preset = null;
      cfg = extend({}, defaults, fixShorthands(Dialog.defaults), fixShorthands(Dialog[preset]), fixShorthands(cfg), true, true);
      self.cfg = cfg;
      self.id = nextUid();
      self.onPreventScrollDelegate = bind(self.onPreventScroll, self);
      self.onButtonClickDelegate = bind(self.onButtonClick, self);
      self.onButtonKeyupDelegate = bind(self.onButtonKeyup, self);
      self.showDelegate = bind(self.show, self);
      self.hideDelegate = bind(self.hide, self);
      self.toggleDelegate = bind(self.toggle, self);
      self.onImageLoadDelegate = bind(self.onImageLoad, self);
      manager.register(self);

      if (cfg.modal) {
        cfg.overlay.enabled = true;
      }

      self.overlay = new MetaphorJs.dialog.Overlay(self);
      var pointerCls = ucfirst(cfg.pointer.$class || "Html");
      self.pointer = cls.factory("MetaphorJs.dialog.pointer." + pointerCls, self, cfg.pointer);

      if (isFunction(cfg.position.type)) {
        self.positionGetType = cfg.position.type;
      }

      self.setTarget(cfg.target);

      if (cfg.target && cfg.useHref) {
        var href = MetaphorJs.dom.getAttr(self.getTarget(), "href");

        if (href.substr(0, 1) === "#") {
          cfg.render.el = href;
        } else {
          cfg.remote.url = href;
        }
      }

      if (!cfg.render.lazy) {
        self.render();
      }

      self.trigger("init", self);
      self.setHandlers("bind");
    },

    /* **** General api **** */

    /**
     * @method
     * @returns {HTMLElement}
     */
    getElem: function () {
      return this.node;
    },

    /**
     * @method
     * @returns {string}
     */
    getInstanceId: function () {
      return this.id;
    },

    /**
     * Get dialog's config.
     * @method
     * 
     * @return {object}
     */
    getCfg: function () {
      return this.cfg;
    },

    /**
     * Get dialog's pointer object
     * @method
     * @returns {MetaphorJs.dialog.pointer.*}
     */
    getPointer: function () {
      return this.pointer;
    },

    /**
     * Get dialog's overlay object
     * @method
     * @returns {MetaphorJs.dialog.Overlay}
     */
    getOverlay: function () {
      return this.overlay;
    },

    /**
     * @method
     * 
     * @return {boolean}
     */
    isEnabled: function () {
      return this.enabled;
    },

    /**
     * @method
     * 
     * @return {boolean}
     */
    isVisible: function () {
      return this.visible;
    },

    /**
     * @method
     * 
     * @returns {boolean}
     */
    isHideAllIgnored: function () {
      return this.cfg.show.ignoreHideAll;
    },

    /**
     * @method
     * 
     * @return {boolean}
     */
    isFrozen: function () {
      return this.frozen;
    },

    /**
     * @method
     * @returns {boolean}
     */
    isRendered: function () {
      return this.rendered;
    },

    /**
     * Enable dialog (enabled by default)
     * @method
     * 
     */
    enable: function () {
      this.enabled = true;
    },

    /**
     * Disable dialog
     * 
     * @method
     */
    disable: function () {
      this.hide();
      this.enabled = false;
    },

    /**
     * The difference between freeze and disable is that
     * disable always hides dialog and freeze makes current
     * state permanent (if it was shown, it will stay shown
     * until unfreeze() is called).
     * 
     * @method
     */
    freeze: function () {
      this.frozen = true;
    },

    /**
     * Unfreeze dialog
     * @method
     * 
     */
    unfreeze: function () {
      this.frozen = false;
    },

    /**
     * Get groups.
     * @method
     * 
     * @return {[]}
     */
    getGroup: function () {
      var cfg = this.cfg;

      if (!cfg.group) {
        return [""];
      } else {
        return isString(cfg.group) ? [cfg.group] : cfg.group;
      }
    },

    /**
     * Show/hide
     * @method
     * 
     * @param {Event} e Optional
     * @param {bool} immediately Optional
     */
    toggle: function (e, immediately) {
      var self = this; // if switching between dynamic targets
      // we need not to hide tooltip

      if (e && e.stopPropagation && self.dynamicTarget) {
        if (self.visible && self.isDynamicTargetChanged(e)) {
          return self.show(e);
        }
      }

      return self[self.visible ? 'hide' : 'show'](e, immediately);
    },

    /* **** Events **** */
    resetHandlers: function (fn, context) {
      var self = this;
      self.setHandlers("unbind");
      self.bindSelfOnRender = false;

      if (fn) {
        fn.call(context, self, self.getCfg());
      }

      self.setHandlers("bind");
    },
    setHandlers: function (mode, only) {
      var self = this,
          cfg = self.cfg,
          fns = ["show", "hide", "toggle"],
          lfn = mode === "bind" ? MetaphorJs.dom.addListener : MetaphorJs.dom.removeListener,
          dfn = mode === "bind" ? MetaphorJs.dom.delegate : MetaphorJs.dom.undelegate,
          fn,
          fnCfg,
          selector,
          e,
          i,
          len,
          evs,
          el,
          j,
          jl;

      while (fn = fns.shift()) {
        fnCfg = cfg[fn].events;

        if (fnCfg === false) {
          continue;
        }

        if (isString(fnCfg) || isArray(fnCfg)) {
          if (self.dynamicTarget) {
            var tmp = {};
            tmp[fnCfg] = cfg.target;
            fnCfg = {
              "_html": tmp
            };
          } else {
            fnCfg = {
              "_target": fnCfg
            };
          }
        }

        for (selector in fnCfg) {
          if (only) {
            if (only === '_self') {
              if (selector !== '_self' && selector !== "_overlay" && selector.substr(0, 1) !== '>') {
                continue;
              }
            } else if (selector !== only) {
              continue;
            }
          }

          if ((selector === '_self' || selector === '_overlay' || selector.substr(0, 1) === '>') && !self.node) {
            self.bindSelfOnRender = true;
            continue;
          }

          evs = fnCfg[selector];

          if (!evs) {
            continue;
          }

          switch (selector) {
            case "_target":
              el = [self.getTarget()];
              break;

            case "_self":
              el = [self.node];
              break;

            case "_window":
              el = [window];
              break;

            case "_document":
              el = [window.document];
              break;

            case "_html":
              el = [window.document.documentElement];
              break;

            case "_overlay":
              el = [self.overlay.getElem()];
              break;

            default:
              el = selector.substr(0, 1) === '>' ? MetaphorJs.dom.select(selector.substr(1), self.node) : MetaphorJs.dom.select(selector);
          }

          if (!el || !el.length) {
            continue;
          }

          if (isString(evs)) {
            evs = [evs];
          }

          if (isArray(evs)) {
            for (i = 0, len = evs.length; i < len; i++) {
              for (j = -1, jl = el.length; ++j < jl; lfn(el[j], evs[i], self[fn + "Delegate"])) {}
            }
          } else {
            for (e in evs) {
              for (j = -1, jl = el.length; ++j < jl; dfn(el[j], evs[e], e, self[fn + "Delegate"])) {}
            }
          }
        }
      }
    },
    onPreventScroll: function (e) {
      MetaphorJs.dom.normalizeEvent(e).preventDefault();
    },
    onButtonClick: function (e) {
      var target = MetaphorJs.dom.normalizeEvent(e).target,
          btnId = MetaphorJs.dom.data(target, "metaphorjsTooltip-button-id");

      if (btnId) {
        this.trigger("button", this, btnId, e);
      }
    },
    onButtonKeyup: function (e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        var target = e.target,
            btnId = MetaphorJs.dom.data(target, "metaphorjsTooltip-button-id");

        if (btnId) {
          this.trigger("button", this, btnId, MetaphorJs.dom.normalizeEvent(e));
        }
      }
    },
    getEventConfig: function (e, action) {
      var self = this,
          ecfg = getEventConfig(e, action, self.node),
          cfg = self.cfg;

      if (!ecfg && cfg.events[action]) {
        ecfg = cfg.events[action][e.type] || cfg.events[action]['*'];
      }

      return ecfg;
    },

    /* **** Show **** */

    /**
     * Show dialog
     * @method
     * 
     * @param {Event} e Optional. True to skip delay.
     * @param {bool} immediately Optional
     */
    show: function (e, immediately) {
      // if called as an event handler, we do not return api
      var self = this,
          cfg = self.cfg,
          returnValue = null,
          scfg = cfg.show,
          returnMode = null;

      if (e) {
        e = MetaphorJs.dom.normalizeEvent(e);
      } // if tooltip is disabled, we do not stop propagation and do not return false.s


      if (!self.isEnabled()) {
        returnMode = "disabled";
      } // if tooltip is already shown
      // and hide timeout was set.
      // we need to restart timer


      if (!returnMode && self.visible && self.hideTimeout) {
        window.clearTimeout(self.hideTimeout);
        self.hideTimeout = async(self.hide, self, null, cfg.hide.timeout);
        returnMode = "hidetimeout";
      } // if tooltip was delayed to hide
      // we cancel it.


      if (!returnMode && self.hideDelay) {
        window.clearTimeout(self.hideDelay);
        self.hideDelay = null;
        self.visible = true;
        returnMode = "hidedelay";
      } // various checks: tooltip should be enabled,
      // should not be already shown, it should
      // have some content, or empty content is allowed.
      // also if beforeShow() returns false, we can't proceed
      // if tooltip was frozen, we do not show or hide


      if (!returnMode && self.frozen) {
        returnMode = "frozen";
      } // cancel delayed destroy
      // so that we don't have to re-render dialog


      if (self.destroyDelay) {
        window.clearTimeout(self.destroyDelay);
        self.destroyDelay = null;
      }

      var dtChanged = false; // if we have a dynamicTarget

      if (e && self.dynamicTarget) {
        dtChanged = self.changeDynamicTarget(e);
      }

      if (self.visible) {
        if (!dtChanged) {
          returnMode = returnMode || "visible";
        } else {
          self.reposition(e);
          returnMode = "reposition";
        }
      }

      if (!returnMode || dtChanged) {
        // if tooltip is not rendered yet we render it
        if (!self.node) {
          self.render();
        } else if (dtChanged) {
          self.changeDynamicContent();
        }
      } // if beforeShow callback returns false we stop.


      if (!returnMode && self.trigger('before-show', self, e) === false) {
        returnMode = "beforeshow";
      }

      var ecfg;

      if (e && (ecfg = self.getEventConfig(e, "show"))) {
        if (ecfg.process) {
          returnValue = ecfg.process(self, e, "show", returnMode);
        } else {
          ecfg.stopPropagation && e.stopPropagation();
          ecfg.preventDefault && e.preventDefault();
          returnValue = ecfg.returnValue;
        }
      }

      if (returnMode) {
        return returnValue;
      } // first, we stop all current animations


      MetaphorJs.animate.stop(self.node); // as of this moment we mark dialog as visible so that hide() were able
      // to work. also, all next steps should check for this state
      // in case if tooltip case hidden back during the process

      self.visible = true;

      if (scfg.single) {
        manager.hideAll(self);
      }

      self.toggleTitleAttribute(false);

      if (scfg.delay && !immediately) {
        self.showDelay = async(self.showAfterDelay, self, [e], scfg.delay);
      } else {
        self.showAfterDelay(e, immediately);
      }

      return returnValue;
    },
    showAfterDelay: function (e, immediately) {
      var self = this,
          cfg = self.cfg;
      self.showDelay = null; // if tooltip was already hidden, we can't proceed

      if (!self.visible) {
        return;
      }

      self.trigger('show-after-delay', self, e);

      if (cfg.hide.remove) {
        self.appendElem();
      }

      self.reposition(e);

      if (cfg.show.preventScroll) {
        var ps = cfg.show.preventScroll,
            i,
            l;

        if (ps === true) {
          ps = "body";
        }

        ps = MetaphorJs.dom.select(ps);

        for (i = -1, l = ps.length; ++i < l; MetaphorJs.dom.addListener(ps[i], "mousewheel", self.onPreventScrollDelegate) && MetaphorJs.dom.addListener(ps[i], "touchmove", self.onPreventScrollDelegate)) {}
      }

      self.overlay.show();

      if (cfg.show.animate && !immediately) {
        self.animate("show").done(function () {
          self.showAfterAnimation(e);
        });
      } else {
        raf(function () {
          self.showAfterAnimation(e);
        });
      }
    },
    showAfterAnimation: function (e) {
      var self = this,
          cfg = self.cfg,
          node = self.node; // if tooltip was already hidden, we can't proceed

      if (!self.visible) {
        return;
      } // now we can finally show the dialog (if it wasn't shown already
      // during the animation


      MetaphorJs.dom.removeClass(node, cfg.cls.hidden);
      MetaphorJs.dom.addClass(node, cfg.cls.visible);

      if (!cfg.render.keepVisible) {
        node.style.display = cfg.show.display || "block";
      } // if it has to be shown only for a limited amount of time,
      // we set timeout.


      if (cfg.hide.timeout) {
        self.hideTimeout = async(self.hide, self, null, cfg.hide.timeout);
      }

      if (cfg.show.focus) {
        async(self.setFocus, self, null, 20);
      }

      self.trigger('show', self, e);
    },

    /* **** Hide **** */

    /**
     * Hide dialog
     * @method
     * 
     * @param {Event} e Optional.
     * @param {bool} immediately Optional. True to skip delay.
     * @param {bool} cancelShowDelay Optional. If showing already started but was delayed -
     * cancel that delay.
     */
    hide: function (e, immediately, cancelShowDelay) {
      var self = this,
          returnValue = null,
          returnMode = null,
          cfg = self.cfg;
      self.hideTimeout = null; // if the timer was set to hide the tooltip
      // but then we needed to close tooltip immediately

      if (!self.visible && self.hideDelay && immediately) {
        window.clearTimeout(self.hideDelay);
        self.hideDelay = null;
        self.visible = true;
      } // various checks


      if (!self.node || !self.visible || !self.isEnabled()) {
        returnMode = !self.node ? "noelem" : !self.visible ? "hidden" : "disabled";
      } // if tooltip is still waiting to be shown after delay timeout,
      // we cancel this timeout and return.


      if (self.showDelay && !returnMode) {
        if (cfg.hide.cancelShowDelay || cancelShowDelay) {
          window.clearTimeout(self.showDelay);
          self.showDelay = null;
          self.visible = false;
          returnMode = "cancel";
        } else {
          returnMode = "delay";
        }
      } // if tooltip was frozen, we do not show or hide


      if (self.frozen && !returnMode) {
        returnMode = "frozen";
      } // lets see what the callback will tell us


      if (!returnMode && self.trigger('before-hide', self, e) === false) {
        returnMode = "beforehide";
      }

      var ecfg;

      if (e && e.stopPropagation && (ecfg = self.getEventConfig(e, "hide"))) {
        if (ecfg.process) {
          returnValue = ecfg.process(self, e, "hide", returnMode);
        } else {
          if (ecfg.stopPropagation) e.stopPropagation();
          if (ecfg.preventDefault) e.preventDefault();
          returnValue = ecfg.returnValue;
        }
      }

      if (returnMode) {
        return returnValue;
      } // now we can stop all current animations


      MetaphorJs.animate.stop(self.node); // and change the state

      self.visible = false; //self.toggleTitleAttribute(true);

      if (self.dynamicTarget) {
        self.resetDynamicTarget();
      }

      if (cfg.hide.delay && !immediately) {
        self.hideDelay = async(self.hideAfterDelay, self, [e], cfg.hide.delay);
      } else {
        self.hideAfterDelay(e, immediately);
      }

      return returnValue;
    },
    hideAfterDelay: function (e, immediately) {
      var self = this,
          cfg = self.cfg;
      self.hideDelay = null;

      if (self.visible) {
        return;
      }

      self.trigger('hide-after-delay', self, e);

      if (cfg.show.preventScroll) {
        var ps = cfg.show.preventScroll,
            i,
            l;

        if (ps === true) {
          ps = "body";
        }

        ps = MetaphorJs.dom.select(ps);

        for (i = -1, l = ps.length; ++i < l; MetaphorJs.dom.removeListener(ps[i], "mousewheel", self.onPreventScrollDelegate) && MetaphorJs.dom.removeListener(ps[i], "touchmove", self.onPreventScrollDelegate)) {}
      }

      self.overlay.hide();

      if (cfg.hide.animate && !immediately) {
        self.animate("hide").done(function () {
          self.hideAfterAnimation(e);
        });
      } else {
        raf(function () {
          self.hideAfterAnimation(e);
        });
      }
    },
    hideAfterAnimation: function (e) {
      var self = this,
          cfg = self.cfg,
          node = self.node; // we need to check if the tooltip was returned to visible state
      // while hiding animation

      if (self.visible) {
        return;
      }

      MetaphorJs.dom.removeClass(node, cfg.cls.visible);
      MetaphorJs.dom.addClass(node, cfg.cls.hidden);

      if (!cfg.render.keepVisible) {
        node.style.display = "none";
      }

      self.trigger('hide', self, e);
      var lt = cfg.render.lifetime;

      if (lt !== null) {
        if (lt === 0) {
          self.destroyElem();
        } else {
          self.destroyDelay = async(self.destroyElem, self, null, lt);
        }
      }

      if (node && cfg.hide.destroy) {
        raf(function () {
          MetaphorJs.dom.data(node, cfg.instanceName, null);
          self.$destroy();
        });
      } else if (node && cfg.hide.remove) {
        raf(function () {
          self.removeElem();
        });
      }
    },

    /* **** Render **** */
    render: function () {
      var self = this,
          cfg = self.cfg,
          elem; // if already rendered, we return

      if (self.node) {
        return;
      }

      var rnd = cfg.render,
          cls = cfg.cls; // custom rendering function

      if (rnd.fn) {
        var res = rnd.fn.call(self.$$callbackContext, self);
        rnd[isString(res) ? 'tpl' : 'el'] = res;
      }

      if (rnd.el) {
        if (isString(rnd.el)) {
          elem = MetaphorJs.dom.select(rnd.el).shift();
          rnd.keepInDOM = true;
        } else {
          elem = rnd.el;
        }
      } else {
        var tmp = window.document.createElement("div");
        tmp.innerHTML = rnd.tpl;
        elem = tmp.firstChild;
      }

      if (!elem) {
        elem = window.document.createElement("div");
      }

      self.node = elem;

      if (rnd.id) {
        MetaphorJs.dom.setAttr(elem, 'id', rnd.id);
      }

      if (!cfg.render.keepVisible) {
        elem.style.display = "none";
      }

      MetaphorJs.dom.addClass(elem, cls.dialog);
      MetaphorJs.dom.addClass(elem, cls.hidden);

      if (rnd.style) {
        MetaphorJs.dom.setStyle(elem, rnd.style);
      }

      self.overlay.render();

      if (!cfg.hide.remove) {
        self.appendElem();
      } else {
        if (elem.parentNode) {
          elem.parentNode.removeChild(elem);
        }
      }

      if (rnd.zIndex) {
        MetaphorJs.dom.setStyle(elem, {
          zIndex: rnd.zIndex
        });
      }

      var cnt = cfg.content;

      if (cnt.value !== false) {
        if (cnt.value) {
          self.setContent(cnt.value);
        } else {
          if (cnt.fn) {
            self.setContent(cnt.fn.call(self.$$callbackContext, self));
          } else {
            self[cfg.remote.url ? 'loadContent' : 'readContent']();
          }
        }
      }

      self.pointer.render();
      self.pointer.append();

      if (cfg.buttons) {
        var btnId, btn;

        for (btnId in cfg.buttons) {
          btn = MetaphorJs.dom.select(cfg.buttons[btnId], elem).shift();

          if (btn) {
            MetaphorJs.dom.data(btn, "metaphorjsTooltip-button-id", btnId);
            MetaphorJs.dom.addListener(btn, "click", self.onButtonClickDelegate);
            MetaphorJs.dom.addListener(btn, "keyup", self.onButtonKeyupDelegate);
          }
        }
      }

      if (self.bindSelfOnRender) {
        self.setHandlers('bind', '_self');
        self.bindSelfOnRender = false;
      }

      self.rendered = true;
      self.trigger('render', self);
    },

    /* **** Position **** */
    setPositionType: function (type) {
      var self = this,
          positionCls = self.getPositionClass(type);
      self.cfg.position.type = type;

      if (self.positionClass !== positionCls || !self.position) {
        if (self.position) {
          self.position.$destroy();
          self.position = null;
        }

        if (positionCls) {
          self.position = cls.factory(positionCls, self);
        }
      } else {
        self.position.type = type;
      }

      if (self.isVisible()) {
        self.reposition();
      }
    },
    getPosition: function (e) {
      var self = this,
          cfgPos = self.cfg.position;

      if (!self.position) {
        if (!self.positionGetType && cfgPos.type !== "custom") {
          if (isFunction(cfgPos.get) && cfgPos.type !== "m") {
            cfgPos.type = "custom";
          }
        }

        var type = self.positionGetType ? self.positionGetType.call(self.$$callbackContext, self, e) : cfgPos.type,
            positionCls = self.getPositionClass(type);
        cfgPos.type = type;

        if (positionCls === false) {
          return;
        }

        if (self.positionClass !== positionCls) {
          self.position = cls.factory(positionCls, self);
        } else {
          self.position.type = type;
        }
      }

      return self.position;
    },
    getPositionClass: function (type) {
      if (!type) {
        return false;
      }

      if (isFunction(type) || type === "custom") {
        return "MetaphorJs.dialog.position.Custom";
      } else if (type === "draggable") {
        return "MetaphorJs.dialog.position.Draggable";
      } else if (type === "none") {
        return "MetaphorJs.dialog.position.None";
      }

      var fc = type.substr(0, 1);

      if (!fc) {
        return false;
      } else if (fc === "w") {
        return "MetaphorJs.dialog.position.Window";
      } else if (fc === "m") {
        return "MetaphorJs.dialog.position.Mouse";
      } else {
        return "MetaphorJs.dialog.position.Target";
      }
    },

    /**
     * Usually called internally from show().
     * @method
     * 
     * @param {Event} e Optional.
     */
    reposition: function (e) {
      var self = this;

      if (self.repositioning) {
        return;
      }

      if (self.node && !MetaphorJs.dom.isAttached(self.node)) {
        MetaphorJs.dom.whenAttached(self.node).done(function () {
          self.reposition(e);
        });
        return;
      }

      self.repositioning = true;
      e && (e = MetaphorJs.dom.normalizeEvent(e));
      self.getPosition(e);
      self.trigger("before-reposition", self, e);
      self.getPosition(e);
      self.trigger("reposition", self, e);
      self.repositioning = false;
    },

    /* **** Target **** */

    /**
     * Get dialog's target.
     * @method
     * 
     * @return {HTMLElement}
     */
    getTarget: function () {
      return this.dynamicTarget ? this.dynamicTargetEl : this.target;
    },

    /**
     * Set new dialog's target.
     * @method
     * 
     * @param {string|Element} newTarget Selector or dom node
     */
    setTarget: function (newTarget) {
      if (!newTarget) {
        return;
      }

      var self = this,
          change = false,
          prev = self.target;

      if (self.target) {
        self.setHandlers('unbind', '_target');
        change = true;
      } else if (self.dynamicTarget) {
        change = true;
      }

      var isStr = isString(newTarget);

      if (isStr && newTarget.substr(0, 1) !== "#") {
        self.dynamicTarget = true;
        self.target = null;
      } else {
        if (isStr) {
          newTarget = MetaphorJs.dom.select(newTarget).shift();
        }

        self.dynamicTarget = false;
        self.target = newTarget;
      }

      if (change) {
        self.setHandlers('bind', '_target');
        self.trigger("target-change", self, newTarget, prev);
      }
    },
    resetDynamicTarget: function () {
      var self = this,
          curr = self.dynamicTargetEl;

      if (curr) {
        self.setHandlers("unbind", "_target");
        self.trigger("target-change", self, null, curr);
      }
    },
    isDynamicTargetChanged: function (e) {
      var self = this,
          cfg = self.cfg,
          dt = cfg.target,
          t = e.target,
          curr = self.dynamicTargetEl;

      while (t && !MetaphorJs.dom.is(t, dt)) {
        t = t.parentNode;
      }

      if (!t) {
        return false;
      }

      return !curr || curr !== t;
    },
    changeDynamicTarget: function (e) {
      var self = this,
          cfg = self.cfg,
          dt = cfg.target,
          t = e.target,
          curr = self.dynamicTargetEl;

      while (t && !MetaphorJs.dom.is(t, dt)) {
        t = t.parentNode;
      }

      if (!t) {
        return false;
      }

      if (!curr || curr !== t) {
        if (curr) {
          self.setHandlers("unbind", "_target");
        }

        self.dynamicTargetEl = t;
        self.setHandlers("bind", "_target");
        self.trigger("target-change", self, t, curr);
        return true;
      } else {
        return false;
      }
    },

    /* **** Content **** */

    /**
     * @method
     * 
     * @return {HTMLElement}
     */
    getContentElem: function () {
      var self = this,
          node = self.node;

      if (!node) {
        return null;
      }

      if (self.cfg.selector.content) {
        var el = MetaphorJs.dom.select(self.cfg.selector.content, node).shift();
        return el || node;
      } else {
        return node;
      }
    },

    /**
     * Set new content.
     * @method
     * 
     * @param {string|object} content {
         *      See "selector" option
         *      @required
     * }
     * @param {string} mode "", "attribute", "remote" -- optional (used internally). See
     * content.prepare option.
     */
    setContent: function (content, mode) {
      mode = mode || '';
      var self = this,
          node = self.node,
          cfg = self.cfg,
          pnt = self.pointer;

      if (!node) {
        cfg.content.value = content;
        return self;
      }

      if (cfg.content.prepare) {
        content = cfg.content.prepare.call(self.$$callbackContext, self, mode, content);
      }

      var contentElem = self.getContentElem(),
          fixPointer = self.rendered && !cfg.selector.content && pnt,
          pntEl = fixPointer && pnt.getElem();

      if (fixPointer && pntEl) {
        try {
          node.removeChild(pntEl);
        } catch (thrownError) {
          error(thrownError);
        }
      }

      if (!isString(content)) {
        for (var i in content) {
          var sel = cfg.selector[i];

          if (sel) {
            var cel = MetaphorJs.dom.select(sel, contentElem).shift();

            if (cel) {
              cel.innerHTML = content[i];
            }
          }
        }
      } else {
        contentElem.innerHTML = content;
      } // if there a pointer, and this is not initial content set,
      // and there is no selector for content
      // we must restore pointer after dialog's inner html
      // has been replaced with new content


      if (fixPointer && pntEl) {
        try {
          node.appendChild(pntEl);
        } catch (thrownError) {
          error(thrownError);
        }
      }

      var imgs = MetaphorJs.dom.select("img", contentElem),
          l;
      self.images = imgs.length;

      for (i = -1, l = imgs.length; ++i < l; MetaphorJs.dom.addListener(imgs[i], "load", self.onImageLoadDelegate)) {}

      self.trigger('content-change', self, content, mode);
      self.onContentChange();
    },

    /**
     * Force dialog to re-read content from attributes.
     * @method
     * 
     */
    readContent: function () {
      var self = this,
          cfg = self.cfg,
          el = self.getTarget(),
          content;

      if (el) {
        if (typeof cfg.content.attr === "string") {
          content = MetaphorJs.dom.getAttr(el, cfg.content.attr);
        } else {
          content = MetaphorJs.dom.getAttr(el, 'tooltip') || MetaphorJs.dom.getAttr(el, 'title') || MetaphorJs.dom.getAttr(el, 'alt');
        }
      }

      if (content) {
        self.setContent(content, 'attribute');
      }
    },

    /**
     * Load remote content.
     * @method
     * @param {object} options Merged with cfg.remote
     */
    loadContent: function (options) {
      const self = this,
            cfg = self.cfg;
      MetaphorJs.dom.addClass(self.node, cfg.cls.loading);
      var opt = extend({}, cfg.remote, options, true, true);
      self.trigger('before-fetch', self, opt);

      if (opt.useMetaphor) {
        if (!MetaphorJs.remote || !MetaphorJs.remote.fetch) {
          console.error("MetaphorJs.remote.fetch is not available in this build");
        }

        delete opt.useMetaphor;
        return MetaphorJs.remote.fetch(opt).done(self.onRemoteLoad, self);
      }

      return fetch(opt).then(r => r.text()).then(resp => self.onRemoteLoad(resp));
    },
    onRemoteLoad: function (data) {
      var self = this;
      MetaphorJs.dom.removeClass(self.node, self.cfg.cls.loading);
      self.setContent(data, 'remote');
    },
    onImageLoad: function () {
      this.images--;
      this.onContentChange();
    },
    onContentChange: function () {
      if (this.visible) {
        this.reposition();
      }
    },
    changeDynamicContent: function () {
      var self = this,
          cfg = self.cfg;

      if (cfg.content.fn) {
        self.setContent(cfg.content.fn.call(self.$$callbackContext, self));
      } else if (cfg.content.attr) {
        self.readContent();
      }
    },
    toggleTitleAttribute: function (state) {
      var self = this,
          trg = self.getTarget(),
          title;

      if (trg) {
        if (state === false) {
          if (trg.hasAttribute("title")) {
            MetaphorJs.dom.setAttr(trg, "tooltip", MetaphorJs.dom.getAttr(trg, "title"));
            MetaphorJs.dom.removeAttr(trg, 'title');
          }
        } else if (title = MetaphorJs.dom.getAttr(trg, "tooltip")) {
          MetaphorJs.dom.setAttr(trg, "title", title);
        }
      }
    },

    /* **** Dimension **** */
    getDialogSize: function () {
      var self = this;

      if (!self.rendered) {
        self.render();
      }

      var cfg = self.cfg,
          node = self.node,
          hidden = cfg.cls.hidden ? MetaphorJs.dom.hasClass(node, cfg.cls.hidden) : !MetaphorJs.dom.isVisible(node),
          size,
          left = node.style.left;

      if (hidden) {
        MetaphorJs.dom.setStyle(node, {
          left: "-1000px"
        });
        node.style.display = cfg.show.display;
      }

      size = {
        width: MetaphorJs.dom.getOuterWidth(node),
        height: MetaphorJs.dom.getOuterHeight(node)
      };

      if (hidden) {
        MetaphorJs.dom.setStyle(node, {
          left: left
        });
        node.style.display = "none";
      }

      return size;
    },
    getTargetSize: function () {
      var self = this,
          target = self.getTarget();

      if (!target) {
        return null;
      }

      return {
        width: MetaphorJs.dom.getOuterWidth(target),
        height: MetaphorJs.dom.getOuterHeight(target)
      };
    },

    /* **** Misc **** */

    /**
     * Set focus based on focus setting.
     * @method
     */
    setFocus: function () {
      var self = this,
          cfg = self.cfg,
          af = cfg.show.focus,
          node = self.node,
          i,
          input;

      if (af === true) {
        input = MetaphorJs.dom.select("input", node).concat(MetaphorJs.dom.select("textarea", node));

        if (input.length > 0) {
          input[0].focus();
        } else if (cfg.buttons) {
          for (i in cfg.buttons) {
            var btn = MetaphorJs.dom.select(cfg.buttons[i], node).shift();
            btn && btn.focus();
            break;
          }
        }
      } else {
        var el = MetaphorJs.dom.select(af, node).shift();
        el && el.focus();
      }
    },
    getScrollEl: function (cfgScroll) {
      if (cfgScroll === true || cfgScroll === false) {
        return window;
      } else if (typeof cfgScroll === "string") {
        return MetaphorJs.dom.select(cfgScroll).shift();
      } else {
        return cfgScroll;
      }
    },
    animate: function (section, e) {
      var self = this,
          cfg = self.cfg,
          node = self.node,
          a,
          skipDisplay;
      a = cfg[section].animate;

      if (isFunction(a)) {
        a = a(self, e);
      }

      skipDisplay = a.skipDisplayChange || false;

      if (isBool(a)) {
        a = section;
      } else if (isString(a)) {
        a = [a];
      }

      return MetaphorJs.animate.animate(node, a, function () {
        if (section === "show" && !skipDisplay) {
          return new MetaphorJs.lib.Promise(function (resolve, reject) {
            raf(function () {
              node.style.display = cfg.show.display || "block";
              resolve();
            });
          });
        }
      }, false);
    },
    removeElem: function () {
      var self = this,
          node = self.node;
      self.overlay.remove();

      if (node && node.parentNode) {
        raf(function () {
          if (!self.visible) {
            node.parentNode.removeChild(node);
          }
        });
      }
    },
    appendElem: function () {
      var self = this,
          cfg = self.cfg,
          body = window.document.body,
          rnd = cfg.render,
          to = rnd.appendTo || body;
      self.overlay.append();

      if (self.node && cfg.render.appendTo !== false) {
        to.appendChild(self.node);
        self.trigger("attached", self, to);
      } else if (self.node && MetaphorJs.dom.isAttached(self.node)) {
        self.trigger("attached", self, self.node.parentNode);
      }
    },

    /* **** Destroy **** */
    destroyElem: function () {
      var self = this,
          node = self.node;
      self.setHandlers("unbind", "_self");
      self.bindSelfOnRender = true;
      self.pointer.remove();
      self.overlay.remove();

      if (node) {
        if (!self.cfg.render.keepInDOM) {
          node.parentNode && node.parentNode.removeChild(node);
        }

        self.node = null;
      }

      self.trigger("lifetime", self);
    },
    onDestroy: function () {
      var self = this;
      self.setHandlers("unbind");
      self.trigger("destroy", self);
      self.destroyElem();
      self.overlay && self.overlay.$destroy();
      self.pointer && self.pointer.$destroy();
      self.position && self.position.$destroy();
    }
  }, {
    defaults: null
  });
  return Dialog;
}();

/***/ }),

/***/ "../metaphorjs-dialog/src/dialog/Manager.js":
/*!**************************************************!*\
  !*** ../metaphorjs-dialog/src/dialog/Manager.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs-dialog/src/__init.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dialog.Manager = cls({
  all: null,
  groups: null,
  $init: function () {
    this.all = {};
    this.groups = {};
  },
  register: function (dialog) {
    var id = dialog.getInstanceId(),
        grps = dialog.getGroup(),
        self = this,
        all = self.all,
        groups = self.groups,
        i,
        len,
        g;
    all[id] = dialog;

    for (i = 0, len = grps.length; i < len; i++) {
      g = grps[i];

      if (!groups[g]) {
        groups[g] = {};
      }

      groups[g][id] = true;
    }

    dialog.on("destroy", this.unregister, this);
  },
  unregister: function (dialog) {
    var id = dialog.getInstanceId();
    delete this.all[id];
  },
  hideAll: function (dialog) {
    var id = dialog.getInstanceId(),
        grps = dialog.getGroup(),
        self = this,
        all = self.all,
        groups = self.groups,
        i,
        len,
        gid,
        ds,
        did;

    for (i = 0, len = grps.length; i < len; i++) {
      gid = grps[i];
      ds = groups[gid];

      for (did in ds) {
        if (!all[did]) {
          delete ds[did];
        } else if (did != id && !all[did].isHideAllIgnored()) {
          all[did].hide(null, true, true);
        }
      }
    }
  }
});

/***/ }),

/***/ "../metaphorjs-dialog/src/dialog/Overlay.js":
/*!**************************************************!*\
  !*** ../metaphorjs-dialog/src/dialog/Overlay.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs-dialog/src/__init.js");

__webpack_require__(/*! metaphorjs/src/func/dom/setStyle.js */ "../metaphorjs/src/func/dom/setStyle.js");

__webpack_require__(/*! metaphorjs/src/func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! metaphorjs/src/func/dom/normalizeEvent.js */ "../metaphorjs/src/func/dom/normalizeEvent.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/animate.js */ "../metaphorjs-animate/src/animate/animate.js");

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      raf = __webpack_require__(/*! metaphorjs-animate/src/func/raf.js */ "../metaphorjs-animate/src/func/raf.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      isBool = __webpack_require__(/*! metaphorjs-shared/src/func/isBool.js */ "../metaphorjs-shared/src/func/isBool.js");

module.exports = MetaphorJs.dialog.Overlay = cls({
  dialog: null,
  enabled: false,
  color: '#000',
  opacity: .5,
  cls: null,
  animateShow: false,
  animateHide: false,
  $mixins: [MetaphorJs.mixin.Observable],
  $init: function (dialog) {
    var self = this;
    self.dialog = dialog;
    self.onClickDelegate = bind(self.onClick, self);
    extend(self, dialog.getCfg().overlay, true, false);
    self.$$observable.createEvent("click", false);

    if (self.enabled) {
      self.enabled = false;
      self.enable();
    }
  },
  getElem: function () {
    var self = this;

    if (self.enabled && !self.node) {
      self.render();
    }

    return self.node;
  },
  enable: function () {
    var self = this;

    if (!self.enabled) {
      self.enabled = true;
    }
  },
  disable: function () {
    var self = this;

    if (self.enabled) {
      self.remove();
      self.enabled = false;
    }
  },
  show: function (e) {
    var self = this;

    if (!self.enabled) {
      return;
    }

    if (self.animateShow) {
      self.animate("show", e);
    } else {
      self.node.style.display = "block";
    }
  },
  hide: function (e) {
    var self = this;

    if (self.node) {
      if (self.animateHide) {
        self.animate("hide", e);
      } else {
        self.node.style.display = "none";
      }
    }
  },
  render: function () {
    var self = this;

    if (!self.enabled) {
      return;
    }

    var node = window.document.createElement("div"),
        cfg = self.dialog.getCfg(),
        style = {
      display: "none",
      position: "fixed",
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };

    if (self.opacity !== false) {
      style.opacity = self.opacity;
    }

    if (self.color !== false) {
      style.backgroundColor = self.color;
    }

    MetaphorJs.dom.setStyle(node, style);
    MetaphorJs.dom.addListener(node, "click", self.onClickDelegate);

    if (cfg.render.zIndex) {
      MetaphorJs.dom.setStyle(node, "zIndex", cfg.render.zIndex);
    }

    if (self.cls) {
      MetaphorJs.dom.addClass(node, self.cls);
    }

    self.node = node;
  },
  remove: function () {
    var self = this,
        node = self.node;

    if (node) {
      raf(function () {
        //if (!dialog.isVisible() && node.parentNode) {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      });
    }
  },
  append: function () {
    var self = this,
        cfg = self.dialog.getCfg(),
        to = cfg.render.appendTo || window.document.body;

    if (!self.enabled || self.$destroyed) {
      return;
    }

    if (!self.node) {
      self.render();
    }

    to.appendChild(self.node);
  },
  animate: function (type, e) {
    var self = this,
        node = self.node,
        a;
    a = type == "show" ? self.animateShow : self.animateHide;

    if (isFunction(a)) {
      a = a(self, e);
    }

    if (isBool(a)) {
      a = type;
    } else if (isString(a)) {
      a = [a];
    }

    return MetaphorJs.animate.animate(node, a, function () {
      if (type == "show") {
        return new MetaphorJs.lib.Promise(function (resolve, reject) {
          raf(function () {
            node.style.display = "";
            resolve();
          });
        });
      }
    }, false);
  },
  onClick: function (e) {
    var self = this;
    var res = self.trigger("click", self.dialog, self, e);

    if (res === false) {
      return null;
    }

    if (self.modal) {
      e = MetaphorJs.dom.normalizeEvent(e);
      e.preventDefault();
      e.stopPropagation();
      return false;
    }

    return null;
  },
  onDestroy: function () {
    var self = this;
    self.remove();
  }
});

/***/ }),

/***/ "../metaphorjs-dialog/src/dialog/pointer/Abstract.js":
/*!***********************************************************!*\
  !*** ../metaphorjs-dialog/src/dialog/pointer/Abstract.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "../metaphorjs-dialog/src/__init.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dialog.pointer.Abstract = cls({
  enabled: null,
  node: null,
  correctX: 0,
  correctY: 0,
  $init: function (dialog, cfg) {
    var self = this;
    extend(self, cfg, true, false);
    self.origCfg = cfg;
    self.dialog = dialog;
    self.opposite = {
      t: "b",
      r: "l",
      b: "t",
      l: "r"
    };
    self.names = {
      t: 'top',
      r: 'right',
      b: 'bottom',
      l: 'left'
    };
    self.sides = {
      t: ['l', 'r'],
      r: ['t', 'b'],
      b: ['r', 'l'],
      l: ['b', 't']
    };

    if (self.enabled !== false && cfg.size) {
      self.enabled = true;
    } else {
      self.enabled = false;
    }
  },
  enable: function () {
    var self = this;

    if (!self.enabled) {
      self.enabled = true;
      self.render();

      if (self.dialog.isVisible()) {
        self.dialog.reposition();
      }
    }
  },
  disable: function () {
    var self = this;

    if (self.enabled) {
      self.remove();
      self.enabled = false;

      if (self.dialog.isVisible()) {
        self.dialog.reposition();
      }
    }
  },
  getElem: function () {
    return this.node;
  },
  getSize: function () {
    return this.enabled ? this.size : 0;
  },
  setCorrectionOffset: function (x, y) {
    this.correctX = x;
    this.correctY = y;
  },
  getCorrectionValue: function (type, value, position) {
    if (!value) {
      return 0;
    }

    var self = this,
        pri = position.substr(0, 1),
        sec = position.substr(1, 1),
        tsize = self.dialog.getDialogSize(),
        width = self.width,
        sprop = pri == "t" || pri == "b" ? "width" : "height",
        min,
        max;

    switch (sec) {
      case "":
        max = tsize[sprop] / 2 - width / 2;
        min = -max;
        break;

      case "l":
        min = 0;
        max = tsize[sprop] - width / 2;
        break;

      case "r":
        min = -(tsize[sprop] - width / 2);
        max = 0;
        break;
    }

    value = value < 0 ? Math.max(min, value) : Math.min(max, value);

    if ((pri == "t" || pri == "b") && type == "x") {
      return value;
    }

    if ((pri == "l" || pri == "r") && type == "y") {
      return value;
    }

    return 0;
  },
  getDialogPositionOffset: function (position) {
    var self = this,
        pp = (self.detectPointerPosition(position) || "").substr(0, 1),
        dp = self.dialog.getPosition().getPrimaryPosition(position),
        ofs = {
      x: 0,
      y: 0
    };

    if (!self.enabled) {
      return ofs;
    }

    if (pp == self.opposite[dp]) {
      ofs[pp == "t" || pp == "b" ? "y" : "x"] = pp == "b" || pp == "r" ? -self.size : self.size;
    }

    return ofs;
  },
  detectPointerPosition: function (dialogPosition) {
    var self = this,
        pri,
        sec,
        thr;

    if (self.position && !dialogPosition) {
      if (isFunction(self.position)) {
        return self.position.call(self.dialog.$$callbackContext, self.dialog, self.origCfg);
      }

      return self.position;
    }

    pri = self.dialog.getPosition().getPrimaryPosition(dialogPosition) || "";
    sec = self.dialog.getPosition().getSecondaryPosition(dialogPosition) || "";
    thr = sec ? sec.substr(1, 1) : null;

    if (!pri) {
      return null;
    }

    var position = self.opposite[pri] || "";

    if (sec) {
      sec = sec.substr(0, 1);

      if (thr === "c") {
        position += self.opposite[sec];
      } else {
        position += sec;
      }
    }

    return position;
  },
  detectPointerDirection: function (position) {
    var self = this;

    if (self.direction) {
      if (isFunction(self.direction)) {
        return self.direction.call(self.dialog.$$callbackContext, self.dialog, position, self.origCfg);
      }

      return self.direction;
    }

    return position;
  },
  update: function () {
    var self = this;
    self.remove();
    self.render();
    self.append();

    if (self.dialog.isVisible()) {
      self.dialog.reposition();
    }
  },
  setType: function (position, direction) {
    var self = this;
    self.position = position;
    self.direction = direction;
    self.update();
    self.reposition();
  },
  render: function () {},
  onDestroy: function () {
    var self = this;
    self.remove();
  },
  reposition: function () {},
  append: function () {
    var self = this;

    if (!self.enabled) {
      return;
    }

    if (!self.node) {
      self.render();
    }

    if (!self.node) {
      return;
    }

    self.reposition();
    var parent = self.dialog.getElem();

    if (parent) {
      parent.appendChild(self.node);
    }
  },
  remove: function () {
    var self = this,
        node = self.node;

    if (node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }

      self.node = null;
    }
  }
});

/***/ }),

/***/ "../metaphorjs-dialog/src/dialog/pointer/Html.js":
/*!*******************************************************!*\
  !*** ../metaphorjs-dialog/src/dialog/pointer/Html.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "../metaphorjs-dialog/src/__init.js");

__webpack_require__(/*! metaphorjs/src/func/dom/setStyle.js */ "../metaphorjs/src/func/dom/setStyle.js");

__webpack_require__(/*! metaphorjs/src/func/dom/addClass.js */ "../metaphorjs/src/func/dom/addClass.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/getPrefixes.js */ "../metaphorjs-animate/src/animate/getPrefixes.js");

__webpack_require__(/*! ./Abstract.js */ "../metaphorjs-dialog/src/dialog/pointer/Abstract.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      ucfirst = __webpack_require__(/*! metaphorjs-shared/src/func/ucfirst.js */ "../metaphorjs-shared/src/func/ucfirst.js");

module.exports = MetaphorJs.dialog.pointer.Html = function () {
  var ie6 = null,
      defaultProps = {
    backgroundColor: 'transparent',
    width: '0px',
    height: '0px',
    position: 'absolute',
    fontSize: '0px',
    // ie6
    lineHeight: '0px' // ie6

  };
  return MetaphorJs.dialog.pointer.Abstract.$extend({
    node: null,
    sub: null,
    $init: function (dialog, cfg) {
      if (ie6 === null) {
        ie6 = window.document.all && !window.XMLHttpRequest;
      }

      var self = this;
      self.$super(dialog, cfg);
      self.width = self.width || self.size * 2;

      if (self.inner) {
        self.enabled = true;
      }
    },
    createInner: function () {
      var self = this,
          newcfg = extend({}, self.origCfg);
      newcfg.size = self.size - self.border * 2;
      newcfg.width = self.width - self.border * 4;
      newcfg.border = 0;
      newcfg.borderColor = null;
      newcfg.borderCls = null;
      newcfg.offset = 0;
      newcfg.inner = self.border;
      self.sub = new MetaphorJs.dialog.pointer.Html(self.dialog, newcfg);
    },
    getBorders: function (position, direction, color) {
      var self = this,
          borders = {},
          pri = position.substr(0, 1),
          dpri = direction.substr(0, 1),
          dsec = direction.substr(1),
          style = ie6 ? "dotted" : "solid",
          names = self.names,
          sides = self.sides,
          opposite = self.opposite; // in ie6 "solid" wouldn't make transparency :(
      // this is always height : border which is opposite to direction

      borders['border' + ucfirst(names[opposite[pri]])] = self.size + "px solid " + color; // border which is similar to direction is always 0

      borders['border' + ucfirst(names[pri])] = "0 " + style + " transparent";

      if (!dsec) {
        // if pointer's direction matches pointer primary position (p: l|lt|lb, d: l)
        // then we set both side borders to a half of the width;
        var side = Math.floor(self.width / 2);
        borders['border' + ucfirst(names[sides[dpri][0]])] = side + "px " + style + " transparent";
        borders['border' + ucfirst(names[sides[dpri][1]])] = side + "px " + style + " transparent";
      } else {
        // if pointer's direction doesn't match with primary position (p: l|lt|lb, d: t|b)
        // we set the border opposite to direction to the full width;
        borders['border' + ucfirst(names[dsec])] = "0 solid transparent";
        borders['border' + ucfirst(names[opposite[dsec]])] = self.width + "px " + style + " transparent";
      }

      return borders;
    },
    getOffsets: function (position, direction) {
      var self = this,
          offsets = {},
          names = self.names,
          opposite = self.opposite,
          pri = position.substr(0, 1),
          auto = pri == 't' || pri == 'b' ? "r" : "b";
      offsets[names[pri]] = self.inner ? 'auto' : -self.size + "px";
      offsets[names[auto]] = "auto";

      if (!self.inner) {
        var margin;

        switch (position) {
          case 't':
          case 'r':
          case 'b':
          case 'l':
            if (direction != position) {
              if (direction == 'l' || direction == 't') {
                margin = self.offset;
              } else {
                margin = -self.width + self.offset;
              }
            } else {
              margin = -self.width / 2 + self.offset;
            }

            break;

          case 'bl':
          case 'tl':
          case 'lt':
          case 'rt':
            margin = self.offset;
            break;

          default:
            margin = -self.width - self.offset;
            break;
        }

        offsets['margin' + ucfirst(names[opposite[auto]])] = margin + "px";
        var positionOffset;

        switch (position) {
          case 't':
          case 'r':
          case 'b':
          case 'l':
            positionOffset = '50%';
            break;

          case 'tr':
          case 'rb':
          case 'br':
          case 'lb':
            positionOffset = '100%';
            break;

          default:
            positionOffset = 0;
            break;
        }

        offsets[names[opposite[auto]]] = positionOffset;
        var pfxs = MetaphorJs.animate.getPrefixes(),
            transformPfx = pfxs.transform,
            transform = "",
            cx = self.correctX,
            cy = self.correctY;

        if (transformPfx) {
          if (cx) {
            transform += " translateX(" + self.getCorrectionValue("x", cx, position) + "px)";
          }

          if (cy) {
            transform += " translateY(" + self.getCorrectionValue("y", cy, position) + "px)";
          }

          offsets[transformPfx] = transform;
        }
      } else {
        var innerOffset,
            dpri = direction.substr(0, 1),
            dsec = direction.substr(1);

        if (dsec) {
          if (dsec == 'l' || dsec == 't') {
            innerOffset = self.inner + 'px';
          } else {
            innerOffset = -self.width - self.inner + 'px';
          }
        } else {
          innerOffset = Math.floor(-self.width / 2) + 'px';
        }

        offsets[names[opposite[auto]]] = innerOffset;
        offsets[names[opposite[dpri]]] = -(self.size + self.inner * 2) + 'px';
      }

      return offsets;
    },
    render: function () {
      var self = this;

      if (!self.enabled) {
        return;
      }

      if (self.node) {
        return;
      }

      var position = self.detectPointerPosition();

      if (!position) {
        return;
      }

      if (self.border && !self.sub) {
        self.createInner();
      }

      self.node = window.document.createElement('div');
      var cmt = window.document.createComment(" ");
      self.node.appendChild(cmt);
      MetaphorJs.dom.setStyle(self.node, defaultProps);
      MetaphorJs.dom.addClass(self.node, self.borderCls || self.cls);

      if (self.sub) {
        self.sub.render();
        self.node.appendChild(self.sub.getElem());
      }
    },
    reposition: function () {
      var self = this,
          position = self.detectPointerPosition(),
          direction = self.detectPointerDirection(position);

      if (!self.node) {
        return;
      }

      MetaphorJs.dom.setStyle(self.node, self.getBorders(position, direction, self.borderColor || self.color));
      MetaphorJs.dom.setStyle(self.node, self.getOffsets(position, direction));

      if (self.sub) {
        self.sub.reposition();
      }
    },
    update: function () {
      var self = this;

      if (self.sub) {
        self.sub.$destroy();
        self.sub = null;
      }

      self.remove();
      self.node = null;
      self.render();
      self.append();

      if (self.dialog.isVisible()) {
        self.dialog.reposition();
      }
    },
    onDestroy: function () {
      var self = this;

      if (self.sub) {
        self.sub.$destroy();
        self.sub = null;
      }

      self.$super();
    },
    remove: function () {
      var self = this;

      if (self.sub) {
        self.sub.remove();
      }

      self.$super();
    }
  });
}();

/***/ }),

/***/ "../metaphorjs-dialog/src/dialog/position/Abstract.js":
/*!************************************************************!*\
  !*** ../metaphorjs-dialog/src/dialog/position/Abstract.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "../metaphorjs-dialog/src/__init.js");

__webpack_require__(/*! metaphorjs/src/func/dom/setStyle.js */ "../metaphorjs/src/func/dom/setStyle.js");

__webpack_require__(/*! metaphorjs/src/func/dom/select.js */ "../metaphorjs/src/func/dom/select.js");

__webpack_require__(/*! metaphorjs/src/func/dom/normalizeEvent.js */ "../metaphorjs/src/func/dom/normalizeEvent.js");

__webpack_require__(/*! metaphorjs/src/func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getScrollTop.js */ "../metaphorjs/src/func/dom/getScrollTop.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getScrollLeft.js */ "../metaphorjs/src/func/dom/getScrollLeft.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getOuterWidth.js */ "../metaphorjs/src/func/dom/getOuterWidth.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getOuterHeight.js */ "../metaphorjs/src/func/dom/getOuterHeight.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getWidth.js */ "../metaphorjs/src/func/dom/getWidth.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getHeight.js */ "../metaphorjs/src/func/dom/getHeight.js");

__webpack_require__(/*! metaphorjs/src/func/dom/isAttached.js */ "../metaphorjs/src/func/dom/isAttached.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dialog.position.Abstract = cls({
  dialog: null,
  positionBase: null,
  correct: "solid",
  $init: function (dialog) {
    var self = this;
    self.dialog = dialog;
    extend(self, dialog.getCfg().position, true, false);
    self.onWindowResizeDelegate = bind(self.onWindowResize, self);
    self.onWindowScrollDelegate = bind(self.onWindowScroll, self);

    if (self.type === "auto") {
      self.type = null;
    }

    var pt = self.preferredType || self.type;

    if (typeof pt === "string") {
      var pts = self.getAllPositions(),
          inx;

      if ((inx = pts.indexOf(pt)) !== -1) {
        pts.splice(inx, 1);
        pts.unshift(pt);
      }

      self.preferredType = pts;
      !self.type && (self.type = pts[0]);
    } else if (!pt) {
      self.preferredType = self.getAllPositions();
      !self.type && (self.type = self.preferredType[0]);
    } else {
      !self.type && (self.type = self.preferredType[0]);
    }

    dialog.on("reposition", self.onReposition, self);
    dialog.on("show-after-delay", self.onShowAfterDelay, self);
    dialog.on("hide-after-delay", self.onHideAfterDelay, self);

    if (dialog.isVisible()) {
      self.onShowAfterDelay();
    }
  },
  getPositionBase: function () {
    var self = this,
        dlg = self.dialog;

    if (self.positionBase) {
      return self.positionBase;
    }

    var b;

    if (b = dlg.getCfg().position.base) {
      if (typeof b === "string") {
        self.positionBase = MetaphorJs.dom.select(b).shift();
      } else {
        self.positionBase = b;
      }

      return self.positionBase;
    }

    return null;
  },
  getBoundary: function () {
    var self = this,
        base = self.getPositionBase(),
        sx = self.screenX || 0,
        sy = self.screenY || 0,
        w,
        h,
        st,
        sl,
        ofs;

    if (base) {
      ofs = MetaphorJs.dom.getOffset(base);
      w = MetaphorJs.dom.getOuterWidth(base);
      h = MetaphorJs.dom.getOuterHeight(base);
      return {
        x: ofs.left + sx,
        y: ofs.top + sy,
        x1: ofs.left + w - sx,
        y1: ofs.top + h - sy,
        w: w,
        h: h
      };
    } else {
      w = MetaphorJs.dom.getWidth(window);
      h = MetaphorJs.dom.getHeight(window);
      st = MetaphorJs.dom.getScrollTop(window);
      sl = MetaphorJs.dom.getScrollLeft(window);
      return {
        x: sl + sx,
        y: st + sy,
        x1: sl + w - sx,
        y1: st + h - sy,
        w: w,
        h: h
      };
    }
  },
  getPrimaryPosition: function (pos) {
    return false;
  },
  getSecondaryPosition: function (pos) {
    return false;
  },
  getAllPositions: function () {
    return [];
  },
  correctPosition: function (e) {
    var self = this,
        pri = self.getPrimaryPosition(),
        strategy = self.correct;

    if (!pri || !strategy) {
      return;
    }

    var dlg = self.dialog,
        boundary = self.getBoundary(),
        size = dlg.getDialogSize(),
        pts = self.preferredType,
        pt = pts[0],
        i,
        l;

    if (strategy && strategy !== "none") {
      if (strategy && strategy != "solid") {
        if (self.type != pt && self.checkIfFits(e, pt, boundary, size, false)) {
          self.changeType(pt);
          return self.fitToBoundary(self.getCoords(e), boundary, size);
        }

        if (self.checkIfFits(e, self.type, boundary, size, false)) {
          return self.fitToBoundary(self.getCoords(e), boundary, size);
        }
      }

      if (strategy && strategy != "position-only") {
        for (i = 0, l = pts.length; i < l; i++) {
          if (self.checkIfFits(e, pts[i], boundary, size, true)) {
            self.changeType(pts[i]);
            return self.getCoords(e);
          }
        }
      }
    }

    return self.getCoords(e);
  },
  checkIfFits: function (e, position, boundary, size, fully) {
    var self = this,
        coords = self.getCoords(e, position, true); // leave only basic positions here

    if (!fully && self.getSecondaryPosition(position)) {
      return false;
    }

    if (fully) {
      return !(coords.x < boundary.x || coords.y < boundary.y || coords.x + size.width > boundary.x1 || coords.y + size.height > boundary.y1);
    } else {
      var pri = self.getPrimaryPosition(position);

      switch (pri) {
        case "t":
          return coords.y >= boundary.y;

        case "r":
          return coords.x + size.width <= boundary.x1;

        case "b":
          return coords.y + size.height <= boundary.y1;

        case "l":
          return coords.x >= boundary.x;
      }
    }
  },
  fitToBoundary: function (coords, boundary, size) {
    var self = this,
        base = self.getPositionBase(),
        x = base ? 0 : boundary.x,
        y = base ? 0 : boundary.y,
        x1 = base ? boundary.w : boundary.x1,
        y1 = base ? boundary.h : boundary.y1,
        xDiff = 0,
        yDiff = 0,
        pointer = self.dialog.getPointer();

    if (coords.x < x) {
      xDiff = coords.x - x;
      coords.x = x;
    }

    if (coords.y < y) {
      yDiff = coords.y - y;
      coords.y = y;
    }

    if (coords.x + size.width > x1) {
      xDiff = coords.x + size.width - x1;
      coords.x -= xDiff;
    }

    if (coords.y + size.height > y1) {
      yDiff = coords.y + size.height - y1;
      coords.y -= yDiff;
    }

    pointer.setCorrectionOffset(xDiff, yDiff);
    pointer.reposition();
    return coords;
  },
  changeType: function (type) {
    var self = this,
        dlg = self.dialog,
        pointer = dlg.getPointer();
    self.type = type;
    pointer.setType(null, null);
  },
  onReposition: function (dlg, e) {
    var self = this,
        coords; // cannot calculate and apply position

    if (!dlg.node || !MetaphorJs.dom.isAttached(dlg.node)) {
      return;
    }

    if (self.screenX !== false || self.screenY !== false) {
      coords = self.correctPosition(e);
    } else {
      coords = self.getCoords(e);
    }

    self.apply(coords);
  },
  getCoords: function (e) {
    return {
      x: 0,
      y: 0
    };
  },
  apply: function (coords) {
    if (!coords) {
      return;
    }

    if (isNaN(coords.x) || isNaN(coords.y)) {
      return;
    }

    var self = this,
        dlg = self.dialog,
        axis = dlg.getCfg().position.axis,
        pos = {};
    axis != "y" && (pos.left = coords.x + "px");
    axis != "x" && (pos.top = coords.y + "px");
    MetaphorJs.dom.setStyle(dlg.getElem(), pos);
  },
  onWindowResize: function (e) {
    this.dialog.reposition(MetaphorJs.dom.normalizeEvent(e));
  },
  onWindowScroll: function (e) {
    this.dialog.reposition(MetaphorJs.dom.normalizeEvent(e));
  },
  onShowAfterDelay: function () {
    var self = this;

    if (self.resize || self.screenX || self.screenY) {
      MetaphorJs.dom.addListener(window, "resize", self.onWindowResizeDelegate);
    }

    if (self.scroll || self.screenX || self.screenY) {
      MetaphorJs.dom.addListener(self.dialog.getScrollEl(self.scroll), "scroll", self.onWindowScrollDelegate);
    }
  },
  onHideAfterDelay: function () {
    var self = this;

    if (self.resize || self.screenX || self.screenY) {
      MetaphorJs.dom.removeListener(window, "resize", self.onWindowResizeDelegate);
    }

    if (self.scroll || self.screenX || self.screenY) {
      MetaphorJs.dom.removeListener(self.dialog.getScrollEl(self.scroll), "scroll", self.onWindowScrollDelegate);
    }
  },
  onDestroy: function () {
    var self = this,
        dlg = self.dialog;
    MetaphorJs.dom.removeListener(window, "resize", self.onWindowResizeDelegate);
    MetaphorJs.dom.removeListener(dlg.getScrollEl(self.scroll), "scroll", self.onWindowScrollDelegate);
    dlg.un("reposition", self.onReposition, self);
    dlg.un("show-after-delay", self.onShowAfterDelay, self);
    dlg.un("hide-after-delay", self.onHideAfterDelay, self);

    if (dlg.isVisible()) {
      self.onHideAfterDelay();
    }
  }
});

/***/ }),

/***/ "../metaphorjs-dialog/src/dialog/position/Custom.js":
/*!**********************************************************!*\
  !*** ../metaphorjs-dialog/src/dialog/position/Custom.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

__webpack_require__(/*! ../../__init.js */ "../metaphorjs-dialog/src/__init.js");

__webpack_require__(/*! ./Abstract.js */ "../metaphorjs-dialog/src/dialog/position/Abstract.js");

module.exports = MetaphorJs.dialog.position.Custom = MetaphorJs.dialog.position.Abstract.$extend({
  getCoords: function (e) {
    var dlg = this.dialog;
    return this.get.call(dlg.$$callbackContext || this, dlg, e);
  }
});

/***/ }),

/***/ "../metaphorjs-dialog/src/dialog/position/Draggable.js":
/*!*************************************************************!*\
  !*** ../metaphorjs-dialog/src/dialog/position/Draggable.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

__webpack_require__(/*! ../../__init.js */ "../metaphorjs-dialog/src/__init.js");

__webpack_require__(/*! ./Abstract.js */ "../metaphorjs-dialog/src/dialog/position/Abstract.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getOffset.js */ "../metaphorjs/src/func/dom/getOffset.js");

module.exports = MetaphorJs.dialog.position.Draggable = MetaphorJs.dialog.position.Abstract.$extend({
  getCoords: function (e) {
    var dlg = this.dialog;

    if (this.get) {
      return this.get.call(dlg.$$callbackContext, dlg, e);
    } else {
      // if node is not yet visible,
      // we try to extract position from style
      if (!MetaphorJs.dom.isVisible(dlg.getElem())) {
        var elem = dlg.getElem(),
            left = elem.style.left,
            top = elem.style.top;

        if (left && top) {
          return {
            x: parseInt(left),
            y: parseInt(top)
          };
        }
      } // otherwise get element offset


      var ofs = MetaphorJs.dom.getOffset(dlg.getElem());
      return {
        x: ofs.left,
        y: ofs.top
      };
    }
  },
  correctPosition: function (e) {
    var self = this,
        dlg = self.dialog,
        boundary = self.getBoundary(),
        size = dlg.getDialogSize();

    if (!self.checkIfFits(e, self.type, boundary, size, true)) {
      return self.fitToBoundary(self.getCoords(e), boundary, size);
    }

    return self.getCoords(e);
  }
});

/***/ }),

/***/ "../metaphorjs-dialog/src/dialog/position/Mouse.js":
/*!*********************************************************!*\
  !*** ../metaphorjs-dialog/src/dialog/position/Mouse.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js");

__webpack_require__(/*! ../../__init.js */ "../metaphorjs-dialog/src/__init.js");

__webpack_require__(/*! metaphorjs/src/func/dom/normalizeEvent.js */ "../metaphorjs/src/func/dom/normalizeEvent.js");

__webpack_require__(/*! metaphorjs/src/func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getOffset.js */ "../metaphorjs/src/func/dom/getOffset.js");

__webpack_require__(/*! ./Target.js */ "../metaphorjs-dialog/src/dialog/position/Target.js");

module.exports = MetaphorJs.dialog.position.Mouse = MetaphorJs.dialog.position.Target.$extend({
  correct: "position",
  $init: function (dialog) {
    var self = this;
    self.onMouseMoveDelegate = bind(self.onMouseMove, self);
    self.$super(dialog);
  },
  getCoords: function (e, type, absolute) {
    if (!e) {
      return null;
    }

    var self = this,
        origType = type || self.type,
        dlg = self.dialog,
        cfg = dlg.getCfg(),
        size = dlg.getDialogSize(),
        base = self.getPositionBase(),
        pos = {},
        type = (type || self.type).substr(1),
        offsetX = cfg.position.offsetX,
        offsetY = cfg.position.offsetY,
        axis = cfg.position.axis,
        pntOfs = dlg.getPointer().getDialogPositionOffset(origType),
        absOfs = {
      x: 0,
      y: 0
    };

    if (!absolute && base) {
      var baseOfs = MetaphorJs.dom.getOffset(base);
      absOfs.x = baseOfs.left;
      absOfs.y = baseOfs.top;
    }

    switch (type) {
      case "":
        {
          pos = self.get.call(dlg.$$callbackContext, dlg, e, type, absolute);
          break;
        }

      case "c":
        {
          pos.y = e.pageY - absOfs.y - size.height / 2;
          pos.x = e.pageX - absOfs.x - size.width / 2;
          break;
        }

      case "t":
        {
          pos.y = e.pageY - absOfs.y - size.height - offsetY;
          pos.x = e.pageX - absOfs.x - size.width / 2;
          break;
        }

      case "r":
        {
          pos.y = e.pageY - absOfs.y - size.height / 2;
          pos.x = e.pageX - absOfs.x + offsetX;
          break;
        }

      case "b":
        {
          pos.y = e.pageY - absOfs.y + offsetY;
          pos.x = e.pageX - absOfs.x - size.width / 2;
          break;
        }

      case "l":
        {
          pos.y = e.pageY - absOfs.y - size.height / 2;
          pos.x = e.pageX - absOfs.x - size.width - offsetX;
          break;
        }

      case "rt":
        {
          pos.y = e.pageY - absOfs.y - size.height - offsetY;
          pos.x = e.pageX - absOfs.x + offsetX;
          break;
        }

      case "rb":
        {
          pos.y = e.pageY - absOfs.y + offsetY;
          pos.x = e.pageX - absOfs.x + offsetX;
          break;
        }

      case "lt":
        {
          pos.y = e.pageY - absOfs.y - size.height - offsetY;
          pos.x = e.pageX - absOfs.x - size.width - offsetX;
          break;
        }

      case "lb":
        {
          pos.y = e.pageY - absOfs.y + offsetY;
          pos.x = e.pageX - absOfs.x - size.width - offsetX;
          break;
        }
    }

    if (pntOfs) {
      pos.x += pntOfs.x;
      pos.y += pntOfs.y;
    }

    if (axis) {
      var tp = self.$super(e, type);

      if (tp) {
        if (axis == "x") {
          pos.y = tp.y;
        } else {
          pos.x = tp.x;
        }
      }
    }

    return pos;
  },
  onShowAfterDelay: function () {
    var self = this;
    self.$super();
    MetaphorJs.dom.addListener(window.document.documentElement, "mousemove", self.onMouseMoveDelegate);
  },
  onHideAfterDelay: function () {
    var self = this;
    self.$super();
    MetaphorJs.dom.removeListener(window.document.documentElement, "mousemove", self.onMouseMoveDelegate);
  },
  onMouseMove: function (e) {
    this.dialog.reposition(MetaphorJs.dom.normalizeEvent(e));
  },
  getPrimaryPosition: function (pos) {
    return (pos || this.type).substr(1, 1);
  },
  getSecondaryPosition: function (pos) {
    return (pos || this.type).substr(2);
  },
  getAllPositions: function () {
    return ["mt", "mr", "mb", "ml", "mrt", "mrb", "mlb", "mlt"];
  }
});

/***/ }),

/***/ "../metaphorjs-dialog/src/dialog/position/None.js":
/*!********************************************************!*\
  !*** ../metaphorjs-dialog/src/dialog/position/None.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "../metaphorjs-dialog/src/__init.js");

__webpack_require__(/*! ./Abstract.js */ "../metaphorjs-dialog/src/dialog/position/Abstract.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getOffset.js */ "../metaphorjs/src/func/dom/getOffset.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeStyle.js */ "../metaphorjs/src/func/dom/removeStyle.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dialog.position.None = MetaphorJs.dialog.position.Abstract.$extend({
  $init: function (dialog) {
    this.$super(dialog);
    MetaphorJs.dom.removeStyle(dialog.getElem(), "left");
    MetaphorJs.dom.removeStyle(dialog.getElem(), "top");
  },
  getCoords: function (e) {
    var dlg = this.dialog,
        ofs = MetaphorJs.dom.getOffset(dlg.getElem());
    return {
      x: ofs.left,
      y: ofs.top
    };
  },
  apply: function () {},
  correctPosition: function (e) {
    return this.getCoords(e);
  }
});

/***/ }),

/***/ "../metaphorjs-dialog/src/dialog/position/Target.js":
/*!**********************************************************!*\
  !*** ../metaphorjs-dialog/src/dialog/position/Target.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getOffset.js */ "../metaphorjs/src/func/dom/getOffset.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getPosition.js */ "../metaphorjs/src/func/dom/getPosition.js");

__webpack_require__(/*! ./Abstract.js */ "../metaphorjs-dialog/src/dialog/position/Abstract.js");

module.exports = MetaphorJs.dialog.position.Target = MetaphorJs.dialog.position.Abstract.$extend({
  getCoords: function (e, type, absolute) {
    var self = this,
        dlg = self.dialog,
        cfg = dlg.getCfg(),
        target = dlg.getTarget();

    if (!target) {
      return null;
    }

    type = type || self.type;
    var pBase = self.getPositionBase(),
        size = dlg.getDialogSize(),
        offset = pBase && !absolute ? MetaphorJs.dom.getPosition(target, pBase) : MetaphorJs.dom.getOffset(target),
        tsize = dlg.getTargetSize(),
        pos = {},
        pri = type.substr(0, 1),
        sec = type.substr(1),
        offsetX = cfg.position.offsetX,
        offsetY = cfg.position.offsetY,
        pntOfs = dlg.pointer.getDialogPositionOffset(type);

    switch (pri) {
      case "t":
        {
          pos.y = offset.top - size.height - offsetY;
          break;
        }

      case "r":
        {
          pos.x = offset.left + tsize.width + offsetX;
          break;
        }

      case "b":
        {
          pos.y = offset.top + tsize.height + offsetY;
          break;
        }

      case "l":
        {
          pos.x = offset.left - size.width - offsetX;
          break;
        }
    }

    switch (sec) {
      case "t":
        {
          pos.y = offset.top + offsetY;
          break;
        }

      case "r":
        {
          pos.x = offset.left + tsize.width - size.width - offsetX;
          break;
        }

      case "b":
        {
          pos.y = offset.top + tsize.height - size.height - offsetY;
          break;
        }

      case "l":
        {
          pos.x = offset.left + offsetX;
          break;
        }

      case "rc":
        {
          pos.x = offset.left + tsize.width + offsetX;
          break;
        }

      case "lc":
        {
          pos.x = offset.left - size.width - offsetX;
          break;
        }

      case "":
        {
          switch (pri) {
            case "t":
            case "b":
              {
                pos.x = offset.left + tsize.width / 2 - size.width / 2;
                break;
              }

            case "r":
            case "l":
              {
                pos.y = offset.top + tsize.height / 2 - size.height / 2;
                break;
              }
          }

          break;
        }
    }

    if (pntOfs) {
      pos.x += pntOfs.x;
      pos.y += pntOfs.y;
    }

    return pos;
  },
  getPrimaryPosition: function (pos) {
    return (pos || this.type || "").substr(0, 1);
  },
  getSecondaryPosition: function (pos) {
    return (pos || this.type || "").substr(1);
  },
  getAllPositions: function () {
    return ["t", "r", "b", "l", "tl", "tr", "rt", "rb", "br", "bl", "lb", "lt", "tlc", "trc", "brc", "blc"];
  }
});

/***/ }),

/***/ "../metaphorjs-dialog/src/dialog/position/Window.js":
/*!**********************************************************!*\
  !*** ../metaphorjs-dialog/src/dialog/position/Window.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

__webpack_require__(/*! ../../__init.js */ "../metaphorjs-dialog/src/__init.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getScrollTop.js */ "../metaphorjs/src/func/dom/getScrollTop.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getScrollLeft.js */ "../metaphorjs/src/func/dom/getScrollLeft.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getOuterWidth.js */ "../metaphorjs/src/func/dom/getOuterWidth.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getOuterHeight.js */ "../metaphorjs/src/func/dom/getOuterHeight.js");

__webpack_require__(/*! ./Abstract.js */ "../metaphorjs-dialog/src/dialog/position/Abstract.js");

module.exports = MetaphorJs.dialog.position.Window = MetaphorJs.dialog.position.Abstract.$extend({
  getCoords: function (e, type) {
    var self = this,
        dlg = self.dialog,
        pBase = self.getPositionBase() || window,
        size = dlg.getDialogSize(),
        pos = {},
        type = (type || self.type).substr(1),
        offsetX = self.offsetX,
        offsetY = self.offsetY,
        st = MetaphorJs.dom.getScrollTop(pBase),
        sl = MetaphorJs.dom.getScrollLeft(pBase),
        ww = MetaphorJs.dom.getOuterWidth(pBase),
        wh = MetaphorJs.dom.getOuterHeight(pBase);

    switch (type) {
      case "c":
        {
          pos.y = wh / 2 - size.height / 2 + st + offsetY;
          pos.x = ww / 2 - size.width / 2 + sl + offsetX;
          break;
        }

      case "t":
        {
          pos.y = st + offsetY;
          pos.x = ww / 2 - size.width / 2 + sl + offsetX;
          break;
        }

      case "r":
        {
          pos.y = wh / 2 - size.height / 2 + st - offsetY;
          pos.x = ww - size.width + sl - offsetX;
          break;
        }

      case "b":
        {
          pos.y = wh - size.height + st - offsetY;
          pos.x = ww / 2 - size.width / 2 + sl + offsetX;
          break;
        }

      case "l":
        {
          pos.y = wh / 2 - size.height / 2 + st + offsetY;
          pos.x = sl + offsetX;
          break;
        }

      case "rt":
        {
          pos.y = st + offsetY;
          pos.x = ww - size.width + sl - offsetX;
          break;
        }

      case "rb":
        {
          pos.y = wh - size.height + st - offsetY;
          pos.x = ww - size.width + sl - offsetX;
          break;
        }

      case "lt":
        {
          pos.y = st + offsetY;
          pos.x = sl + offsetX;
          break;
        }

      case "lb":
        {
          pos.y = wh - size.height + st - offsetY;
          pos.x = sl + offsetX;
          break;
        }
    }

    return pos;
  },
  getPrimaryPosition: function (type) {
    return (type || this.type).substr(1, 1);
  },
  getSecondaryPosition: function (type) {
    return (type || this.type).substr(2);
  },
  getAllPositions: function () {
    return ["wt", "wr", "wb", "wl", "wrt", "wrb", "wlb", "wlt", "wc"];
  },
  correctPosition: function (e) {
    return this.getCoords(e);
  }
});

/***/ }),

/***/ "../metaphorjs-dialog/src/directive/dropdown.js":
/*!******************************************************!*\
  !*** ../metaphorjs-dialog/src/directive/dropdown.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../dialog/Dialog.js */ "../metaphorjs-dialog/src/dialog/Dialog.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getParentDocument.js */ "../metaphorjs/src/func/dom/getParentDocument.js");

const Directive = __webpack_require__(/*! metaphorjs/src/app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      isThenable = __webpack_require__(/*! metaphorjs-shared/src/func/isThenable.js */ "../metaphorjs-shared/src/func/isThenable.js"),
      ns = __webpack_require__(/*! metaphorjs-namespace/src/var/ns.js */ "../metaphorjs-namespace/src/var/ns.js");

Directive.registerAttribute("dropdown", 1100, Directive.$extend({
  $class: "MetaphorJs.app.Directive.attr.Dropdown",
  id: "dropdown",
  _autoOnChange: false,
  _dialog: null,
  _contentNode: null,
  _hostCmp: null,
  _contentCmp: null,
  _asyncInit: true,
  initConfig: function () {
    this.$super();
    MetaphorJs.app.Directive.attr.Dropdown.initConfig(this.config);
  },
  initDirective: function () {
    var self = this,
        config = self.config,
        state = self.state,
        ref = config.get("ref"),
        cmpid = config.get("cmp"),
        selector = config.get("selector"),
        doc = MetaphorJs.dom.getParentDocument(self.node),
        cmp;

    if (self.component) {
      if (ref) {
        cmp = self.component.getRefCmp(ref) || self.component.getRefCmpPromise(ref);
      } else if (cmpid) {
        if (typeof cmpid === "string") {
          if (state.$app) {
            cmp = state.$app.getCmp(cmpid) || state.$app.onAvailable(cmpid);
          }
        } else {
          cmp = cmpid;
        }
      } else if (selector) {
        self._contentNode = doc.querySelector(selector);
      }

      if (cmp) {
        if (isThenable(cmp)) {
          cmp.done(function (component) {
            self._contentCmp = component;
            self._contentNode = component.getRefEl("main");
          });
          cmp.done(self._initDialog, self);
        } else {
          self._contentCmp = cmp;
          self._contentNode = cmp.getRefEl("main");

          self._initDialog();
        }
      }
    } else {
      self._contentNode = doc.getElementById(ref);

      self._initDialog();
    }

    self.$super();
  },
  initChange: function () {// skip setting onChange listener
  },
  _initDialog: function () {
    var self = this;

    if (!self._dialog) {
      var cls = ns.get(self.config.get("dialog")),
          cfg = self._getDialogConfig();

      self._dialog = new cls(cfg);
      self.$$observable.relayEvent(self._dialog, "*");

      self._dialog.on("*", self.state.$check, self.state);
    }

    return this._dialog;
  },
  _getDialogConfig: function () {
    var self = this,
        config = self.config,
        cfgCfg = config.get("config"),
        on = config.get("on"),
        un = config.get("un"),
        appendTo = config.get("appendTo"),
        position = config.get("position"),
        animate = config.get("animate"),
        opposite = {
      "click": "click",
      "mouseover": "mouseout"
    };

    if (appendTo && typeof appendTo === "string") {
      appendTo = window.document.querySelector(appendTo);
    }

    var defCfg = {
      preset: config.get("preset") || null,
      target: self.node,
      content: false,
      render: {
        el: self._contentNode,
        keepInDOM: true,
        appendTo: appendTo || false
      },
      position: position || false
    };

    if (on === "click") {
      extend(defCfg, {
        events: {
          show: {
            "click": {
              stopPropagation: true,
              preventDefault: true
            }
          },
          hide: {
            click: {
              stopPropagation: false,
              preventDefault: false
            }
          }
        },
        toggle: {
          events: {
            _target: on
          }
        },
        hide: {
          animate: animate,
          events: {
            _html: "click"
          }
        },
        show: {
          animate: animate
        }
      });
    } else if (on === "mouseover") {
      extend(defCfg, {
        show: {
          animate: animate,
          events: {
            _target: on,
            _self: on
          }
        },
        hide: {
          animate: animate,
          events: {
            _target: un || opposite[on]
          }
        }
      });
    }

    var cfg = extend({}, cfgCfg, defCfg, true, true);
    return cfg;
  },
  onDestroy: function () {
    if (this._dialog) {
      this._dialog.$destroy();
    }

    this.$super();
  }
}, {
  initConfig: function (config) {
    var s = MetaphorJs.lib.Config.MODE_STATIC;
    config.disableProperty("value");
    config.setDefaultMode("ref", s);
    config.setDefaultMode("selector", s);
    config.setDefaultMode("cmp", s);
    config.setDefaultMode("dialog", s);
    config.setDefaultMode("on", s);
    config.setDefaultMode("un", s);
    config.setDefaultMode("appendTo", s);
    config.setDefaultMode("position", s);
    config.setDefaultMode("preset", s);
    config.setType("animate", "bool", s);
    config.setDefaultValue("dialog", "MetaphorJs.dialog.Dialog");
    config.setDefaultValue("on", "click");
  }
}));

/***/ }),

/***/ "../metaphorjs-dialog/src/mixin/Dialog.js":
/*!************************************************!*\
  !*** ../metaphorjs-dialog/src/mixin/Dialog.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs-dialog/src/__init.js");

__webpack_require__(/*! metaphorjs/src/lib/DomEvent.js */ "../metaphorjs/src/lib/DomEvent.js");

__webpack_require__(/*! ../dialog/Dialog.js */ "../metaphorjs-dialog/src/dialog/Dialog.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js");

module.exports = MetaphorJs.mixin.Dialog = {
  dialog: null,
  dialogPreset: null,
  dialogCfg: null,
  _hidden: true,
  autoRender: true,
  target: null,
  isTooltip: false,
  $beforeInit: function (cfg) {
    var self = this;
    self.autoRender = true;

    if ((!cfg || !cfg.node) && !self.template && (!cfg || !cfg.template)) {
      self.node = window.document.createElement("div");
    }

    self.$intercept("_onRenderingFinished", self._onDialogRenderingFinished, self, "after");
  },
  $beforeDestroy: function () {
    if (this.dialog) {
      this.dialog.$destroy();
    }
  },
  getDialogCfg: function () {
    var self = this;
    return extend({}, self.dialogCfg, {
      preset: self.dialogPreset,
      render: {
        el: self.getRefEl("main"),
        keepInDOM: true,
        appendTo: false,
        lazy: false
      }
    }, true, true);
  },
  getDialog: function () {
    return this.dialog;
  },
  _onDialogRenderingFinished: function () {
    var self = this,
        i,
        l,
        items = self.items;

    if (items) {
      // insert all placeholders, but
      // attach only resolved items
      for (i = -1, l = items.length; ++i < l;) {
        self._putItemInPlace(items[i]);
      }
    }

    this._createDialog();
  },
  _createDialog: function () {
    var self = this;
    self.dialog = new MetaphorJs.dialog.Dialog(self.getDialogCfg());
    self.dialog.on("show", self.onDialogShow, self);
    self.dialog.on("hide", self.onDialogHide, self);
    self.dialog.on("before-show", self.onBeforeDialogShow, self);
    self.dialog.on("before-hide", self.onBeforeDialogHide, self);
    self.dialog.on("destroy", self.onDialogDestroy, self);
    self.dialog.on("attached", self.onDialogAttached, self);

    if (!self._hidden) {
      self.show();
    }
  },
  show: function (e) {
    if (e && !(e instanceof MetaphorJs.lib.DomEvent)) {
      e = null;
    }

    if (this.dialog) {
      this.dialog.show(e);
    } else this._hidden = false;
  },
  hide: function (e) {
    if (e && !(e instanceof MetaphorJs.lib.DomEvent)) {
      e = null;
    }

    if (this.dialog) {
      this.dialog.hide(e);
    } else this._hidden = true;
  },
  onDialogAttached: function () {
    if (!this._attached) {
      this.render(this.node.parentNode);
    }
  },
  onBeforeDialogShow: function () {
    var self = this;

    if (!self._rendered) {
      self.render();
    } else if (!self._attached && self.renderTo) {
      self.attach(self.renderTo, self.renderBefore);
    }

    self._hidden = false;
  },
  onDialogShow: function () {
    var self = this;
    self.trigger("show", self);
  },
  onBeforeDialogHide: function () {},
  onDialogHide: function () {
    var self = this;

    if (!self.$destroyed) {
      self._hidden = true;
      self.trigger("hide", self);
    }
  },
  onDialogDestroy: function () {
    var self = this;

    if (!self.$destroying) {
      self.dialog = null;
      self.$destroy();
    }
  }
};

/***/ }),

/***/ "../metaphorjs-model/src/__init.js":
/*!*****************************************!*\
  !*** ../metaphorjs-model/src/__init.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

MetaphorJs.model = MetaphorJs.model || {};

/***/ }),

/***/ "../metaphorjs-model/src/directive/attr/each.js":
/*!******************************************************!*\
  !*** ../metaphorjs-model/src/directive/attr/each.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs/src/app/StoreRenderer.js */ "../metaphorjs/src/app/StoreRenderer.js");

__webpack_require__(/*! metaphorjs/src/directive/attr/each.js */ "../metaphorjs/src/directive/attr/each.js");

__webpack_require__(/*! ../../model/Store.js */ "../metaphorjs-model/src/model/Store.js");

const Directive = __webpack_require__(/*! metaphorjs/src/app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.getDirective("attr", "each").registerType(MetaphorJs.model.Store, MetaphorJs.app.StoreRenderer);

/***/ }),

/***/ "../metaphorjs-model/src/model/Model.js":
/*!**********************************************!*\
  !*** ../metaphorjs-model/src/model/Model.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isThenable = __webpack_require__(/*! metaphorjs-shared/src/func/isThenable.js */ "../metaphorjs-shared/src/func/isThenable.js");

__webpack_require__(/*! ../__init.js */ "../metaphorjs-model/src/__init.js");

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");

module.exports = MetaphorJs.model.Model = function () {
  let instances = {},
      cache = {};
  /**
   * @class MetaphorJs.model.Model
   */

  return cls({
    $mixins: [MetaphorJs.mixin.Observable],
    type: null,
    fields: null,
    record: null,
    store: null,
    plain: false,
    lastFetchedResponse: null,

    /**
     * @constructor
     * @method $init
     * @param {object} cfg {
     *      Properties 
     *      <code>json,id,url,fn,data,success,extra,root,data,
     *              processRequest,validate,resolve</code> are valid 
     *      on the top level and inside all create/load/save/delete/controller
     *      groups.<br> Use string or function instead of object as shortcut
     *      for load.url/save.url/load.fn/save.fn etc.
     * 
     *      @type {string} type Record class
     *      @type {object} fields {
     *          Fields conf
     *          @type {object|string} *name* {
     *              Field name: conf
     *              @type {string} type {
     *                  int|bool|boolean|double|float|date
     *              }
     *              @type {function} parseFn {
     *                  Parse date field
     *                  @param {string} value
     *                  @param {string} format Format from this config
     *              }
     *              @type {function} formatFn {
     *                  Prepare date field for sending
     *                  @param {*} value
     *                  @param {string} format Format from this config
     *              }
     *              @type {string} format Date format {
     *                  If format == "timestamp", <code>date = parseInt(value) * 1000</code>
     *              }
     *              @type {function} restore {
     *                  Custom value processor (on receiving). Another way is to override
     *                  <code>onRestoreField(rec, name, value)</code> method
     *                  @param {object} rec Record from response
     *                  @param {*} value Data value
     *                  @param {string} name Field name
     *                  @returns {*}
     *              }
     *              @type {function} store {
     *                  Custom value processor (on sending). Another way is to override
     *                  <code>onStoreField(rec, value, name)</code> method.
     *                  @param {object} rec 
     *                  @param {*} value
     *                  @param {string} name
     *                  @returns {string}
     *              }
     *          }
     *      }
     *      
     *      @type {bool} json Send data as json string in the request body.
     *      @type {string} url Api endpoint.
     *                      In url you can use <code>:name</code> placeholders,
     *                      they will be taken from payload.
     *      @type {function} fn Optional function that performs request.
     *                       It accepts payload and returns Promise which
     *                          is then resolved with response. 
     *      @type {string} id Id field. Where to take record id from or 
     *                      put record id to (when sending).
     *      @type {string|function} success Success field or function
     *                     that takes response and returns boolean. 
     *                     If resulted in false, request fails. Leave
     *                     undefined to skip this check.
     *      @type {object} data Main data payload.
     *      @type {object} extra Extra params object. Adds data to payload, 
     *                          overrides data fields.
     *      @type {string} root Records root. In "load" requests this is
     *                          the field to take records from,
     *                          in other requests (if defined) this will be the field
     *                          to put payload into.
     *      @type {object} remote Various fetch settings
     *      @type {function} processRequest {
     *          Custom request processor.
     *          @param {MetaphorJs.lib.Promise} returnPromise The promise 
     *                          that is returned from load()/save() etc. 
     *                          You can take control of this promise if needed.
     *          @param {int|string|null} id Record id (if applicable)
     *          @param {object|string|null} data Payload
     *      }
     *      @type {function} validate {
     *          Validate request
     *          @param {int|string|null} id Record id (if applicable)
     *          @param {object|string|null} data Payload
     *          @returns {boolean} Return false to cancel the request and 
     *                              reject promise.
     *      }
     *      @type {function} resolve {
     *          Custom request resolver
     *          @param {int|string|null} id Record id (if applicable)
     *          @param {object|string|null} data Payload
     *          @returns {MetaphorJs.lib.Promise|*} If returned Promise, 
     *              this promise will be returned from the function making
     *              the request. If returned something else, 
     *              will return a new Promise resolved with this value. 
     *              If returned nothing, will continue making the request
     *              as usual.
     *      }
     * 
     *      @type {object} record {
     *          @type {string|object} create New record config
     *          @type {string|object} load Load one record config
     *          @type {string|object} save Save one record config
     *          @type {string|object} delete Delete one record config
     *          @type {object} extend {
     *              Use properties of this object to extend every
     *              received record. If you don't want to create
     *              a whole record class but want to add a few 
     *              methods to a record object.
     *          }
     *      }
     *      @type {object} store {
     *          @type {string} total Total count of records field
     *          @type {string} start Start field: pagination offset
     *          @type {string} limit Limit field: pagination per page
     *          @type {string|object} load Load multiple records
     *          @type {string|object} save Save multiple records
     *          @type {string|object} delete Delete multiple records
     *      }
     * 
     *      @type {object} controller {
     *          @type {object} *name* {
     *              Controller config (<code>id,root,data,success</code> etc).<br>
     *              Called via <code>model.runController("name")</code>
     *          }
     *      }
     * }
     * @code src-docs/snippets/model.js
     * @code src-docs/snippets/controller.js
     */
    $init: function (cfg) {
      let defaults = {
        record: {
          load: null,
          save: null,
          "delete": null,
          id: null,
          data: null,
          success: null,
          extra: {}
        },
        store: {
          load: null,
          save: null,
          "delete": null,
          id: null,
          data: null,
          total: null,
          start: null,
          limit: null,
          success: null,
          extra: {}
        }
      };

      if (!this.fields) {
        this.fields = {};
      }

      extend(this, defaults, false, true);
      extend(this, cfg, true, true);
      this.plain = !this.type;
    },

    /**
     * Do records within this model have type (config's "type" property) 
     * or are they plain objects
     * @method
     * @returns {bool}
     */
    isPlain: function () {
      return this.plain;
    },

    /**
     * Get config property related to specific record action 
     * (create/save/load/delete).If there is no such config,
     * it will check a higher level config: <br>
     * config.record.load.url or config.record.url or
     * config.url
     * @method
     * @param {string} type create|load|save|delete
     * @param {string} prop
     * @returns {*}
     * @code model.getRecordProp("load", "url");
     */
    getRecordProp: function (type, prop) {
      return this.getProp("record", type, prop);
    },

    /**
     * Set record config property. See getRecordProp and constructor's config.
     * @method
     * @param {string} prop
     * @param {string|int|bool} value
     */
    setRecordProp: function (prop, value) {
      this.record[prop] = value;
    },

    /**
     * Get config property related to specific store action 
     * (save/load/delete). If there is no such config,
     * it will check a higher level config: <br>
     * config.store.load.url or config.store.url or
     * config.url
     * @method
     * @param {string} type load|save|delete
     * @param {string} prop
     * @returns {*}
     */
    getStoreProp: function (type, prop) {
      return this.getProp("store", type, prop);
    },

    /**
     * Set store config property. See getStoreProp and constructor's config.
     * @method
     * @param {string} prop
     * @param {string|int|bool} value
     */
    setStoreProp: function (prop, value) {
      this.store[prop] = value;
    },

    /**
     * Get config property related to specific action 
     * (save/load/delete). If there is no such config,
     * it will check a higher level config: <br>
     * config.:what:.:type:.:prop: or config.:what:.:prop: or
     * config.:prop:
     * @method
     * @param {string} what record|store
     * @param {string} type create|load|save|delete
     * @param {string} prop
     * @returns {*}
     */
    getProp: function (what, type, prop) {
      let profile = this[what];
      return profile[type] && profile[type][prop] || profile[prop] || this[prop] || null;
    },

    /**
     * Set config property. 
     * @method
     * @param {string} prop
     * @param {string|int|bool} value
     */
    setProp: function (prop, value) {
      return this[prop] = value;
    },
    _prepareRequestUrl: function (url, data) {
      url = url.replace(/:([a-z0-9_\-]+)/gi, function (match, name) {
        let value = data[name];

        if (value != undefined) {
          delete data[name];
          return value;
        } else {
          return match;
        }
      });

      if (/:([a-z0-9_\-]+)/.test(url)) {
        return null;
      }

      return url;
    },
    _makeRequest: function (what, type, id, data) {
      const profile = this[what],
            idProp = this.getProp(what, type, "id"),
            dataProp = this.getProp(what, type, "root"),
            url = this.getProp(what, type, "url"),
            isJson = this.getProp(what, type, "json"),
            remoteCfg = {};
      let res;
      let cfg = !isString(profile[type]) && !isFunction(profile[type]) ? extend({}, profile[type]) : profile[type];

      if (!cfg) {
        if (url) {
          cfg = {
            url
          };
        } else {
          throw what + "." + type + " not defined";
        }
      } else if (isString(cfg)) {
        cfg = {
          url: cfg
        };
      } else if (isFunction(cfg)) {
        cfg = {
          fn: cfg
        };
      }

      if (!cfg.url) {
        if (!url && !cfg.fn) {
          throw what + "." + type + " url not defined";
        }

        url && (cfg.url = url);
      }

      remoteCfg.url = cfg.url;

      if (cfg.remote) {
        extend(remoteCfg, cfg.remote, true, false);
      }

      if (cfg.validate) {
        res = cfg.validate.call(this, id, data);

        if (res === false) {
          return MetaphorJs.lib.Promise.reject(res);
        }
      }

      if (cfg.resolve) {
        res = cfg.resolve.call(this, id, data);

        if (res && isThenable(res)) {
          return res;
        } else if (res) {
          return MetaphorJs.lib.Promise.resolve(res);
        }
      }

      remoteCfg.data = extend({}, cfg.data, this.extra, profile.extra, profile[type] ? profile[type].extra : null, remoteCfg.data, data, true, true);

      if (cfg.fn) {
        const df = what === "controller" ? cfg.fn(id, remoteCfg.data) : cfg.fn(remoteCfg.data),
              promise = new MetaphorJs.lib.Promise();
        df.then(response => {
          if (what === "record") {
            this._processRecordResponse(type, response, promise);
          } else if (what === "store") {
            this._processStoreResponse(type, response, promise);
          } else if (what === "controller") {
            this._processControllerResponse(type, response, promise);
          }
        });
        return promise;
      } else if (!MetaphorJs.remote || !MetaphorJs.remote.fetch) {
        console.error("MetaphorJs.remote.fetch is not available in this build");
      }

      if (id && idProp) {
        remoteCfg.data[idProp] = id;
      }

      if (data && dataProp && type !== "load") {
        remoteCfg.data[dataProp] = data;
      }

      remoteCfg.url = this._prepareRequestUrl(remoteCfg.url, remoteCfg.data);

      if (!remoteCfg.url) {
        return MetaphorJs.lib.Promise.reject();
      }

      if (!remoteCfg.method) {
        if (what !== "controller") {
          remoteCfg.method = type === "load" ? "GET" : "POST";
        } else {
          remoteCfg.method = "GET";
        }
      }

      if (isJson && remoteCfg.data && remoteCfg.method !== 'GET') {
        // && cfg.type != 'GET') {
        remoteCfg.contentType = "text/plain";
        remoteCfg.data = JSON.stringify(remoteCfg.data);
      }

      remoteCfg.context = this;
      let returnPromise;

      if (what === "record") {
        remoteCfg.processResponse = (response, deferred) => {
          this.lastFetchedResponse = response;

          this._processRecordResponse(type, response, deferred);
        };

        returnPromise = this._processRecordRequest(MetaphorJs.remote.fetch(remoteCfg), type, id, data);
      } else if (what === "store") {
        remoteCfg.processResponse = (response, deferred) => {
          this.lastFetchedResponse = response;

          this._processStoreResponse(type, response, deferred);
        };

        returnPromise = this._processStoreRequest(MetaphorJs.remote.fetch(remoteCfg), type, id, data);
      } else if (what === "controller") {
        remoteCfg.processResponse = (response, deferred) => {
          this.lastFetchedResponse = response;

          this._processControllerResponse(type, response, deferred);
        };

        returnPromise = this._processControllerRequest(MetaphorJs.remote.fetch(remoteCfg), type, id, data);
      }

      if (cfg.processRequest) {
        cfg.processRequest.call(this, returnPromise, id, data);
      }

      return returnPromise;
    },
    _processRecordRequest: function (promise, type, id, data) {
      return promise;
    },
    _processRecordResponse: function (type, response, df) {
      let idProp = this.getRecordProp(type, "id"),
          dataProp = this.getRecordProp(type, "root"),
          data = dataProp ? response[dataProp] : response,
          id = data && data[idProp] || response[idProp];

      if (!this._getSuccess("record", type, response)) {
        df.reject(response);
      } else {
        data = this.normalizeRecord(data);
        data = this.extendPlainRecord(data);
        df.resolve({
          id,
          data
        });
      }
    },
    _processStoreRequest: function (promise, type, id, data) {
      return promise;
    },
    _processStoreResponse: function (type, response, df) {
      const dataProp = this.getStoreProp(type, "root"),
            totalProp = this.getStoreProp(type, "total"),
            data = dataProp ? response[dataProp] : response,
            total = totalProp ? response[totalProp] : null;

      if (!this._getSuccess("store", type, response)) {
        df.reject(response);
      } else {
        df.resolve({
          data,
          total
        });
      }
    },
    _processControllerRequest: function (promise, type, id, data) {
      return promise;
    },
    _processControllerResponse: function (type, response, df) {
      if (!this._getSuccess("controller", type, response)) {
        df.reject(response);
      } else {
        df.resolve(response);
      }
    },
    _getSuccess: function (what, type, response) {
      const sucProp = this.getProp(what, type, "success");

      if (typeof sucProp === "function") {
        return sucProp(response);
      }

      if (sucProp && response[sucProp] != undefined) {
        return response[sucProp];
      } else {
        return true;
      }
    },
    runController: function (name, id, data) {
      return this._makeRequest("controller", name, id, data);
    },

    /**
     * @method
     * @param {string|number} id Record id
     * @returns {MetaphorJs.lib.Promise}
     */
    loadRecord: function (id) {
      return this._makeRequest("record", "load", id);
    },

    /**
     * Send a create or save request with record data
     * @method
     * @param {MetaphorJs.model.Record} rec
     * @param {array|null} keys
     * @param {object|null} extra
     * @returns {MetaphorJs.lib.Promise}
     */
    saveRecord: function (rec, keys, extra) {
      return this._makeRequest("record", rec.getId() ? "save" : "create", rec.getId(), extend({}, rec.storeData(rec.getData(keys)), extra));
    },

    /**
     * Make a record/delete request.
     * @method
     * @param {MetaphorJs.model.Record} rec
     * @returns {MetaphorJs.lib.Promise}
     */
    deleteRecord: function (rec) {
      return this._makeRequest("record", "delete", rec.getId());
    },

    /**
     * Load store records
     * @method
     * @param {MetaphorJs.model.Store} store
     * @param {object} params
     * @returns {MetaphorJs.lib.Promise}
     */
    loadStore: function (store, params) {
      return this._makeRequest("store", "load", null, params);
    },

    /**
     * Send store records back to server for saving
     * @method
     * @param {MetaphorJs.model.Store} store
     * @param {object} recordData
     * @returns {MetaphorJs.lib.Promise}
     */
    saveStore: function (store, recordData) {
      return this._makeRequest("store", "save", null, recordData);
    },

    /**
     * Delete store records
     * @method
     * @param {MetaphorJs.model.Store} store
     * @param {array} ids
     * @returns {MetaphorJs.lib.Promise}
     */
    deleteRecords: function (store, ids) {
      return this._makeRequest("store", "delete", ids);
    },

    /**
     * Takes plain object and extends with properties
     * defined in model.record.extend
     * @method
     * @returns {object}
     */
    extendPlainRecord: function (rec) {
      const ext = this.getRecordProp(null, "extend");
      rec = ext ? extend(rec, ext, false, false) : rec;
      rec.$$model = this;
      return rec;
    },

    /**
     * Normalize record data response
     * @param {object} data 
     */
    normalizeRecord: function (data) {
      return data;
    },

    /**
     * Get field configs
     * @method
     * @returns {object}
     */
    getFields: function () {
      return this.fields;
    },

    /**
     * Extract record id from a record
     * @method
     * @param {object} rec
     * @returns {*|null}
     */
    getRecordId: function (rec) {
      const idProp = this.getRecordProp("load", "id");
      return rec ? (rec.getId ? rec.getId() : rec[idProp]) || null : null;
    },

    /**
     * Convert field's value from database state to app state
     * @method
     * @param {MetaphorJs.model.Record} rec
     * @param {string} name
     * @param {string|int|bool|Date} value
     * @returns {*}
     */
    restoreField: function (rec, name, value) {
      const f = this.fields[name];

      if (f) {
        const type = isString(f) ? f : f.type;

        switch (type) {
          case "int":
            {
              value = parseInt(value);
              break;
            }

          case "bool":
          case "boolean":
            {
              if (isString(value)) {
                value = value.toLowerCase();
                value = !(value === "off" || value === "no" || value === "0" || value == "false" || value == "null");
              } else {
                value = value ? true : false;
              }

              break;
            }

          case "double":
          case "float":
            {
              value = parseFloat(value);
              break;
            }

          case "date":
            {
              if (f['parseFn']) {
                value = f['parseFn'](value, f.format);
              } else if (Date['parse']) {
                value = Date['parse'](value, f.format);
              } else {
                if (f.format === "timestamp") {
                  value = parseInt(value) * 1000;
                }

                value = new Date(value);
              }

              break;
            }
        }

        if (f.restore) {
          value = f.restore.call(rec, value, name);
        }
      }

      return this.onRestoreField(rec, name, value);
    },

    /**
     * Override this method to have your own value processor
     * @method
     * @access protected
     * @param {MetaphorJs.model.Record} rec
     * @param {string} name
     * @param {string|int|bool} value
     * @returns {string|int|bool|Date}
     */
    onRestoreField: function (rec, name, value) {
      return value;
    },

    /**
     * Convert field's value from app state to database state
     * @method
     * @param {MetaphorJs.model.Record} rec
     * @param {string} name
     * @param {string|int|bool|Date} value
     * @returns {*}
     */
    storeField: function (rec, name, value) {
      const f = this.fields[name];

      if (f) {
        const type = isString(f) ? f : f.type;

        switch (type) {
          case "bool":
          case "boolean":
            {
              value = value ? "1" : "0";
              break;
            }

          case "date":
            {
              if (f['formatFn']) {
                value = f['formatFn'](value, f.format);
              } else if (Date.format) {
                value = Date.format(value, f.format);
              } else {
                if (f.format === "timestamp") {
                  value = value.getTime() / 1000;
                } else {
                  value = value['format'] ? value['format'](f.format) : value.toString();
                }
              }

              break;
            }

          default:
            {
              value = value.toString();
            }
        }

        if (f.store) {
          value = f.store.call(rec, value, name);
        }
      }

      return this.onStoreField(rec, name, value);
    },

    /**
     * Override this method to have your own value processor
     * @method
     * @access protected
     * @param {MetaphorJs.model.Record} rec
     * @param {string} name
     * @param {string|int|bool} value
     * @returns {string|int}
     */
    onStoreField: function (rec, name, value) {
      return value;
    }
  }, {
    /**
     * @static
     * @method
     * @param {string} model Model class name
     * @param {object} cfg Model config
     * @returns {object}
     */
    create: function (model, cfg) {
      if (model === "MetaphorJs.model.Model") {
        return cls.factory(model, cfg);
      } else {
        if (cfg) {
          return cls.factory(model, cfg);
        } else {
          if (instances[model]) {
            return instances[model];
          } else {
            return instances[model] = cls.factory(model);
          }
        }
      }
    },

    /**
     * @static
     * @method
     * @param {MetaphorJs.model.Record} rec
     */
    addToCache: function (rec) {
      const id = rec.getId(),
            cname = rec.$getClass();

      if (!(rec instanceof MetaphorJs.model.Record) && cname) {
        if (!cache[cname]) {
          cache[cname] = {};
        }

        cache[cname][id] = rec;
      }
    },

    /**
     * @static
     * @method
     * @param {string} type Class name
     * @param {string|int|bool} id
     */
    getFromCache: function (type, id) {
      if (cache[type] && cache[type][id]) {
        return cache[type][id];
      } else {
        return null;
      }
    },

    /**
     * @static
     * @method
     * @param {string} type Class name
     * @param {string|int|bool} id
     */
    removeFromCache: function (type, id) {
      if (cache[type] && cache[type][id]) {
        delete cache[type][id];
      }
    }
  });
}();

/***/ }),

/***/ "../metaphorjs-model/src/model/Record.js":
/*!***********************************************!*\
  !*** ../metaphorjs-model/src/model/Record.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js");

__webpack_require__(/*! ../__init.js */ "../metaphorjs-model/src/__init.js");

__webpack_require__(/*! ./Model.js */ "../metaphorjs-model/src/model/Model.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");
/**
 * @class MetaphorJs.model.Record
 * @mixes MetaphorJs.mixin.Observable
 */


module.exports = MetaphorJs.model.Record = cls({
  /**
   * @event dirty-change {
   *  Record become changed on unchanged
   *  @param {MetaphorJs.model.Record} rec
   *  @param {boolean} dirty
   * }
   */

  /**
   * @event change {
   *  General record change event
   *  @param {MetaphorJs.model.Record} rec 
   *  @param {string} key
   *  @param {*} value 
   *  @param {*} prevValue
   * }
   */

  /**
   * @event change-_key_ {
   *  Specific key change event
   *  @param {MetaphorJs.model.Record} rec 
   *  @param {string} key
   *  @param {*} value 
   *  @param {*} prevValue
   * }
   */

  /**
   * @event before-load {
   *  @param {MetaphorJs.model.Record}
   * }
   */

  /**
   * @event load {
   *  @param {MetaphorJs.model.Record}
   * }
   */

  /**
   * @event failed-load {
   *  @param {MetaphorJs.model.Record}
   * }
   */

  /**
   * @event before-save {
   *  @param {MetaphorJs.model.Record}
   * }
   */

  /**
   * @event save {
   *  @param {MetaphorJs.model.Record}
   * }
   */

  /**
   * @event failed-save {
   *  @param {MetaphorJs.model.Record}
   * }
   */

  /**
   * @event before-delete {
   *  @param {MetaphorJs.model.Record}
   * }
   */

  /**
   * @event delete {
   *  @param {MetaphorJs.model.Record}
   * }
   */

  /**
   * @event failed-delete {
   *  @param {MetaphorJs.model.Record}
   * }
   */

  /**
   * @event reset {
   *  @param {MetaphorJs.model.Record}
   * }
   */
  $mixins: [MetaphorJs.mixin.Observable],
  id: null,
  data: null,
  orig: null,
  modified: null,
  loaded: false,
  loading: false,
  dirty: false,
  model: null,
  standalone: true,
  stores: null,
  importUponSave: false,
  importUponCreate: false,

  /**
   * @constructor
   * @method $init
   * @param {*} id
   * @param {object} cfg {
   *  @type {string|MetaphorJs.model.Model} model
   *  @type {boolean} autoLoad {
   *      Load record automatically when constructed
   *      @default true
   *  }
   *  @type {boolean} importUponSave {
   *      Import new data from response on save request
   *      @default false
   *  }
   *  @type {boolean} importUponCreate {
   *      Import new data from response on create request
   *      @default false
   *  }
   * }
   */

  /**
   * @constructor
   * @method $init
   * @param {object} cfg
   */

  /**
   * @constructor
   * @method $init
   * @param {string|int|null} id
   * @param {object} data
   * @param {object} cfg
   */
  $init: function (id, data, cfg) {
    let args = arguments.length;

    if (args === 1) {
      cfg = id;
      id = null;
      data = null;
    } else if (args === 2) {
      cfg = data;
      data = null;
    }

    this.data = {};
    this.orig = {};
    this.stores = [];
    this.modified = {};
    cfg = cfg || {};
    this.$super(cfg);

    if (isString(this.model)) {
      this.model = MetaphorJs.model.Model.create(this.model);
    } else if (!(this.model instanceof MetaphorJs.model.Model)) {
      this.model = new MetaphorJs.model.Model(this.model);
    }

    this.id = id;

    if (data) {
      this.importData(data);
    } else if (cfg.autoLoad !== false && id) {
      this.load();
    }

    if (this.$getClass() !== "MetaphorJs.model.Record") {
      MetaphorJs.model.Model.addToCache(this);
    }
  },

  /**
   * Is record finished loading from server
   * @method
   * @returns {bool}
   */
  isLoaded: function () {
    return this.loaded;
  },

  /**
   * Is record still loading from server
   * @method
   * @returns {bool}
   */
  isLoading: function () {
    return this.loading;
  },

  /**
   * Is this record was created separately from a store
   * @method
   * @returns {bool}
   */
  isStandalone: function () {
    return this.standalone;
  },

  /**
   * Does this record have changes
   * @method
   * @returns {bool}
   */
  isDirty: function () {
    return this.dirty;
  },

  /**
   * @method
   * @returns {MetaphorJs.model.Model}
   */
  getModel: function () {
    return this.model;
  },

  /**
   * Make this record belong to a store
   * @method
   * @param {MetaphorJs.model.Store} store
   */
  attachStore: function (store) {
    let sid = store.getId();

    if (this.stores.indexOf(sid) == -1) {
      this.stores.push(sid);
    }
  },

  /**
   * Remove attachment to a store. If record is not standalone,
   * it will be destroyed.
   * @method
   * @param {MetaphorJs.model.Store} store
   */
  detachStore: function (store) {
    var sid = store.getId(),
        inx;

    if (!this.$destroyed && (inx = this.stores.indexOf(sid)) != -1) {
      this.stores.splice(inx, 1);

      if (this.stores.length == 0 && !this.standalone) {
        this.$destroy();
      }
    }
  },

  /**
   * Mark this record as having changes
   * @method
   * @param {bool} dirty
   */
  setDirty: function (dirty) {
    if (this.dirty != dirty) {
      this.dirty = !!dirty;
      this.trigger("dirty-change", this, dirty);
    }
  },

  /**
   * Import record data. Resets record to a unchanged state
   * @method
   * @param {object} data
   */
  importData: function (data) {
    let processed = {},
        name;

    if (data) {
      for (name in data) {
        processed[name] = this.model.restoreField(this, name, data[name]);
      }

      this.data = processed;
    }

    this.orig = extend({}, this.data);
    this.modified = {};
    this.loaded = true;
    this.setDirty(false);
  },

  /**
   * Prepare data for sending to a server
   * @method
   * @access protected
   * @param {object} data
   * @returns {object}
   */
  storeData: function (data) {
    let processed = {},
        name;

    for (name in data) {
      processed[name] = this.model.storeField(this, name, data[name]);
    }

    return processed;
  },

  /**
   * Get record id
   * @method
   * @returns {*}
   */
  getId: function () {
    return this.id;
  },

  /**
   * Get record data. Returns a new object with all data keys 
   * or only the ones specified and without keys starting with $.
   * @method
   * @param {[]|null|string} keys
   * @returns {object}
   */
  getData: function (keys) {
    let data = {},
        i;

    if (keys) {
      let len;
      keys = isString(keys) ? [keys] : keys;

      for (i = 0, len = keys.length; i < len; i++) {
        data[keys[i]] = this.data[keys[i]];
      }

      return data;
    } else {
      let sdata = this.data;

      for (i in sdata) {
        if (i.substr(0, 1) === "$") {
          continue;
        }

        data[i] = sdata[i];
      }

      return data;
    }
  },

  /**
   * Get changed properties
   * @method
   * @returns {object}
   */
  getChanged: function () {
    return extend({}, this.modified);
  },

  /**
   * Is the field changed
   * @method
   * @param {string} key
   * @returns {bool}
   */
  isChanged: function (key) {
    return this.modified[key] || false;
  },

  /**
   * Get specific data key
   * @method
   * @param {string} key
   * @returns {*}
   */
  get: function (key) {
    return this.data[key];
  },

  /**
   * Set record id
   * @method
   * @param {*} id
   */
  setId: function (id) {
    if (!this.id && id) {
      this.id = id;
    }
  },

  /**
   * Set data field
   * @method
   * @param {string} key
   * @param {*} value
   */
  set: function (key, value) {
    let prev = this.data[key];
    value = this.model.restoreField(this, key, value);
    this.data[key] = value;

    if (prev != value) {
      this.modified[key] = true;
      this.setDirty(true);
      this.trigger("change", this, key, value, prev);
      this.trigger("change-" + key, this, key, value, prev);
    }
  },

  /**
   * Revert record to the last saved state
   * @method
   */
  revert: function () {
    if (this.dirty) {
      this.data = extend({}, this.orig);
      this.modified = {};
      this.setDirty(false);
    }
  },

  /**
   * Load record from the server
   * @method
   * @returns {MetaphorJs.lib.Promise}
   */
  load: function () {
    this.loading = true;
    this.trigger("before-load", this);
    return this.model.loadRecord(this.id).always(() => {
      this.loading = false;
    }).done(response => {
      this.setId(response.id);
      this.importData(response.data);
      this.trigger("load", this);
    }).fail(() => {
      this.trigger("failed-load", this);
    });
  },

  /**
   * Send data back to server 
   * @method
   * @param {array|null|string} keys Only send these keys
   * @param {object|null} extra Send this data along with record data
   * @returns {MetaphorJs.lib.Promise}
   */
  save: function (keys, extra) {
    this.trigger("before-save", this);
    let create = !this.getId(),
        imprt = create ? this.importUponCreate : this.importUponSave;
    return this.model.saveRecord(this, keys, extra).done(response => {
      if (response.id) {
        this.setId(response.id);
      }

      if (imprt) {
        this.importData(response.data);
      }

      this.trigger("save", this);
    }).fail(() => this.trigger("failed-save", this));
  },

  /**
   * Send delete request
   * @method
   * @returns {MetaphorJs.lib.Promise}
   */
  "delete": function () {
    this.trigger("before-delete", this);
    return this.model.deleteRecord(this).done(() => {
      this.trigger("delete", this);
      this.$destroy();
    }).fail(() => {
      this.trigger("failed-delete", this);
    });
  },

  /**
   * Set record back to unloaded state
   * @method
   */
  reset: function () {
    this.id = null;
    this.data = {};
    this.orig = {};
    this.modified = {};
    this.loaded = false;
    this.dirty = false;
    this.trigger("reset", this);
  },
  onDestroy: function () {
    MetaphorJs.model.Model.removeFromCache(this.$getClass(), this.id);
    this.$super();
  }
});

/***/ }),

/***/ "../metaphorjs-model/src/model/Store.js":
/*!**********************************************!*\
  !*** ../metaphorjs-model/src/model/Store.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      filterArray = __webpack_require__(/*! metaphorjs-shared/src/func/filterArray.js */ "../metaphorjs-shared/src/func/filterArray.js"),
      sortArray = __webpack_require__(/*! metaphorjs-shared/src/func/sortArray.js */ "../metaphorjs-shared/src/func/sortArray.js");

__webpack_require__(/*! ../__init.js */ "../metaphorjs-model/src/__init.js");

__webpack_require__(/*! ./Model.js */ "../metaphorjs-model/src/model/Model.js");

__webpack_require__(/*! ./Record.js */ "../metaphorjs-model/src/model/Record.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");

module.exports = MetaphorJs.model.Store = function () {
  const allStores = {};
  /**
   * @class MetaphorJs.model.Store
   * @mixes MetaphorJs.mixin.Observable
   */

  return cls({
    /**
     * @event update {
     *  Store contents got updated
     *  @param {MetaphorJs.model.Store} store
     *  @param {MetaphorJs.model.Record|object} rec
     * }
     */

    /**
     * @event before-load {
     *  Before store sends a get request to the server
     *  @param {MetaphorJs.model.Store} store
     *  @returns {boolean} return false to cancel laoding
     * }
     */

    /**
     * @event load {
     *  After store finished loading and updating its contents
     *  @param {MetaphorJs.model.Store} store
     * }
     */

    /**
     * @event loading-end {
     *  After store finished loading but before updating.<br>
     *  This event does not respect <code>silent</code> option. 
     *  The purpose of this event is to let you 
     *  display loading indicator or something like that.
     *  @param {MetaphorJs.model.Store} store
     * }
     */

    /**
     * @event loading-start {
     *  The store requested the server.<br>
     *  This event does not respect <code>silent</code> option. 
     *  The purpose of this event is to let you 
     *  display loading indicator or something like that.
     *  @param {MetaphorJs.model.Store} store
     * }
     */

    /**
     * @event failed-load {
     *  There was an error while loading
     *  @param {MetaphorJs.model.Store} store
     *  @param {string|Error} reason
     * }
     */

    /**
     * @event before-save {
     *  Before sending "save" request
     *  @param {MetaphorJs.model.Store} store
     *  @param {array} recs
     *  @returns {boolean} return false to cancel saving
     * }
     */

    /**
     * @event save {
     *  Records have been saved
     *  @param {MetaphorJs.model.Store} store
     * }
     */

    /**
     * @event failed-save {
     *  There was an error while saving
     *  @param {MetaphorJs.model.Store} store
     *  @param {string|Error} reason
     * }
     */

    /**
     * @event before-delete {
     *  Before sending "delete" request
     *  @param {MetaphorJs.model.Store} store
     *  @param {array} ids 
     *  @returns {boolean} return false to cancel deletion
     * }
     */

    /**
     * @event delete {
     *  Records have been deleted
     *  @param {MetaphorJs.model.Store} store
     *  @param {array} ids 
     * }
     */

    /**
     * @event failed-delete {
     *  There was an error while deleting
     *  @param {MetaphorJs.model.Store} store
     *  @param {array} ids 
     * }
     */

    /**
     * @event add {
     *  Some records were added to the store
     *  @param {MetaphorJs.model.Store} store
     *  @param {array} recs 
     * }
     */

    /**
     * @event remove {
     *  Record got removed from the store
     *  @param {MetaphorJs.model.Store} store
     *  @param {MetaphorJs.model.Record|object} rec
     *  @param {string|int} id 
     * }
     */

    /**
     * @event replace {
     *  A record was replaced
     *  @param {MetaphorJs.model.Store} store
     *  @param {MetaphorJs.model.Record|object} old
     *  @param {MetaphorJs.model.Record|object} rec
     * }
     */

    /**
     * @event clear {
     *  The store has been cleared
     *  @param {MetaphorJs.model.Store} store
     *  @param {array} recs
     * }
     */
    $mixins: [MetaphorJs.mixin.Observable],
    id: null,
    autoLoad: false,
    clearOnLoad: true,
    model: null,
    extraParams: null,
    loaded: false,
    loading: false,
    local: false,
    items: null,
    current: null,
    itemMap: null,
    currentMap: null,
    length: 0,
    currentLength: 0,
    maxLength: 0,
    totalLength: 0,
    start: 0,
    pageSize: null,
    pages: null,
    filtered: false,
    sorted: false,
    filterBy: null,
    filterOpt: null,
    sortBy: null,
    sortDir: null,
    publicStore: false,
    idProp: null,
    loadingPromise: null,

    /**
     * @constructor
     * @method $init
     * @param {object} options {
     *  @type {string} url Api endpoint url if not defined in model
     *  @type {boolean} local {
     *      This store does not load data from remote server
     *      @default false
     *  }
     *  @type {int} pageSize Number of records per page
     *  @type {boolean} autoLoad {
     *      @default false
     *  }
     *  @type {boolean} clearOnLoad {
     *      On load, remove everything already added 
     *      @default true
     *  }
     *  @type {string|object|MetaphorJs.model.Model} model
     *  @type {object} extraParams {
     *      Extra params to add to every request
     *  }
     *  @type {MetaphorJs.model.Store} sourceStore {
     *      Keep in sync with another store
     *  }
     * }
     * @param {array} initialData Array of records
     */

    /**
     * @constructor
     * @method $init
     * @param {string} url
     * @param {object} options
     * @param {array} initialData
     */
    $init: function (url, options, initialData) {
      this.items = [];
      this.current = [];
      this.itemMap = {};
      this.currentMap = {};
      this.loaded = false;
      this.extraParams = this.extraParams || {};

      if (url && !isString(url)) {
        initialData = options;
        options = url;
        url = null;
      }

      options = options || {};

      if (url) {
        options.url = url;
      }

      this.$super(options);
      extend(this, options, true, false);
      this.id = this.id || nextUid();
      this.filtered = !!this.filterBy;

      if (this.publicStore) {
        allStores[this.id] = this;
      }

      this.initModel(options);
      this.$$observable.createEvent("beforeload", false);

      if (!this.local && this.autoLoad) {
        this.load();
      } else if (initialData) {
        if (isArray(initialData)) {
          this._loadArray(initialData);
        } else {
          this._fetchData(initialData);
        }
      }

      if (this.local) {
        this.loaded = true;
      }

      if (this.sourceStore) {
        this.initSourceStore(this.sourceStore, "on");
      }
    },

    /**
     * Change store's model
     * @param {MetaphorJs.model.Model} model 
     */
    setModel: function (model) {
      this.model = model;
      this.initModel({});
    },
    initModel: function (options) {
      if (isString(this.model)) {
        this.model = MetaphorJs.model.Model.create(this.model);
      } else if (!(this.model instanceof MetaphorJs.model.Model)) {
        this.model = new MetaphorJs.model.Model(this.model);
      }

      if (options.url) {
        this.model.store.load = options.url;
      }

      this.idProp = this.model.getStoreProp("load", "id");
    },
    initSourceStore: function (sourceStore, mode) {
      sourceStore[mode]("update", this.onSourceStoreUpdate, this);
    },
    onSourceStoreUpdate: function () {
      this.$$observable.suspendAllEvents();
      this.clear();
      this.addMany(this.sourceStore.toArray());
      this.$$observable.resumeAllEvents();
      this.trigger("update", this);
    },

    /**
     * Get store id
     * @method
     * @returns {string}
     */
    getId: function () {
      return this.id;
    },

    /**
     * Is this store finished loading data
     * @method
     * @returns {bool}
     */
    isLoaded: function () {
      return this.loaded;
    },

    /**
     * Is this store local (does not load remote data)
     * @method
     * @returns {bool}
     */
    isLocal: function () {
      return this.local;
    },

    /**
     * Make this store local or remote
     * @method
     * @param {bool} state
     */
    setLocal: function (state) {
      this.local = !!state;
    },

    /**
     * Is this store currently loading
     * @method
     * @returns {bool}
     */
    isLoading: function () {
      return this.loading;
    },

    /**
     * Does this store have a filter applied
     * @method
     * @returns {bool}
     */
    isFiltered: function () {
      return this.filtered;
    },

    /**
     * Does this store have a sorter applied
     * @method
     * @returns {bool}
     */
    isSorted: function () {
      return this.sorted;
    },

    /**
     * Get number of records in this store
     * @method
     * @param {boolean} unfiltered
     * @returns {number}
     */
    getLength: function (unfiltered) {
      return unfiltered ? this.length : this.currentLength;
    },

    /**
     * Get number of records on the server
     * @method
     * @returns {number}
     */
    getTotalLength: function () {
      return this.totalLength || this.currentLength;
    },

    /**
     * Is this store currently empty
     * @method
     * @param {boolean} unfiltered
     * @returns {boolean}
     */
    isEmpty: function (unfiltered) {
      return unfiltered ? this.length === 0 : this.currentLength === 0;
    },

    /**
     * Get number of pages (based on pageSize setting)
     * @method
     * @returns {number}
     */
    getPagesCount: function () {
      if (this.pageSize !== null) {
        return parseInt(this.totalLength / this.pageSize);
      } else {
        return 1;
      }
    },

    /**
     * Set extra param. It will be sent along with every request
     * @method
     * @param {string} k
     * @param {string|int|null} v
     */
    setParam: function (k, v) {
      if (v === null) {
        delete this.extraParams[k];
      } else {
        this.extraParams[k] = v;
      }
    },

    /**
     * Get extra param
     * @method
     * @param {string} k
     * @returns {*}
     */
    getParam: function (k) {
      return this.extraParams[k];
    },

    /**
     * Get all extra params (in a new object)
     * @method
     * @returns {object}
     */
    getParams: function () {
      return extend({}, this.extraParams);
    },

    /**
     * Clear all extra params
     * @method
     */
    clearParams: function () {
      this.extraParams = {};
    },

    /**
     * Set remote record offset
     * @method
     * @param {number} val
     */
    setStart: function (val) {
      this.start = val;
    },

    /**
     * Set page size
     * @method
     * @param {number} val
     */
    setPageSize: function (val) {
      this.pageSize = val;
    },

    /**
     * Get unprocessed response data
     * @method
     * @returns {object}
     */
    getFetchedData: function () {
      return this.fetchedData;
    },

    /**
     * Does this store have records marked as dirty
     * @method
     * @param {boolean} unfiltered If filter is appied this flag will 
     *  make this method ignore the filter
     * @returns {bool}
     */
    hasDirty: function (unfiltered) {
      if (this.model.isPlain()) {
        return false;
      }

      let ret = false;
      this.each(function (rec) {
        if (rec.isDirty()) {
          ret = true;
          return false;
        }

        return true;
      }, null, unfiltered);
      return ret;
    },

    /**
     * Get list of records marked as dirty
     * @method
     * @param {boolean} unfiltered If filter is appied this flag will 
     *  make this method ignore the filter
     * @returns {array}
     */
    getDirty: function (unfiltered) {
      let recs = [];

      if (this.model.isPlain()) {
        return recs;
      }

      this.each(function (rec) {
        if (rec.isDirty()) {
          recs.push(rec);
        }
      }, null, unfiltered);
      return recs;
    },

    /**
     * Get current model
     * @method
     * @returns {MetaphorJs.model.Model}
     */
    getModel: function () {
      return this.model;
    },

    /**
     * Get list of records (affected by store filter)
     * @method
     * @returns {array}
     */
    toArray: function () {
      return this.current.slice();
    },

    /**
     * @ignore
     * initialize store with data from remote sever
     * @method
     * @param {object} data
     */
    _fetchData: function (data, options) {
      options = options || {};

      if (!options.silent && this.trigger("before-load", this) === false) {
        return;
      }

      this.fetchedData = data;

      this.model._processStoreResponse("load", data, {
        resolve: response => {
          this._onModelLoadSuccess(response, options);
        },
        reject: reason => {
          this._onModelLoadFail(reason, options);
        }
      });
    },

    /**
     * @ignore
     * initialize store with local data
     * @param {[]} recs
     * @param {{}} options
     */
    _loadArray: function (recs, options) {
      options = options || {};

      if (!options.silent && this.trigger("before-load", this) === false) {
        return;
      }

      if (isArray(recs)) {
        this._load(recs, options);

        this.totalLength = this.length;
      }
    },

    /**
     * @ignore
     * load records no matter where they came from
     * @param {[]} recs
     * @param {{}} options
     */
    _load: function (recs, options) {
      const prepend = options.prepend;
      options = options || {};
      recs = recs || [];

      if (prepend) {
        this.insertMany(0, recs, true, true);
      } else {
        this.addMany(recs, true, true);
      }

      this.loaded = true;
      this.loading = false;
      this.trigger("loading-end", this);
      this.onLoad();

      if (!options.skipUpdate) {
        this.update();
      }

      if (!options.silent) {
        this.trigger("load", this);
      }
    },

    /**
     * (Re)load store. 
     * @method
     * @param {object} params {
     *  Add these params to load request
     *  @optional
     * }
     * @param {object} options {
     *  @type {boolean} silent {
     *      Do not trigger events
     *      @default false
     *  }
     *  @type {boolean} noopOnEmpty {
     *      Stop doing anything as soon as we know the data is empty
     *      (do not clear and update)
     *      @default false
     *  }
     *  @type {boolean} prepend {
     *      Insert loaded data in front of old ones (and do not clear)
     *      @default false
     *  }
     *  @type {boolean} append {
     *      Insert loaded data after existing records (and do not clear)
     *      @default false
     *  }
     *  @type {boolean} skipUpdate {
     *      Skip updating store - re-filter, re-map
     *      @default false
     *  }
     * }
     * @returns {MetaphorJs.lib.Promise}
     */
    load: function (params, options) {
      const ms = this.model.store,
            sp = ms.start,
            lp = ms.limit,
            ps = this.pageSize;

      if (this.loadingPromise && this.loadingPromise.abort) {
        this.loadingPromise.abort();
      }

      options = options || {};

      if (this.local) {
        return null;
      }

      params = extend({}, this.extraParams, params || {});

      if (ps !== null && !params[sp] && !params[lp]) {
        if (sp) {
          params[sp] = this.start;
        }

        if (lp) {
          params[lp] = ps;
        }
      }

      if (!options.silent && this.trigger("before-load", this) === false) {
        return null;
      }

      this.loading = true;
      this.trigger("loading-start", this);
      return this.loadingPromise = this.model.loadStore(this, params).done(response => {
        if (this.$destroyed) {
          return;
        }

        this.loadingPromise = null;
        this.fetchedData = this.model.lastFetchedResponse;

        this._onModelLoadSuccess(response, options);
      }).fail(reason => {
        if (this.$destroyed) {
          return;
        }

        this.loadingPromise = null;
        this.fetchedData = this.model.lastFetchedResponse;

        this._onModelLoadFail(reason, options);
      });
    },
    _onModelLoadSuccess: function (response, options) {
      options = options || {};

      if (options.noopOnEmpty && !response.data.length) {
        return;
      }

      if (!options.prepend && !options.append && this.clearOnLoad && this.length > 0) {
        this.clear(true);
      }

      if (response.total !== null && response.total !== undefined) {
        this.totalLength = parseInt(response.total);
      }

      this._load(response.data, options);
    },
    _onModelLoadFail: function (reason, options) {
      this.onFailedLoad();

      if (!options.silent) {
        this.trigger("failed-load", this, reason);
      }
    },

    /**
     * Override this method to catch successful loads
     * @method
     */
    onLoad: emptyFn,

    /**
     * Override this method to catch failed loads
     * @method
     */
    onFailedLoad: emptyFn,

    /**
     * Save all dirty records
     * @method
     * @param {boolean} silent {
     *  Do not trigger events
     *  @default false
     * }
     * @returns {MetaphorJs.lib.Promise}
     */
    save: function (silent) {
      let recs = {},
          cnt = 0;

      if (this.local) {
        return null;
      }

      if (this.model.isPlain()) {
        throw new Error("Cannot save plain store");
      }

      this.each(rec => {
        if (rec.isDirty()) {
          recs[rec.getId()] = rec.storeData(rec.getData());
          cnt++;
        }
      });

      if (!cnt) {
        return null;
      }

      if (!silent && this.trigger("before-save", this, recs) === false) {
        return null;
      }

      return this.model.saveStore(this, recs).done(response => this._onModelSaveSuccess(response, silent)).fail(reason => this._onModelSaveFail(reason, silent));
    },
    _onModelSaveSuccess: function (response, silent) {
      let i,
          len,
          id,
          rec,
          data = response.data;

      if (data && data.length) {
        for (i = 0, len = data.length; i < len; i++) {
          id = this.getRecordId(data[i]);
          rec = this.getById(id);

          if (rec) {
            rec.importData(data[i]);
          }
        }
      }

      this.onSave();

      if (!silent) {
        this.trigger("save", this);
      }
    },
    _onModelSaveFail: function (reason, silent) {
      this.onFailedSave(reason);

      if (!silent) {
        this.trigger("failed-save", this, reason);
      }
    },

    /**
     * Override this method to catch successful saves
     * @method
     */
    onSave: emptyFn,

    /**
     * Override this method to catch failed saves
     * @method
     */
    onFailedSave: emptyFn,

    /**
     * Delete record by id (send delete request)
     * @method
     * @param {int|string|array} ids Record id(s)
     * @param {boolean} silent {
     *  Do not trigger events
     *  @default false
     * }
     * @param {boolean} skipUpdate {
     *  Skip updating store (re-filter, re-map)
     *  @default false
     * }
     * @returns {MetaphorJs.lib.Promise}
     */
    deleteById: function (ids, silent, skipUpdate) {
      let i, len, rec;

      if (this.local) {
        return null;
      }

      if (!ids || isArray(ids) && !ids.length) {
        throw new Error("Record id required");
      }

      if (!isArray(ids)) {
        ids = [ids];
      }

      for (i = 0, len = ids.length; i < len; i++) {
        rec = this.getById(ids[i]);
        this.remove(rec, silent, skipUpdate);

        if (rec instanceof MetaphorJs.model.Record) {
          rec.$destroy();
        }
      }

      if (!silent && this.trigger("before-delete", this, ids) === false) {
        return null;
      }

      return this.model.deleteRecords(this, ids).done(() => {
        this.totalLength -= ids.length;
        this.onDelete();

        if (!silent) {
          this.trigger("delete", this, ids);
        }
      }).fail(() => {
        this.onFailedDelete();

        if (!silent) {
          this.trigger("failed-delete", this, ids);
        }
      });
    },

    /**
     * Override this method to catch successful deletes
     * @method
     */
    onDelete: emptyFn,

    /**
     * Override this method to catch failed deletes
     * @method
     */
    onFailedDelete: emptyFn,

    /**
     * Delete record at index
     * @method
     * @param {number} inx Position at which to delete record
     * @param {boolean} silent
     * @param {boolean} skipUpdate
     * @returns {MetaphorJs.lib.Promise}
     */
    deleteAt: function (inx, silent, skipUpdate) {
      const rec = this.getAt(inx);

      if (!rec) {
        throw new Error("Record not found at " + inx);
      }

      return this["delete"](rec, silent, skipUpdate);
    },

    /**
     * Delete record
     * @method
     * @param {MetaphorJs.model.Record} rec
     * @param {boolean} silent
     * @param {boolean} skipUpdate
     * @returns {MetaphorJs.lib.Promise}
     */
    "delete": function (rec, silent, skipUpdate) {
      return this.deleteById(this.getRecordId(rec), silent, skipUpdate);
    },

    /**
     * Delete multiple records
     * @method
     * @param {MetaphorJs.model.Record[]} recs
     * @param {boolean} silent
     * @param {boolean} skipUpdate
     * @returns {MetaphorJs.lib.Promise}
     */
    deleteRecords: function (recs, silent, skipUpdate) {
      const ids = [];
      let i, len;

      for (i = 0, len = recs.length; i < len; i++) {
        ids.push(this.getRecordId(recs[i]));
      }

      return this.deleteById(ids, silent, skipUpdate);
    },

    /**
     * Load store if not loaded or call provided callback
     * @method
     * @param {object} options See load()
     * @returns {MetaphorJs.lib.Promise}
     */
    loadOr: function (options) {
      if (!this.local && !this.isLoading() && !this.isLoaded()) {
        return this.load(null, options);
      }

      return MetaphorJs.lib.Promise.resolve(this);
    },

    /**
     * Load previous page and prepend before current records
     * @method
     * @param {object} options {
     *      See load(). append,prepend and noopOnEmpty will be set to
     *      false, true and true.
     * }
     * @returns {MetaphorJs.lib.Promise}
     */
    addPrevPage: function (options) {
      options = options || {};
      options.append = false;
      options.prepend = true;
      options.noopOnEmpty = true;
      return this.loadPrevPage(options);
    },

    /**
     * Load next page and append after current records
     * @method
     * @param {object} options {
     *      See load(). append,prepend and noopOnEmpty will be set to
     *      true, false and true.
     * }
     * @returns {MetaphorJs.lib.Promise}
     */
    addNextPage: function (options) {
      options = options || {};
      options.append = true;
      options.prepend = false;
      options.noopOnEmpty = true;

      if (!this.local && (!this.totalLength || this.length < this.totalLength)) {
        return this.load({
          start: this.length,
          limit: this.pageSize
        }, options);
      } else {
        return MetaphorJs.lib.Promise.resolve();
      }
    },

    /**
     * Load next page and replace current records with records from 
     * the next page
     * @method
     * @param {object} options See load()
     * @returns {MetaphorJs.lib.Promise}
     */
    loadNextPage: function (options) {
      if (!this.totalLength || this.local || this.length < this.totalLength) {
        this.start += this.pageSize;

        if (!this.local) {
          return this.load(null, options);
        } else {
          this.update();
        }
      }

      return MetaphorJs.lib.Promise.resolve();
    },

    /**
     * Load prev page and replace current records with records from 
     * the prev page
     * @method
     * @param {object} options See load()
     * @returns {MetaphorJs.lib.Promise}
     */
    loadPrevPage: function (options) {
      if (this.start > 0) {
        this.start -= this.pageSize;

        if (this.start < 0) {
          this.start = 0;
        }

        if (!this.local) {
          return this.load(null, options);
        } else {
          this.update();
        }
      }

      return MetaphorJs.lib.Promise.resolve();
    },

    /**
     * Load a page and replace current records with records from 
     * the page
     * @method
     * @param {int} start Records offset
     * @param {object} options See load()
     * @returns {MetaphorJs.lib.Promise}
     */
    loadPage: function (start, options) {
      this.start = parseInt(start, 10);

      if (this.start < 0) {
        this.start = 0;
      }

      if (!this.local) {
        return this.load(null, options);
      } else {
        this.update();
      }

      return MetaphorJs.lib.Promise.resolve();
    },

    /**
     * Extract id from a record
     * @method
     * @param {MetaphorJs.model.Record|object} rec
     * @returns {int|string|null}
     */
    getRecordId: function (rec) {
      if (!rec) {
        return null;
      } else if (rec instanceof MetaphorJs.model.Record) {
        return rec.getId();
      } else if (this.model) {
        return this.model.getRecordId(rec) || rec[this.idProp] || null;
      } else {
        return rec[this.idProp] || null;
      }
    },

    /**
     * Get record data as plain object
     * @method
     * @param {MetaphorJs.model.Record|object} rec
     * @returns {object}
     */
    getRecordData: function (rec) {
      return this.model.isPlain() ? rec : rec.data;
    },

    /**
     * @ignore
     * @method
     * @access protected
     * @param {MetaphorJs.model.Record|Object} item
     * @returns MetaphorJs.model.Record|Object
     */
    processRawDataItem: function (item) {
      if (item instanceof MetaphorJs.model.Record) {
        return item;
      }

      if (this.model.isPlain()) {
        return this.model.extendPlainRecord(this.model.normalizeRecord(item));
      } else {
        const type = this.model.type,
              id = this.getRecordId(item);
        let r;

        if (id) {
          r = MetaphorJs.model.Model.getFromCache(type, id);
        }

        if (!r) {
          r = cls.factory(type, id, item, {
            model: this.model,
            standalone: false
          });
        }

        return r;
      }
    },

    /**
     * @ignore
     * @method
     * @param {string} mode on|un
     * @param {MetaphorJs.model.Record} rec
     * @returns {MetaphorJs.model.Record}
     */
    bindRecord: function (mode, rec) {
      rec[mode]("change", this.onRecordChange, this);
      rec[mode]("destroy", this.onRecordDestroy, this);
      rec[mode]("dirty-change", this.onRecordDirtyChange, this);
      return rec;
    },

    /**
     * @ignore
     * @method
     * @access protected
     * @param {MetaphorJs.model.Record|Object} rec
     */
    onRecordDirtyChange: function (rec) {
      this.trigger("update", this, rec);
    },

    /**
     * @ignore
     * @method
     * @access protected
     * @param {MetaphorJs.model.Record|Object} rec
     * @param {string} k
     * @param {string|int|bool} v
     * @param {string|int|bool} prev
     */
    onRecordChange: function (rec, k, v, prev) {
      this.trigger("update", this, rec);
    },

    /**
     * @ignore
     * @method
     * @access protected
     * @param {MetaphorJs.model.Record|Object} rec
     */
    onRecordDestroy: function (rec) {
      this.remove(rec);
    },

    /**
     * Remove and return first record
     * @method
     * @param {boolean} silent Do not trigger events
     * @param {boolean} skipUpdate Do not run store updates
     * @param {boolean} unfiltered Execute on unfiltered set of records
     * @returns {MetaphorJs.model.Record|Object|null}
     */
    shift: function (silent, skipUpdate, unfiltered) {
      return this.removeAt(0, 1, silent, skipUpdate, unfiltered);
    },

    /**
     * Insert record at the beginning. Works with unfiltered data
     * @method
     * @param {object|MetaphorJs.model.Record} rec
     * @param {boolean} silent Do not trigger events
     * @param {boolean} skipUpdate Do not run store updates
     * @returns {MetaphorJs.model.Record|object}
     */
    unshift: function (rec, silent, skipUpdate) {
      return this.insert(0, rec, silent, skipUpdate);
    },

    /**
     * Remove and return last record
     * @method
     * @param {boolean} silent Do not trigger events
     * @param {boolean} skipUpdate Do not run store updates
     * @param {boolean} unfiltered Execute on unfiltered set of records
     * @returns {MetaphorJs.model.Record|object|null}
     */
    pop: function (silent, skipUpdate, unfiltered) {
      return this.removeAt(this.length - 1, 1, silent, skipUpdate, unfiltered);
    },

    /**
     * Add many records to the store. Works with unfiltered data
     * @method
     * @param {MetaphorJs.model.Record[]|object[]} recs
     * @param {boolean} silent Do not trigger events
     * @param {boolean} skipUpdate Do not run store updates
     */
    addMany: function (recs, silent, skipUpdate) {
      let i,
          l,
          start = this.length;

      for (i = 0, l = recs.length; i < l; i++) {
        this.insert(start + i, recs[i], true, true);
      }

      if (!skipUpdate) {
        this.update();
      }

      if (l > 0 && !silent) {
        this.trigger("add", recs);
      }
    },

    /**
     * Add one record to the store. Works with unfiltered data
     * @method
     * @param {MetaphorJs.model.Record|object} rec
     * @param {boolean} silent Do not trigger events
     * @param {boolean} skipUpdate Do not run store updates
     */
    add: function (rec, silent, skipUpdate) {
      return this.insert(this.length, rec, silent, skipUpdate);
    },

    /**
     * Override this method to catch when records are added
     * @method 
     * @param {int} index
     * @param {MetaphorJs.model.Record|object} rec
     */
    onAdd: emptyFn,

    /**
     * Remove records from specific position
     * @method
     * @param {number} index {
     *  Starting index 
     *  @required
     * }
     * @param {number} length {
     *  Number of records to remove
     *  @default 1
     * }
     * @param {boolean} silent Do not trigger events
     * @param {boolean} skipUpdate Do not run store updates
     * @param {boolean} unfiltered Execute on unfiltered set of records
     * @returns {MetaphorJs.model.Record|object|undefined}
     */
    removeAt: function (index, length, silent, skipUpdate, unfiltered) {
      let i = 0,
          l = this.length;

      if (l === 0) {
        return;
      }

      if (index === null) {
        //index   = 0; ??
        return;
      }

      while (index < 0) {
        index = l + index;
      }

      if (length == null) {
        length = 1;
      }

      if (!unfiltered) {
        index = this.items.indexOf(this.current[index]);
      }

      while (index < this.length && index >= 0 && i < length) {
        this.length--;
        const rec = this.items[index];
        this.items.splice(index, 1);
        const id = this.getRecordId(rec);

        if (id !== undefined) {
          delete this.itemMap[id];
          delete this.currentMap[id];
        }

        this.onRemove(rec, id);

        if (!skipUpdate) {
          this.update();
        }

        if (!silent) {
          this.trigger('remove', rec, id);
        }

        if (rec instanceof MetaphorJs.model.Record) {
          this.bindRecord("un", rec);
          rec.detachStore(this);

          if (length === 1) {
            return rec.$destroyed ? undefined : rec;
          }
        } else {
          if (length === 1) {
            return rec;
          }
        }

        i++;
      }

      return undefined;
    },

    /**
     * Remove records between start and end indexes
     * @method
     * @param {int} start Start index
     * @param {int} end End index
     * @param {boolean} silent Do not trigger events
     * @param {boolean} skipUpdate Do not run store updates
     * @param {boolean} unfiltered Execute on unfiltered set of records
     * @returns {MetaphorJs.model.Record|object|undefined}
     */
    removeRange: function (start, end, silent, skipUpdate, unfiltered) {
      const l = this.length;

      if (l === 0) {
        return;
      }

      if (start == null && end == null) {
        return this.clear(silent);
      }

      if (start == null) {
        start = 0;
      }

      while (start < 0) {
        start = l + start;
      }

      if (end == null) {
        end = l - 1;
      }

      while (end < 0) {
        end = l + start;
      }

      return this.removeAt(start, end - start + 1, silent, skipUpdate, unfiltered);
    },

    /**
     * Override this method to catch all record removals
     * @method
     * @param {MetaphorJs.model.Record|object} rec
     * @param {int|string|null} id
     */
    onRemove: emptyFn,

    /**
     * Insert multiple records at specific index. (Works with unfiltered set)
     * @method
     * @param {int} index {
     *  @required
     * }
     * @param {array} recs
     * @param {boolean} silent Do not trigger events
     * @param {boolean} skipUpdate Do not run store updates
     */
    insertMany: function (index, recs, silent, skipUpdate) {
      let i, l;

      for (i = 0, l = recs.length; i < l; i++) {
        this.insert(index + i, recs[i], true, true);
      }

      if (l > 0 && !skipUpdate) {
        this.update();
      }

      if (l > 0 && !silent) {
        this.trigger("add", recs);
      }
    },

    /**
     * Insert record at specific index. (Works with unfiltered set)
     * @method
     * @param {number} index {
     *  @required
     * }
     * @param {MetaphorJs.model.Record|object} rec
     * @param {boolean} silent Do not trigger events
     * @param {boolean} skipUpdate Do not run store updates
     * @returns {MetaphorJs.model.Record|object}
     */
    insert: function (index, rec, silent, skipUpdate) {
      let id,
          last = false;
      rec = this.processRawDataItem(rec);
      id = this.getRecordId(rec);

      if (this.itemMap[id]) {
        this.$$observable.suspendAllEvents();
        this.removeId(id);
        this.$$observable.resumeAllEvents();
      }

      if (index >= this.length) {
        this.items.push(rec);
        last = true;
      } else {
        this.items.splice(index, 0, rec);
      }

      this.length++;

      if (this.maxLength && this.length > this.maxLength) {
        if (last) {
          this.pop(silent, true);
        } else {
          this.shift(silent, true);
        }
      }

      if (id !== undefined) {
        this.itemMap[id] = rec;
      }

      if (rec instanceof MetaphorJs.model.Record) {
        rec.attachStore(this);
        this.bindRecord("on", rec);
      }

      this.onAdd(index, rec);

      if (!skipUpdate) {
        this.update();
      }

      if (!silent) {
        this.trigger('add', [rec]);
      }

      return rec;
    },

    /**
     * Replace one record with another
     * @method
     * @param {MetaphorJs.model.Record|object} old Old record
     * @param {MetaphorJs.model.Record|object} rec New record
     * @param {boolean} silent Do not trigger events
     * @param {boolean} skipUpdate Do not run store updates
     * @returns {MetaphorJs.model.Record|object} new record
     */
    replace: function (old, rec, silent, skipUpdate) {
      const index = this.items.indexOf(old);
      this.removeAt(index, 1, true, true, true);
      this.insert(index, rec, true, true);

      if (!skipUpdate) {
        this.update();
      }

      this.onReplace(old, rec);

      if (!silent) {
        this.trigger('replace', old, rec);
      }

      return rec;
    },

    /**
     * Replace record with given id by another record
     * @method
     * @param {int|string} id Old record id
     * @param {MetaphorJs.model.Record|object} rec New record
     * @param {boolean} silent Do not trigger events
     * @param {boolean} skipUpdate Do not run store updates
     * @returns {MetaphorJs.model.Record|object} new record
     */
    replaceId: function (id, rec, silent, skipUpdate) {
      const index = this.indexOfId(id);
      return this.replace(this.getAt(index), rec, silent, skipUpdate);
    },

    /**
     * Override this method to catch all record replacements
     * @method
     * @param {MetaphorJs.model.Record|object} old Old record
     * @param {MetaphorJs.model.Record|object} rec New record
     */
    onReplace: emptyFn,

    /**
     * Remove record from the store
     * @method
     * @param {MetaphorJs.model.Record|object} rec
     * @param {boolean} silent Do not trigger events
     * @param {boolean} skipUpdate Do not run store updates
     * @returns {MetaphorJs.model.Record|object|null}
     */
    remove: function (rec, silent, skipUpdate) {
      const inx = this.indexOf(rec, true);

      if (inx !== -1) {
        return this.removeAt(inx, 1, silent, skipUpdate, true);
      }

      return null;
    },

    /**
     * Remove record from the store by record id
     * @method
     * @param {string|int} id Record id
     * @param {boolean} silent Do not trigger events
     * @param {boolean} skipUpdate Do not run store updates
     * @returns {MetaphorJs.model.Record|object|null}
     */
    removeId: function (id, silent, skipUpdate) {
      const inx = this.indexOfId(id, true);

      if (inx !== -1) {
        return this.removeAt(inx, 1, silent, skipUpdate, true);
      }
    },

    /**
     * Does this store contains record
     * @method
     * @param {MetaphorJs.model.Record|object} rec
     * @param {boolean} unfiltered Check unfiltered set
     * @returns {boolean}
     */
    contains: function (rec, unfiltered) {
      return this.indexOf(rec, unfiltered) !== -1;
    },

    /**
     * Does this store contains a record with given id
     * @method
     * @param {string|int} id Record id
     * @param {boolean} unfiltered Check in unfiltered set
     * @returns {boolean}
     */
    containsId: function (id, unfiltered) {
      if (unfiltered) {
        return this.itemMap[id] !== undefined;
      } else {
        return this.currentMap[id] !== undefined;
      }
    },

    /**
     * Remove all records from the store
     * @method
     * @param {boolean} silent Do not trigger events
     */
    clear: function (silent) {
      const recs = this.getRange();

      this._reset();

      this.onClear();

      if (!silent) {
        this.trigger('update', this);
        this.trigger('clear', this, recs);
      }
    },

    /**
     * Override this method to catch when the store is being cleared
     * @method
     */
    onClear: emptyFn,

    /**
     * Same as clear but it doesn't trigger any events. 
     * This is what clear() calls internally
     * @method
     */
    reset: function () {
      this._reset();

      this.start = 0;
    },
    _reset: function (keepRecords) {
      let i, len, rec;

      if (!keepRecords) {
        for (i = 0, len = this.items.length; i < len; i++) {
          rec = this.items[i];

          if (rec instanceof MetaphorJs.model.Record) {
            this.bindRecord("un", rec);
            rec.detachStore(this);
          }
        }
      }

      this.length = 0;
      this.currentLength = 0;
      this.totalLength = 0;
      this.items = [];
      this.current = [];
      this.itemMap = {};
      this.currentMap = {};
      this.loaded = this.local;
    },

    /**
     * Get record at given index
     * @method
     * @param {int} index
     * @param {boolean} unfiltered Get from unfiltered set
     * @returns {MetaphorJs.model.Record|object|null}
     */
    getAt: function (index, unfiltered) {
      return unfiltered ? this.items[index] || undefined : this.current[index] || undefined;
    },

    /**
     * Get record by id
     * @method
     * @param {string|int} id Record id
     * @param {boolean} unfiltered Get from unfiltered set
     * @returns {MetaphorJs.model.Record|object|null}
     */
    getById: function (id, unfiltered) {
      return unfiltered ? this.itemMap[id] || undefined : this.currentMap[id] || undefined;
    },

    /**
     * Get index of record
     * @method
     * @param {MetaphorJs.model.Record|object} rec
     * @param {boolean} unfiltered Lookup in unfiltered set
     * @returns {int} returns -1 if not found
     */
    indexOf: function (rec, unfiltered) {
      return unfiltered ? this.items.indexOf(rec) : this.current.indexOf(rec);
    },

    /**
     * Get index of record by given record id
     * @method
     * @param {string|int} id Record id
     * @param {boolean} unfiltered Lookup in unfiltered set
     * @returns {int} returns -1 if not found
     */
    indexOfId: function (id, unfiltered) {
      return this.indexOf(this.getById(id, unfiltered), unfiltered);
    },

    /**
     * Interate over store records
     * @method
     * @param {function} fn {
     *      @param {MetaphorJs.model.Record|object} rec
     *      @param {number} index
     *      @param {number} length
     *      @returns {boolean|null} return false to stop
     * }
     * @param {object} context fn's context
     * @param {boolean} unfiltered Iterate over unfiltered set
     */
    each: function (fn, context, unfiltered) {
      const items = unfiltered ? this.items.slice() : this.current.slice();
      let i, len;

      for (i = 0, len = items.length; i < len; i++) {
        if (fn.call(context, items[i], i, len) === false) {
          break;
        }
      }
    },

    /**
     * Map store
     * @param {function} fn 
     * @param {object} context 
     * @param {boolean} unfiltered 
     * @returns []
     */
    map: function (fn, context, unfiltered) {
      const ret = [];
      this.each(rec => ret.push(fn.call(context, rec)), null, unfiltered);
      return ret;
    },

    /**
     * Iterate over store records
     * @method
     * @param {function} fn {
     *      @param {string|number} id Record id
     *      @param {number} index Record position in set
     *      @param {number} length Set length
     *      @returns {boolean|null} return false to stop
     * }
     * @param {object} context fn's context
     * @param {boolean} unfiltered Iterate over unfiltered set
     */
    eachId: function (fn, context, unfiltered) {
      this.each((rec, i, len) => fn.call(context, this.getRecordId(rec), i, len), null, unfiltered);
    },

    /**
     * Collect values of given field
     * @method
     * @param {string} f Field name
     * @param {boolean} unfiltered Collect from unfiltered set
     * @returns {array}
     */
    collect: function (f, unfiltered) {
      const rt = !this.model.isPlain();
      return this.map(rec => rt ? rec.get(f) : rec[f], null, unfiltered).filter(r => r !== undefined);
    },

    /**
     * Get first record
     * @method
     * @param {boolean} unfiltered Get from unfiltered set
     * @returns {MetaphorJs.model.Record|object|null}
     */
    first: function (unfiltered) {
      return unfiltered ? this.items[0] : this.current[0];
    },

    /**
     * Get last record
     * @method
     * @param {boolean} unfiltered Get from unfiltered set
     * @returns {MetaphorJs.model.Record|object|null}
     */
    last: function (unfiltered) {
      return unfiltered ? this.items[this.length - 1] : this.current[this.current - 1];
    },

    /**
     * Get a slice of records list
     * @method
     * @param {number} start {
     *  Start index
     *  @default 0
     * }
     * @param {number} end {
     *  End index
     *  @default length-1
     * }
     * @param {boolean} unfiltered Get from unfiltered set
     * @returns {MetaphorJs.model.Record[]|object[]}
     */
    getRange: function (start, end, unfiltered) {
      const items = unfiltered ? this.items : this.current,
            r = [];
      let i;

      if (items.length < 1) {
        return r;
      }

      start = start || 0;
      end = Math.min(end == undefined ? this.length - 1 : end, this.length - 1);

      if (start <= end) {
        for (i = start; i <= end; i++) {
          r.push(items[i]);
        }
      } else {
        for (i = start; i >= end; i--) {
          r.push(items[i]);
        }
      }

      return r;
    },

    /**
     * Find and return record matching custom filter
     * @method
     * @param {function} fn {
     *      @param {MetaphorJs.model.Record|object} rec
     *      @param {string|int} id
     *      @returns {boolean} Return true to accept record
     * }
     * @param {object} context fn's context
     * @param {number} start { @default 0 }
     * @param {boolean} unfiltered Look in unfiltered set
     * @returns {MetaphorJs.model.Record|object|null}
     */
    findBy: function (fn, context, start, unfiltered) {
      const inx = this.findIndexBy(fn, context, start, unfiltered);
      return inx === -1 ? undefined : this.getAt(inx, unfiltered);
    },

    /**
     * Find index of a record matching custom filter
     * @method
     * @param {function} fn {
     *      @param {MetaphorJs.model.Record|object} rec
     *      @param {string|int} id
     *      @returns {boolean} return true to accept record
     * }
     * @param {object} context fn's context
     * @param {number} start { @default 0 }
     * @param {boolean} unfiltered Look in unfiltered set
     * @returns {int} returns -1 if not found
     */
    findIndexBy: function (fn, context, start, unfiltered) {
      const it = unfiltered ? this.items : this.current;
      let i, len;

      for (i = start || 0, len = it.length; i < len; i++) {
        if (fn.call(context, it[i], this.getRecordId(it[i]))) {
          return i;
        }
      }

      return -1;
    },

    /**
     * Find record by its field value
     * @method
     * @param {string} property Record's field name
     * @param {string|int|bool} value Value to compare to
     * @param {bool} exact Make a strict comparison
     * @param {boolean} unfiltered Look in unfiltered set
     * @returns {MetaphorJs.model.Record|object|null}
     * @code store.find("name", "Jane");
     */
    find: function (property, value, exact, unfiltered) {
      const rt = !this.model.isPlain();
      const inx = this.findIndexBy(rec => {
        const v = rt ? rec.get(property) : rec[property];

        if (exact) {
          return v === value;
        } else {
          return v == value;
        }
      }, this, 0, unfiltered);
      return inx !== -1 ? this.getAt(inx, unfiltered) : null;
    },

    /**
     * Find record by its field value.<br>
     * Same as <code>find()</code> but with exact=true
     * @method
     * @param {string} property Record's field name
     * @param {string|int|bool} value Value to compare to
     * @param {boolean} unfiltered Look in unfiltered set
     * @returns {MetaphorJs.model.Record|object|null}
     */
    findExact: function (property, value, unfiltered) {
      return this.find(property, value, true, unfiltered);
    },

    /**
     * Find record by a set of fields
     * @method
     * @param {object} props A set of field:value pairs to match record against.
     * All fields must match for the record to be accepted.
     * @param {boolean} unfiltered Look in unfiltered set
     * @returns {MetaphorJs.model.Record|object|null}
     */
    findBySet: function (props, unfiltered) {
      let found = null,
          match,
          i;
      this.each(function (rec) {
        match = true;

        for (i in props) {
          if (props[i] != rec[i]) {
            match = false;
            break;
          }
        }

        if (match) {
          found = rec;
          return false;
        }

        return true;
      }, null, unfiltered);
      return found;
    },

    /**
     * Re-apply filter and sorting. 
     * Call this function if you used <code>skipUpdate</code> before.
     * @method
     */
    update: function () {
      const filtered = this.filtered,
            sorted = this.sorted,
            isPlain = this.model.isPlain();

      if (this.local) {
        this.totalLength = this.length = this.items.length;
      }

      this.currentLength = this.length;
      this.currentMap = this.itemMap;
      this.current = this.items;

      if (filtered) {
        const by = this.filterBy,
              opt = this.filterOpt;
        let current, map;
        this.current = current = [];
        this.currentMap = map = {};
        this.each(rec => {
          if (filterArray.compare(isPlain ? rec : rec.data, by, opt)) {
            current.push(rec);
            map[this.getRecordId(rec)] = rec;
          }
        }, null, true);
        this.currentLength = this.current.length;
      }

      if (this.local && this.pageSize) {
        this.current = this.current.slice(this.start, this.start + this.pageSize);
        this.currentLength = this.current.length;
      }

      if (sorted) {
        const sortBy = this.sortBy,
              rt = !this.model.isPlain(),
              getterFn = function (item) {
          return rt ? item.get(sortBy) : item[sortBy];
        };

        this.current = sortArray(this.current, isFunction(sortBy) ? {
          fn: sortBy
        } : getterFn, this.sortDir);
      }

      this.trigger("update", this);
    },

    /**
     * Filter store using a custom filter. This will change store contents
     * and length and you might have to use <code>unfiltered</code> flag
     * in some of the methods later. 
     * @method
     * @param {object|string|regexp|function|boolean} by
     * @param {string|boolean} opt
     * @code metaphorjs-shared/src-docs/examples/filterArray.js
     */
    filter: function (by, opt) {
      this.filtered = true;
      this.filterBy = by;
      this.filterOpt = opt;
      this.update();
    },

    /**
     * Clear filter
     * @method
     */
    clearFilter: function () {
      if (!this.filtered) {
        return;
      }

      this.filterBy = null;
      this.filterOpt = null;
      this.update();
    },

    /**
     * Sort array
     * @method
     * @param {string|function} by {
     *  Either a field name to sort by, or a function 
     *  @param {MetaphorJs.model.Record|object} a
     *  @param {MetaphorJs.model.Record|object} b 
     *  @returns {int} -1|0|1
     * }
     * @param {string} dir asc|desc
     */
    sort: function (by, dir) {
      this.sorted = true;
      this.sortBy = by;
      this.sortDir = dir;
      this.update();
    },

    /**
     * Clear sorting
     * @method
     */
    clearSorting: function () {
      this.sorted = false;
      this.sortBy = null;
      this.sortDir = null;
      this.update();
    },
    onDestroy: function () {
      delete allStores[this.id];

      if (this.sourceStore) {
        this.initSourceStore(this.sourceStore, "un");
      }

      this.clear();
      this.trigger("destroy", this);
      this.$super();
    }
  }, {
    /**
     * Find store
     * @static
     * @method
     * @param {string} id
     * @returns MetaphorJs.model.Store|null
     */
    lookupStore: function (id) {
      return allStores[id] || null;
    },

    /**
     * Iterate over registered stores
     * @static
     * @method
     * @param {function} fn {
     *  @param {MetaphorJs.model.Store} store
     *  @returns {boolean} return false to stop
     * }
     * @param {object} fnScope
     */
    eachStore: function (fn, fnScope) {
      let id;

      for (id in allStores) {
        if (fn.call(fnScope, allStores[id]) === false) {
          break;
        }
      }
    }
  });
}();

/***/ }),

/***/ "../metaphorjs-namespace/src/lib/Namespace.js":
/*!****************************************************!*\
  !*** ../metaphorjs-namespace/src/lib/Namespace.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-shared/src/lib/Cache */ "../metaphorjs-shared/src/lib/Cache.js");

const isObject = __webpack_require__(/*! metaphorjs-shared/src/func/isObject */ "../metaphorjs-shared/src/func/isObject.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @class MetaphorJs.lib.Namespace
 * @code src-docs/examples/main.js
 */

/**
 * Construct namespace
 * @constructor
 * @param {object} root {
 *  Namespace root object. Everything you register
 *  will be assigned as property of root object at some level.
 *  The parameter is optional. Pass your own object or window or global
 *  to have direct access to its properties. 
 *  @optional
 * }
 */


module.exports = MetaphorJs.lib.Namespace = function (root) {
  root = root || {};
  var self = this,
      cache = new MetaphorJs.lib.Cache(false);

  var parseNs = function (ns) {
    var tmp = ns.split("."),
        i,
        last = tmp.pop(),
        parent = tmp.join("."),
        len = tmp.length,
        name,
        current = root;

    if (cache[parent]) {
      return [cache[parent], last, ns];
    }

    if (len > 0) {
      for (i = 0; i < len; i++) {
        name = tmp[i];

        if (current[name] === undefined) {
          current[name] = {};
        }

        current = current[name];
      }
    }

    return [current, last, ns];
  };
  /**
   * Get namespace/cache object. 
   * @method
   * @param {string} objName Object name to get link to. Use the same name
   * as you used then registered or added the object.
   * @param {bool} cacheOnly Only get cached value. 
   * Return undefined if there is no cached value.
   * @returns {*}
   */


  var get = function (objName, cacheOnly) {
    var ex = cache.get(objName);

    if (ex !== undefined || cacheOnly) {
      return ex;
    }

    var tmp = objName.split("."),
        i,
        len = tmp.length,
        name,
        current = root;

    for (i = 0; i < len; i++) {
      name = tmp[i];

      if (current[name] === undefined) {
        return undefined;
      }

      current = current[name];
    }

    if (current) {
      cache.add(objName, current);
    }

    return current;
  };
  /**
   * Register item in namespace and cache. Given <code>root</code> is your
   * root object, registering <code>register("My.Value", 1)</code> will 
   * result in <code>root.My.Value === 1</code>.
   * @method
   * @param {string} objName Object name to register
   * @param {*} value
   * @returns {*} value
   */


  var register = function (objName, value) {
    var parse = parseNs(objName),
        parent = parse[0],
        name = parse[1];

    if (isObject(parent) && parent[name] === undefined) {
      parent[name] = value;
      cache.add(parse[2], value);
    }

    return value;
  };
  /**
   * Check if given object name exists in namespace.
   * @method
   * @param {string} objName
   * @returns {boolean}
   */


  var exists = function (objName) {
    return get(ns, true) !== undefined;
  };
  /**
   * Add item only to cache. This method will not add anything
   * to the root object. The <code>get</code> method will still return
   * value of this object.
   * @method
   * @param {string} objName
   * @param {*} value
   * @returns {*} value
   */


  var add = function (objName, value) {
    return cache.add(objName, value);
  };
  /**
   * Remove item from cache. Leaves namespace object unchanged.
   * @method
   * @param {string} objName
   * @returns {*} removed value
   */


  var remove = function (objName) {
    return cache.remove(objName);
  };
  /**
   * Make alias in the cache.
   * @method
   * @param {string} from
   * @param {string} to
   * @returns {*} value
   */


  var makeAlias = function (from, to) {
    var value = cache.get(from);

    if (value !== undefined) {
      cache.add(to, value);
    }

    return value;
  };
  /**
   * Destroy namespace and all classes in it
   * @method $destroy
   */


  var destroy = function () {
    var self = this,
        k;
    cache.eachEntry(function (entry) {
      if (entry && entry.$destroy) {
        entry.$destroy();
      }
    });
    cache.$destroy();
    cache = null;

    for (k in self) {
      self[k] = null;
    }
  };

  self.register = register;
  self.exists = exists;
  self.get = get;
  self.add = add;
  self.remove = remove;
  self.makeAlias = makeAlias;
  self.$destroy = destroy;
};

/***/ }),

/***/ "../metaphorjs-namespace/src/var/ns.js":
/*!*********************************************!*\
  !*** ../metaphorjs-namespace/src/var/ns.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/Namespace */ "../metaphorjs-namespace/src/lib/Namespace.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Already constructed private namespace 
 * with <code>MetaphorJs</code> object and its alias <code>mjs</code> 
 * registered at top level.
 * @var ns 
 */


module.exports = function () {
  var ns = new MetaphorJs.lib.Namespace();
  ns.register("MetaphorJs", MetaphorJs);
  ns.register("mjs", MetaphorJs);
  return ns;
}();

/***/ }),

/***/ "../metaphorjs-observable/src/lib/Observable.js":
/*!******************************************************!*\
  !*** ../metaphorjs-observable/src/lib/Observable.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

__webpack_require__(/*! ./ObservableEvent.js */ "../metaphorjs-observable/src/lib/ObservableEvent.js");

module.exports = MetaphorJs.lib.Observable = function () {
  /**
   * @description A javascript event system implementing multiple patterns: 
   * observable, collector and pipe.
   * @description Observable:
   * @code src-docs/examples/observable.js
   *
   * @description Collector:
   * @code src-docs/examples/collector.js
   * 
   * @description Pipe:
   * @code src-docs/examples/pipe.js
   *
   * @class MetaphorJs.lib.Observable
   * @author Ivan Kuindzhi
   */
  var Observable = function () {
    this.events = {};
  };

  extend(Observable.prototype, {
    /**
     * @method createEvent
     * @param {string} name {
     *      Event name
     *      @required
     * }
     * @param {object|string|bool} options {
     *  Options object or returnResult value. All options are optional.
     * 
     *  @type {string|bool} returnResult {
     *   false -- return first 'false' result and stop calling listeners after that<br>
     *   true -- return first 'true' result and stop calling listeners after that<br>
     *   "all" -- return all results as array<br>
     *   "concat" -- merge all results into one array (each result must be array)<br>
     *   "merge" -- merge all results into one object (each result much be object)<br>
     *   "pipe" -- pass return value of previous listener to the next listener.
     *             Only first trigger parameter is being replaced with return value,
     *             others stay as is.<br>
     *   "first" -- return result of the first handler (next listener will not be called)<br>
     *   "nonempty" -- return first nonempty result<br>
     *   "last" -- return result of the last handler (all listeners will be called)<br>
     *  }
     *  @type {bool} autoTrigger {
     *      once triggered, all future subscribers will be automatically called
     *      with last trigger params
     *      @code src-docs/examples/autoTrigger.js
     * }
     *  @type {function} triggerFilter {
     *      This function will be called each time event is triggered. 
     *      Return false to skip listener.
     *       @code src-docs/examples/triggerFilter.js
     *       @param {object} listener This object contains all information about the listener, including
     *           all data you provided in options while subscribing to the event.
     *       @param {[]} arguments
     *       @return {bool}
     *  }
     *  @type {object} filterContext triggerFilter's context
     *  @type {bool} expectPromises {   
     *      Expect listeners to return Promises. If <code>returnResult</code> is set,
     *      promises will be treated as return values unless <code>resolvePromises</code>
     *      is set.
     *  }
     *  @type {bool} resolvePromises {
     *      In pair with <code>expectPromises</code> and <code>returnResult</code>
     *      this option makes trigger function wait for promises to resolve.
     *      All or just one depends on returnResult mode. "pipe" mode 
     *      makes promises resolve consequentially passing resolved value
     *      to the next promise.
     *  }
     * }
     * @returns {MetaphorJs.lib.ObservableEvent}
     */
    createEvent: function (name, options) {
      name = name.toLowerCase();
      var events = this.events;

      if (!events[name]) {
        events[name] = new MetaphorJs.lib.ObservableEvent(name, options);
      }

      return events[name];
    },

    /**
    * @method
    * @access public
    * @param {string} name Event name
    * @return {MetaphorJs.lib.ObservableEvent|undefined}
    */
    getEvent: function (name) {
      name = name.toLowerCase();
      return this.events[name];
    },

    /**
    * Subscribe to an event or register collector function.
    * @method
    * @access public
    * @param {string} name {
    *       Event name. Use '*' to subscribe to all events.
    *       @required
    * }
    * @param {function} fn {
    *       Callback function
    *       @required
    * }
    * @param {object} context "this" object for the callback function
    * @param {object} options {
    *       You can pass any key-value pairs in this object. All of them will be passed 
    *       to triggerFilter (if you're using one).
    *       @type {bool} first {
    *           True to prepend to the list of handlers
    *           @default false
    *       }
    *       @type {number} limit {
    *           Call handler this number of times; 0 for unlimited
    *           @default 0
    *       }
    *       @type {number} start {
    *           Start calling handler after this number of calls. Starts from 1
    *           @default 1
    *       }
    *       @type {array} append Append parameters
    *       @type {array} prepend Prepend parameters
    *       @type {array} replaceArgs Replace parameters
    *       @type {bool} allowDupes allow the same handler twice
    *       @type {bool|int} async run event asynchronously. If event was
    *                      created with <code>expectPromises: true</code>, 
    *                      this option is ignored.
    * }
    */
    on: function (name, fn, context, options) {
      name = name.toLowerCase();
      var events = this.events;

      if (!events[name]) {
        events[name] = new MetaphorJs.lib.ObservableEvent(name);
      }

      return events[name].on(fn, context, options);
    },

    /**
    * Same as {@link class:Observable.on}, but options.limit is forcefully set to 1.
    * @method
    * @access public
    */
    once: function (name, fn, context, options) {
      options = options || {};
      options.limit = 1;
      return this.on(name, fn, context, options);
    },

    /**
     * Subscribe to an event and return a promise that will be resolved
     * with event payload
     * @param {string} name Event name
     * @return {Promise}
     * @code src-docs/examples/promise.js
     */
    promise: function (name) {
      return new Promise(resolve => {
        this.once(name, resolve, null, {
          limit: 1
        });
      });
    },

    /**
    * Unsubscribe from an event
    * @method
    * @access public
    * @param {string} name Event name
    * @param {function} fn Event handler
    * @param {object} context If you called on() with context you must 
    *                         call un() with the same context
    */
    un: function (name, fn, context) {
      name = name.toLowerCase();
      var events = this.events;

      if (!events[name]) {
        return;
      }

      events[name].un(fn, context);
    },

    /**
     * Relay all events of <code>eventSource</code> through this observable.
     * @method
     * @access public
     * @code src-docs/examples/relay.js
     * @param {object} eventSource
     * @param {string} eventName
     * @param {string} triggerName
     * @param {string} triggerNamePfx prefix all relayed event names
     */
    relayEvent: function (eventSource, eventName, triggerName, triggerNamePfx) {
      eventSource.on(eventName, this.trigger, this, {
        prepend: eventName === "*" ? null : // use provided new event name or original name
        [triggerName || eventName],
        replaceArgs: eventName === "*" && triggerNamePfx ? function (l, args) {
          args[0] = triggerNamePfx + args[0];
          return args;
        } : null
      });
    },

    /**
     * Stop relaying events of <code>eventSource</code>
     * @method
     * @access public
     * @param {object} eventSource
     * @param {string} eventName
     */
    unrelayEvent: function (eventSource, eventName) {
      eventSource.un(eventName, this.trigger, this);
    },

    /**
     * @method hasListener
     * @access public
     * @return bool
     */

    /**
    * @method hasListener
    * @access public
    * @param {string} name Event name { @required }
    * @return bool
    */

    /**
    * @method
    * @access public
    * @param {string} name Event name { @required }
    * @param {function} fn Callback function { @required }
    * @param {object} context Function's "this" object
    * @return bool
    */
    hasListener: function (name, fn, context) {
      var events = this.events;

      if (name) {
        name = name.toLowerCase();

        if (!events[name]) {
          return false;
        }

        return events[name].hasListener(fn, context);
      } else {
        for (name in events) {
          if (events[name].hasListener()) {
            return true;
          }
        }

        return false;
      }
    },

    /**
    * @method
    * @access public
    * @param {string} name Event name { @required }
    * @return bool
    */
    hasEvent: function (name) {
      return !!this.events[name];
    },

    /**
    * Remove all listeners from all events
    * @method removeAllListeners
    * @access public
    */

    /**
    * Remove all listeners from specific event
    * @method
    * @access public
    * @param {string} name Event name { @required }
    */
    removeAllListeners: function (name) {
      var events = this.events;

      if (name) {
        if (!events[name]) {
          return;
        }

        events[name].removeAllListeners();
      } else {
        for (name in events) {
          events[name].removeAllListeners();
        }
      }
    },

    /**
    * Trigger an event -- call all listeners. Also triggers '*' event.
    * @method
    * @access public
    * @param {string} name Event name { @required }
    * @param {*} ... As many other params as needed
    * @return mixed
    */
    trigger: function () {
      var name = arguments[0],
          events = this.events,
          e,
          res = null;
      name = name.toLowerCase();

      if (events[name]) {
        e = events[name];
        res = e.trigger.apply(e, toArray(arguments).slice(1));
      } // trigger * event with current event name
      // as first argument


      if (e = events["*"]) {
        e.trigger.apply(e, arguments);
      }

      return res;
    },

    /**
    * Suspend an event. Suspended event will not call any listeners on trigger().
    * @method
    * @access public
    * @param {string} name Event name
    */
    suspendEvent: function (name) {
      name = name.toLowerCase();
      var events = this.events;

      if (!events[name]) {
        return;
      }

      events[name].suspend();
    },

    /**
    * @method
    * @access public
    */
    suspendAllEvents: function () {
      var events = this.events;

      for (var name in events) {
        events[name].suspend();
      }
    },

    /**
    * Resume suspended event.
    * @method
    * @access public
    * @param {string} name Event name
    */
    resumeEvent: function (name) {
      name = name.toLowerCase();
      var events = this.events;

      if (!events[name]) {
        return;
      }

      events[name].resume();
    },

    /**
    * @method
    * @access public
    */
    resumeAllEvents: function () {
      var events = this.events;

      for (var name in events) {
        events[name].resume();
      }
    },

    /**
     * @method
     * @access public
     * @param {string} name Event name
     */
    destroyEvent: function (name) {
      var events = this.events;

      if (events[name]) {
        events[name].removeAllListeners();
        events[name].$destroy();
        delete events[name];
      }
    },

    /**
    * Destroy observable
    * @method
    * @md-not-inheritable
    * @access public
    */
    $destroy: function () {
      var self = this,
          events = self.events;

      for (var i in events) {
        self.destroyEvent(i);
      }

      for (i in self) {
        self[i] = null;
      }
    }
  }, true, false);

  const __createEvents = function (host, obs, events) {
    for (var i in events) {
      host.createEvent ? host.createEvent(i, events[i]) : obs.createEvent(i, events[i]);
    }
  };

  const __on = function (host, obs, event, fn, context) {
    host.on ? host.on(event, fn, context || host) : obs.on(event, fn, context || host);
  };

  Observable['$initHost'] = function (host, hostCfg, observable) {
    var i;

    if (host.$$events) {
      __createEvents(host, observable, host.$$events);
    }

    if (hostCfg && hostCfg.callback) {
      var ls = hostCfg.callback,
          context = ls.context || ls.scope || ls.$context;
      if (ls.$events) __createEvents(host, observable, ls.$events);
      ls.context = null;
      ls.scope = null;

      for (i in ls) {
        if (ls[i]) {
          __on(host, observable, i, ls[i], context);
        }
      }

      hostCfg.callback = null;

      if (context) {
        host.$$callbackContext = context;
      }
    }
  };

  Observable['$initHostConfig'] = function (host, config, scope, node) {
    var msl = MetaphorJs.lib.Config.MODE_LISTENER,
        ctx;
    config.setDefaultMode("callbackContext", MetaphorJs.lib.Config.MODE_SINGLE);
    config.eachProperty(function (name) {
      if (name.substring(0, 4) === 'on--') {
        config.setMode(name, msl);

        if (!ctx) {
          if (scope.$app) ctx = config.get("callbackContext") || (node ? scope.$app.getParentCmp(node) : null) || scope.$app || scope;else ctx = config.get("callbackContext") || scope;
        }

        host.on(name.substring(4), config.get(name), ctx);
      }
    });
  };

  return Observable;
}();

/***/ }),

/***/ "../metaphorjs-observable/src/lib/ObservableEvent.js":
/*!***********************************************************!*\
  !*** ../metaphorjs-observable/src/lib/ObservableEvent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      async = __webpack_require__(/*! metaphorjs-shared/src/func/async.js */ "../metaphorjs-shared/src/func/async.js"),
      error = __webpack_require__(/*! metaphorjs-shared/src/func/error.js */ "../metaphorjs-shared/src/func/error.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.lib.ObservableEvent = function () {
  /**
   * This class is private - you can't create an event other than via Observable.
   * See {@link class:Observable} reference.
   * @class MetaphorJs.lib.ObservableEvent
   * @private
   */
  var ObservableEvent = function (name, options) {
    var self = this;
    self.name = name;
    self.listeners = [];
    self.map = {};
    self.hash = nextUid();
    self.uni = '$$' + name + '_' + self.hash;
    self.suspended = false;
    self.lid = 0; // listener id

    self.fid = 0; // function id (same function can be different listeners)
    //self.limit          = 0;

    if (typeof options === "object" && options !== null) {
      extend(self, options, true, false);
    } else {
      self.returnResult = options;
    }

    self.triggered = 0;
  };

  extend(ObservableEvent.prototype, {
    name: null,
    listeners: null,
    map: null,
    hash: null,
    uni: null,
    suspended: false,
    lid: null,
    fid: null,
    limit: 0,
    triggered: 0,
    returnResult: null,
    autoTrigger: null,
    lastTrigger: null,
    triggerFilter: null,
    filterContext: null,
    expectPromises: false,
    resolvePromises: false,

    /**
     * Get event name
     * @method
     * @returns {string}
     */
    getName: function () {
      return this.name;
    },

    /**
     * @method
     */
    $destroy: function () {
      var self = this,
          k;

      for (k in self) {
        self[k] = null;
      }
    },

    /**
     * @method
     * @param {function} fn Callback function { @required }
     * @param {object} context Function's "this" object
     * @param {object} options See {@link class:Observable.on}
     */
    on: function (fn, context, options) {
      if (!fn) {
        return null;
      }

      context = context || null;
      options = options || {};
      var self = this,
          uni = self.uni,
          lid = ++self.lid,
          fid = fn[uni] || ++self.fid,
          ctxUni = uni + "_" + fid,
          first = options.first || false;

      if (fn[uni] && (!context || context[ctxUni]) && !options.allowDupes) {
        return null;
      }

      if (!fn[uni]) {
        fn[uni] = fid;
      }

      if (context && !context[ctxUni]) {
        context[ctxUni] = true;
      }

      var e = {
        fn: fn,
        context: context,
        id: lid,
        fid: fid,
        async: false,
        called: 0,
        // how many times the function was triggered
        limit: 0,
        // how many times the function is allowed to trigger
        start: 1,
        // from which attempt it is allowed to trigger the function
        count: 0,
        // how many attempts to trigger the function was made
        append: null,
        // append parameters
        prepend: null,
        // prepend parameters
        replaceArgs: null // replace parameters

      };
      extend(e, options, true, false);

      if (e.async === true) {
        e.async = 1;
      }

      if (options.once) {
        e.limit = 1;
      }

      if (first) {
        self.listeners.unshift(e);
      } else {
        self.listeners.push(e);
      }

      self.map[lid] = e;

      if (self.autoTrigger && self.lastTrigger && !self.suspended) {
        var prevFilter = self.triggerFilter;

        self.triggerFilter = function (l) {
          if (l.id === lid) {
            return prevFilter ? prevFilter(l) !== false : true;
          }

          return false;
        };

        self.trigger.apply(self, self.lastTrigger);
        self.triggerFilter = prevFilter;
      }

      return lid;
    },

    /**
     * @method
     * @param {function} fn Callback function { @required }
     * @param {object} context Function's "this" object
     * @param {object} options See {@link class:Observable.on}
     */
    once: function (fn, context, options) {
      options = options || {};
      options.limit = 1;
      return this.on(fn, context, options);
    },

    /**
     * @method
     * @param {function} fn Callback function { @required }
     * @param {object} context Callback context
     */
    un: function (fn, context) {
      var self = this,
          inx = -1,
          uni = self.uni,
          listeners = self.listeners,
          fid,
          lid;

      if (fn == parseInt(fn)) {
        lid = parseInt(fn);

        if (!self.map[lid]) {
          return false;
        }

        fid = self.map[lid].fid;
      } else {
        fid = fn[uni];
      }

      if (!fid) {
        return false;
      }

      var ctxUni = uni + "_" + fid;
      context = context || null;

      for (var i = 0, len = listeners.length; i < len; i++) {
        if (listeners[i].fid === fid && listeners[i].context === context) {
          inx = i;
          lid = listeners[i].id;
          delete fn[uni];

          if (context) {
            delete context[ctxUni];
          }

          break;
        }
      }

      if (inx === -1) {
        return false;
      }

      listeners.splice(inx, 1);
      delete self.map[lid];
      return true;
    },

    /**
     * @method hasListener
     * @return bool
     */

    /**
     * @method
     * @param {function} fn Callback function { @required }
     * @param {object} context Callback context
     * @return boolean
     */
    hasListener: function (fn, context) {
      var self = this,
          listeners = self.listeners,
          fid;

      if (fn) {
        if (!isFunction(fn)) {
          fid = parseInt(fn);
        } else {
          fid = fn[self.uni];
        }

        if (!fid) {
          return false;
        }

        var ctxUni = self.uni + "_" + fid;

        for (var i = 0, len = listeners.length; i < len; i++) {
          if (listeners[i].fid === fid) {
            if (!context || context[ctxUni]) {
              return true;
            }
          }
        }

        return false;
      } else {
        return listeners.length > 0;
      }
    },

    /**
     * @method
     */
    removeAllListeners: function () {
      var self = this,
          listeners = self.listeners,
          uni = self.uni,
          i,
          len,
          ctxUni;

      for (i = 0, len = listeners.length; i < len; i++) {
        ctxUni = uni + "_" + listeners[i].fn[uni];
        delete listeners[i].fn[uni];

        if (listeners[i].context) {
          delete listeners[i].context[ctxUni];
        }
      }

      self.listeners = [];
      self.map = {};
    },

    /**
     * @method
     */
    suspend: function () {
      this.suspended = true;
    },

    /**
     * @method
     */
    resume: function () {
      this.suspended = false;
    },
    _prepareArgs: function (l, triggerArgs) {
      var args, prepend, append, repl;

      if (l.append || l.prepend) {
        prepend = l.prepend;
        append = l.append;
        args = triggerArgs.slice();

        if (prepend) {
          if (typeof prepend === "function") {
            prepend = prepend(l, triggerArgs);
          }

          args = prepend.concat(args);
        }

        if (append) {
          if (typeof append === "function") {
            append = append(l, triggerArgs);
          }

          args = args.concat(append);
        }
      } else if (l.replaceArgs) {
        repl = l.replaceArgs;

        if (typeof repl === "function") {
          repl = repl(l, triggerArgs);
        }

        args = [].concat(repl);
      } else {
        args = triggerArgs;
      }

      return args;
    },

    /**
     * @method
     * @return {*}
     */
    trigger: function () {
      var self = this,
          listeners = self.listeners,
          rr = self.returnResult,
          filter = self.triggerFilter,
          filterContext = self.filterContext,
          expectPromises = self.expectPromises,
          keepPromiseOrder = self.keepPromiseOrder,
          results = [],
          origArgs = toArray(arguments),
          prevPromise,
          resPromise,
          args,
          resolver;

      if (self.suspended) {
        return null;
      }

      if (self.limit > 0 && self.triggered >= self.limit) {
        return null;
      }

      self.triggered++;

      if (self.autoTrigger) {
        self.lastTrigger = origArgs.slice();
      } // in pipe mode if there is no listeners,
      // we just return piped value


      if (listeners.length === 0) {
        if (rr === "pipe") {
          return origArgs[0];
        }

        return null;
      }

      var ret = rr === "all" || rr === "concat" ? [] : rr === "merge" ? {} : null,
          q,
          l,
          res;

      if (rr === "first") {
        q = [listeners[0]];
      } else {
        // create a snapshot of listeners list
        q = listeners.slice();
      }

      if (expectPromises && rr === "last") {
        keepPromiseOrder = true;
      } // now if during triggering someone unsubscribes
      // we won't skip any listener due to shifted
      // index


      while (l = q.shift()) {
        // listener may already have unsubscribed
        if (!l || !self.map[l.id]) {
          continue;
        }

        args = self._prepareArgs(l, origArgs);

        if (filter && filter.call(filterContext, l, args, self) === false) {
          continue;
        }

        if (l.filter && l.filter.apply(l.filterContext || l.context, args) === false) {
          continue;
        }

        l.count++;

        if (l.count < l.start) {
          continue;
        }

        if (l.async && !expectPromises) {
          res = null;
          async(l.fn, l.context, args, l.async);
        } else {
          if (expectPromises) {
            resolver = function (l, rr, args) {
              return function (value) {
                if (rr === "pipe") {
                  args[0] = value;
                  args = self._prepareArgs(l, args);
                }

                return l.fn.apply(l.context, args);
              };
            }(l, rr, origArgs.slice());

            if (prevPromise) {
              res = prevPromise.then(resolver);
            } else {
              res = l.fn.apply(l.context, args);
            }

            res.catch(error);
          } else {
            res = l.fn.apply(l.context, args);
          }
        }

        l.called++;

        if (l.called === l.limit) {
          self.un(l.id);
        } // This rule is valid in all cases sync and async.
        // It either returns first value or first promise.


        if (rr === "first") {
          return res;
        } // Promise branch


        if (expectPromises) {
          // we collect all results for further processing/resolving
          results.push(res);

          if ((rr === "pipe" || keepPromiseOrder) && res) {
            prevPromise = res;
          }
        } else {
          if (rr !== null) {
            if (rr === "all") {
              ret.push(res);
            } else if (rr === "concat" && res) {
              ret = ret.concat(res);
            } else if (rr === "merge") {
              extend(ret, res, true, false);
            } else if (rr === "nonempty" && res) {
              return res;
            } else if (rr === "pipe") {
              ret = res;
              origArgs[0] = res;
            } else if (rr === "last") {
              ret = res;
            } else if (rr === false && res === false) {
              return false;
            } else if (rr === true && res === true) {
              return true;
            }
          }
        }
      }

      if (expectPromises) {
        if (rr === "pipe") {
          return prevPromise;
        }

        resPromise = Promise.all(results);

        if (self.resolvePromises && rr !== null && rr !== "all") {
          resPromise = resPromise.then(function (values) {
            var i,
                l = values.length,
                res;

            for (i = 0; i < l; i++) {
              res = values[i];

              if (rr === "concat" && res) {
                ret = ret.concat(res);
              } else if (rr === "merge") {
                extend(ret, res, true, false);
              } else if (rr === "nonempty" && res) {
                return res;
              } else if (rr === "last") {
                ret = res;
              } else if (rr === false && res === false) {
                return false;
              } else if (rr === true && res === true) {
                return true;
              }
            }

            return ret;
          });
        }

        return resPromise;
      } else return ret;
    }
  }, true, false);
  return ObservableEvent;
}();

/***/ }),

/***/ "../metaphorjs-observable/src/mixin/Observable.js":
/*!********************************************************!*\
  !*** ../metaphorjs-observable/src/mixin/Observable.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/Observable.js */ "../metaphorjs-observable/src/lib/Observable.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @mixin MetaphorJs.mixin.Observable
 * @description Mixin adds observable features to the host object.
 *              It adds 'callback' option to the host config. See $beforeInit.
 *              Mixin is designed for MetaphorJs class system.
 * @code src-docs/examples/mixin.js
 */


module.exports = MetaphorJs.mixin.Observable = {
  /**
   * @private
   * @type {Observable}
   * @description You can use this instance in your $init function
   */
  $$observable: null,

  /**
   * @private
   * @type {object}
   */
  $$callbackContext: null,

  /**
   * @protected
   * @type {object} {
   *      Override this to define event properties. 
   *      Object's key is event name, value - either returnResult or 
   *      options object. See {@link class:MetaphorJs.lib.Observable.createEvent}
   * }
   */
  $$events: null,

  /**
   * @method
   * @private
   * @param {object} cfg {
   *      This is a config that was passed to the host object's constructor.
   *      It is being passed to mixin's $beforeInit automatically.
   *      @type {object} callback {
   *          Here, except for 'context', '$context' and 'scope', 
   *          keys are event names and values are listeners. 
   *          @type {object} context All given listeners context
   *          @type {object} scope The same
   *      }
   * }
   */
  $beforeInit: function (cfg) {
    var self = this;
    self.$$observable = new MetaphorJs.lib.Observable();
    self.$initObservable(cfg);
  },

  /**
   * @method
   * @private
   * @ignore
   * @param {object} cfg
   */
  $initObservable: function (cfg) {
    MetaphorJs.lib.Observable.$initHost(this, cfg, this.$$observable);
  },

  /**
   * @method
   * @see {@link class:Observable.on}
   */
  on: function () {
    var o = this.$$observable;
    return o ? o.on.apply(o, arguments) : null;
  },

  /**
   * @method
   * @see {@link class:Observable.un}
   */
  un: function () {
    var o = this.$$observable;
    return o ? o.un.apply(o, arguments) : null;
  },

  /**
   * @method
   * @see {@link class:Observable.once}
   */
  once: function () {
    var o = this.$$observable;
    return o ? o.once.apply(o, arguments) : null;
  },

  /**
   * @method
   * @see {@link class:Observable.trigger}
   */
  trigger: function () {
    var o = this.$$observable;
    return o ? o.trigger.apply(o, arguments) : null;
  },

  /**
   * @method
   * @private
   * @ignore
   */
  $beforeDestroy: function () {
    this.$$observable.trigger("before-destroy", this);
  },

  /**
   * @method
   * @private
   * @ignore
   */
  $afterDestroy: function () {
    var self = this;
    self.$$observable.trigger("destroy", self);
    self.$$observable.$destroy();
    self.$$observable = null;
  }
};

/***/ }),

/***/ "../metaphorjs-promise/src/lib/Promise.js":
/*!************************************************!*\
  !*** ../metaphorjs-promise/src/lib/Promise.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isThenable = __webpack_require__(/*! metaphorjs-shared/src/func/isThenable.js */ "../metaphorjs-shared/src/func/isThenable.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      error = __webpack_require__(/*! metaphorjs-shared/src/func/error.js */ "../metaphorjs-shared/src/func/error.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js");

module.exports = MetaphorJs.lib.Promise = function () {
  var PENDING = 0,
      FULFILLED = 1,
      REJECTED = 2,
      CANCELLED = 3,
      queue = [],
      qRunning = false,
      nextTick = typeof process !== "undefined" ? process.nextTick : function (fn) {
    setTimeout(fn, 0);
  },
      // synchronous queue of asynchronous functions:
  // callbacks must be called in "platform stack"
  // which means setTimeout/nextTick;
  // also, they must be called in a strict order.
  nextInQueue = function () {
    qRunning = true;
    var next = queue.shift();
    nextTick(function () {
      next[0].apply(next[1], next[2]);

      if (queue.length) {
        nextInQueue();
      } else {
        qRunning = false;
      }
    }, 0);
  },

  /**
   * add to execution queue
   * @function
   * @param {Function} fn
   * @param {Object} scope
   * @param {[]} args
   * @ignore
   */
  next = function (fn, scope, args) {
    args = args || [];
    queue.push([fn, scope, args]);

    if (!qRunning) {
      nextInQueue();
    }
  },

  /**
   * returns function which receives value from previous promise
   * and tries to resolve next promise with new value returned from given function(prev value)
   * or reject on error.
   * promise1.then(success, failure) -> promise2
   * wrapper(success, promise2) -> fn
   * fn(promise1 resolve value) -> new value
   * promise2.resolve(new value)
   *
   * @function
   * @param {Function} fn
   * @param {Promise} promise
   * @returns {Function}
   * @ignore
   */
  resolveWrapper = function (fn, promise) {
    return function (value) {
      try {
        promise.resolve(fn(value));
      } catch (thrownError) {
        promise.reject(thrownError);
      }
    };
  };
  /**
   * @class MetaphorJs.lib.Promise
   */

  /**
   * @constructor 
   * @method Promise
   * @param {Function} fn {
   *  @description Constructor accepts two parameters: resolve and reject functions.
   *  @param {function} resolve {
   *      @param {*} value
   *  }
   *  @param {function} reject {
   *      @param {*} reason
   *  }
   * }
   * @param {Object} context
   * @returns {Promise}
   */

  /**
   * @constructor 
   * @method Promise 
   * @param {Thenable} thenable
   * @returns {Promise}
   */

  /**
   * @constructor 
   * @method Promise 
   * @param {*} value Value to resolve promise with
   * @returns {Promise}
   */

  /**
   * @constructor 
   * @method Promise 
   * @returns {Promise}
   */


  var Promise = function (fn, context) {
    if (fn instanceof Promise) {
      return fn;
    }

    if (!(this instanceof Promise)) {
      return new Promise(fn, context);
    }

    var self = this,
        then;
    self._fulfills = [];
    self._rejects = [];
    self._dones = [];
    self._fails = [];

    if (arguments.length > 0) {
      if (then = isThenable(fn)) {
        if (fn instanceof Promise) {
          fn.then(bind(self.resolve, self), bind(self.reject, self));
        } else {
          new Promise(then, fn).then(bind(self.resolve, self), bind(self.reject, self));
        }
      } else if (isFunction(fn)) {
        try {
          fn.call(context, bind(self.resolve, self), bind(self.reject, self));
        } catch (thrownError) {
          self.reject(thrownError);
        }
      } else {
        self.resolve(fn);
      }
    }
  };

  extend(Promise.prototype, {
    _state: PENDING,
    _fulfills: null,
    _rejects: null,
    _dones: null,
    _fails: null,
    _wait: 0,
    _value: null,
    _reason: null,
    _triggered: false,

    /**
     * Is promise still pending (as opposed to resolved or rejected)
     * @method
     * @returns {boolean}
     */
    isPending: function () {
      return this._state === PENDING;
    },

    /**
     * Is the promise fulfilled. Same as isResolved()
     * @method
     * @returns {boolean}
     */
    isFulfilled: function () {
      return this._state === FULFILLED;
    },

    /**
     * Is the promise resolved. Same as isFulfilled()
     * @method
     * @returns {boolean}
     */
    isResolved: function () {
      return this._state === FULFILLED;
    },

    /**
     * Is the promise rejected
     * @method
     * @returns {boolean}
     */
    isRejected: function () {
      return this._state === REJECTED;
    },

    /**
     * Is the promise was destroyed before resolving or rejecting
     * @method
     * @returns {boolean}
     */
    isCancelled: function () {
      return this._state === CANCELLED;
    },

    /**
     * Did someone subscribed to this promise
     * @method
     * @returns {boolean}
     */
    hasListeners: function () {
      var self = this,
          ls = [self._fulfills, self._rejects, self._dones, self._fails],
          i,
          l;

      for (i = 0, l = ls.length; i < l; i++) {
        if (ls[i] && ls[i].length) {
          return true;
        }
      }

      return false;
    },
    _cleanup: function () {
      var self = this;
      self._fulfills = null;
      self._rejects = null;
      self._dones = null;
      self._fails = null;
    },
    _processValue: function (value, cb, allowThenanle) {
      var self = this,
          then;

      if (self._state !== PENDING) {
        return;
      }

      if (value === self) {
        self._doReject(new TypeError("cannot resolve promise with itself"));

        return;
      }

      if (allowThenanle) {
        try {
          if (then = isThenable(value)) {
            if (value instanceof Promise) {
              value.then(bind(self._processResolveValue, self), bind(self._processRejectReason, self));
            } else {
              new Promise(then, value).then(bind(self._processResolveValue, self), bind(self._processRejectReason, self));
            }

            return;
          }
        } catch (thrownError) {
          if (self._state === PENDING) {
            self._doReject(thrownError);
          }

          return;
        }
      }

      cb.call(self, value);
    },
    _callResolveHandlers: function () {
      var self = this;

      self._done();

      var cbs = self._fulfills,
          cb;

      while (cb = cbs.shift()) {
        next(cb[0], cb[1], [self._value]);
      }

      self._cleanup();
    },
    _doResolve: function (value) {
      var self = this;
      self._value = value;
      self._state = FULFILLED;

      if (self._wait === 0) {
        self._callResolveHandlers();
      }
    },
    _processResolveValue: function (value) {
      this._processValue(value, this._doResolve, true);
    },

    /**
     * Resolve the promise
     * @method
     * @param {*} value
     */
    resolve: function (value) {
      var self = this;

      if (self._triggered) {
        return self;
      }

      self._triggered = true;

      self._processResolveValue(value);

      return self;
    },
    _callRejectHandlers: function () {
      var self = this;

      self._fail();

      var cbs = self._rejects,
          cb;

      while (cb = cbs.shift()) {
        next(cb[0], cb[1], [self._reason]);
      }

      self._cleanup();
    },
    _doReject: function (reason) {
      var self = this;
      self._state = REJECTED;
      self._reason = reason;

      if (self._wait === 0) {
        self._callRejectHandlers();
      }
    },
    _processRejectReason: function (reason) {
      this._processValue(reason, this._doReject, false);
    },

    /**
     * Reject the promise
     * @method
     * @param {*} reason
     */
    reject: function (reason) {
      var self = this;

      if (self._triggered) {
        return self;
      }

      self._triggered = true;

      self._processRejectReason(reason);

      return self;
    },

    /**
     * @method
     * @async
     * @param {Function} resolve -- called when this promise is resolved; 
     *  returns new resolve value or promise
     * @param {Function} reject -- called when this promise is rejected; 
     *  returns new reject reason
     * @param {object} context -- resolve's and reject's functions "this" object
     * @returns {Promise} new promise
     */
    then: function (resolve, reject, context) {
      var self = this,
          promise = new Promise(),
          state = self._state;

      if (context) {
        if (resolve) {
          resolve = bind(resolve, context);
        }

        if (reject) {
          reject = bind(reject, context);
        }
      }

      if (state === PENDING || self._wait !== 0) {
        if (resolve && isFunction(resolve)) {
          self._fulfills.push([resolveWrapper(resolve, promise), null]);
        } else {
          self._fulfills.push([promise.resolve, promise]);
        }

        if (reject && isFunction(reject)) {
          self._rejects.push([resolveWrapper(reject, promise), null]);
        } else {
          self._rejects.push([promise.reject, promise]);
        }
      } else if (state === FULFILLED) {
        if (resolve && isFunction(resolve)) {
          next(resolveWrapper(resolve, promise), null, [self._value]);
        } else {
          promise.resolve(self._value);
        }
      } else if (state === REJECTED) {
        if (reject && isFunction(reject)) {
          next(resolveWrapper(reject, promise), null, [self._reason]);
        } else {
          promise.reject(self._reason);
        }
      }

      return promise;
    },

    /**
     * Add reject listener.
     * @method
     * @async
     * @param {Function} reject -- same as then(null, reject)
     * @returns {Promise} new promise
     */
    "catch": function (reject) {
      return this.then(null, reject);
    },
    _done: function () {
      var self = this,
          cbs = self._dones,
          cb;

      while (cb = cbs.shift()) {
        try {
          cb[0].call(cb[1] || null, self._value);
        } catch (thrown) {
          error(thrown);
        }
      }
    },

    /**
     * Add resolve listener
     * @method
     * @sync
     * @param {Function} fn -- function to call when promise is resolved
     * @param {Object} context -- function's "this" object
     * @returns {Promise} same promise
     */
    done: function (fn, context) {
      var self = this,
          state = self._state;

      if (state === FULFILLED && self._wait === 0) {
        try {
          fn.call(context || null, self._value);
        } catch (thrown) {
          error(thrown);
        }
      } else if (state === PENDING || self._wait > 0) {
        self._dones.push([fn, context]);
      }

      return self;
    },
    _fail: function () {
      var self = this,
          cbs = self._fails,
          cb;

      while (cb = cbs.shift()) {
        try {
          cb[0].call(cb[1] || null, self._reason);
        } catch (thrown) {
          error(thrown);
        }
      }
    },

    /**
     * Add reject listener
     * @method
     * @sync
     * @param {Function} fn -- function to call when promise is rejected.
     * @param {Object} context -- function's "this" object
     * @returns {Promise} same promise
     */
    fail: function (fn, context) {
      var self = this,
          state = self._state;

      if (state === REJECTED && self._wait === 0) {
        try {
          fn.call(context || null, self._reason);
        } catch (thrown) {
          error(thrown);
        }
      } else if (state === PENDING || self._wait > 0) {
        self._fails.push([fn, context]);
      }

      return self;
    },

    /**
     * Add both resolve and reject listener
     * @method
     * @sync
     * @param {Function} fn -- function to call when promise resolved or rejected
     * @param {Object} context -- function's "this" object
     * @return {Promise} same promise
     */
    always: function (fn, context) {
      this.done(fn, context);
      this.fail(fn, context);
      return this;
    },

    /**
     * Add both resolve and reject listener
     * @method
     * @sync
     * @param {Function} fn -- function to call when promise resolved or rejected
     * @param {Object} context -- function's "this" object
     * @return {Promise} same promise
     */
    finally: function (fn, context) {
      this.done(fn, context);
      this.fail(fn, context);
      return this;
    },

    /**
     * Get a thenable object
     * @method
     * @returns {object} then: function, done: function, fail: function, always: function
     */
    promise: function () {
      var self = this;
      return {
        then: bind(self.then, self),
        done: bind(self.done, self),
        fail: bind(self.fail, self),
        always: bind(self.always, self),
        "catch": bind(self['catch'], self)
      };
    },

    /**
     * Call resolve/reject handlers only after <code>value</code> 
     * promise is resolved. <br>
     * <code>
     * var p = new MetaphorJs.lib.Promise;
     * var p2 = new MetaphorJs.lib.Promise;
     * p.done(function(){console.log('ok')})
     * p.after(p2); // add as many promises as needed
     * p.resolve(); // nothing
     * p2.resolve(); // 'ok' !
     * </code>
     * Keep in mind, that current promise will not be auto resolved. 
     * @method
     * @param {*|Promise} value
     * @returns {Promise} self
     */
    after: function (value) {
      var self = this;

      if (isThenable(value)) {
        self._wait++;

        var done = function () {
          self._wait--;

          if (self._wait === 0 && self._state !== PENDING && self._state !== CANCELLED) {
            self._state === FULFILLED ? self._callResolveHandlers() : self._callRejectHandlers();
          }
        };

        if (isFunction(value.done)) {
          value.done(done);
        } else {
          value.then(done);
        }
      }

      return self;
    },

    /**
     * Cancel and destroy current promise. No resolve or reject 
     * callbacks will be called. isCancelled() will return true.
     * @method
     */
    $destroy: function () {
      this._cleanup();

      this._state === PENDING && (this._state = CANCELLED);
    }
  }, true, false);
  /**
   * Call function <code>fn</code> with given args in given context
   * and use its return value as resolve value for a new promise.
   * Then return this promise.
   * @static
   * @method
   * @param {function} fn
   * @param {object} context
   * @param {[]} args
   * @returns {Promise}
   */

  Promise.fcall = function (fn, context, args) {
    return Promise.resolve(fn.apply(context, args || []));
  };
  /**
   * Create new promise and resolve it with given value
   * @static
   * @method
   * @param {*} value
   * @returns {Promise}
   */


  Promise.resolve = function (value) {
    var p = new Promise();
    p.resolve(value);
    return p;
  };
  /**
   * Create new promise and reject it with given reason
   * @static
   * @method
   * @param {*} reason
   * @returns {Promise}
   */


  Promise.reject = function (reason) {
    var p = new Promise();
    p.reject(reason);
    return p;
  };
  /**
   * Take a list of promises or values and once all promises are resolved,
   * create a new promise and resolve it with a list of final values.<br>
   * If one of the promises is rejected, it will reject the returned promise.
   * @static
   * @method
   * @param {[]} promises -- array of promises or resolve values
   * @returns {Promise}
   */


  Promise.all = function (promises) {
    if (!promises.length) {
      return Promise.resolve(null);
    }

    var p = new Promise(),
        len = promises.length,
        values = new Array(len),
        cnt = len,
        i,
        item,
        done = function (value, inx) {
      values[inx] = value;
      cnt--;

      if (cnt === 0) {
        p.resolve(values);
      }
    };

    for (i = 0; i < len; i++) {
      (function (inx) {
        item = promises[i];

        if (item instanceof Promise) {
          item.done(function (value) {
            done(value, inx);
          }).fail(p.reject, p);
        } else if (isThenable(item) || isFunction(item)) {
          new Promise(item).done(function (value) {
            done(value, inx);
          }).fail(p.reject, p);
        } else {
          done(item, inx);
        }
      })(i);
    }

    return p;
  };
  /**
   * Same as <code>all()</code> but it treats arguments as list of values.
   * @static
   * @method
   * @param {Promise|*} promise1
   * @param {Promise|*} promise2
   * @param {Promise|*} promiseN
   * @returns {Promise}
   */


  Promise.when = function () {
    return Promise.all(arguments);
  };
  /**
   * Same as <code>all()</code> but the resulting promise
   * will not be rejected if ones of the passed promises is rejected.
   * @static
   * @method
   * @param {[]} promises -- array of promises or resolve values
   * @returns {Promise}
   */


  Promise.allResolved = function (promises) {
    if (!promises.length) {
      return Promise.resolve(null);
    }

    var p = new Promise(),
        len = promises.length,
        values = [],
        cnt = len,
        i,
        item,
        settle = function (value) {
      values.push(value);
      proceed();
    },
        proceed = function () {
      cnt--;

      if (cnt === 0) {
        p.resolve(values);
      }
    };

    for (i = 0; i < len; i++) {
      item = promises[i];

      if (item instanceof Promise) {
        item.done(settle).fail(proceed);
      } else if (isThenable(item) || isFunction(item)) {
        new Promise(item).done(settle).fail(proceed);
      } else {
        settle(item);
      }
    }

    return p;
  };
  /**
   * Given the list of promises or values it will return a new promise
   * and resolve it with the first resolved value.
   * @static
   * @method
   * @param {[]} promises -- array of promises or resolve values
   * @returns {Promise}
   */


  Promise.race = function (promises) {
    if (!promises.length) {
      return Promise.resolve(null);
    }

    var p = new Promise(),
        len = promises.length,
        i,
        item;

    for (i = 0; i < len; i++) {
      item = promises[i];

      if (item instanceof Promise) {
        item.done(p.resolve, p).fail(p.reject, p);
      } else if (isThenable(item) || isFunction(item)) {
        new Promise(item).done(p.resolve, p).fail(p.reject, p);
      } else {
        p.resolve(item);
      }

      if (!p.isPending()) {
        break;
      }
    }

    return p;
  };
  /**
   * Takes a list of async functions and executes 
   * them in given order consequentially
   * @static
   * @method
   * @param {[]} functions -- array of promises or resolve values or functions
   * @returns {Promise}
   */


  Promise.waterfall = function (functions) {
    if (!functions.length) {
      return Promise.resolve(null);
    }

    var first = functions.shift(),
        promise = isFunction(first) ? Promise.fcall(first) : Promise.resolve(fn),
        fn;

    while (fn = functions.shift()) {
      if (isThenable(fn)) {
        promise = promise.then(function (fn) {
          return function () {
            return fn;
          };
        }(fn));
      } else if (isFunction(fn)) {
        promise = promise.then(fn);
      } else {
        promise.resolve(fn);
      }
    }

    return promise;
  };
  /**
   * Works like Array.forEach but it expects passed function to 
   * return a Promise.
   * @static
   * @method 
   * @param {array} items 
   * @param {function} fn {
   *  @param {*} value
   *  @param {int} index
   *  @returns {Promise|*}
   * }
   * @param {object} context 
   * @param {boolean} allResolved if true, the resulting promise
   * will fail if one of the returned promises fails.
   */


  Promise.forEach = function (items, fn, context, allResolved) {
    var left = items.slice(),
        p = new Promise(),
        values = [],
        i = 0;

    var next = function () {
      if (!left.length) {
        p.resolve(values);
        return;
      }

      var item = left.shift(),
          index = i;
      i++;
      Promise.fcall(fn, context, [item, index]).done(function (result) {
        values.push(result);
        next();
      }).fail(function (reason) {
        if (allResolved) {
          p.reject(reason);
        } else {
          values.push(null);
          next();
        }
      });
    };

    next();
    return p;
  };
  /**
   * Returns a promise with additional <code>countdown</code>
   * method. Call this method <code>cnt</code> times and
   * the promise will get resolved.
   * @static
   * @method
   * @param {int} cnt 
   * @returns {Promise}
   */


  Promise.counter = function (cnt) {
    var promise = new Promise();

    promise.countdown = function () {
      cnt--;

      if (cnt === 0) {
        promise.resolve();
      }
    };

    return promise;
  };

  return Promise;
}();

/***/ }),

/***/ "../metaphorjs-shared/src/MetaphorJs.js":
/*!**********************************************!*\
  !*** ../metaphorjs-shared/src/MetaphorJs.js ***!
  \**********************************************/
/***/ ((module) => {

const MetaphorJs = {
  plugin: {},
  mixin: {},
  lib: {},
  dom: {},
  regexp: {},
  browser: {},
  app: {},
  prebuilt: null
};
module.exports = MetaphorJs;

/***/ }),

/***/ "../metaphorjs-shared/src/func/_/_varType.js":
/*!***************************************************!*\
  !*** ../metaphorjs-shared/src/func/_/_varType.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const toString = __webpack_require__(/*! ../toString */ "../metaphorjs-shared/src/func/toString.js");

module.exports = function () {
  const types = {
    '[object String]': 0,
    '[object Number]': 1,
    '[object Boolean]': 2,
    '[object Object]': 3,
    '[object Function]': 4,
    '[object Array]': 5,
    '[object RegExp]': 9,
    '[object Date]': 10
  };
  /*
   * 'string': 0,
   * 'number': 1,
   * 'boolean': 2,
   * 'object': 3,
   * 'function': 4,
   * 'array': 5,
   * 'null': 6,
   * 'undefined': 7,
   * 'NaN': 8,
   * 'regexp': 9,
   * 'date': 10,
   * unknown: -1
   * @param {*} value
   * @returns {number}
   */

  return function _varType(val) {
    if (!val) {
      if (val === null) {
        return 6;
      }

      if (val === undefined) {
        return 7;
      }
    }

    let num = types[toString.call(val)];

    if (num === undefined) {
      return -1;
    }

    if (num === 1 && isNaN(val)) {
      return 8;
    }

    return num;
  };
}();

/***/ }),

/***/ "../metaphorjs-shared/src/func/async.js":
/*!**********************************************!*\
  !*** ../metaphorjs-shared/src/func/async.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Execute <code>fn</code> asynchronously
 * @function async
 * @param {Function} fn Function to execute
 * @param {Object} context Function's context (this)
 * @param {[]} args Arguments to pass to fn
 * @param {number} timeout Execute after timeout (number of ms)
 */
module.exports = function async(fn, context, args, timeout) {
  return setTimeout(() => fn.apply(context, args || []), timeout || 0);
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/bind.js":
/*!*********************************************!*\
  !*** ../metaphorjs-shared/src/func/bind.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Bind function to context (Function.bind wrapper)
 * @function bind
 * @param {function} fn
 * @param {*} context
 * @returns {function}
 */
module.exports = function bind(fn, context) {
  return fn.bind(context);
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/browser/joinLocation.js":
/*!*************************************************************!*\
  !*** ../metaphorjs-shared/src/func/browser/joinLocation.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! ../../MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.browser.joinLocation = function (location, opt) {
  var url = "";
  opt = opt || {};

  if (!opt.onlyPath) {
    url += location.protocol + "//";

    if (location.username && location.password) {
      url += location.username + ":" + location.password + "@";
    }

    url += location.hostname;

    if (location.hostname && location.port) {
      url += ":" + location.port;
    }
  }

  if (!opt.onlyHost) {
    url += location.pathname || "/";

    if (location.search && location.search != "?") {
      url += location.search;
    }

    if (location.hash && location.hash != "#") {
      url += location.hash;
    }
  }

  return url;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/browser/parseLocation.js":
/*!**************************************************************!*\
  !*** ../metaphorjs-shared/src/func/browser/parseLocation.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../var/regexp/location.js */ "../metaphorjs-shared/src/var/regexp/location.js");

const MetaphorJs = __webpack_require__(/*! ../../MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.browser.parseLocation = function (url) {
  var matches = url.match(MetaphorJs.regexp.location) || [],
      wl = (typeof window != "undefined" ? window.location : null) || {};
  return {
    protocol: matches[4] || wl.protocol || "http:",
    hostname: matches[11] || wl.hostname || "",
    host: (matches[11] || "") + (matches[12] ? ":" + matches[12] : "") || wl.host || "",
    username: matches[8] || wl.username || "",
    password: matches[9] || wl.password || "",
    port: parseInt(matches[12], 10) || wl.port || "",
    href: url,
    path: (matches[13] || "/") + (matches[16] || ""),
    pathname: matches[13] || "/",
    search: matches[16] || "",
    hash: matches[17] && matches[17] != "#" ? matches[17] : ""
  };
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/copy.js":
/*!*********************************************!*\
  !*** ../metaphorjs-shared/src/func/copy.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isArray = __webpack_require__(/*! ./isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      isRegExp = __webpack_require__(/*! ./isRegExp.js */ "../metaphorjs-shared/src/func/isRegExp.js"),
      isPlainObject = __webpack_require__(/*! ./isPlainObject.js */ "../metaphorjs-shared/src/func/isPlainObject.js"),
      isDate = __webpack_require__(/*! ./isDate.js */ "../metaphorjs-shared/src/func/isDate.js"),
      isFunction = __webpack_require__(/*! ./isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js");

module.exports = function copy(source, dest) {
  if (typeof window != "undefined" && source === window) {
    throw new Error("Cannot copy window object");
  } else if (typeof __webpack_require__.g != "undefined" && source === __webpack_require__.g) {
    throw new Error("Cannot copy global object");
  }

  if (!dest) {
    dest = source;

    if (source) {
      if (isArray(source)) {
        dest = copy(source, []);
      } else if (isDate(source)) {
        dest = new Date(source.getTime());
      } else if (isRegExp(source)) {
        dest = new RegExp(source.source);
      } else if (isPlainObject(source)) {
        dest = copy(source, {});
      }
    }
  } else {
    if (source === dest) {
      throw new Error("Objects are identical");
    }

    if (isArray(source)) {
      dest.length = 0;

      for (var i = 0, l = source.length; i < l; i++) {
        dest.push(copy(source[i]));
      }
    } else {
      var key;

      for (key in dest) {
        delete dest[key];
      }

      for (key in source) {
        if (source.hasOwnProperty(key)) {
          if (key.charAt(0) == '$' || isFunction(source[key])) {
            dest[key] = source[key];
          } else {
            dest[key] = copy(source[key]);
          }
        }
      }
    }
  }

  return dest;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/emptyFn.js":
/*!************************************************!*\
  !*** ../metaphorjs-shared/src/func/emptyFn.js ***!
  \************************************************/
/***/ ((module) => {

module.exports = function emptyFn() {};

/***/ }),

/***/ "../metaphorjs-shared/src/func/equals.js":
/*!***********************************************!*\
  !*** ../metaphorjs-shared/src/func/equals.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isArray = __webpack_require__(/*! ./isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      isDate = __webpack_require__(/*! ./isDate.js */ "../metaphorjs-shared/src/func/isDate.js"),
      isRegExp = __webpack_require__(/*! ./isRegExp.js */ "../metaphorjs-shared/src/func/isRegExp.js"),
      isWindow = __webpack_require__(/*! ./isWindow.js */ "../metaphorjs-shared/src/func/isWindow.js"),
      isFunction = __webpack_require__(/*! ./isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"); // from Angular

/**
 * Performs various checks comparing two arguments. 
 * Compared items can be of any type including
 * objects and arrays.
 * @function equals
 * @param {*} o1 
 * @param {*} o2 
 * @returns {boolean}
 */


module.exports = function equals(o1, o2) {
  if (o1 === o2) return true;
  if (o1 === null || o2 === null) return false;
  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN

  var t1 = typeof o1,
      t2 = typeof o2,
      length,
      key,
      keySet;

  if (t1 === t2) {
    if (t1 === 'object') {
      if (isArray(o1)) {
        if (!isArray(o2)) return false;

        if ((length = o1.length) === o2.length) {
          for (key = 0; key < length; key++) {
            if (!equals(o1[key], o2[key])) return false;
          }

          return true;
        }
      } else if (isDate(o1)) {
        return isDate(o2) && o1.getTime() === o2.getTime();
      } else if (isRegExp(o1) && isRegExp(o2)) {
        return o1.toString() === o2.toString();
      } else {
        if (isWindow(o1) || isWindow(o2) || isArray(o2)) return false;
        keySet = {};

        for (key in o1) {
          if (key.charAt(0) === '$' || isFunction(o1[key])) {
            //&& typeof o1[key] == "object") {
            continue;
          } //if (isFunction(o1[key])) {
          //    continue;
          //}


          if (!equals(o1[key], o2[key])) {
            return false;
          }

          keySet[key] = true;
        }

        for (key in o2) {
          if (!keySet.hasOwnProperty(key) && key.charAt(0) !== '$' && o2[key] !== undefined && !isFunction(o2[key])) return false;
        }

        return true;
      }
    }
  }

  return false;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/error.js":
/*!**********************************************!*\
  !*** ../metaphorjs-shared/src/func/error.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Log thrown error to console (in debug mode) and 
 * call all error listeners
 * @function error
 * @param {Error} e 
 */
module.exports = function () {
  var listeners = [];

  var error = function error(e) {
    var i, l;

    for (i = 0, l = listeners.length; i < l; i++) {
      listeners[i][0].call(listeners[i][1], e);
    }
    /*DEBUG-START*/


    if (typeof console != "undefined" && console.error) {
      console.error(e);
    }
    /*DEBUG-END*/

  };
  /**
   * Subscribe to all errors
   * @method on
   * @param {function} fn 
   * @param {object} context 
   */


  error.on = function (fn, context) {
    error.un(fn, context);
    listeners.push([fn, context]);
  };
  /**
   * Unsubscribe from all errors
   * @method un
   * @param {function} fn 
   * @param {object} context 
   */


  error.un = function (fn, context) {
    var i, l;

    for (i = 0, l = listeners.length; i < l; i++) {
      if (listeners[i][0] === fn && listeners[i][1] === context) {
        listeners.splice(i, 1);
        break;
      }
    }
  };

  return error;
}();

/***/ }),

/***/ "../metaphorjs-shared/src/func/extend.js":
/*!***********************************************!*\
  !*** ../metaphorjs-shared/src/func/extend.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const toArray = __webpack_require__(/*! ./toArray */ "../metaphorjs-shared/src/func/toArray.js");

const isPlainObject = __webpack_require__(/*! ./isPlainObject */ "../metaphorjs-shared/src/func/isPlainObject.js");

const isBool = __webpack_require__(/*! ./isBool */ "../metaphorjs-shared/src/func/isBool.js");
/**
 * Copy properties = require( one object to another
 * @function extend
 * @param {Object} dst
 * @param {Object} src
 * @param {Object} src2 ... srcN
 * @param {boolean} override {
 *  Override already existing keys 
 *  @default false
 * }
 * @param {boolean} deep {
 *  Do not copy objects by link, deep copy by value
 *  @default false
 * }
 * @returns {object}
 */


module.exports = function extend() {
  var override = false,
      deep = false,
      args = toArray(arguments),
      dst = args.shift(),
      src,
      k,
      value;

  if (isBool(args[args.length - 1])) {
    override = args.pop();
  }

  if (isBool(args[args.length - 1])) {
    deep = override;
    override = args.pop();
  }

  if (override && !deep && typeof Object !== "undefined" && !!Object.assign) {
    Object.assign.apply(Object, [dst].concat(args));
    return dst;
  }

  while (args.length) {
    // src can be empty
    src = args.shift();

    if (!src) {
      continue;
    }

    for (k in src) {
      if (src.hasOwnProperty(k) && (value = src[k]) !== undefined) {
        if (deep) {
          if (dst[k] && isPlainObject(dst[k]) && isPlainObject(value)) {
            extend(dst[k], value, override, deep);
          } else {
            if (override === true || dst[k] == undefined) {
              // == checks for null and undefined
              if (isPlainObject(value)) {
                dst[k] = {};
                extend(dst[k], value, override, true);
              } else {
                dst[k] = value;
              }
            }
          }
        } else {
          if (override === true || dst[k] == undefined) {
            dst[k] = value;
          }
        }
      }
    }
  }

  return dst;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/filterArray.js":
/*!****************************************************!*\
  !*** ../metaphorjs-shared/src/func/filterArray.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isBool = __webpack_require__(/*! ./isBool.js */ "../metaphorjs-shared/src/func/isBool.js"),
      isFunction = __webpack_require__(/*! ./isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isPrimitive = __webpack_require__(/*! ./isPrimitive.js */ "../metaphorjs-shared/src/func/isPrimitive.js"),
      isPlainObject = __webpack_require__(/*! ./isPlainObject.js */ "../metaphorjs-shared/src/func/isPlainObject.js");
/**
 * Filter array of various objects by object field
 * @function filterArray
 * @param {array} list Array to filter
 * @param {string|boolean|regexp} by 
 * @param {string|boolean|null} opt true | false | "strict"
 * @code src-docs/examples/filterArray.js
 */

/**
 * Filter array of various objects by object field
 * @function filterArray
 * @param {array} list Array to filter
 * @param {function} by {
 *  @param {*} value array[i]
 *  @returns {boolean}
 * }
 * @param {object} opt true | false | "strict"
 */

/**
 * Filter array of various objects by object field
 * @function filterArray
 * @param {array} list Array to filter
 * @param {object} by 
 * @param {object} opt true | false | "strict"
 */


module.exports = function () {
  var compareValues = function (value, to, opt) {
    if (isFunction(to)) {
      return to(value, opt);
    } else if (to === "" || to === undefined) {
      return true;
    } else if (value === undefined) {
      return false;
    } else if (isBool(value)) {
      return value === to;
    } else if (to instanceof RegExp) {
      return to.test("" + value);
    } else if (opt === "strict") {
      return "" + value === "" + to;
    } else if (opt === true || opt === null || opt === undefined) {
      return ("" + value).toLowerCase().indexOf(("" + to).toLowerCase()) != -1;
    } else if (opt === false) {
      return ("" + value).toLowerCase().indexOf(("" + to).toLowerCase()) == -1;
    }

    return false;
  },
      compare = function (value, by, opt) {
    if (isFunction(by)) {
      return by(value, opt);
    }

    if (isPrimitive(value)) {
      if (by.$ === undefined) {
        return true;
      } else {
        return compareValues(value, by.$, opt);
      }
    }

    var k, i;

    for (k in by) {
      if (k === '$') {
        for (i in value) {
          if (compareValues(value[i], by.$, opt)) {
            return true;
          }
        }
      } else {
        if (compareValues(value[k], by[k], opt)) {
          return true;
        }
      }
    }

    return false;
  };

  var filterArray = function filterArray(a, by, opt) {
    if (!isPlainObject(by) && !isFunction(by)) {
      by = {
        $: by
      };
    }

    var ret = [],
        i,
        l;

    for (i = -1, l = a.length; ++i < l;) {
      if (compare(a[i], by, opt)) {
        ret.push(a[i]);
      }
    }

    return ret;
  };

  filterArray.compare = compare;
  return filterArray;
}();

/***/ }),

/***/ "../metaphorjs-shared/src/func/getRegExp.js":
/*!**************************************************!*\
  !*** ../metaphorjs-shared/src/func/getRegExp.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/Cache.js */ "../metaphorjs-shared/src/lib/Cache.js");

const MetaphorJs = __webpack_require__(/*! ../MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get cached regular expression
 * @function getRegExp
 * @param {string} expr
 * @returns {RegExp}
 */


module.exports = function getRegExp(expr) {
  var g = MetaphorJs.lib.Cache.global(),
      k = "regex_" + expr;
  return g.get(k) || g.add(k, new RegExp(expr));
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/instantiate.js":
/*!****************************************************!*\
  !*** ../metaphorjs-shared/src/func/instantiate.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isObject = __webpack_require__(/*! ./isObject.js */ "../metaphorjs-shared/src/func/isObject.js");
/**
 * Instantite class when you have a list of arguments
 * and you can't just use .apply()
 * @function instantiate
 * @param {function} fn Class constructor
 * @param {array} args Constructor arguments
 * @returns {object}
 */


module.exports = function instantiate(fn, args) {
  var Temp = function () {},
      inst,
      ret;

  Temp.prototype = fn.prototype;
  inst = new Temp();
  ret = fn.apply(inst, args); // If an object has been returned then return it otherwise
  // return the original instance.
  // (consistent with behaviour of the new operator)

  return isObject(ret) || ret === false ? ret : inst;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/intercept.js":
/*!**************************************************!*\
  !*** ../metaphorjs-shared/src/func/intercept.js ***!
  \**************************************************/
/***/ ((module) => {

/**
 * Function interceptor
 * @function intercept
 * @param {function} origFn Original function
 * @param {function} interceptor Function that should execute instead(ish)
 * @param {object|null} context Function's context
 * @param {object|null} origContext Original function's context
 * @param {string} when {
 *  before | after | instead
 *  @default before
 * }
 * @param {bool} replaceValue true to return interceptor's return value
 * instead of original
 * @returns {Function}
 */
module.exports = function intercept(origFn, interceptor, context, origContext, when, replaceValue) {
  when = when || "before";
  return function () {
    var intrRes, origRes;

    if (when == "instead") {
      return interceptor.apply(context || origContext, arguments);
    } else if (when == "before") {
      intrRes = interceptor.apply(context || origContext, arguments);
      origRes = intrRes !== false ? origFn.apply(origContext || context, arguments) : null;
    } else {
      origRes = origFn.apply(origContext || context, arguments);
      intrRes = interceptor.apply(context || origContext, arguments);
    }

    return replaceValue ? intrRes : origRes;
  };
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/isArray.js":
/*!************************************************!*\
  !*** ../metaphorjs-shared/src/func/isArray.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const _varType = __webpack_require__(/*! ./_/_varType */ "../metaphorjs-shared/src/func/_/_varType.js");
/**
 * Check if given value is array (not just array-like)
 * @function isArray
 * @param {*} value
 * @returns {boolean}
 */


module.exports = function isArray(value) {
  return typeof value === "object" && _varType(value) === 5;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/isBool.js":
/*!***********************************************!*\
  !*** ../metaphorjs-shared/src/func/isBool.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Check if given value is a boolean value
 * @function isBool
 * @param {*} value 
 * @returns {boolean}
 */
module.exports = function isBool(value) {
  return value === true || value === false;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/isDate.js":
/*!***********************************************!*\
  !*** ../metaphorjs-shared/src/func/isDate.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const _varType = __webpack_require__(/*! ./_/_varType.js */ "../metaphorjs-shared/src/func/_/_varType.js");
/**
 * Check if given value is a Date object
 * @function isDate
 * @param {*} value
 * @returns {boolean} 
 */


module.exports = function isDate(value) {
  return _varType(value) === 10;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/isFunction.js":
/*!***************************************************!*\
  !*** ../metaphorjs-shared/src/func/isFunction.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * Check if given value is a function
 * @function isFunction
 * @param {*} value 
 * @returns {boolean}
 */
module.exports = function isFunction(value) {
  return typeof value == 'function';
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/isNull.js":
/*!***********************************************!*\
  !*** ../metaphorjs-shared/src/func/isNull.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Check if given value is a null value
 * @function isNull
 * @param {*} value 
 * @returns {boolean}
 */
module.exports = function isNull(value) {
  return value === null;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/isNumber.js":
/*!*************************************************!*\
  !*** ../metaphorjs-shared/src/func/isNumber.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const _varType = __webpack_require__(/*! ./_/_varType.js */ "../metaphorjs-shared/src/func/_/_varType.js");
/**
 * Check if given value is a number (not number-like)
 * @function isNumber
 * @param {*} value 
 * @returns {boolean}
 */


module.exports = function isNumber(value) {
  return _varType(value) === 1;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/isObject.js":
/*!*************************************************!*\
  !*** ../metaphorjs-shared/src/func/isObject.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const _varType = __webpack_require__(/*! ./_/_varType */ "../metaphorjs-shared/src/func/_/_varType.js");
/**
 * Check if given value is an object (non-scalar)
 * @function isObject
 * @param {*} value 
 * @returns {boolean}
 */


module.exports = function isObject(value) {
  if (value === null || typeof value != "object") {
    return false;
  }

  var vt = _varType(value);

  return vt > 2 || vt == -1;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/isPlainObject.js":
/*!******************************************************!*\
  !*** ../metaphorjs-shared/src/func/isPlainObject.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const _varType = __webpack_require__(/*! ./_/_varType */ "../metaphorjs-shared/src/func/_/_varType.js");
/**
 * Check if given value is plain object
 * @function isPlainObject
 * @param {*} value 
 * @returns {boolean}
 */


module.exports = function isPlainObject(value) {
  // IE < 9 returns [object Object] = require( toString(htmlElement)
  return typeof value == "object" && _varType(value) === 3 && !value.nodeType && value.constructor === Object;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/isPrimitive.js":
/*!****************************************************!*\
  !*** ../metaphorjs-shared/src/func/isPrimitive.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const _varType = __webpack_require__(/*! ./_/_varType.js */ "../metaphorjs-shared/src/func/_/_varType.js");
/**
 * Check if given value is a primitive (string, number, boolean)
 * @function isPrimitive
 * @param {*} value 
 * @returns {boolean}
 */


module.exports = function isPrimitive(value) {
  var vt = _varType(value);

  return vt < 3 && vt > -1;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/isRegExp.js":
/*!*************************************************!*\
  !*** ../metaphorjs-shared/src/func/isRegExp.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const _varType = __webpack_require__(/*! ./_/_varType.js */ "../metaphorjs-shared/src/func/_/_varType.js");
/**
 * Check if given value is regular expression
 * @function isRegExp
 * @param {*} value 
 * @returns {boolean}
 */


module.exports = function isRegExp(value) {
  return _varType(value) === 9;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/isString.js":
/*!*************************************************!*\
  !*** ../metaphorjs-shared/src/func/isString.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * Check if given value is a string
 * @function isString
 * @param {*} value 
 * @returns {boolean}
 */
module.exports = function isString(value) {
  return typeof value === "string" || value === "" + value;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/isThenable.js":
/*!***************************************************!*\
  !*** ../metaphorjs-shared/src/func/isThenable.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isFunction = __webpack_require__(/*! ./isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js");
/**
 * Checks if given value is a thenable (a Promise)
 * @function isThenable
 * @param {*} any
 * @returns {boolean|function}
 */


module.exports = function isThenable(any) {
  // any.then must only be accessed once
  // this is a promise/a+ requirement
  if (!any) {
    //  || !any.then
    return false;
  }

  var t; //if (!any || (!isObject(any) && !isFunction(any))) {

  if ((t = typeof any) != "object" && t != "function") {
    return false;
  }

  var then = any.then;
  return isFunction(then) ? then : false;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/isWindow.js":
/*!*************************************************!*\
  !*** ../metaphorjs-shared/src/func/isWindow.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * Check if given object is a window object
 * @function isWindow
 * @param {*} obj 
 * @returns {boolean}
 */
module.exports = function isWindow(obj) {
  if (typeof window === "undefined") {
    return false;
  }

  return obj === window || obj && obj.document && obj.location && obj.alert && obj.setInterval;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/levenshteinDiff.js":
/*!********************************************************!*\
  !*** ../metaphorjs-shared/src/func/levenshteinDiff.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const equals = __webpack_require__(/*! ./equals.js */ "../metaphorjs-shared/src/func/equals.js");
/**
 * @function levenshteinDiff {
 *  @param {array} from
 *  @param {array} to
 *  @returns {object} {
 *      @type {number} changes
 *      @type {int} distance
 *      @type {array} prescription {
 *          List of instructions D(delete),R(replace),I(insert)
 *      }
 *  }
 * }
 */


module.exports = function levenshteinDiff(from, to) {
  var m = from.length,
      n = to.length,
      D = new Array(m + 1),
      P = new Array(m + 1),
      i,
      j,
      c,
      route,
      cost,
      dist,
      ops = 0;

  if (m == n && m === 0) {
    return {
      changes: 0,
      distance: 0,
      prescription: []
    };
  }

  for (i = 0; i <= m; i++) {
    D[i] = new Array(n + 1);
    P[i] = new Array(n + 1);
    D[i][0] = i;
    P[i][0] = 'D';
  }

  for (i = 0; i <= n; i++) {
    D[0][i] = i;
    P[0][i] = 'I';
  }

  for (i = 1; i <= m; i++) {
    for (j = 1; j <= n; j++) {
      cost = !equals(from[i - 1], to[j - 1]) ? 1 : 0;

      if (D[i][j - 1] < D[i - 1][j] && D[i][j - 1] < D[i - 1][j - 1] + cost) {
        //Insert
        D[i][j] = D[i][j - 1] + 1;
        P[i][j] = 'I';
      } else if (D[i - 1][j] < D[i - 1][j - 1] + cost) {
        //Delete
        D[i][j] = D[i - 1][j] + 1;
        P[i][j] = 'D';
      } else {
        //Replace or noop
        D[i][j] = D[i - 1][j - 1] + cost;

        if (cost === 1) {
          P[i][j] = 'R';
        } else {
          P[i][j] = '-';
        }
      }
    }
  } //Prescription


  route = [];
  i = m;
  j = n;

  do {
    c = P[i][j];
    route.push(c);

    if (c !== '-') {
      ops++;
    }

    if (c === 'R' || c === '-') {
      i--;
      j--;
    } else if (c === 'D') {
      i--;
    } else {
      j--;
    }
  } while (i !== 0 || j !== 0);

  dist = D[m][n];
  return {
    changes: ops / route.length,
    distance: dist,
    prescription: route.reverse()
  };
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/levenshteinMove.js":
/*!********************************************************!*\
  !*** ../metaphorjs-shared/src/func/levenshteinMove.js ***!
  \********************************************************/
/***/ ((module) => {

/**
 * @function levenshteinMove {
 *  @param {array} a1
 *  @param {array} a2 
 *  @param {array} prescription Prescription from levenshteinDiff
 *  @param {function} getKey {
 *      Function that tracks unique items of array
 *      @param {*} item 
 *      @returns {string} item id
 *  }
 * }
 */
module.exports = function levenshteinMove(a1, a2, prs, getKey) {
  var newPrs = [],
      i,
      l,
      k,
      action,
      map1 = {},
      prsi,
      a2i,
      index;

  for (i = 0, l = a1.length; i < l; i++) {
    k = getKey(a1[i], i);

    if (k) {
      map1[k] = i;
    }
  }

  a2i = 0;
  var used = {};

  for (prsi = 0, l = prs.length; prsi < l; prsi++) {
    action = prs[prsi];

    if (action === 'D') {
      continue;
    }

    k = getKey(a2[a2i], a2i);

    if (k !== undefined && used[k] !== true && (index = map1[k]) !== undefined) {
      newPrs.push(index);
      used[k] = true;
    } else {
      newPrs.push(action);
    }

    a2i++;
  }

  return newPrs;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/nextUid.js":
/*!************************************************!*\
  !*** ../metaphorjs-shared/src/func/nextUid.js ***!
  \************************************************/
/***/ ((module) => {

const uid = ['0', '0', '0']; // from AngularJs

/**
 * Generates new alphanumeric id with starting 
 * length of 3 characters. IDs are consequential.
 * @function nextUid
 * @returns {string}
 */

function nextUid() {
  var index = uid.length;
  var digit;

  while (index) {
    index--;
    digit = uid[index].charCodeAt(0);

    if (digit == 57
    /*'9'*/
    ) {
      uid[index] = 'A';
      return uid.join('');
    }

    if (digit == 90
    /*'Z'*/
    ) {
      uid[index] = '0';
    } else {
      uid[index] = String.fromCharCode(digit + 1);
      return uid.join('');
    }
  }

  uid.unshift('0');
  return uid.join('');
}

;
module.exports = nextUid;

/***/ }),

/***/ "../metaphorjs-shared/src/func/returnFalse.js":
/*!****************************************************!*\
  !*** ../metaphorjs-shared/src/func/returnFalse.js ***!
  \****************************************************/
/***/ ((module) => {

/**
 * Function that returns false
 * @function returnFalse
 * @returns {boolean}
 */
module.exports = function returnFalse() {
  return false;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/returnTrue.js":
/*!***************************************************!*\
  !*** ../metaphorjs-shared/src/func/returnTrue.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * Function that returns true
 * @function returnTrue
 * @returns {boolean}
 */
module.exports = function returnTrue() {
  return true;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/sortArray.js":
/*!**************************************************!*\
  !*** ../metaphorjs-shared/src/func/sortArray.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isFunction = __webpack_require__(/*! ./isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isPlainObject = __webpack_require__(/*! ./isPlainObject.js */ "../metaphorjs-shared/src/func/isPlainObject.js");
/**
 * Sort array of various objects by some field
 * @function sortArray
 * @param {array} arr Array to sort
 * @param {function|string|object} by {
 *  Either a string: object field name to sort by<br>
 *  Or a function: takes array item and returns value by which to sort<br>
 *  Or an object:
 *  @type {function} fn {
 *      @param {*} itemA
 *      @param {*} itemB
 *      @returns {number} -1,0,1
 *  }
 *  @type {object|null} context fn's context
 * }
 * @param {string} dir 
 * @returns {array}
 */


module.exports = function sortArray(arr, by, dir) {
  if (!dir) {
    dir = "asc";
  }

  var ret = arr.slice(),
      fn,
      ctx;

  if (isPlainObject(by) && by.fn) {
    fn = by.fn;
    ctx = by.context;
  }

  ret.sort(function (a, b) {
    if (fn) {
      return fn.call(ctx, a, b);
    }

    var typeA = typeof a,
        typeB = typeof b,
        valueA = a,
        valueB = b;

    if (typeA != typeB) {
      return 0;
    }

    if (typeA === "object") {
      if (isFunction(by)) {
        valueA = by(a);
        valueB = by(b);
      } else {
        valueA = a[by];
        valueB = b[by];
      }
    }

    if (typeof valueA === "number") {
      return valueA - valueB;
    } else {
      valueA = ("" + valueA).toLowerCase();
      valueB = ("" + valueB).toLowerCase();
      if (valueA === valueB) return 0;
      return valueA > valueB ? 1 : -1;
    }
  });
  return dir == "desc" ? ret.reverse() : ret;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/split.js":
/*!**********************************************!*\
  !*** ../metaphorjs-shared/src/func/split.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Intellegently splits string into parts using a separator, 
 * leaving untouched parts where separator is inside quotes.
 * @param {string} str
 * @param {string} separator
 * @param {bool} allowEmpty
 * @returns {array}
 */
module.exports = function (str, separator, allowEmpty) {
  var l = str.length,
      sl = separator.length,
      i = 0,
      prev = 0,
      inQDbl = false,
      inQSng = false,
      parts = [],
      esc = "\\",
      char;

  if (!sl) {
    return [str];
  }

  for (; i < l; i++) {
    char = str.charAt(i);

    if (char == esc) {
      i++;
      continue;
    }

    if (char == '"') {
      inQDbl = !inQDbl;
      continue;
    }

    if (char == "'") {
      inQSng = !inQSng;
      continue;
    }

    if (!inQDbl && !inQSng) {
      if (sl == 1 && char == separator || sl > 1 && str.substring(i, i + sl) == separator) {
        if (str.substr(i - 1, sl) == separator || str.substr(i + 1, sl) == separator) {
          if (!allowEmpty) {
            i += sl - 1;
            continue;
          }
        }

        parts.push(str.substring(prev, i).replace(esc + separator, separator));
        prev = i + sl;
        i += sl - 1;
      }
    }
  }

  parts.push(str.substring(prev).replace(esc + separator, separator));
  return parts;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/toArray.js":
/*!************************************************!*\
  !*** ../metaphorjs-shared/src/func/toArray.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * Transform anything into array
 * @function toArray
 * @param {*} list
 * @returns {array}
 */
module.exports = function toArray(list) {
  if (list && !list.length != undefined && list !== "" + list) {
    for (var a = [], i = -1, l = list.length >>> 0; ++i !== l; a[i] = list[i]) {}

    return a;
  } else if (list) {
    return [list];
  } else {
    return [];
  }
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/toBool.js":
/*!***********************************************!*\
  !*** ../metaphorjs-shared/src/func/toBool.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Converts given value to boolean. <br>
 * false: "", 0, false, undefined, null, "false", "no", "0"<br>
 * true: everything else
 * @function toBool
 * @param {*} val 
 * @returns {boolean}
 */
module.exports = function toBool(val) {
  if (!val) {
    // real false, empty string, null, zero
    return false;
  }

  if (typeof val === "string") {
    val = val.toLowerCase();

    if (val === "false" || val === "no" || val === '0') {
      return false;
    }
  }

  return true;
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/toCamelCase.js":
/*!****************************************************!*\
  !*** ../metaphorjs-shared/src/func/toCamelCase.js ***!
  \****************************************************/
/***/ ((module) => {

/**
 * Convert dashes to camel case
 * @function toCamelCase
 * @param {string} str 
 * @returns {string}
 */
module.exports = function toCamelCase(str) {
  return str.replace(/-./g, function (match) {
    return match.charAt(1).toUpperCase();
  });
};

/***/ }),

/***/ "../metaphorjs-shared/src/func/toString.js":
/*!*************************************************!*\
  !*** ../metaphorjs-shared/src/func/toString.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * Convert anything to string
 * @function toString
 * @param {*} value
 * @returns {string}
 */
module.exports = Object.prototype.toString;

/***/ }),

/***/ "../metaphorjs-shared/src/func/ucfirst.js":
/*!************************************************!*\
  !*** ../metaphorjs-shared/src/func/ucfirst.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * Change first character to upper case
 * @function ucfirst
 * @param {string} str 
 * @returns {string}
 */
module.exports = function ucfirst(str) {
  return str.substr(0, 1).toUpperCase() + str.substr(1);
};

/***/ }),

/***/ "../metaphorjs-shared/src/lib/Cache.js":
/*!*********************************************!*\
  !*** ../metaphorjs-shared/src/lib/Cache.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! ../MetaphorJs */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.lib.Cache = function () {
  let globalCache;
  /**
   * @class MetaphorJs.lib.Cache
   */

  /**
   * @method
   * @constructor
   * @param {bool} cacheRewritable
   */

  var Cache = function (cacheRewritable) {
    var storage = {},
        finders = [];

    if (arguments.length == 0) {
      cacheRewritable = true;
    }

    return {
      /**
       * Add finder function. If cache doesn't have an entry
       * with given name, it calls finder functions with this
       * name as a parameter. If one of the functions
       * returns anything else except undefined, it will
       * store this value and return every time given name
       * is requested.
       * @param {function} fn {
       *  @param {string} name
       *  @param {Cache} cache
       *  @returns {* | undefined}
       * }
       * @param {object} context
       * @param {bool} prepend Put in front of other finders
       */
      addFinder: function (fn, context, prepend) {
        finders[prepend ? "unshift" : "push"]({
          fn: fn,
          context: context
        });
      },

      /**
       * Add cache entry
       * @method
       * @param {string} name
       * @param {*} value
       * @param {bool} rewritable
       * @returns {*} value
       */
      add: function (name, value, rewritable) {
        if (storage[name] && storage[name].rewritable === false) {
          return storage[name];
        }

        storage[name] = {
          rewritable: typeof rewritable != "undefined" ? rewritable : cacheRewritable,
          value: value
        };
        return value;
      },

      /**
       * Get cache entry
       * @method
       * @param {string} name
       * @param {*} defaultValue {
       *  If value is not found, put this default value it its place
       * }
       * @returns {* | undefined}
       */
      get: function (name, defaultValue) {
        if (!storage[name]) {
          if (finders.length) {
            var i,
                l,
                res,
                self = this;

            for (i = 0, l = finders.length; i < l; i++) {
              res = finders[i].fn.call(finders[i].context, name, self);

              if (res !== undefined) {
                return self.add(name, res, true);
              }
            }
          }

          if (defaultValue !== undefined) {
            return this.add(name, defaultValue);
          }

          return undefined;
        }

        return storage[name].value;
      },

      /**
       * Remove cache entry
       * @method
       * @param {string} name
       * @returns {*}
       */
      remove: function (name) {
        var rec = storage[name];

        if (rec && rec.rewritable === true) {
          delete storage[name];
        }

        return rec ? rec.value : undefined;
      },

      /**
       * Check if cache entry exists
       * @method
       * @param {string} name
       * @returns {boolean}
       */
      exists: function (name) {
        return !!storage[name];
      },

      /**
       * Walk cache entries
       * @method
       * @param {function} fn {
       *  @param {*} value
       *  @param {string} key
       * }
       * @param {object} context
       */
      eachEntry: function (fn, context) {
        var k;

        for (k in storage) {
          fn.call(context, storage[k].value, k);
        }
      },

      /**
       * Clear cache
       * @method
       */
      clear: function () {
        storage = {};
      },

      /**
       * Clear and destroy cache
       * @method
       */
      $destroy: function () {
        var self = this;

        if (self === globalCache) {
          globalCache = null;
        }

        storage = null;
        cacheRewritable = null;
        self.add = null;
        self.get = null;
        self.destroy = null;
        self.exists = null;
        self.remove = null;
      }
    };
  };
  /**
   * Get global cache
   * @method
   * @static
   * @returns {Cache}
   */


  Cache.global = function () {
    if (!globalCache) {
      globalCache = new Cache(true);
    }

    return globalCache;
  };

  return Cache;
}();

/***/ }),

/***/ "../metaphorjs-shared/src/lib/Color.js":
/*!*********************************************!*\
  !*** ../metaphorjs-shared/src/lib/Color.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const MetaphorJs = __webpack_require__(/*! ../MetaphorJs */ "../metaphorjs-shared/src/MetaphorJs.js");

const extend = __webpack_require__(/*! ../func/extend */ "../metaphorjs-shared/src/func/extend.js");

const isArray = __webpack_require__(/*! ../func/isArray */ "../metaphorjs-shared/src/func/isArray.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MetaphorJs.lib.Color = function () {
  var processSet = function (args, prev) {
    var val = [];

    if (args.length > 1 || typeof args[0] === "number" || typeof args[0] === "string") {
      var a1 = args[0],
          a2 = args[1],
          a3 = args[2],
          a4 = args[3];
      val = prev.slice();
      a1 !== undefined && a1 !== null && (val[0] = a1);
      a2 !== undefined && a2 !== null && (val[1] = a2);
      a3 !== undefined && a3 !== null && (val[2] = a3);
      a4 !== undefined && a4 !== null && (val[3] = a4);
    } else {
      val = args[0];
    }

    val[0] = parseFloat(val[0] || 0);
    val[1] = parseFloat(val[1] || 0);
    val[2] = parseFloat(val[2] || 0);
    val[3] = val[3] === 0 ? 0 : parseFloat(val[3] || 1);
    return val;
  },
      set = function (inModel, outModel, args, prev) {
    var val = processSet(args, prev);
    return convert(inModel, outModel, val);
  },
      convert = function (from, to, val, doRound) {
    var conv = from + "2" + to;

    if (from !== to) {
      if (conversion[conv]) {
        val = conversion[conv](val);
      } else if (conversion[from + "2rgba"] && conversion["rgba2" + to]) {
        val = conversion["rgba2" + to](conversion[from + "2rgba"](val));
      } else {
        throw new Error("Cannot convert " + from + " to " + to);
      }
    }

    if (doRound) {
      val = round(val);
    }

    return val;
  },
      round = function (input) {
    var val = input.slice();
    val[0] = Math.round(val[0] || 0);
    val[1] = Math.round(val[1] || 0);
    val[2] = Math.round(val[2] || 0);
    return val;
  },
      hex2full = function (short) {
    var r = short.substring(0, 1).toLowerCase(),
        g = short.substring(1, 2).toLowerCase(),
        b = short.substring(2, 3).toLowerCase();
    return r + r + g + g + b + b;
  },
      conversion = {
    rgba2hex: function (rgba) {
      var r = Math.round(rgba[0]).toString(16),
          g = Math.round(rgba[1]).toString(16),
          b = Math.round(rgba[2]).toString(16);
      r.length === 1 && (r = "0" + r);
      g.length === 1 && (g = "0" + g);
      b.length === 1 && (b = "0" + b);
      return r + g + b;
    },
    hex2rgba: function (hex) {
      var a = 1;

      if (hex.length > 6) {
        a = parseInt(hex.substring(6, 8), 16);
        a = a / 255;
      }

      return [parseInt(hex.substring(0, 2), 16), parseInt(hex.substring(2, 4), 16), parseInt(hex.substring(4, 6), 16), a];
    },
    rgba2hsla: function (rgba) {
      var r = rgba[0] / 255;
      var g = rgba[1] / 255;
      var b = rgba[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;

      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      var l = (min + max) / 2;

      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }

      return [h, s * 100, l * 100, rgba.length > 3 ? rgba[3] : 1];
    },
    hsla2rgba: function (hsla) {
      var h = hsla[0] / 360;
      var s = (hsla[1] || 100) / 100;
      var l = (hsla[2] || 100) / 100;
      var a = hsla.length > 3 ? hsla[3] : 1;
      var t2;
      var t3;
      var val;

      if (s === 0) {
        val = l * 255;
        return [val, val, val, a];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      var t1 = 2 * l - t2;
      var rgba = [0, 0, 0, a];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);

        if (t3 < 0) {
          t3++;
        }

        if (t3 > 1) {
          t3--;
        }

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgba[i] = val * 255;
      }

      return rgba;
    },
    hsva2rgba: function (hsva) {
      var h = hsva[0] / 60,
          s = hsva[1] / 100,
          v = hsva[2] / 100,
          a = hsva.length > 3 ? hsva[3] : 1,
          hi = Math.floor(h) % 6,
          f = h - Math.floor(h),
          p = 255 * v * (1 - s),
          q = 255 * v * (1 - s * f),
          t = 255 * v * (1 - s * (1 - f));
      v *= 255;

      switch (hi) {
        case 0:
          return [v, t, p, a];

        case 1:
          return [q, v, p, a];

        case 2:
          return [p, v, t, a];

        case 3:
          return [p, q, v, a];

        case 4:
          return [t, p, v, a];

        case 5:
          return [v, p, q, a];
      }
    },
    rgba2hsva: function (rgba) {
      var rdif,
          gdif,
          bdif,
          h,
          s,
          r = rgba[0] / 255,
          g = rgba[1] / 255,
          b = rgba[2] / 255,
          a = rgba.length > 3 ? rgba[3] : 1,
          v = Math.max(r, g, b),
          diff = v - Math.min(r, g, b);

      var diffc = function (c) {
        return (v - c) / 6 / diff + 1 / 2;
      };

      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);

        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }

        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }

      return [h * 360, s * 100, v * 100, a];
    },
    rgba2str: function (rgba) {
      return color2str("rgba", rgba);
    },
    hsla2str: function (hsla) {
      return color2str("hsla", hsla);
    },
    hsva2str: function (hsva) {
      return color2str("hsva", hsva);
    },
    str2rgba: function (str) {
      return parseString(str);
    },
    str2hsla: function (str) {
      return parseString(str);
    },
    str2hsva: function (str) {
      return parseString(str);
    }
  },
      color2str = function (model, color) {
    var vals = round(color.slice()),
        a = vals[3];

    if (a > 0 && a < 1) {
      vals[3] = a.toFixed(2);
    }

    return model + "(" + vals.join(',') + ")";
  },
      parseString = function (str) {
    var match = str.match(/[\d, \.]+/);

    if (match) {
      var parts = match[0].split(",");
      parts[0] && (parts[0] = parseInt(parts[0]));
      parts[1] && (parts[1] = parseInt(parts[1]));
      parts[2] && (parts[2] = parseInt(parts[2]));
      parts[3] && (parts[3] = parseFloat(parts[3]));
      return parts;
    }

    return [0, 0, 0, 1];
  };
  /**
   * @class MetaphorJs.lib.Color
   * @constructor
   * @param {string|MetaphorJs.lib.Color|array|null} color 
   * @param {string} model rgba|hsva
   */


  var Color = function (color, model) {
    if (!model && color instanceof MetaphorJs.lib.Color) {
      model = color.model;
    }

    this.model = model || "rgba";
    this.color = [0, 0, 0, 1];

    if (color) {
      this.setColor(color);
    }
  };

  extend(Color.prototype, {
    model: null,
    color: null,

    /**
     * Create object copy
     * @returns {MetaphorJs.lib.Color}
     */
    copy: function () {
      return new Color(this);
    },

    /**
     * @method
     * @param {string|MetaphorJs.lib.Color|array} color {
     *  hex code, color object or rgba array
     * }
     */
    setColor: function (color) {
      if (!color) {
        return;
      }

      var t = typeof color;

      if (t === 'string') {
        if (color.substring(0, 1) === "#") {
          color = color.substring(1);
        }

        color = color.toLowerCase();

        if (color.length === 3) {
          this.setHEX(hex2full(color));
        } else if (color.indexOf("rgba") !== -1) {
          this.setRGBA(parseString(color));
        } else if (color.indexOf("hsl") !== -1) {
          this.setHSLA(parseString(color));
        } else if (color.indexOf("hsv") !== -1) {
          this.setHSVA(parseString(color));
        } else if (color.length > 5) {
          this.setHEX(color);
        }
      } else if (color instanceof MetaphorJs.lib.Color) {
        if (this.model === "rgba") {
          this.setRGBA(color.getRGBA());
        } else if (this.model === "hsva") {
          this.setHSVA(color.getHSVA());
        }
      } else if (isArray(color)) {
        if (this.model === "rgba") {
          this.setRGBA(color);
        } else if (this.model === "hsva") {
          this.setHSVA(color);
        }
      }
    },

    /**
     * @method
     * @param {string} hex 
     */
    setHEX: function (hex) {
      var a = this.color[3];
      this.color = convert("hex", this.model, hex);

      if (hex.length < 7) {
        this.color[3] = a;
      }
    },

    /**
     * Set hsla
     * @method setHSLA
     * @param {int} h
     * @param {int} s
     * @param {int} l
     * @param {float} a
     */

    /**
     * Set hsla
     * @method setHSLA
     * @param {array} hsla 
     */
    setHSLA: function () {
      this.color = set("hsla", this.model, arguments, this.getHSLA());
    },

    /**
     * Set hsva
     * @method setHSVA
     * @param {int} h
     * @param {int} s
     * @param {int} v
     * @param {float} a
     */

    /**
     * Set hsla
     * @method setHSVA
     * @param {array} hsva 
     */
    setHSVA: function () {
      this.color = set("hsva", this.model, arguments, this.getHSVA());
    },

    /**
     * Set rgba
     * @method setRGBA
     * @param {int} r
     * @param {int} g
     * @param {int} b
     * @param {float} a
     */

    /**
     * Set hsla
     * @method setRGBA
     * @param {array} rgba 
     */
    setRGBA: function () {
      this.color = set("rgba", this.model, arguments, this.getRGBA());
    },

    /**
     * Set alpha channel
     * @param {float} a 
     */
    setAlpha: function (a) {
      a = parseFloat(a);
      a < 0 && (a = 0);
      a > 1 && (a = 1);
      this.color[3] = a;
    },

    /**
     * Get color in given format
     * @param {string} format hex|rgba|hsla|hsva|rgbastr|hslastr|hsvastr
     * @param {boolean} floats 
     */
    getAs: function (format, floats) {
      switch (format) {
        case "hex":
          return this.getHEX();

        case "rgba":
          return this.getRGBA(floats);

        case "hsla":
          return this.getHSLA(floats);

        case "hsva":
          return this.getHSVA(floats);

        case "rgbastr":
          return this.getRGBAString();

        case "hslastr":
          return this.getHSLAString();

        case "hsvastr":
          return this.getHSVAString();

        default:
          return this.getHEX();
      }
    },

    /**
     * @method
     * @returns {float}
     */
    getAlpha: function () {
      return this.color[3];
    },

    /**
     * @method
     * @param {boolean} floats true to not round values to ints
     * @returns {int}
     */
    getR: function (floats) {
      return this.getRGBA(floats)[0];
    },

    /**
     * @method
     * @param {boolean} floats true to not round values to ints
     * @returns {int}
     */
    getG: function (floats) {
      return this.getRGBA(floats)[1];
    },

    /**
     * @method
     * @param {boolean} floats true to not round values to ints
     * @returns {int}
     */
    getB: function (floats) {
      return this.getRGBA(floats)[2];
    },

    /**
     * @method
     * @param {boolean} floats true to not round values to ints
     * @returns {int}
     */
    getH: function (floats) {
      return this.getHSVA(floats)[0];
    },

    /**
     * @method
     * @param {boolean} floats true to not round values to ints
     * @returns {int}
     */
    getS: function (floats) {
      return this.getHSVA(floats)[1];
    },

    /**
     * @method
     * @param {boolean} floats true to not round values to ints
     * @returns {int}
     */
    getV: function (floats) {
      return this.getHSVA(floats)[2];
    },

    /**
     * @method
     * @param {boolean} floats true to not round values to ints
     * @returns {array}
     */
    getHSLA: function (floats) {
      return convert(this.model, "hsla", this.color, !floats);
    },

    /**
     * @method
     * @param {boolean} floats true to not round values to ints
     * @returns {array}
     */
    getRGBA: function (floats) {
      return convert(this.model, "rgba", this.color, !floats);
    },

    /**
     * @method
     * @param {boolean} floats true to not round values to ints
     * @returns {array}
     */
    getHSVA: function (floats) {
      return convert(this.model, "hsva", this.color, !floats);
    },

    /**
     * @method
     * @returns {string}
     */
    getHEX: function () {
      return convert(this.model, "hex", round(this.color));
    },

    /**
     * @method
     * @returns {string}
     */
    getRGBAString: function () {
      return convert("rgba", "str", convert(this.model, "rgba", this.color));
    },

    /**
     * @method
     * @returns {string}
     */
    getHSLAString: function () {
      return convert("hsla", "str", convert(this.model, "hsla", this.color));
    },

    /**
     * @method
     * @returns {string}
     */
    getHSVAString: function () {
      return convert("hsva", "str", convert(this.model, "hsva", this.color));
    },
    toString: function (format) {
      return format ? this.getAs(format) : this.getHEX();
    }
  });
  return Color;
}());

/***/ }),

/***/ "../metaphorjs-shared/src/lib/LocalText.js":
/*!*************************************************!*\
  !*** ../metaphorjs-shared/src/lib/LocalText.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isPlainObject = __webpack_require__(/*! ../func/isPlainObject.js */ "../metaphorjs-shared/src/func/isPlainObject.js"),
      isArray = __webpack_require__(/*! ../func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      extend = __webpack_require__(/*! ../func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      MetaphorJs = __webpack_require__(/*! ../MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * A storage of plural definitions
 * @class MetaphorJs.lib.LocalText
 */


module.exports = MetaphorJs.lib.LocalText = function () {
  var pluralDef = function ($number, $locale) {
    if ($locale === "pt_BR") {
      // temporary set a locale for brasilian
      $locale = "xbr";
    }

    if ($locale.length > 3) {
      $locale = $locale.substr(0, -$locale.lastIndexOf('_'));
    }

    switch ($locale) {
      case 'bo':
      case 'dz':
      case 'id':
      case 'ja':
      case 'jv':
      case 'ka':
      case 'km':
      case 'kn':
      case 'ko':
      case 'ms':
      case 'th':
      case 'tr':
      case 'vi':
      case 'zh':
        return 0;

      case 'af':
      case 'az':
      case 'bn':
      case 'bg':
      case 'ca':
      case 'da':
      case 'de':
      case 'el':
      case 'en':
      case 'eo':
      case 'es':
      case 'et':
      case 'eu':
      case 'fa':
      case 'fi':
      case 'fo':
      case 'fur':
      case 'fy':
      case 'gl':
      case 'gu':
      case 'ha':
      case 'he':
      case 'hu':
      case 'is':
      case 'it':
      case 'ku':
      case 'lb':
      case 'ml':
      case 'mn':
      case 'mr':
      case 'nah':
      case 'nb':
      case 'ne':
      case 'nl':
      case 'nn':
      case 'no':
      case 'om':
      case 'or':
      case 'pa':
      case 'pap':
      case 'ps':
      case 'pt':
      case 'so':
      case 'sq':
      case 'sv':
      case 'sw':
      case 'ta':
      case 'te':
      case 'tk':
      case 'ur':
      case 'zu':
        return $number === 1 ? 0 : 1;

      case 'am':
      case 'bh':
      case 'fil':
      case 'fr':
      case 'gun':
      case 'hi':
      case 'ln':
      case 'mg':
      case 'nso':
      case 'xbr':
      case 'ti':
      case 'wa':
        return $number === 0 || $number === 1 ? 0 : 1;

      case 'be':
      case 'bs':
      case 'hr':
      case 'ru':
      case 'sr':
      case 'uk':
        return $number % 10 === 1 && $number % 100 !== 11 ? 0 : $number % 10 >= 2 && $number % 10 <= 4 && ($number % 100 < 10 || $number % 100 >= 20) ? 1 : 2;

      case 'cs':
      case 'sk':
        return $number === 1 ? 0 : $number >= 2 && $number <= 4 ? 1 : 2;

      case 'ga':
        return $number === 1 ? 0 : $number === 2 ? 1 : 2;

      case 'lt':
        return $number % 10 === 1 && $number % 100 !== 11 ? 0 : $number % 10 >= 2 && ($number % 100 < 10 || $number % 100 >= 20) ? 1 : 2;

      case 'sl':
        return $number % 100 === 1 ? 0 : $number % 100 === 2 ? 1 : $number % 100 === 3 || $number % 100 === 4 ? 2 : 3;

      case 'mk':
        return $number % 10 === 1 ? 0 : 1;

      case 'mt':
        return $number === 1 ? 0 : $number === 0 || $number % 100 > 1 && $number % 100 < 11 ? 1 : $number % 100 > 10 && $number % 100 < 20 ? 2 : 3;

      case 'lv':
        return $number === 0 ? 0 : $number % 10 === 1 && $number % 100 !== 11 ? 1 : 2;

      case 'pl':
        return $number === 1 ? 0 : $number % 10 >= 2 && $number % 10 <= 4 && ($number % 100 < 12 || $number % 100 > 14) ? 1 : 2;

      case 'cy':
        return $number === 1 ? 0 : $number === 2 ? 1 : $number === 8 || $number === 11 ? 2 : 3;

      case 'ro':
        return $number === 1 ? 0 : $number === 0 || $number % 100 > 0 && $number % 100 < 20 ? 1 : 2;

      case 'ar':
        return $number === 0 ? 0 : $number === 1 ? 1 : $number === 2 ? 2 : $number >= 3 && $number <= 10 ? 3 : $number >= 11 && $number <= 99 ? 4 : 5;

      default:
        return 0;
    }
  };
  /**
   * @method LocalText
   * @constructor
   * @param {string} locale 2char locale id
   */


  var LocalText = function (locale) {
    var self = this;
    self.store = {};

    if (locale) {
      self.locale = locale;
    }
  };

  extend(LocalText.prototype, {
    store: null,
    locale: "en",

    /**
     * @method
     * @param {string} locale 2char locale id
     */
    setLocale: function (locale) {
      this.locale = locale;
    },

    /**
     * Set plural definition
     * @method
     * @param {string} key
     * @param {array|object} value {
     *  Array:<br>
     *  0: Singular form<br>
     *  1: LocalText form<br>
     *  2: Second plural form<br>
     *  3: Third plural form<br>
     *  Object:<br>
     *  <int>: Respective number<br>
     *  "one": Singular form for 1<br>
     *  "negative": Negative values form<br>
     *  "other": All other
     * }
     */
    set: function (key, value) {
      var store = this.store;

      if (store[key] === undefined) {
        store[key] = value;
      }
    },

    /**
     * Load plural definitions
     * @method
     * @param {object} keys {
     *  key: definition pairs; see set()
     * }
     */
    load: function (keys) {
      extend(this.store, keys, false, false);
    },

    /**
     * Get definition. If key is not found, will return -- key --
     * @method
     * @param {string} key
     * @returns {array|object|string}
     */
    get: function (key) {
      var self = this;
      return self.store[key] || (self === globalText ? '-- ' + key + ' --' : globalText.get(key));
    },

    /**
     * Get variant best suited for the number
     * @method
     * @param {string} key
     * @param {int} number
     * @returns {string}
     */
    plural: function (key, number) {
      var self = this,
          strings = typeof key === "string" ? self.get(key) : key,
          def = pluralDef(number, self.locale);

      if (!isArray(strings)) {
        if (isPlainObject(strings)) {
          if (strings[number]) {
            return strings[number];
          }

          if (number === 1 && strings.one !== undefined) {
            return strings.one;
          } else if (number < 0 && strings.negative !== undefined) {
            return strings.negative;
          } else {
            return strings.other;
          }
        }

        return strings;
      } else {
        return strings[def];
      }
    },

    /**
     * Destroy definitions store
     * @method
     */
    $destroy: function () {
      this.store = null;
    }
  }, true, false);
  var globalText = new LocalText();

  LocalText.global = function () {
    return globalText;
  };

  return LocalText;
}();

/***/ }),

/***/ "../metaphorjs-shared/src/lib/Provider.js":
/*!************************************************!*\
  !*** ../metaphorjs-shared/src/lib/Provider.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

const extend = __webpack_require__(/*! ../func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      isThenable = __webpack_require__(/*! ../func/isThenable.js */ "../metaphorjs-shared/src/func/isThenable.js"),
      isFunction = __webpack_require__(/*! ../func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isString = __webpack_require__(/*! ../func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      isBool = __webpack_require__(/*! ../func/isBool.js */ "../metaphorjs-shared/src/func/isBool.js"),
      instantiate = __webpack_require__(/*! ../func/instantiate.js */ "../metaphorjs-shared/src/func/instantiate.js"),
      MetaphorJs = __webpack_require__(/*! ../MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.lib.Provider = function () {
  const VALUE = 1,
        CONSTANT = 2,
        FACTORY = 3,
        SERVICE = 4,
        PROVIDER = 5;
  let globalProvider;

  const Provider = function () {
    this.store = {};
  };

  extend(Provider.prototype, {
    store: null,
    instantiate: function (fn, context, args, isClass) {
      if (fn.$instantiate) {
        return fn.$instantiate.apply(fn, args);
      } else if (isClass) {
        return instantiate(fn, args);
      } else {
        return fn.apply(context, args);
      }
    },
    inject: function (injectable, context, currentValues, callArgs, isClass) {
      currentValues = currentValues || {};
      callArgs = callArgs || [];
      var self = this;

      if (isFunction(injectable)) {
        if (injectable.inject) {
          var tmp = injectable.inject.slice();
          tmp.push(injectable);
          injectable = tmp;
        } else {
          return self.instantiate(injectable, context, callArgs, isClass);
        }
      } else if (isString(injectable)) {
        return self.resolve(injectable, currentValues);
      } else {
        injectable = injectable.slice();
      }

      var values = [],
          fn = injectable.pop(),
          i,
          l;

      for (i = -1, l = injectable.length; ++i < l; values.push(self.resolve(injectable[i], currentValues))) {}

      return MetaphorJs.lib.Promise.all(values).then(function (values) {
        return self.instantiate(fn, context, values, isClass);
      });
    },
    value: function (name, value) {
      this.store[name] = {
        type: VALUE,
        value: value
      };
    },
    constant: function (name, value) {
      var store = this.store;

      if (!store[name]) {
        store[name] = {
          type: CONSTANT,
          value: value
        };
      }
    },
    factory: function (name, fn, context, singleton) {
      if (isBool(context)) {
        singleton = context;
        context = null;
      }

      this.store[name] = {
        type: FACTORY,
        singleton: singleton,
        fn: fn,
        context: context
      };
    },
    service: function (name, constr, singleton) {
      this.store[name] = {
        type: SERVICE,
        singleton: singleton,
        fn: constr
      };
    },
    provider: function (name, constr) {
      this.store[name + "Provider"] = {
        name: name,
        type: PROVIDER,
        fn: constr,
        instance: null
      };
    },
    isResolved: function (name) {
      var item = this.store[name];
      return item && (item.type === VALUE || item.type === CONSTANT);
    },
    resolve: function (name, currentValues, callArgs) {
      var self = this,
          store = self.store,
          type,
          item,
          res;
      currentValues = currentValues || {};
      callArgs = callArgs || [];

      if (currentValues[name] !== undefined) {
        return currentValues[name];
      }

      if (item = store[name]) {
        type = item.type;

        if (type === VALUE || type === CONSTANT) {
          return item.value;
        } else if (type === FACTORY) {
          res = self.inject(item.fn, item.context, currentValues, callArgs);
        } else if (type === SERVICE) {
          res = self.inject(item.fn, null, currentValues, callArgs, true);
        } else if (type === PROVIDER) {
          if (!item.instance) {
            item.instance = MetaphorJs.lib.Promise.resolve(self.inject(item.fn, null, currentValues)).done(function (instance) {
              item.instance = instance;
              store[item.name] = {
                type: FACTORY,
                fn: instance.$get,
                context: instance
              };
            });
          }

          return item.instance;
        }

        if (item.singleton) {
          item.type = VALUE;
          item.value = res;

          if (type === FACTORY && isThenable(res)) {
            res[res.done ? "done" : "then"](function (value) {
              item.value = value;
            });
          }
        }

        return currentValues[name] = res;
      } else {
        if (store[name + "Provider"]) {
          self.resolve(name + "Provider", currentValues);
          return self.resolve(name, currentValues);
        }

        if (self === globalProvider) {
          throw new Error("Could not provide value for " + name);
        } else {
          return globalProvider.resolve(name);
        }
      }
    },
    $destroy: function () {
      this.store = null;
    }
  }, true, false);

  Provider.global = function () {
    return globalProvider;
  };

  globalProvider = new Provider();
  return Provider;
}();

/***/ }),

/***/ "../metaphorjs-shared/src/lib/Queue.js":
/*!*********************************************!*\
  !*** ../metaphorjs-shared/src/lib/Queue.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const async = __webpack_require__(/*! ../func/async.js */ "../metaphorjs-shared/src/func/async.js"),
      extend = __webpack_require__(/*! ../func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      bind = __webpack_require__(/*! ../func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      nextUid = __webpack_require__(/*! ../func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      isThenable = __webpack_require__(/*! ../func/isThenable.js */ "../metaphorjs-shared/src/func/isThenable.js"),
      emptyFn = __webpack_require__(/*! ../func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js"),
      isNumber = __webpack_require__(/*! ../func/isNumber.js */ "../metaphorjs-shared/src/func/isNumber.js"),
      error = __webpack_require__(/*! ../func/error.js */ "../metaphorjs-shared/src/func/error.js"),
      raf = __webpack_require__(/*! metaphorjs-animate/src/func/raf.js */ "../metaphorjs-animate/src/func/raf.js"),
      MetaphorJs = __webpack_require__(/*! ../MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.lib.Queue = function () {
  const Queue = function (cfg) {
    var self = this;
    cfg = cfg || {};
    self._queue = [];
    self._map = {};
    self.id = "$$" + nextUid();
    self._f = bind(self._finish, self);

    for (var i in cfg) {
      self[i] = cfg[i];
    }
  };

  Queue.REPLACE = 1;
  Queue.ONCE = 2;
  Queue.MULTIPLE = 3;
  Queue.ONCE_EVER = 4;
  extend(Queue.prototype, {
    _queue: null,
    _map: null,
    _nextRequested: false,
    _running: false,
    currentItemNo: null,
    length: 0,
    id: null,
    async: true,
    auto: true,
    thenable: false,
    stack: false,
    context: null,
    onResult: null,
    onFinish: null,
    counter: 0,
    mode: Queue.MULTIPLE,
    add: function (fn, context, args, mode, prepend, async) {
      var self = this,
          qid = self.id,
          id = fn[qid] || nextUid(),
          item = {
        id: id,
        fn: fn,
        context: context,
        args: args,
        async: async,
        itemno: ++self.counter
      };
      mode = mode || self.mode;

      if (mode === Queue.ONCE_EVER && fn[qid]) {
        return fn[qid];
      }

      fn[qid] = id;

      if (self._map[id]) {
        if (mode === Queue.REPLACE) {
          self.remove(id);
        } else if (mode === Queue.ONCE) {
          return id;
        }
      }

      self._queue[prepend ? "unshift" : "push"](item);

      self._map[id] = item;
      self.length = self._queue.length;

      if (self.auto) {
        self.next();
      }

      return id;
    },
    append: function (fn, context, args, mode, async) {
      return this.add(fn, context, args, mode, false, async);
    },
    prepend: function (fn, context, args, mode, async) {
      return this.add(fn, context, args, mode, true, async);
    },
    remove: function (id) {
      var self = this,
          queue = self._queue,
          i,
          l;

      for (i = 0, l = queue.length; i < l; i++) {
        if (queue[i].id === id) {
          queue.splice(i, 1);
          break;
        }
      }

      delete self._map[id];
    },
    isEmpty: function () {
      return this.length === 0;
    },
    isRunning: function () {
      return this._running;
    },
    next: function () {
      var self = this,
          item,
          res;

      if (self._running) {
        self._nextRequested = true;
        return;
      }

      self._nextRequested = false;
      item = self._queue[self.stack ? "pop" : "shift"]();
      self.length = self._queue.length;

      if (!item) {
        return false;
      }

      self._running = true;
      self.currentItemNo = item.itemno;
      delete self._map[item.id];

      var fn = function () {
        try {
          res = item.fn.apply(item.context || self.context, item.args || []);
        } catch (thrown) {
          error(thrown);
        } finally {
          if (isThenable(res)) {
            res.then(self._f, self._f);
          } else {
            self._finish(res);
          }
        }
      };

      var asnc = item.async || self.async || false;
      !asnc && fn();
      asnc === "raf" && raf(fn);
      asnc && asnc !== "raf" && async(fn, null, null, isNumber(asnc) ? asnc : 0);
    },
    _finish: function (result) {
      var self = this;
      self.onResult && self.onResult.call(self.context, result);

      if (self._running) {
        self._running = false;
        self.currentItemNo = null;

        if (self.auto || self._nextRequested) {
          if (self.next() === false) {
            self.onFinish && self.onFinish.call(self.context);
          }
        } else {
          self.length === 0 && self.onFinish && self.onFinish.call(self.context);
        }
      }
    },
    $destroy: function () {
      var self = this;
      self._queue = null;
      self._map = null;
      self.context = null;
      self._nextRequested = false;
      self._running = false;
      self.next = emptyFn;
    }
  }, true, false);
  return Queue;
}();

/***/ }),

/***/ "../metaphorjs-shared/src/mixin/Provider.js":
/*!**************************************************!*\
  !*** ../metaphorjs-shared/src/mixin/Provider.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/Provider.js */ "../metaphorjs-shared/src/lib/Provider.js");

const MetaphorJs = __webpack_require__(/*! ../MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.mixin.Provider = {
  /**
   * @type {Provider}
   */
  $$provider: null,
  $beforeInit: function () {
    this.$$provider = new MetaphorJs.lib.Provider();
  },
  value: function () {
    var p = this.$$provider;
    return p.value.apply(p, arguments);
  },
  constant: function () {
    var p = this.$$provider;
    return p.constant.apply(p, arguments);
  },
  factory: function () {
    var p = this.$$provider;
    return p.factory.apply(p, arguments);
  },
  service: function () {
    var p = this.$$provider;
    return p.service.apply(p, arguments);
  },
  provider: function () {
    var p = this.$$provider;
    return p.provider.apply(p, arguments);
  },
  isResolved: function () {
    var p = this.$$provider;
    return p.isResolved.apply(p, arguments);
  },
  resolve: function () {
    var p = this.$$provider;
    return p.resolve.apply(p, arguments);
  },
  inject: function () {
    var p = this.$$provider;
    return p.inject.apply(p, arguments);
  },
  $afterDestroy: function () {
    this.$$provider.$destroy();
    this.$$provider = null;
  }
};

/***/ }),

/***/ "../metaphorjs-shared/src/var/regexp/email.js":
/*!****************************************************!*\
  !*** ../metaphorjs-shared/src/var/regexp/email.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! ../../MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.regexp.email = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i;

/***/ }),

/***/ "../metaphorjs-shared/src/var/regexp/location.js":
/*!*******************************************************!*\
  !*** ../metaphorjs-shared/src/var/regexp/location.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! ../../MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.regexp.location = /^(((([^:\/#\?]+:)?(?:(\/\/)((?:(([^:@\/#\?]+)(?:\:([^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((\/?(?:[^\/\?#]+\/+)*)([^\?#]*)))?(\?[^#]+)?)(#.*)?/;

/***/ }),

/***/ "../metaphorjs-shared/src/var/regexp/url.js":
/*!**************************************************!*\
  !*** ../metaphorjs-shared/src/var/regexp/url.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! ../../MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"); ///^((https?|ftp):\/\/|)(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
// https://gist.github.com/dperini/729294


module.exports = MetaphorJs.regexp.url = new RegExp("^" + // protocol identifier
"(?:(?:https?|ftp)://)" + // user:pass authentication
"(?:\\S+(?::\\S*)?@)?" + "(?:" + // IP address exclusion
// private & local networks
"(?!(?:10|127)(?:\\.\\d{1,3}){3})" + "(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" + "(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})" + // IP address dotted notation octets
// excludes loopback network 0.0.0.0
// excludes reserved space >= 224.0.0.0
// excludes network & broacast addresses
// (first & last IP address of each class)
"(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" + "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" + "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" + "|" + // host name
"(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)" + // domain name
"(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" + // TLD identifier
"(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))" + ")" + // port number
"(?::\\d{2,5})?" + // resource path
"(?:/\\S*)?" + "$", "i");

/***/ }),

/***/ "./dev-test/container.js":
/*!*******************************!*\
  !*** ./dev-test/container.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

var cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
    ns = __webpack_require__(/*! metaphorjs-namespace/src/var/ns.js */ "../metaphorjs-namespace/src/var/ns.js"),
    MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

var Test = {};
ns.register("Test", Test);
cls({
  $class: "Test.container.Cmp1",
  $extends: "MetaphorJs.app.Component",
  as: "ctrl",
  move: function () {
    var parent1 = window.mainApp.getCmp("parent1"),
        parent2 = window.mainApp.getCmp("parent2");

    if (parent1.hasItem(this)) {
      parent2.addItem(this);
    } else {
      parent1.addItem(this);
    }
  },
  template: {
    html: "<p>This is container child #1; " + "<a href=\"#\" (click)=\"this.ctrl.move()\">move</a></p>"
  }
});
cls({
  $class: "Test.container.Cmp2",
  $extends: "Test.container.Cmp1",
  as: "ctrl",
  template: {
    html: "<p>This is container child #2; " + "<a href=\"#\" (click)=\"this.ctrl.move()\">move</a></p>"
  }
});
cls({
  $class: "Test.container.Cmp3",
  $extends: "MetaphorJs.app.Component",
  as: "ctrl",
  template: {
    html: "<div>Before bind // <span ##bindhere></span> // After bind</div>"
  }
}, {
  supportsDirectives: {
    "bind-html": "bindhere"
  }
});
cls({
  $class: "Test.container.Parent3",
  $extends: "MetaphorJs.app.Container",
  $alias: "MetaphorJs.directive.component.parent3",
  id: "parent3",
  template: 'container2.html'
});
cls({
  $class: "Test.container.Cmp4",
  $extends: "MetaphorJs.app.Component",
  $alias: "MetaphorJs.directive.component.cmp4",
  template: {
    html: "<div>This is cmp4</div>"
  }
});
cls({
  $class: "Test.ContainerApp",
  $extends: "MetaphorJs.app.App",
  initApp: function (node, state) {
    window.mainApp = this;
    state.bindText = "AAA";
    state.$makePublicDefault();
    var div = document.createElement("div");
    div.innerHTML = 'Dynamicly created node';
    var parent1 = new MetaphorJs.app.Container({
      id: "parent1",
      defaultAddTo: "body",
      renderTo: document.getElementById("container-app"),
      template: 'container1.html',
      items: [new Test.container.Cmp1({
        id: "child1"
      }), new Test.container.Cmp2({
        id: "child2"
      }), new Test.container.Cmp3({
        id: "child3",
        directives: {
          state: state,
          "bind-html": {
            value: {
              expression: "this.bindText"
            }
          }
        }
      }), div]
    });
    parent1.render();
    var parent2 = new MetaphorJs.app.Container({
      id: "parent2",
      config: {
        tag: "div"
      }
    });
    parent2.render(document.getElementById("container-app"));
  }
});
cls({
  $class: "Test.UIApp",
  $extends: "MetaphorJs.app.App",
  initApp: function (node, state) {
    window.mainApp = this;
    window.cls = cls;
    this.menu1 = new MetaphorJs.ui.menu.Menu({
      directives: {
        "class": "vertical"
      },
      items: [{
        text: "Text 1",
        callback: {
          click: function () {
            console.log(this);
            console.log("dynamic menu click");
          }
        },
        items: ['<i class="dropdown icon" @after></i>'],
        menu: {
          items: [{
            text: "Text 2"
          }]
        }
      }, '|', {
        text: "Test"
      }]
    });
  },
  afterRender: function () {
    this.menu1.render(this.getRefEl("dynamic-menu"));
  }
});

/***/ }),

/***/ "./src/__init.js":
/*!***********************!*\
  !*** ./src/__init.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

MetaphorJs.ui = MetaphorJs.ui || {
  button: {},
  panel: {},
  window: {},
  field: {
    view: {}
  },
  dialog: {},
  menu: {},
  toolbar: {},
  form: {},
  mixin: {},
  util: {
    view: {}
  }
};

/***/ }),

/***/ "./src/filter/color.js":
/*!*****************************!*\
  !*** ./src/filter/color.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-shared/src/lib/Color.js */ "../metaphorjs-shared/src/lib/Color.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @filter get
 * @param {object} input
 * @param {string} format
 * @returns {*}
 */


MetaphorJs.filter.color = function (val, state, prop) {
  var c = new MetaphorJs.lib.Color(val);
  return c.getAs(prop);
};

/***/ }),

/***/ "./src/ui/button/Button.js":
/*!*********************************!*\
  !*** ./src/ui/button/Button.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../mixin/WithActiveState.js */ "./src/ui/mixin/WithActiveState.js");

__webpack_require__(/*! ../mixin/WithText.js */ "./src/ui/mixin/WithText.js");

__webpack_require__(/*! ../mixin/WithDropdown.js */ "./src/ui/mixin/WithDropdown.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.button.Button = MetaphorJs.app.Container.$extend({
  $mixins: [MetaphorJs.ui.mixin.WithActiveState, MetaphorJs.ui.mixin.WithText, MetaphorJs.ui.mixin.WithDropdown],
  $class: "MetaphorJs.ui.button.Button",
  $alias: "MetaphorJs.directive.component.ui-button",
  template: "ui/button/button.html",
  as: "button",
  onClick: function (e) {
    this.trigger("click", this, e);
  }
}, {
  defaultDropdown: {
    on: "click"
  },
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true,
    click: "button",
    dblclick: "button",
    mousedown: "button",
    mouseup: "button",
    mousemove: "button",
    dropdown: true
  },
  propsToItems: {
    "menu": "MetaphorJs.ui.menu.Menu"
  },
  dropdownClasses: ["MetaphorJs.ui.menu.Menu"],
  configProps: ["text", "active"]
});

/***/ }),

/***/ "./src/ui/button/Group.js":
/*!********************************!*\
  !*** ./src/ui/button/Group.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.button.Group = MetaphorJs.app.Container.$extend({
  $class: "MetaphorJs.ui.button.Group",
  template: "ui/button/group.html"
}, {
  allowUnwrapped: ["MetaphorJs.ui.button.Button"],
  wrapper: "MetaphorJs.ui.button.Button",
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true
  }
});

/***/ }),

/***/ "./src/ui/button/Split.js":
/*!********************************!*\
  !*** ./src/ui/button/Split.js ***!
  \********************************/
/***/ (() => {



/***/ }),

/***/ "./src/ui/dialog/Alert.js":
/*!********************************!*\
  !*** ./src/ui/dialog/Alert.js ***!
  \********************************/
/***/ (() => {



/***/ }),

/***/ "./src/ui/dialog/ColorPicker.js":
/*!**************************************!*\
  !*** ./src/ui/dialog/ColorPicker.js ***!
  \**************************************/
/***/ (() => {



/***/ }),

/***/ "./src/ui/dialog/Confirm.js":
/*!**********************************!*\
  !*** ./src/ui/dialog/Confirm.js ***!
  \**********************************/
/***/ (() => {



/***/ }),

/***/ "./src/ui/dialog/Popup.js":
/*!********************************!*\
  !*** ./src/ui/dialog/Popup.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! metaphorjs-dialog/src/dialog/Container.js */ "../metaphorjs-dialog/src/dialog/Container.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.dialog.Popup = MetaphorJs.app.Container.$extend({});

/***/ }),

/***/ "./src/ui/dialog/Window.js":
/*!*********************************!*\
  !*** ./src/ui/dialog/Window.js ***!
  \*********************************/
/***/ (() => {



/***/ }),

/***/ "./src/ui/field/Checkbox.js":
/*!**********************************!*\
  !*** ./src/ui/field/Checkbox.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! ./Field.js */ "./src/ui/field/Field.js");

__webpack_require__(/*! metaphorjs/src/lib/Input.js */ "../metaphorjs/src/lib/Input.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js");

module.exports = MetaphorJs.ui.field.Checkbox = MetaphorJs.ui.field.Field.$extend({
  $class: "MetaphorJs.ui.field.Checkbox",
  $alias: "MetaphorJs.directive.component.ui-checkbox",
  template: "ui/field/checkbox.html",
  afterRender: function () {
    var self = this,
        input;

    if (self.$refs.node.input) {
      self.input = input = MetaphorJs.lib.Input.get(self.$refs.node.input);
      self.setValue = bind(input.setValue, input);
      self.getValue = bind(input.getValue, input);
      self.onKey = bind(input.onKey, input);
      self.unKey = bind(input.unKey, input);
      self.$$observable.relayEvent(input, "change");
    }

    self.$super();
  }
}, {
  supportsDirectives: {
    bind: "input",
    model: "input",
    show: true,
    hide: true,
    class: true,
    style: true,
    "in-focus": "input",
    click: true,
    dblclick: true,
    mousedown: true,
    mouseup: true,
    mousemove: true,
    field: true
  }
});

/***/ }),

/***/ "./src/ui/field/Field.js":
/*!*******************************!*\
  !*** ./src/ui/field/Field.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! metaphorjs/src/directive/attr/bind.js */ "../metaphorjs/src/directive/attr/bind.js");

__webpack_require__(/*! metaphorjs/src/directive/attr/model.js */ "../metaphorjs/src/directive/attr/model.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js");

module.exports = MetaphorJs.ui.field.Field = MetaphorJs.app.Container.$extend({
  $class: "MetaphorJs.ui.field.Field",
  initConfig: function () {
    var self = this,
        config = self.config;
    config.setOption("defaultMode", MetaphorJs.lib.Config.MODE_STATIC);
    config.setType("inputAutoCapitalize", "bool", null, true);
    config.setType("inputAutoCorrect", "bool", null, true);
    config.setType("inputDisabled", "bool", null, false);
    config.setType("clearable", "bool", null, true);
    config.setType("as", null, null, "field");
    config.setType("disabled", "bool", null, false);
    config.setType("readonly", "bool", null, false);
    config.setDefaultMode("name", MetaphorJs.lib.Config.MODE_STATIC);
    config.setDefaultValue("name", "");
    self.$super();
  },
  onDestroy: function () {
    var self = this;

    if (self.bindDirective) {
      self.bindDirective.$destroy();
      self.bindDirective = null;
    }

    if (self.modelDirective) {
      self.modelDirective.$destroy();
      self.modelDirective = null;
    }

    self.$super();
  },

  /* Input API */
  setValue: emptyFn,
  getValue: emptyFn,
  onKey: emptyFn,
  unKey: emptyFn,
  onChange: function (fn, ctx, opt) {
    return this.on("change", fn, ctx, opt);
  },
  unChange: function (fn, ctx) {
    return this.un("change", fn, ctx);
  },
  getInputApi: function () {
    return this;
  }
}, {
  supportsDirectives: {
    "bind": true,
    "model": true
  }
});

/***/ }),

/***/ "./src/ui/field/Input.js":
/*!*******************************!*\
  !*** ./src/ui/field/Input.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! ./Field.js */ "./src/ui/field/Field.js");

__webpack_require__(/*! metaphorjs/src/lib/Input.js */ "../metaphorjs/src/lib/Input.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js");

module.exports = MetaphorJs.ui.field.Input = MetaphorJs.ui.field.Field.$extend({
  $class: "MetaphorJs.ui.field.Input",
  $alias: "MetaphorJs.directive.component.ui-input",
  template: "ui/field/input.html",
  initConfig: function () {
    this.$super();
    var config = this.config;
    config.setType("type", null, MetaphorJs.lib.Config.MODE_STATIC, "text");
    config.setType("placeholder", null, MetaphorJs.lib.Config.MODE_STATIC, "");
  },
  afterRender: function () {
    var self = this,
        input;
    self.input = input = MetaphorJs.lib.Input.get(self.$refs.node.input);
    self.setValue = bind(input.setValue, input);
    self.getValue = bind(input.getValue, input);
    self.onKey = bind(input.onKey, input);
    self.unKey = bind(input.unKey, input);
    self.$$observable.relayEvent(input, "change");
    self.$super();
  }
}, {
  supportsDirectives: {
    bind: "input",
    model: "input",
    show: true,
    hide: true,
    class: true,
    style: true,
    "in-focus": "input",
    click: true,
    dblclick: true,
    mousedown: true,
    mouseup: true,
    mousemove: true,
    field: true
  }
});

/***/ }),

/***/ "./src/ui/field/Radio.js":
/*!*******************************!*\
  !*** ./src/ui/field/Radio.js ***!
  \*******************************/
/***/ (() => {



/***/ }),

/***/ "./src/ui/field/Select.js":
/*!********************************!*\
  !*** ./src/ui/field/Select.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! ../mixin/Selectable.js */ "./src/ui/mixin/Selectable.js");

__webpack_require__(/*! ./Field.js */ "./src/ui/field/Field.js");

__webpack_require__(/*! metaphorjs-model/src/model/Store.js */ "../metaphorjs-model/src/model/Store.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Queue.js */ "../metaphorjs-shared/src/lib/Queue.js");

__webpack_require__(/*! metaphorjs/src/func/dom/addClass.js */ "../metaphorjs/src/func/dom/addClass.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeClass.js */ "../metaphorjs/src/func/dom/removeClass.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getWidth.js */ "../metaphorjs/src/func/dom/getWidth.js");

__webpack_require__(/*! metaphorjs/src/lib/EventBuffer.js */ "../metaphorjs/src/lib/EventBuffer.js");

__webpack_require__(/*! metaphorjs-dialog/src/dialog/Dialog.js */ "../metaphorjs-dialog/src/dialog/Dialog.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! metaphorjs/src/lib/MutationObserver.js */ "../metaphorjs/src/lib/MutationObserver.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getStyle.js */ "../metaphorjs/src/func/dom/getStyle.js");

__webpack_require__(/*! ./view/Select.js */ "./src/ui/field/view/Select.js");

const async = __webpack_require__(/*! metaphorjs-shared/src/func/async.js */ "../metaphorjs-shared/src/func/async.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.field.Select = MetaphorJs.ui.field.Field.$extend({
  $mixins: [MetaphorJs.ui.mixin.Selectable],
  $class: "MetaphorJs.ui.field.Select",
  $alias: "MetaphorJs.directive.component.ui-select",
  $view: "MetaphorJs.ui.field.view.Select",
  template: "ui/field/select.html",
  dialog: null,
  currentValue: null,
  prevValue: null,
  currentName: null,
  resizeBuffer: null,
  _firstLoadSet: false,
  initConfig: function () {
    this.$super();
    var config = this.config;
    config.setDefaultMode("options", MetaphorJs.lib.Config.MODE_DYNAMIC);
    config.setDefaultMode("store", MetaphorJs.lib.Config.MODE_SINGLE);
    config.setType("searchable", "bool", null, false);
    config.setType("storeAutoLoad", "bool", null, true);
    config.setType("storePageSize", "int", null, 20);
    config.setType("storeFilter", null, MetaphorJs.lib.Config.MODE_LISTENER);
    config.setType("valueField", null, null, "id");
    config.setType("displayField", null, null, "name");
    config.setType("showEmptyItem", "bool", null, true);
    config.setType("showNotFound", "bool", null, true);
    config.setType("showSingleClear", "bool", null, false);
    config.setType("keepSelectedOptions", "bool", null, true);
    config.setType("cssDialog", "bool", null, false);
    config.setType("hiddenInputName", "string", null, "");
    config.setType("emptyText", "string", null, "");
    config.setType("emptyItemText", "string", null, "&nbsp;");
    config.setType("notFoundText", "string", null, "Nothing found");
    config.setType("placeholder", "string", null, "");
    config.setType("queryParam", "string", null, "q");
    config.setType("queryMinLength", "int", null, 3);
    config.setType("queryMode", "string", null, "local");
    config.on("options", this.setOptions, this);
  },
  initComponent: function () {
    var self = this,
        state = self.state,
        config = self.config;
    self._prevQuery = "";
    self.searchQueue = new MetaphorJs.lib.Queue({
      auto: true,
      async: 300,
      mode: MetaphorJs.lib.Queue.REPLACE
    });
    state.loading = false;
    state.opened = false;
    state.searchQuery = "";
    state.focused = false;

    if (config.hasExpression("store")) {
      self.store = config.get("store");
    }

    if (!self.store) {
      self.store = new MetaphorJs.model.Store({
        model: config.get("storeModel") || {
          id: config.get("valueField")
        },
        local: !config.hasExpression("storeModel"),
        autoLoad: config.hasExpression("storeModel") && config.get("storeAutoLoad"),
        pageSize: config.get("storePageSize")
      });
    }

    self.store.on("loading-start", self.onStoreStartLoading, self);
    self.store.on("load", self.onStoreLoad, self);

    if (config.get("queryMode") !== "none") {
      self.store.filter(bind(self.storeFilter, self));
    }

    if (config.get("searchable")) {
      self.state.$watch("this.searchQuery", self.onSearchQueryChange, self);
    }

    if (config.hasExpression("storeFilter")) {
      self.storeFilterFn = config.get("storeFilter");
    } else self.storeFilterFn = null;

    if (config.hasExpression("options")) {
      self.setOptions(config.get("options"));
    }

    self.$super();
  },
  afterRender: function () {
    var self = this;
    async(self.initDialog, self, [], 300);
  },
  onDestroy: function () {
    var self = this;

    if (!self.config.$isDestroyed() && self.config.get("searchable")) {
      self.state.$unwatch("this.searchQuery", self.onSearchQueryChange, self);
    }

    self.$super();
  },

  /* PUBLIC API */
  hasSelection: function () {
    if (this.$$selection.length > 0) {
      return true;
    }

    if (this.currentValue) {
      return !isArray(this.currentValue) || this.currentValue.length > 0;
    }

    return false;
  },
  isSelectionEnabled: function () {
    return true; //return !this.config.get("disabled");
  },
  getValue: function () {
    var self = this,
        sels = self.getSelectedValues();

    if (self.isMultiSelection()) {
      return sels;
    } else {
      return sels.length ? sels[0] : null;
    }
  },
  setValue: function (val, name) {
    var self = this;

    if (self.currentValue == val) {
      return;
    }

    self.prevValue = self.currentValue;

    if (self.hasSelection() && !self.isMultiSelection()) {
      self.$$observable.suspendEvent("change");
      self.unselectAll();
      self.$$observable.resumeEvent("change");
    }

    if (!val) {
      self.currentValue = null;
      return;
    }

    if (self.isMultiSelection()) {
      if (!isArray(val)) {
        val = [val];
      }

      self.currentValue = val;
      var i, l;

      for (i = 0, l = val.length; i < l; i++) {
        self.selectItemById(val[i]);
      }
    } else {
      self.currentValue = val;
      self.currentName = name;
      self.selectItemById(val);
    }

    if (!self.state.$$checking) {
      self.state.$check();
    }
  },
  getSelectedValues: function () {
    return this.$$selection.slice();
  },
  getSelectedName: function () {
    var self = this;

    if (self.isMultiSelection()) {
      return null;
    }

    var sel = self.getSelection();

    if (sel.length) {
      return self.getItemName(sel[0]);
    } else if (self.currentName) {
      return self.currentName;
    }

    return self.currentValue;
  },
  getMultiSelection: function () {
    return this.isMultiSelection() ? this.getSelection() : [];
  },
  search: function (query) {
    this.store.start = 0;
    this.store.setParam(this.queryParam, query);
    this.store.load();
  },
  setOptions: function (options) {
    if (this.store && typeof this.store !== "string") {
      this.store.clear();

      if (options) {
        this.store.addMany(options);
      }
    }
  },

  /* PRIVATE */
  onSearchQueryChange: function (query, prev) {
    var self = this;
    self._prevQuery = prev;

    if (!self.store.local && self.config.get("queryMode") !== "local") {
      if (query.length >= self.queryMinLength) {
        self.searchQueue.append(self.search, self, [query]);
      } else if (query === "") {
        if (self.config.get("storeAutoLoad")) {
          self.searchQueue.append(self.search, self, [query]);
        } else {
          self.store.clear();
        }
      } else {
        self.store.clear();
      }
    } else {
      self.store.update();
    }

    self.trigger("query-change", self, query, prev);
  },
  onSelectionChange: function () {
    this.store.update();
    self.prevValue = self.currentValue;
    this.currentValue = this.getValue();
    this.trigger("change", this.currentValue, this, this.prevValue);
  },
  getItemValue: function (item) {
    return item[this.config.get("valueField")];
  },
  getItemName: function (item) {
    return item[this.config.get("displayField")];
  },
  onStoreStartLoading: function () {
    this.state.$set('loading', true);
  },
  onStoreLoad: function () {
    var self = this;

    if (!self._firstLoadSet) {
      self._firstLoadSet = true;

      if (self.currentValue) {
        self.setValue(self.currentValue, self.currentName);
      }
    } else {
      if (self.currentValue) {
        self.$$observable.suspendEvent("selection-change");
        self.setValue(self.currentValue, self.currentName);
        self.$$observable.resumeEvent("selection-change");
      }
    }

    self.state.$set('loading', false);
  },
  storeFilter: function (item) {
    var self = this,
        config = self.config;

    if (self.isSelected(item) && !config.get("keepSelectedOptions")) {
      return false;
    }

    if ((config.get("queryMode") === "local" || self.store.local) && self.state.searchQuery) {
      var text = item[config.get("displayField")];

      if (text) {
        if (self.storeFilterFn) {
          return self.storeFilterFn(item, text, self.state.searchQuery);
        } else {
          return ("" + text).toLowerCase().indexOf(self.state.searchQuery.toLowerCase()) !== -1;
        }
      }
    }

    return true;
  },
  _getSelectOptions: function () {
    var opts = [],
        self = this;

    if (self.config.get("showEmptyItem") && !self.store.isEmpty()) {
      opts.push({
        name: self.config.get("emptyItemText"),
        value: null
      });
    }

    self.store.each(function (item) {
      opts.push({
        name: self.getItemName(item),
        value: self.getItemValue(item)
      });
    });
    return opts;
  },

  /* DIALOG */
  onBeforeDialogShow: function () {
    var self = this,
        pl = MetaphorJs.dom.getStyle(self.node, "padding-left"),
        pr = MetaphorJs.dom.getStyle(self.node, "padding-right");

    if (self.disabled) {
      return false;
    }

    pl = pl ? parseInt(pl) : 0;
    pr = pr ? parseInt(pr) : 0;
    self.dialog.getElem().style.minWidth = pl + pr + MetaphorJs.dom.getWidth(self.node) + "px";
    MetaphorJs.dom.addClass(self.node, "active");
  },
  onDialogShow: function () {
    this.state.$set('opened', true);
  },
  onDialogHide: function () {
    this.state.$set('opened', false);
    MetaphorJs.dom.removeClass(this.node, "active");
  },
  initDialog: function () {
    var self = this,
        cssD = self.config.get("cssDialog"),
        render,
        position;

    if (cssD) {
      position = false;
      render = {
        el: self.getRefEl("menu_items"),
        appendTo: false,
        keepInDOM: true
      };
    } else {
      position = {
        type: "bl",
        offsetY: 1
      };
      render = {
        el: self.getRefEl("menu"),
        zIndex: 100,
        appendTo: document.body,
        style: {
          position: "absolute"
        }
      };
    }

    self.dialog = new MetaphorJs.dialog.Dialog({
      target: self.node,
      position: position,
      content: false,
      modal: false,
      group: "ui-select",
      render: render,
      show: {
        events: false,
        single: true
      },
      hide: {
        events: {
          "body": "click"
        },
        remove: false
      }
    });
    self.dialog.on("show", self.onDialogShow, self);
    self.dialog.on("hide", self.onDialogHide, self);
    self.dialog.on("before-show", self.onBeforeDialogShow, self);
    self.$$observable.relayEvent(self.dialog, "*", null, "menu-");
  }
}, {
  supportsDirectives: {
    bind: true,
    model: true,
    show: true,
    hide: true,
    class: true,
    style: true,
    "in-focus": "search",
    click: true,
    dblclick: true,
    mousedown: true,
    mouseup: true,
    mousemove: true,
    field: true
  }
});

/***/ }),

/***/ "./src/ui/field/view/Select.js":
/*!*************************************!*\
  !*** ./src/ui/field/view/Select.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/component/View.js */ "../metaphorjs/src/app/component/View.js");

__webpack_require__(/*! metaphorjs/src/lib/EventBuffer.js */ "../metaphorjs/src/lib/EventBuffer.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.field.view.Select = MetaphorJs.app.component.View.$extend({
  $beforeHostInit: function () {
    var self = this;
    self.component.$intercept("afterRender", self.afterRender, self, "after");
    self.component.$intercept("onSearchQueryChange", self.onSearchQueryChange, self, "after");
  },
  $afterHostInit: function () {
    var self = this,
        cmp = self.component,
        config = cmp.config;
    config.setType("useHiddenSelect", "bool", null, false);
    config.setType("hiddenSelectBreakpoint", "int");

    if (config.get("useHiddenSelect")) {
      if (config.get("hiddenSelectBreakpoint")) {
        config.set("useHiddenSelect", false);
        self.resizeBuffer = MetaphorJs.dom.EventBuffer.get(window, "resize");
        self.resizeBuffer.watchWidth();
        self.resizeBuffer.onBreak("width", config.get("hiddenSelectBreakpoint"), self.onWindowBreak, self);
      }
    }
  },
  afterRender: function () {
    var self = this,
        cmp = self.component;

    if (cmp.isMultiSelection() && cmp.config.get("searchable")) {
      async(self.initSizer, self);
    }

    if (self.resizeBuffer) {
      async(self.onWindowBreak, self);
    }
  },
  onSearchQueryChange: function () {
    var self = this,
        cmp = self.component;

    if (cmp.isMultiSelection()) {
      async(self.setInputWidth, self);
    }
  },
  onWindowBreak: function () {
    var cmp = this.component;
    cmp.config.set("useHiddenSelect", MetaphorJs.dom.getWidth(window) < cmp.config.get("hiddenSelectBreakpoint"));
    cmp.state.$check();
  },
  initSizer: function () {
    if (this.component.getRefEl("sizer")) {
      var style = this.component.getRefEl("sizer").style;
      style.left = '-10000px';
      style.maxWidth = '1000px';
      style.display = 'inline-block';
      style.position = 'absolute';
    }
  },
  setInputWidth: function () {
    var cmp = this.component;
    cmp.getRefEl("search").style.width = MetaphorJs.dom.getWidth(cmp.getRefEl("sizer")) + 10 + "px";
  },
  setSearchFocus: function () {
    this.component.getRefEl("search").focus();
  },
  onSelfClick: function (e) {
    var self = this,
        cmp = self.component;

    if (cmp.config.get("useHiddenSelect")) {
      e.stopPropagation();
      return;
    }

    if (cmp.state.focused && cmp.dialog.isVisible()) {
      e.stopPropagation();
      return;
    }

    if (cmp.config.get("searchable") && !cmp.state.focused) {
      async(self.setSearchFocus, self);
      e.stopPropagation();
    }

    if (!cmp.config.get("searchable") && !cmp.dialog.isVisible()) {
      cmp.dialog.show();
      e.stopPropagation();
    }
  },
  onDropdownIconClick: function (e) {
    e.stopPropagation();
    this.component.dialog.toggle(e, true);
  },
  onItemClick: function (item, e) {
    var self = this,
        cmp = self.component,
        cfg = cmp.config;

    if (cfg.get("readonly")) {
      e.stopPropagation();
      cmp.dialog.hide();
      return;
    }

    if (item) {
      //this.selectItem(item);
      cmp.setValue(item[cfg.get("valueField")], item[cfg.get("displayField")]);
    } else {
      cmp.unselectAll();
    } //if (!cfg.get("keepSelectedOptions")) {
    //    self.store.update();
    //}


    e.stopPropagation();
    cmp.state.$set("searchQuery", "");

    if (!cmp.isMultiSelection()) {
      cmp.dialog.hide();
    } else {
      async(self.setSearchFocus, self);
    }
  },
  onValueTextClick: function (e) {},
  onItemDeleteClick: function (item, e) {
    var self = this,
        cmp = self.component;

    if (!cmp.isSelectionEnabled()) {
      return;
    }

    cmp.unselectItem(item);

    if (!cmp.config.get("keepSelectedOptions")) {
      cmp.store.update();
    }

    e.stopPropagation();
  },

  /*onNotFoundClick: function(item, e) {
      e.stopPropagation();
  },
   onPaginationClick: function(e) {
      e.stopPropagation();
  },*/
  onSearchFocus: function (e) {
    var cmp = this.component;
    cmp.state.$set("focused", true);

    if (!cmp.dialog.isVisible()) {
      cmp.dialog.show();
      e.stopPropagation();
    }
  },
  onSearchBlur: function (e) {
    var cmp = this.component;
    cmp.state.$set("focused", false);

    if (!cmp.dialog.isVisible()) {
      cmp.dialog.show();
      e.stopPropagation();
    }
  },
  onSearchBackspace: function () {
    var cmp = this.component;

    if (!cmp.state.searchQuery) {
      if (!cmp._prevQuery) {
        if (cmp.hasSelection()) {
          cmp.unselectItemById(cmp.$$selection[cmp.$$selection.length - 1]);
          cmp.store.update();
        }
      } else {
        cmp._prevQuery = "";
      }
    }
  },
  onHiddenSelectClick: function (e) {
    e.stopPropagation();
  },
  onHiddenSelectChange: function (e) {
    var self = this,
        cmp = self.component,
        val = cmp.getRefEl("hiddenselect").value;

    if (val) {
      var item = cmp.store.find(cmp.config.get("valueField"), val);

      if (item) {
        cmp.selectItem(item);
      }
    } else {
      cmp.unselectAll();
    }
  }
});

/***/ }),

/***/ "./src/ui/menu/Divider.js":
/*!********************************!*\
  !*** ./src/ui/menu/Divider.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.menu.Divider = MetaphorJs.app.Container.$extend({
  $class: "MetaphorJs.ui.menu.Divider",
  $alias: "MetaphorJs.directive.component.ui-menu-divider",
  template: "ui/menu/divider.html"
}, {
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true,
    click: true,
    dblclick: true,
    mousedown: true,
    mouseup: true,
    mousemove: true
  }
});

/***/ }),

/***/ "./src/ui/menu/Item.js":
/*!*****************************!*\
  !*** ./src/ui/menu/Item.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../mixin/WithActiveState.js */ "./src/ui/mixin/WithActiveState.js");

__webpack_require__(/*! ../mixin/WithText.js */ "./src/ui/mixin/WithText.js");

__webpack_require__(/*! ../mixin/WithDropdown.js */ "./src/ui/mixin/WithDropdown.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.menu.Item = MetaphorJs.app.Container.$extend({
  $mixins: [MetaphorJs.ui.mixin.WithActiveState, MetaphorJs.ui.mixin.WithText, MetaphorJs.ui.mixin.WithDropdown],
  $class: "MetaphorJs.ui.menu.Item",
  $alias: "MetaphorJs.directive.component.ui-menu-item",
  as: "item",
  template: {
    name: {
      expression: "this.tpl"
    }
  },
  initComponent: function () {
    this.state.tpl = this.$self.templates.item;
    this.$super.apply(this, arguments);
  },
  _initChildItem: function (item) {
    var self = this;

    if (item.type === "component") {
      self.state.tpl = self.$self.templates.container;
    }

    self.$super();
  },
  _onDropdownCreated: function (component) {
    this.state.tpl = this.$self.templates.submenu;
  },
  onClick: function (ev) {
    this.trigger("click", this, ev);
  }
}, {
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true,
    click: true,
    dblclick: true,
    mousedown: true,
    mouseup: true,
    mousemove: true,
    dropdown: true
  },
  propsToItems: {
    "menu": "MetaphorJs.ui.menu.Menu"
  },
  templates: {
    item: "ui/menu/item.html",
    container: "ui/menu/container.html",
    submenu: "ui/menu/item-with-sub.html"
  },
  configProps: ["text", "active"],
  dropdownClasses: ["MetaphorJs.ui.menu.Menu"],
  defaultDropdown: {
    on: "mouseover"
  }
});

/***/ }),

/***/ "./src/ui/menu/Menu.js":
/*!*****************************!*\
  !*** ./src/ui/menu/Menu.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ./Item.js */ "./src/ui/menu/Item.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      ns = __webpack_require__(/*! metaphorjs-namespace/src/var/ns.js */ "../metaphorjs-namespace/src/var/ns.js");

module.exports = MetaphorJs.ui.menu.Menu = MetaphorJs.app.Container.$extend({
  $class: "MetaphorJs.ui.menu.Menu",
  $alias: "MetaphorJs.directive.component.ui-menu",
  template: "ui/menu/menu.html",
  _initObjectItem: function (def) {
    if (def.__containerItemDef) {
      return def;
    }

    !def.state && (def.state = this.state.$new());
    var itemCls = this.$self.classes.item;
    typeof itemCls === "string" && (itemCls = ns.get(itemCls));
    return itemCls.createFromPlainObject(def);
  },
  _initStringItem: function (def) {
    if (def === '-' || def === '|') {
      return this.$self.classes.divider;
    }

    return this.$super(def);
  }
}, {
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true
  },
  allowUnwrapped: ["MetaphorJs.ui.menu.Item", "MetaphorJs.ui.menu.Divider"],
  wrapper: "MetaphorJs.ui.menu.Item",
  classes: {
    item: "MetaphorJs.ui.menu.Item",
    divider: "MetaphorJs.ui.menu.Divider"
  }
});

/***/ }),

/***/ "./src/ui/mixin/Selectable.js":
/*!************************************!*\
  !*** ./src/ui/mixin/Selectable.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.mixin.Selectable = {
  $beforeInit: function () {
    this.$$selection = [];
    this.$$_selectable_itemCache = {};
  },
  $initConfig: function () {
    this.config.setType("selectionMode", null, MetaphorJs.lib.Config.MODE_STATIC, "single");
  },
  $beforeDestroy: function () {
    this.$$_selectable_itemCache = null;
  },
  $$_selectable_getItemId: function (item) {
    if (this.store) {
      return this.store.getRecordId(item);
    }

    return item.id;
  },
  getSelection: function (index) {
    var self = this,
        store = self.store,
        sels = self.$$selection,
        items = [],
        i,
        l,
        id;

    for (i = 0, l = sels.length; i < l; i++) {
      id = sels[i];
      items.push(store.getById(id) || self.$$_selectable_itemCache[id]);
    }

    return index !== undefined ? items[index] : items;
  },
  toggleItemSelected: function (item) {
    var self = this;

    if (self.isSelected(item)) {
      self.unselectItem(item);
    } else {
      self.selectItem(item);
    }
  },
  selectItem: function (item) {
    var self = this;
    self.selectItemById(self.$$_selectable_getItemId(item));
  },
  selectItemById: function (id) {
    var self = this;

    if (!self.isSelectionEnabled()) {
      return;
    }

    if (self.$$selection.indexOf(id) === -1) {
      if (!self.isMultiSelection()) {
        self.$$selection = [];
        self.$$_selectable_itemCache = {};
      }

      var item = self.store.getById(id);

      if (item) {
        self.$$selection.push(id);
        self.$$_selectable_itemCache[id] = item;
        self.trigger("selection-change");
        self.onSelectionChange();
      }
    }
  },
  unselectItem: function (item) {
    this.unselectItemById(this.$$_selectable_getItemId(item));
  },
  unselectItemById: function (id) {
    var self = this,
        inx = self.$$selection.indexOf(id);

    if (!self.isSelectionEnabled()) {
      return;
    }

    if (inx !== -1) {
      self.$$selection.splice(inx, 1);
      delete self.$$_selectable_itemCache[id];
      self.trigger("selection-change");
      self.onSelectionChange();
    }
  },
  toggleAllSelected: function () {
    var self = this;

    if (!self.isAllSelected()) {
      self.selectAll();
    } else {
      self.unselectAll();
    }
  },
  selectAll: function () {
    var self = this,
        changed = !self.isAllSelected();

    if (!self.isSelectionEnabled()) {
      return;
    }

    if (self.config.get("selectionMode") !== "single") {
      self.$$selection = [];
      self.$$_selectable_itemCache = {};
      self.store.each(function (item) {
        var id = self.$$_selectable_getItemId(item);
        self.$$selection.push(id);
        self.$$_selectable_itemCache[id] = item;
      });
    }

    if (changed) {
      self.trigger("selection-change");
      self.onSelectionChange();
    }
  },
  unselectAll: function () {
    var self = this;

    if (!self.isSelectionEnabled()) {
      return;
    }

    if (self.$$selection.length > 0) {
      self.$$selection = [];
      self.$$_selectable_itemCache = {};
      self.trigger("selection-change");
      self.onSelectionChange();
    }
  },
  isIdSelected: function (id) {
    return this.$$selection.indexOf(id) !== -1;
  },
  isSelected: function (item) {
    return this.isIdSelected(this.$$_selectable_getItemId(item));
  },
  isSelectionEnabled: function () {
    return true;
  },
  isMultiSelection: function () {
    return this.config.get("selectionMode") === "multi";
  },
  isAllSelected: function () {
    return this.$$selection.length > 0 && this.$$selection.length === this.store.getLength();
  },
  hasSelection: function () {
    return this.$$selection.length > 0;
  },
  onSelectionChange: function () {}
};

/***/ }),

/***/ "./src/ui/mixin/WithActiveState.js":
/*!*****************************************!*\
  !*** ./src/ui/mixin/WithActiveState.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.mixin.WithActiveState = {
  $initConfig: function () {
    this.config.setType("active", "bool", null, false);
    this.config.makeLocalDynamic("active", "this.active");
  },
  isActive: function () {
    return this.config.get("active");
  },
  setActive: function (state) {
    state !== false && (state = true);
    var prev = this.config.get("active");
    this.config.set("active", state);

    if (prev != state) {
      this.trigger("active-state-change", this, state, prev);
    }
  },
  toggleActive: function () {
    this.setActive(!this.config.get("active"));
  }
};

/***/ }),

/***/ "./src/ui/mixin/WithDisabledState.js":
/*!*******************************************!*\
  !*** ./src/ui/mixin/WithDisabledState.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.mixin.WithDisabledState = {
  $initConfig: function () {
    this.config.setType("disabled", "bool", null, false);
    this.config.makeLocalDynamic("disabled", "this.disabled");
  },
  isDisabled: function () {
    return this.config.get("disabled");
  },
  setDisabled: function (state) {
    state !== false && (state = true);
    var prev = this.config.get("disabled");
    this.config.set("disabled", state);

    if (prev != state) {
      this.trigger("disabled-state-change", this, state, prev);
    }
  },
  toggleDisabled: function () {
    this.setDisabled(!this.config.get("disabled"));
  }
};

/***/ }),

/***/ "./src/ui/mixin/WithDropdown.js":
/*!**************************************!*\
  !*** ./src/ui/mixin/WithDropdown.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js");

module.exports = MetaphorJs.ui.mixin.WithDropdown = {
  $beforeInit: function () {
    this.$$dropdowns = [];
  },
  $beforeDestroy: function () {
    this.$$dropdowns = null;
  },
  $initChildItem: function (item) {
    this._checkDropdownItem(item);
  },
  hasDropdown: function () {
    return this.$$dropdowns.length > 0;
  },
  _checkDropdownItem: function (item) {
    var clss = this.$self.dropdownClasses,
        i,
        l;

    if (clss && item.type === "component" && item.resolved) {
      for (i = 0, l = clss.length; i < l; i++) {
        if (item.component.$is(clss[i])) {
          this._initDropdownItem(item);

          return;
        }
      }
    }
  },
  _initDropdownItem: function (item) {
    var self = this,
        dd = extend({}, self.$self.defaultDropdown);
    dd.cmp = {
      value: item.component
    };
    self.$$dropdowns.push(item.component);
    self.applyDirective("dropdown", dd);

    self._onDropdownCreated(item.component);
  },
  _onDropdownCreated: function () {}
};

/***/ }),

/***/ "./src/ui/mixin/WithLoadingState.js":
/*!******************************************!*\
  !*** ./src/ui/mixin/WithLoadingState.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.mixin.WithLoadingState = {
  $initConfig: function () {
    this.config.setType("loading", "bool", null, false);
    this.config.makeLocalDynamic("loading", "this.loading");
  },
  isLoading: function () {
    return this.config.get("loading");
  },
  setLoading: function (state) {
    state !== false && (state = true);
    var prev = this.config.get("loading");
    this.config.set("loading", state);

    if (prev != state) {
      this.trigger("loading-state-change", this, state, prev);
    }
  },
  toggleLoading: function () {
    this.setLoading(!this.config.get("loading"));
  }
};

/***/ }),

/***/ "./src/ui/mixin/WithText.js":
/*!**********************************!*\
  !*** ./src/ui/mixin/WithText.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.mixin.WithText = {
  $initConfig: function () {
    this.config.setType("text", "string", MetaphorJs.lib.Config.MODE_STATIC);
    this.config.setProperty("text", "defaultValue", "", false);
    this.config.makeLocalDynamic("text", "this.text");
  },
  getText: function () {
    return this.config.get("text");
  },
  setText: function (text) {
    this.config.set("text", text);
  }
};

/***/ }),

/***/ "./src/ui/panel/Panel.js":
/*!*******************************!*\
  !*** ./src/ui/panel/Panel.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.panel.Panel = MetaphorJs.app.Container.$extend({
  $class: "MetaphorJs.ui.panel.Panel",
  $alias: "MetaphorJs.directive.component.ui-panel",
  template: "ui/panel/panel.html"
}, {
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true
  }
});

/***/ }),

/***/ "./src/ui/toolbar/Divider.js":
/*!***********************************!*\
  !*** ./src/ui/toolbar/Divider.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../menu/Divider.js */ "./src/ui/menu/Divider.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.toolbar.Divider = MetaphorJs.ui.menu.Divider.$extend({
  $class: "MetaphorJs.ui.toolbar.Divider",
  $alias: "MetaphorJs.directive.component.ui-toolbar-divider",
  template: "ui/toolbar/divider.html"
});

/***/ }),

/***/ "./src/ui/toolbar/Item.js":
/*!********************************!*\
  !*** ./src/ui/toolbar/Item.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../menu/Item.js */ "./src/ui/menu/Item.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.toolbar.Item = MetaphorJs.ui.menu.Item.$extend({
  $class: "MetaphorJs.ui.toolbar.Item",
  $alias: "MetaphorJs.directive.component.ui-toolbar-item"
}, {
  templates: {
    item: "ui/toolbar/item.html",
    container: "ui/toolbar/container.html",
    submenu: "ui/toolbar/item-with-sub.html",
    divider: "ui/toolbar/divider.html"
  },
  dropdownClasses: ["MetaphorJs.ui.menu.Menu"],
  configProps: ["text"]
});

/***/ }),

/***/ "./src/ui/toolbar/Toolbar.js":
/*!***********************************!*\
  !*** ./src/ui/toolbar/Toolbar.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../menu/Menu.js */ "./src/ui/menu/Menu.js");

__webpack_require__(/*! ./Item.js */ "./src/ui/toolbar/Item.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.menu.Toolbar = MetaphorJs.ui.menu.Menu.$extend({
  $class: "MetaphorJs.ui.menu.Toolbar",
  $alias: "MetaphorJs.directive.component.ui-toolbar",
  template: "ui/toolbar/toolbar.html"
}, {
  allowUnwrapped: ["MetaphorJs.ui.toolbar.Item", "MetaphorJs.ui.menu.Menu", "MetaphorJs.ui.toolbar.Divider"],
  wrapper: "MetaphorJs.ui.toolbar.Item",
  classes: {
    item: "MetaphorJs.ui.toolbar.Item",
    divider: "MetaphorJs.ui.toolbar.Divider"
  }
});

/***/ }),

/***/ "./src/ui/util/Canvas.js":
/*!*******************************!*\
  !*** ./src/ui/util/Canvas.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Component.js */ "../metaphorjs/src/app/Component.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Queue.js */ "../metaphorjs-shared/src/lib/Queue.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Color.js */ "../metaphorjs-shared/src/lib/Color.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getInnerWidth.js */ "../metaphorjs/src/func/dom/getInnerWidth.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getInnerHeight.js */ "../metaphorjs/src/func/dom/getInnerHeight.js");

__webpack_require__(/*! metaphorjs/src/func/dom/whenAttached.js */ "../metaphorjs/src/func/dom/whenAttached.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js");

module.exports = MetaphorJs.ui.util.Canvas = MetaphorJs.app.Component.$extend({
  $class: "MetaphorJs.ui.util.Canvas",
  $alias: "MetaphorJs.directive.component.ui-canvas",
  template: "ui/util/canvas.html",
  as: "cnv",
  _renderQueue: null,
  _currentSize: null,
  _sizePromise: null,
  _sizeInterval: null,
  initConfig: function () {
    this.$super();
    var config = this.config,
        mst = MetaphorJs.lib.Config.MODE_STATIC;
    config.setType("width", "int", mst);
    config.setType("height", "int", mst);
  },
  initComponent: function () {
    var self = this;
    self._sizeDelegate = bind(self.getSize, self);
    self._sizePromise = new MetaphorJs.lib.Promise();
    self._renderQueue = new MetaphorJs.lib.Queue({
      async: "raf",
      auto: true,
      mode: MetaphorJs.lib.Queue.REPLACE,
      context: self
    });
  },
  queueAction: function (fn) {
    var self = this;
    self.getSizePromise().done(function () {
      self._renderQueue.add(fn);
    });
  },
  _onCfgWidthChange: function () {
    this._currentSize = null;
    this.queueAction(this.renderCanvas);
  },
  _onCfgHeightChange: function () {
    this._currentSize = null;
    this.queueAction(this.renderCanvas);
  },
  afterAttached: function () {
    var self = this,
        canvas = this.getRefEl("canvas");
    MetaphorJs.dom.whenAttached(canvas).done(function () {
      self.queueAction(self.renderCanvas);
    });
    this.config.on("width", this._onCfgWidthChange, this);
    this.config.on("height", this._onCfgHeightChange, this);
  },

  /**Sizing */
  getCtx: function () {
    if (!this._ctx) {
      var canvas = this.getRefEl("canvas");
      this._ctx = canvas.getContext('2d');
    }

    return this._ctx;
  },
  getSize: function () {
    var canvas = this.getRefEl("canvas");

    if (!this._currentSize) {
      var config = this.config;
      var w = config.has("width"),
          h = config.has("height"),
          main = this.getRefEl("main");

      if (!w) {
        if (main) {
          w = main.style.width ? parseInt(main.style.width) : parseInt(MetaphorJs.dom.getInnerWidth(main));
          w && config.setDefaultValue("width", w);
        }
      }

      if (!h) {
        if (main) {
          h = main.style.height ? parseInt(main.style.height) : parseInt(MetaphorJs.dom.getInnerHeight(main));
          h && config.setDefaultValue("height", h);
        }
      }

      w = config.get("width");
      h = config.get("height");

      if (w > 0 && h > 0) {
        this._currentSize = {
          width: w,
          height: h
        };

        if (this._sizeInterval) {
          window.clearInterval(this._sizeInterval);
          this._sizeInterval = null;
        }
      } else {
        if (!this._sizeInterval) {
          this._sizeInterval = window.setInterval(this._sizeDelegate, 50);
        }
      }
    }

    if (canvas && this._currentSize) {
      if (canvas.width != this._currentSize.width || canvas.height != this._currentSize.height) {
        canvas.width = this._currentSize.width;
        canvas.height = this._currentSize.height;
        canvas.setAttribute("width", this._currentSize.width);
        canvas.setAttribute("height", this._currentSize.height);
      }

      if (this._sizePromise && this._sizePromise.isPending()) {
        // delay rendering
        this._sizePromise.after(new MetaphorJs.lib.Promise(function (resolve) {
          window.setTimeout(resolve, 100);
        }));
      }
    }

    if (this._currentSize && this._sizePromise.isPending()) {
      this._sizePromise.resolve(this._currentSize);
    }

    return this._currentSize;
  },
  getSizePromise: function () {
    this.getSize();
    return this._sizePromise;
  },
  getCanvasWidth: function () {
    return this.getSize().width;
  },
  getCanvasHeight: function () {
    return this.getSize().height;
  },

  /**Rendering */
  renderCanvas: function () {},
  onDestroy: function () {
    this._renderQueue.$destroy();

    this._sizePromise.$destroy();

    this.$super();
  }
}, {
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true,
    click: true,
    dblclick: true,
    mousedown: true,
    mouseup: true,
    mousemove: true
  }
});

/***/ }),

/***/ "./src/ui/util/Color.js":
/*!******************************!*\
  !*** ./src/ui/util/Color.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Component.js */ "../metaphorjs/src/app/Component.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Queue.js */ "../metaphorjs-shared/src/lib/Queue.js");

__webpack_require__(/*! ./Canvas.js */ "./src/ui/util/Canvas.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Color.js */ "../metaphorjs-shared/src/lib/Color.js");

__webpack_require__(/*! metaphorjs/src/func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getOffset.js */ "../metaphorjs/src/func/dom/getOffset.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getScrollTop.js */ "../metaphorjs/src/func/dom/getScrollTop.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getScrollLeft.js */ "../metaphorjs/src/func/dom/getScrollLeft.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js");

module.exports = MetaphorJs.ui.util.Color = MetaphorJs.ui.util.Canvas.$extend({
  $class: "MetaphorJs.ui.util.Color",
  template: "ui/util/color.html",
  _apis: ["dom", "input"],
  _lastX: 0,
  _lastY: 0,
  initComponent: function () {
    var self = this;
    self.$super();
    self.state.pointerLeft = null;
    self.state.pointerTop = null;
    self._mouseDownDelegate = bind(self.onMouseDown, self);
    self._mouseUpDelegate = bind(self.onMouseUp, self);
    self._mouseMoveDelegate = bind(self.onMouseMove, self);
    self._touchDownDelegate = bind(self.onTouchDown, self);
    self._touchUpDelegate = bind(self.onTouchUp, self);
    self._touchMoveDelegate = bind(self.onTouchMove, self);
  },
  isDragging: function () {
    return this._drag;
  },
  afterAttached: function () {
    var self = this;
    self.$super();
    self.queueAction(self.updatePointer);
    var el = self.getRefEl("main");
    MetaphorJs.dom.addListener(el, "mousedown", self._mouseDownDelegate);
    MetaphorJs.dom.addListener(el, "touchstart", self._touchDownDelegate, {
      passive: false
    });
  },
  renderCanvas: function () {},
  updateColor: function () {},
  updatePointer: function () {},

  /**Mouse handling */
  updateCoords: function (e) {
    var size = this.getSize(),
        evt = e.type.indexOf("touch") !== -1 ? e.changedTouches[0] : e,
        clientX = evt.clientX,
        clientY = evt.clientY,
        ofs = MetaphorJs.dom.getOffset(this.getRefEl("main")),
        st = MetaphorJs.dom.getScrollTop(),
        sl = MetaphorJs.dom.getScrollLeft(),
        x = clientX + sl - ofs.left,
        y = clientY + st - ofs.top;
    x < 0 && (x = 0);
    y < 0 && (y = 0);
    x > size.width && (x = size.width);
    y > size.height && (y = size.height);
    this._lastX = x;
    this._lastY = y;
  },
  onTouchDown: function (e) {
    e.preventDefault();
    var b = window.document.body;
    MetaphorJs.dom.addListener(b, "touchend", this._touchUpDelegate, {
      passive: false
    });
    MetaphorJs.dom.addListener(b, "touchmove", this._touchMoveDelegate, {
      passive: false
    });
    this._drag = true;
    this.updateCoords(e);
    this.updateColor();
    this.updatePointer();
  },
  onTouchMove: function (e) {
    e.preventDefault();
    this.onMouseMove(e);
  },
  onTouchUp: function (e) {
    e.preventDefault();
    var b = window.document.body;
    MetaphorJs.dom.removeListener(b, "touchend", this._touchUpDelegate);
    MetaphorJs.dom.removeListener(b, "touchmove", this._touchMoveDelegate);
    this.state.$check();
    this._drag = false;
  },
  onMouseDown: function (e) {
    var b = window.document.body;
    MetaphorJs.dom.addListener(b, "mouseup", this._mouseUpDelegate);
    MetaphorJs.dom.addListener(b, "mousemove", this._mouseMoveDelegate);
    this._drag = true;
    this.updateCoords(e);
    this.updateColor();
    this.updatePointer();
  },
  onMouseMove: function (e) {
    if (this._drag) {
      this.updateCoords(e);
      this.updateColor();
      this.updatePointer();
      this.state.$check();
    }
  },
  onMouseUp: function (e) {
    var b = window.document.body;
    MetaphorJs.dom.removeListener(b, "mouseup", this._mouseUpDelegate);
    MetaphorJs.dom.removeListener(b, "mousemove", this._mouseMoveDelegate);
    this.state.$check();
    this._drag = false;
  },

  /* Input API */
  setValue: emptyFn,
  getValue: emptyFn,
  onKey: emptyFn,
  unKey: emptyFn,
  onChange: function (fn, ctx, opt) {
    return this.on("change", fn, ctx, opt);
  },
  unChange: function (fn, ctx) {
    return this.un("change", fn, ctx);
  },
  getInputApi: function () {
    return this;
  }
}, {
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true,
    bind: true,
    model: true,
    input: true,
    click: true,
    dblclick: true,
    mousedown: true,
    mouseup: true,
    mousemove: true,
    mouseover: true,
    mouseout: true
  }
});

/***/ }),

/***/ "./src/ui/util/ColorAlpha.js":
/*!***********************************!*\
  !*** ./src/ui/util/ColorAlpha.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ./Color.js */ "./src/ui/util/Color.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Color.js */ "../metaphorjs-shared/src/lib/Color.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.util.ColorAlpha = MetaphorJs.ui.util.Color.$extend({
  $class: "MetaphorJs.ui.util.ColorAlpha",
  $alias: "MetaphorJs.directive.component.ui-color-alpha",
  _apis: ["dom", "input"],
  _color: null,
  _alpha: null,
  _lastX: 0,
  _lastY: 0,
  initConfig: function () {
    this.$super();
    var self = this,
        config = self.config,
        mst = MetaphorJs.lib.Config.MODE_STATIC;
    config.setType("position", "string", mst, "v");
    config.setType("cursor", "string", mst);
    config.setType("alpha", "float", null, 1);
    config.setDefaultValue("color", "hsva(0,100,100,1)");
    config.on("alpha", self.setValue, self);
    config.on("color", self.setColor, self);
    config.on("hue", self.setHue, self);
  },
  initComponent: function () {
    this.$super();
    this._color = new MetaphorJs.lib.Color(null, "hsva");

    this._color.setColor(this.config.get("color"));

    if (this.config.has("alpha")) {
      this._alpha = this.config.get("alpha");

      this._color.setAlpha(this._alpha);
    } else this._alpha = this._color.getAlpha();
  },
  setColor: function (color) {
    this._color.setColor(color);

    if (this._attached) {
      this.queueAction(this.renderCanvas);
    }
  },
  setHue: function (hue) {
    this._color.setHSVA(hue);

    if (this._attached) {
      this.queueAction(this.renderCanvas);
    }
  },
  setValue: function (alpha) {
    alpha = parseFloat(alpha);
    alpha < 0 && (alpha = 0);
    alpha > 1 && (alpha = 1);
    var prev = this._alpha;
    this._alpha = alpha;

    if (alpha != prev) {
      if (this._attached) {
        this.queueAction(this.updatePointer);
      }

      this.trigger("change", alpha, prev);
    }
  },

  /**Rendering */
  renderCanvas: function () {
    var self = this,
        ctx = self.getCtx(),
        size = self.getSize(),
        pos = self.config.get("position"),
        c = new MetaphorJs.lib.Color(this._color),
        grd;
    c.setAlpha(1);
    ctx.clearRect(0, 0, size.width, size.height);
    ctx.rect(0, 0, size.width, size.height);

    if (pos === "v") {
      grd = ctx.createLinearGradient(0, 0, 0, size.height);
    } else {
      grd = ctx.createLinearGradient(0, 0, size.width, 0);
    }

    grd.addColorStop(0, c.getRGBAString());
    c.setAlpha(0);
    grd.addColorStop(1, c.getRGBAString());
    ctx.fillStyle = grd;
    ctx.fill();
  },

  /** Color */
  _getIntValue: function () {
    var pos = this.config.get("position"),
        size = this.getSize()[pos === "v" ? "height" : "width"],
        mouse = this[pos === "v" ? "_lastY" : "_lastX"];
    return 1 - mouse / size;
  },
  updateColor: function () {
    this.setValue(this._getIntValue());
  },
  updatePointer: function () {
    var mouse,
        pos = this.config.get("position"),
        size = this.getSize(),
        skey = pos === 'v' ? 'height' : 'width',
        pkeyPrim = pos === 'v' ? 'pointerTop' : 'pointerLeft',
        pkeySec = pos === 'v' ? 'pointerLeft' : 'pointerTop',
        ckey = pos === 'v' ? '_lastY' : '_lastX'; // follow mouse

    if (this._drag) {
      mouse = this[ckey];
    } // reflect current value
    else {
      mouse = (1 - this._alpha) * size[skey];
    }

    mouse < 0 && (mouse = 0);
    mouse > size[skey] && (mouse = size[skey]);
    this.state[pkeySec] = "50%";
    this.state[pkeyPrim] = parseInt(mouse) + "px"; // if pointer is updated via renderQueue

    if (!this._drag) {
      this.state.$check();
    }
  }
}, {
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true,
    bind: true,
    model: true,
    input: true,
    click: true,
    dblclick: true,
    mousedown: true,
    mouseup: true,
    mousemove: true,
    mouseover: true,
    mouseout: true
  }
});

/***/ }),

/***/ "./src/ui/util/ColorHue.js":
/*!*********************************!*\
  !*** ./src/ui/util/ColorHue.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ./Color.js */ "./src/ui/util/Color.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Color.js */ "../metaphorjs-shared/src/lib/Color.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.util.ColorHue = MetaphorJs.ui.util.Color.$extend({
  $class: "MetaphorJs.ui.util.ColorHue",
  $alias: "MetaphorJs.directive.component.ui-color-hue",
  _apis: ["dom", "input"],
  _hue: 0,
  _lastX: 0,
  _lastY: 0,
  initConfig: function () {
    this.$super();
    var config = this.config,
        mst = MetaphorJs.lib.Config.MODE_STATIC;
    config.setType("position", "string", mst, "v");
    config.setType("cursor", "string", mst);
    config.setType("hue", "float", null, 0);
    config.on("hue", this.setValue, this);
  },
  initComponent: function () {
    this.$super();

    if (this.config.has("hue")) {
      this._hue = this.config.get("hue");
    }
  },
  setValue: function (hue) {
    hue = parseFloat(hue);
    hue < 0 && (hue = 0);
    hue > 360 && (hue = 360);
    var prev = this._hue;
    this._hue = hue;

    if (this._attached) {
      this.queueAction(this.updatePointer);
    }

    if (hue !== prev) {
      this.trigger("change", hue, prev);
    }
  },

  /**Rendering */
  renderCanvas: function () {
    var self = this,
        ctx = self.getCtx(),
        size = self.getSize(),
        pos = self.config.get("position"),
        grd;
    ctx.clearRect(0, 0, size.width, size.height);
    ctx.rect(0, 0, size.width, size.height);

    if (pos === "v") {
      grd = ctx.createLinearGradient(0, 0, 0, size.height);
    } else {
      grd = ctx.createLinearGradient(0, 0, size.width, 0);
    }

    grd.addColorStop(0, 'rgba(255, 0, 0, 1)');
    grd.addColorStop(0.17, 'rgba(255, 255, 0, 1)');
    grd.addColorStop(0.34, 'rgba(0, 255, 0, 1)');
    grd.addColorStop(0.51, 'rgba(0, 255, 255, 1)');
    grd.addColorStop(0.68, 'rgba(0, 0, 255, 1)');
    grd.addColorStop(0.85, 'rgba(255, 0, 255, 1)');
    grd.addColorStop(1, 'rgba(255, 0, 0, 1)');
    ctx.fillStyle = grd;
    ctx.fill();
  },

  /** Color */
  _getIntValue: function () {
    var pos = this.config.get("position"),
        size = this.getSize()[pos === "v" ? "height" : "width"],
        mouse = this[pos === "v" ? "_lastY" : "_lastX"];
    return mouse / size * 360;
  },
  updateColor: function () {
    this.setValue(this._getIntValue());
  },
  updatePointer: function () {
    var mouse,
        pos = this.config.get("position"),
        size = this.getSize(),
        skey = pos === 'v' ? 'height' : 'width',
        pkeyPrim = pos === 'v' ? 'pointerTop' : 'pointerLeft',
        pkeySec = pos === 'v' ? 'pointerLeft' : 'pointerTop',
        ckey = pos === 'v' ? '_lastY' : '_lastX'; // follow mouse

    if (this._drag) {
      mouse = this[ckey];
    } // reflect current value
    else {
      mouse = this._hue / 360 * size[skey];
    }

    mouse < 0 && (mouse = 0);
    mouse > size[skey] && (mouse = size[skey]);
    this.state[pkeySec] = "50%";
    this.state[pkeyPrim] = parseInt(mouse) + "px"; // if pointer is updated via renderQueue

    if (!this._drag) {
      this.state.$check();
    }
  }
}, {
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true,
    bind: true,
    model: true,
    input: true,
    click: true,
    dblclick: true,
    mousedown: true,
    mouseup: true,
    mousemove: true,
    mouseover: true,
    mouseout: true
  }
});

/***/ }),

/***/ "./src/ui/util/ColorPicker.js":
/*!************************************!*\
  !*** ./src/ui/util/ColorPicker.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Color.js */ "../metaphorjs-shared/src/lib/Color.js");

__webpack_require__(/*! ../../filter/color.js */ "./src/filter/color.js");

__webpack_require__(/*! ./ColorSV.js */ "./src/ui/util/ColorSV.js");

__webpack_require__(/*! ./ColorHue.js */ "./src/ui/util/ColorHue.js");

__webpack_require__(/*! ./ColorAlpha.js */ "./src/ui/util/ColorAlpha.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js");

module.exports = MetaphorJs.ui.util.ColorPicker = MetaphorJs.app.Container.$extend({
  $class: "MetaphorJs.ui.util.ColorPicker",
  $alias: "MetaphorJs.directive.component.ui-color-picker",
  template: "ui/util/color-picker.html",
  as: "pckr",
  _apis: ["node", "input"],
  _updating: false,
  _color: null,
  _prev: null,
  initComponent: function () {
    this.$super();
    this._color = this.state.color = new MetaphorJs.lib.Color(null, "hsva");

    this._color.setColor(this.config.get("color"));

    this._prev = this._color.getHSVAString();
  },
  initConfig: function () {
    this.$super();
    this.config.setType("color", null, null, "hsva(0,100,100,1)");
  },
  afterRender: function () {
    this._updateCanvas();
  },
  _frame: function (val, min, max) {
    val = parseFloat(val);
    val < min && (val = min);
    val > max && (val = max);
    return val;
  },
  _updateCanvas: function () {
    this._updating = true;
    var sv = this.getRefCmp("sv"),
        hue = this.getRefCmp("hue"),
        alpha = this.getRefCmp("alpha"),
        c = this._color;
    sv && sv.setValue(c);
    hue && hue.setValue(c.getH());
    alpha && alpha.setValue(c.getAlpha());
    this.state.$check();
    this._updating = false;
  },
  onInputHex: function (hex) {
    hex = ("" + hex).toLowerCase().trim();

    if (hex.substring(0, 1) === "#") {
      hex = hex.substring(1);
    }

    if (hex === this._color.getHEX()) {
      return;
    }

    var c = new MetaphorJs.lib.Color(hex);

    if (c.getHEX() === hex) {
      this._color.setColor(hex);

      this._updateCanvas();

      this._onChange();
    }
  },
  onInputRgba: function (rgbaStr) {
    rgbaStr = ("" + rgbaStr).toLowerCase().trim();
    rgbaStr = rgbaStr.replace(/\s+/g, '');

    this._color.setColor(rgbaStr);

    this._updateCanvas();

    this._onChange();
  },
  _onInputRGBA: function (r, g, b, a) {
    this._color.setRGBA(r, g, b, a);

    this._updateCanvas();

    this._onChange();
  },
  onInputR: function (r) {
    this._onInputRGBA(this._frame(r, 0, 255));
  },
  onInputG: function (g) {
    this._onInputRGBA(null, this._frame(g, 0, 255));
  },
  onInputB: function (b) {
    this._onInputRGBA(null, null, this._frame(b, 0, 255));
  },
  onInputA: function (a) {
    this._onInputRGBA(null, null, null, this._frame(a, 0, 1));
  },
  _onInputHSV: function (h, s, v) {
    this._color.setHSVA(h, s, v);

    this._updateCanvas();

    this._onChange();
  },
  onInputH: function (h) {
    this._onInputHSV(this._frame(h, 0, 360));
  },
  onInputS: function (s) {
    this._onInputHSV(null, this._frame(s, 0, 100));
  },
  onInputV: function (v) {
    this._onInputHSV(null, null, this._frame(v, 0, 100));
  },
  onInputSV: function (sv) {
    if (this.getRefCmp("sv").isDragging()) {
      this._color.setHSVA(null, sv[0], sv[1]);

      this._onChange();
    }
  },
  onInputHue: function (hue) {
    if (this.getRefCmp("hue").isDragging()) {
      this._color.setHSVA(hue);

      this._onChange();
    }
  },
  onInputAlpha: function (a) {
    if (this.getRefCmp("alpha").isDragging()) {
      this._color.setAlpha(a);

      this._onChange();
    }
  },
  _onChange: function () {
    var val = this._color.getRGBAString(),
        prev = this._prev;

    if (prev !== val) {
      this._prev = val;
      this.trigger("change", val, prev, this._color, this);
    }
  },

  /* Input API */
  setValue: function (color) {
    this._color.setColor(color);

    this._onChange();

    this.state.$check();

    this._updateCanvas();
  },
  getValue: function () {
    return this._color;
  },
  onKey: emptyFn,
  unKey: emptyFn,
  onChange: function (fn, ctx, opt) {
    return this.on("change", fn, ctx, opt);
  },
  unChange: function (fn, ctx) {
    return this.un("change", fn, ctx);
  },
  getInputApi: function () {
    return this;
  }
}, {
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true,
    bind: true,
    model: true,
    click: true,
    dblclick: true,
    mousedown: true,
    mouseup: true,
    mousemove: true,
    mouseover: true,
    mouseout: true
  }
});

/***/ }),

/***/ "./src/ui/util/ColorSV.js":
/*!********************************!*\
  !*** ./src/ui/util/ColorSV.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ./Color.js */ "./src/ui/util/Color.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Color.js */ "../metaphorjs-shared/src/lib/Color.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.util.ColorSV = MetaphorJs.ui.util.Color.$extend({
  $class: "MetaphorJs.ui.util.ColorSV",
  $alias: "MetaphorJs.directive.component.ui-color-sv",
  _color: null,
  _lastX: 0,
  _lastY: 0,
  _sv: null,
  _hue: null,
  initConfig: function () {
    this.$super();
    var config = this.config,
        mst = MetaphorJs.lib.Config.MODE_STATIC;
    config.setType("cursor", "string", mst);
    config.setType("color", null, null, "hsva(0,100,100,1)");
    config.on("color", this.setColor, this);
    config.on("hue", this.setHue, this);
  },
  initComponent: function () {
    this.$super();
    this._color = new MetaphorJs.lib.Color(null, "hsva");

    this._color.setColor(this.config.get("color"));

    this._color.setAlpha(1);

    if (this.config.has("hue")) {
      this._color.setHSVA(this.config.get("hue"));
    }

    this._sv = [this._color.getS(), this._color.getV()];
    this._hue = this._color.getH();
  },
  setColor: function () {
    var c = new MetaphorJs.lib.Color(this.config.get("color"), "hsva");
    this.setHue(c.getH());
    this.setValue([c.getS(), c.getV()]);
  },
  setHue: function (hue) {
    if (this._color.getH() !== hue) {
      this._color.setHSVA(hue);

      this._hue = this._color.getH();

      if (this._attached) {
        this.queueAction(this.renderCanvas);
      }
    }
  },
  setValue: function (sv) {
    var prev = this._sv,
        c = this._color;
    c.setHSVA(this._hue, sv[0], sv[1]);

    if (prev[0] !== c.getS() || prev[1] !== c.getV()) {
      if (this._attached) {
        this.queueAction(this.updatePointer);
      }

      this._sv = sv;
      this.trigger("change", sv, prev);
    }
  },

  /**Rendering */
  renderCanvas: function () {
    var self = this,
        ctx = self.getCtx(),
        size = self.getSize(),
        c = new MetaphorJs.lib.Color(null, "hsva");
    c.setHSVA(this._color.getH(), 100, 100);
    ctx.clearRect(0, 0, size.width, size.height);
    ctx.rect(0, 0, size.width, size.height);
    ctx.fillStyle = c.getRGBAString();
    ctx.fillRect(0, 0, size.width, size.height);
    var grdWhite = ctx.createLinearGradient(0, 0, size.width, 0);
    grdWhite.addColorStop(0, 'rgba(255,255,255,1)');
    grdWhite.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = grdWhite;
    ctx.fillRect(0, 0, size.width, size.height);
    var grdBlack = ctx.createLinearGradient(0, 0, 0, size.height);
    grdBlack.addColorStop(0, 'rgba(0,0,0,0)');
    grdBlack.addColorStop(1, 'rgba(0,0,0,1)');
    ctx.fillStyle = grdBlack;
    ctx.fillRect(0, 0, size.width, size.height);
  },

  /** Color */
  _getS: function () {
    var size = this.getSize().width,
        mouse = this._lastX;
    return parseInt(mouse / size * 100);
  },
  _getV: function () {
    var size = this.getSize().height,
        mouse = this._lastY;
    return 100 - parseInt(mouse / size * 100);
  },
  updateColor: function () {
    this.setValue([this._getS(), this._getV()]);
  },
  updatePointer: function () {
    var size = this.getSize(),
        pleft,
        ptop,
        x,
        y,
        hsva;

    if (!size || !size.width) {
      return;
    } // follow mouse


    if (this._drag) {
      x = this._lastX;
      y = this._lastY;
      x < 0 && (x = 0);
      x > size.width && (x = size.width);
      y < 0 && (y = 0);
      y > size.width && (y = size.width);
      x = x / size.width;
      y = y / size.height;
      pleft = parseInt(x * 100) + "%";
      ptop = parseInt(y * 100) + "%";
    } // reflect current value
    else {
      hsva = this._color.getHSVA();
      pleft = hsva[1] + "%";
      ptop = 100 - hsva[2] + "%";
    }

    this.state.pointerLeft = pleft;
    this.state.pointerTop = ptop; // if pointer is updated via renderQueue

    if (!this._drag) {
      this.state.$check();
    }
  }
}, {
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true,
    bind: true,
    model: true,
    input: true,
    click: true,
    dblclick: true,
    mousedown: true,
    mouseup: true,
    mousemove: true,
    mouseover: true,
    mouseout: true
  }
});

/***/ }),

/***/ "./src/ui/util/Pagination.js":
/*!***********************************!*\
  !*** ./src/ui/util/Pagination.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getOffset.js */ "../metaphorjs/src/func/dom/getOffset.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getScrollParent.js */ "../metaphorjs/src/func/dom/getScrollParent.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.util.Pagination = MetaphorJs.app.Container.$extend({
  $class: "MetaphorJs.ui.util.Pagination",
  $alias: "MetaphorJs.directive.component.ui-pagination",
  template: "ui/util/pagination.html",
  _apis: ["dom", "input"],
  initComponent: function () {
    var state = this.state;
    state.start = 0;
    state.limit = 0;
    state.total = 0;
    state.pages = 0;
    state.page = 0;
    state.hasPrev = 0;
    state.hasNext = 0;
    state.loading = false;
    state.changePage = 0;
    state.hidden = true;
    var store = this.config.get("store") || (this.parentCmp ? this.parentCmp.store : null);
    store && this.setStore(store);
  },
  initConfig: function () {
    var config = this.config,
        mst = MetaphorJs.lib.Config.MODE_STATIC;
    config.setType("as", null, null, "pgn");
    config.setType("simple", "bool", mst, false);
    config.setType("autoscroll", "bool", mst, false);
    config.setType("store", null, MetaphorJs.lib.Config.MODE_DYNAMIC);
    config.on("simple", this.updatePages, this, {
      async: true
    });
  },
  setStore: function (s) {
    this.store && this._bindStore(this.store, "un");
    this.store = s;
    s && this._bindStore(s, "on");
    s && this.updatePages();
  },
  _bindStore: function (s, fn) {
    s[fn]("loading-start", this.onStoreStartLoading, this);
    s[fn]("load", this.onStoreLoad, this);
    s[fn]("update", this.onStoreLoad, this);
  },
  $onPropertyChange: function (val, prev, name) {
    if (name === "simple" && (val === false || val === true)) {
      async(this.updatePages, this);
    }
  },
  onStoreStartLoading: function () {
    this.state.$set({
      loading: true
    });
  },
  onStoreLoad: function () {
    this.updatePages();
  },
  updatePages: function () {
    var store = this.store,
        total,
        count,
        start = store.start,
        pageSize = store.pageSize,
        pages,
        page;

    if (!this.config.get("simple")) {
      total = store.getTotalLength();

      if (!pageSize) {
        pageSize = total;
      }

      pages = Math.ceil(total / pageSize);
      page = Math.floor(start / pageSize) + 1;
      this.state.$set({
        start: start,
        end: Math.min(start + pageSize, total),
        limit: pageSize,
        total: total,
        pages: pages,
        changePage: page,
        page: page,
        hasPrev: page > 1,
        hasNext: page < pages,
        loading: false,
        hidden: pages < 2
      });
    } else {
      count = store.getLength();
      this.state.$set({
        loading: false,
        start: start,
        end: start + count,
        limit: pageSize,
        hasNext: count >= pageSize,
        hasPrev: start > 0,
        hidden: start === 0 && count < pageSize
      });
    }
  },
  onPrevClick: function () {
    this.store.loadPrevPage();
    this.scrollToParent();
  },
  onNextClick: function () {
    this.store.loadNextPage();
    this.scrollToParent();
  },
  hasPages: function () {
    return !this.config.get("simple") ? this.state.pages > 1 : true;
  },
  onPageKeyDown: function () {
    var page = this.state.changePage;

    if (isNaN(page)) {
      page = 1;
    }

    if (page < 1) {
      page = 1;
    }

    if (page > this.state.pages) {
      page = this.state.pages;
    }

    this.state.$set({
      page: page
    });
    this.store.loadPage((this.state.page - 1) * this.state.limit);
    this.scrollToParent();
  },
  scrollToParent: function () {
    if (this.config.get("autoscroll") === false) {
      return;
    }

    var sp = MetaphorJs.dom.getScrollParent(this.$refs.node.main.parentNode);

    if (sp) {
      if (sp === document.body) {
        if (this.parentCmp) {
          var ofs = MetaphorJs.dom.getOffset(this.parentCmp.getRefEl("main"));
          sp.scrollTop = ofs.top;
          document.documentElement.scrollTop = ofs.top;
        }
      } else {
        sp.scrollTop = 0;
      }
    }
  },
  onDestroy: function () {
    this.setStore(null);
  }
}, {
  resolve: {
    parentCmp: '$parentCmp'
  },
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true,
    "in-focus": "input"
  }
});

/***/ }),

/***/ "./src/ui/window/Window.js":
/*!*********************************!*\
  !*** ./src/ui/window/Window.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../__init.js */ "./src/__init.js");

__webpack_require__(/*! metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.ui.window.Window = MetaphorJs.app.Container.$extend({
  $class: "MetaphorJs.ui.window.Window",
  template: "ui/window/window.html",
  _initDraggable: function () {}
}, {
  supportsDirectives: {
    show: true,
    hide: true,
    class: true,
    style: true
  }
});

/***/ }),

/***/ "../metaphorjs-validator/src/__init.js":
/*!*********************************************!*\
  !*** ../metaphorjs-validator/src/__init.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"); // add namespace manually


MetaphorJs.validator = MetaphorJs.validator || {};

/***/ }),

/***/ "../metaphorjs-validator/src/directive/form.js":
/*!*****************************************************!*\
  !*** ../metaphorjs-validator/src/directive/form.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const Directive = __webpack_require__(/*! metaphorjs/src/app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      ns = __webpack_require__(/*! metaphorjs-namespace/src/var/ns.js */ "../metaphorjs-namespace/src/var/ns.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

__webpack_require__(/*! ../validator/Component.js */ "../metaphorjs-validator/src/validator/Component.js");

Directive.registerAttribute("form", 250, function () {
  var dir = function form_directive(state, node, config, renderer, attrSet) {
    dir.initConfig(config);
    var cls = config.get("value"),
        constr = ns.get(cls);

    if (!constr) {
      error(new Error("Class '" + cls + "' not found"));
    } else {
      Directive.resolveNode(node, "form", function (node) {
        if (!renderer.$destroyed) {
          var v = new constr(node, state, renderer, config);
          renderer.on("destroy", v.$destroy, v);
        }
      });
    }
  };

  dir.initConfig = function (config) {
    config.setProperty("value", {
      mode: MetaphorJs.lib.Config.MODE_STATIC,
      type: "string",
      defaultValue: "MetaphorJs.validator.Component"
    });
    config.setMode("submit", MetaphorJs.lib.Config.MODE_FUNC);
  };

  dir.deepInitConfig = function (config) {
    MetaphorJs.validator.Component.initConfig(config);
  };

  return dir;
}());

/***/ }),

/***/ "../metaphorjs-validator/src/directive/validate.js":
/*!*********************************************************!*\
  !*** ../metaphorjs-validator/src/directive/validate.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs/src/func/dom/data.js */ "../metaphorjs/src/func/dom/data.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ../validator/Validator.js */ "../metaphorjs-validator/src/validator/Validator.js");

const Directive = __webpack_require__(/*! metaphorjs/src/app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("validate", 200, function () {
  var dir = function validate_directive(state, node, config, renderer) {
    Directive.resolveNode(node, "validate", function (node) {
      if (!renderer.$destroyed) {
        var id = MetaphorJs.dom.getAttr(node, "name") || MetaphorJs.dom.getAttr(node, "id"),
            v = MetaphorJs.validator.Validator.getValidator(node),
            f = v ? v.getField(id) : null;

        if (f) {
          f.setConfigRules(config);
        }

        config.clear();
      }
    });
  };

  dir.deepInitConfig = function (config) {
    MetaphorJs.validator.Field.deepInitConfig(config);
  };

  return dir;
}());

/***/ }),

/***/ "../metaphorjs-validator/src/func/checkable.js":
/*!*****************************************************!*\
  !*** ../metaphorjs-validator/src/func/checkable.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs-validator/src/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.validator.checkable = function (elem) {
  return /radio|checkbox/i.test(elem.type);
};

/***/ }),

/***/ "../metaphorjs-validator/src/func/empty.js":
/*!*************************************************!*\
  !*** ../metaphorjs-validator/src/func/empty.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs-validator/src/__init.js");

__webpack_require__(/*! ./checkable.js */ "../metaphorjs-validator/src/func/checkable.js");

__webpack_require__(/*! ./getLength.js */ "../metaphorjs-validator/src/func/getLength.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getInputValue.js */ "../metaphorjs/src/func/dom/getInputValue.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"); // from http://bassistance.de/jquery-plugins/jquery-plugin-validation/


module.exports = MetaphorJs.validator.empty = function (value, element) {
  if (!element) {
    return value == undefined || value === '';
  }

  switch (element.nodeName.toLowerCase()) {
    case 'select':
      {
        // could be an array for select-multiple or a string, both are fine this way
        var val = MetaphorJs.dom.getInputValue(element);
        return !val || val.length == 0;
      }

    case 'input':
      {
        if (MetaphorJs.validator.checkable(element)) return MetaphorJs.validator.getLength(value, element) == 0;
        break;
      }
  }

  return value.trim().length == 0;
};

/***/ }),

/***/ "../metaphorjs-validator/src/func/format.js":
/*!**************************************************!*\
  !*** ../metaphorjs-validator/src/func/format.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs-validator/src/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js");

module.exports = MetaphorJs.validator.format = function (str, params) {
  if (isFunction(params)) {
    return str;
  }

  if (!isArray(params)) {
    params = [params];
  }

  var i,
      l = params.length;

  for (i = -1; ++i < l; str = str.replace(new RegExp("\\{" + i + "\\}", "g"), params[i])) {}

  return str;
};

/***/ }),

/***/ "../metaphorjs-validator/src/func/getLength.js":
/*!*****************************************************!*\
  !*** ../metaphorjs-validator/src/func/getLength.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs-validator/src/__init.js");

__webpack_require__(/*! ./checkable.js */ "../metaphorjs-validator/src/func/checkable.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      eachNode = __webpack_require__(/*! metaphorjs/src/func/dom/eachNode.js */ "../metaphorjs/src/func/dom/eachNode.js"),
      select = __webpack_require__(/*! metaphorjs/src/func/dom/select.js */ "../metaphorjs/src/func/dom/select.js"),
      isAttached = __webpack_require__(/*! metaphorjs/src/func/dom/isAttached.js */ "../metaphorjs/src/func/dom/isAttached.js"); // from http://bassistance.de/jquery-plugins/jquery-plugin-validation/


module.exports = MetaphorJs.validator.getLength = function (value, el) {
  var l = 0;

  switch (el.nodeName.toLowerCase()) {
    case 'select':
      eachNode(el, function (node) {
        if (node.selected) {
          l++;
        }
      });
      return l;

    case 'input':
      if (MetaphorJs.validator.checkable(el)) {
        if (el.form) {
          eachNode(el.form, function (node) {
            if (node.type == el.type && node.name == el.name && node.checked) {
              l++;
            }
          });
        } else {
          var parent, inputs, i, len;

          if (isAttached(el)) {
            parent = el.ownerDocument;
          } else {
            parent = el;

            while (parent.parentNode) {
              parent = parent.parentNode;
            }
          }

          inputs = select("input[name=" + el.name + "]", parent);

          for (i = 0, len = inputs.length; i < len; i++) {
            if (inputs[i].checked) {
              l++;
            }
          }
        }

        return l;
      }

  }

  return value.length;
};

/***/ }),

/***/ "../metaphorjs-validator/src/validator/Component.js":
/*!**********************************************************!*\
  !*** ../metaphorjs-validator/src/validator/Component.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      error = __webpack_require__(/*! metaphorjs-shared/src/func/error.js */ "../metaphorjs-shared/src/func/error.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../__init.js */ "../metaphorjs-validator/src/__init.js");

__webpack_require__(/*! ./Validator.js */ "../metaphorjs-validator/src/validator/Validator.js");

__webpack_require__(/*! metaphorjs/src/lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! metaphorjs/src/func/dom/eachNode.js */ "../metaphorjs/src/func/dom/eachNode.js");

__webpack_require__(/*! metaphorjs/src/func/dom/isField.js */ "../metaphorjs/src/func/dom/isField.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

module.exports = MetaphorJs.validator.Component = cls({
  node: null,
  state: null,
  validator: null,
  stateData: null,
  fields: null,
  formName: null,
  nodeCfg: null,
  $init: function (node, state, renderer, nodeCfg) {
    var self = this;
    self.$self.initConfig(nodeCfg);
    self.node = node;
    self.state = state;
    self.stateData = {};
    self.fields = [];
    self.nodeCfg = nodeCfg;
    self.validator = self.createValidator();
    self.formName = nodeCfg.get("ref") || MetaphorJs.dom.getAttr(node, 'name') || MetaphorJs.dom.getAttr(node, 'id') || '$form';
    self.initState();
    self.initStateData();
    self.initValidatorEvents(); // wait for the renderer to finish
    // before making judgements :)

    renderer.on("rendered", self.validator.check, self.validator, {
      once: true
    });
    renderer.on("destroy", self.$destroy, self);
    state.$on("destroy", self.$destroy, self);
  },
  createValidator: function () {
    var self = this,
        node = self.node,
        cfg = {},
        ncfg = self.nodeCfg,
        submit;

    if (submit = ncfg.get("submit")) {
      cfg.callback = cfg.callback || {};

      cfg.callback.submit = function (fn, state) {
        return function () {
          try {
            return fn(state);
          } catch (thrownError) {
            error(thrownError);
          }
        };
      }(submit, self.state);
    }

    return new MetaphorJs.validator.Validator(node, cfg);
  },
  initValidatorEvents: function () {
    var self = this,
        v = self.validator;
    v.on('field-state-change', self.onFieldStateChange, self);
    v.on('state-change', self.onFormStateChange, self);
    v.on('display-state-change', self.onDisplayStateChange, self);
    v.on('field-error-change', self.onFieldErrorChange, self);
    v.on('reset', self.onFormReset, self);
  },
  initState: function () {
    const state = this.state,
          name = this.formName;
    state[name] = this.stateData;
  },
  initStateData: function () {
    var self = this,
        node = self.node,
        state = self.stateData,
        fields = self.fields,
        els,
        el,
        i,
        l,
        name;

    if (node.elements) {
      els = node.elements;
    } else {
      els = [];
      MetaphorJs.dom.eachNode(node, function (el) {
        if (MetaphorJs.dom.isField(el)) {
          els.push(el);
        }
      });
    }

    for (i = -1, l = els.length; ++i < l;) {
      el = els[i];
      name = MetaphorJs.dom.getAttr(el, "name") || MetaphorJs.dom.getAttr(el, 'id');

      if (name && !state[name]) {
        fields.push(name);
        state[name] = {
          $error: null,
          $invalid: null,
          $pristine: true,
          $errorMessage: null
        };
      }
    }

    state.$$validator = self.validator;
    state.$invalid = false;
    state.$pristine = true;
    state.$isDestroyed = bind(self.$isDestroyed, self);
    state.$submit = bind(self.validator.onSubmit, self.validator);
    state.$reset = bind(self.validator.reset, self.validator);
  },
  onDisplayStateChange: function (vld, state) {
    var self = this;

    if (!state) {
      self.onFormReset(vld);
    } else {
      state = self.stateData;
      var i,
          l,
          f,
          fields = self.fields;

      for (i = 0, l = fields.length; i < l; i++) {
        f = state[fields[i]];

        if (f.$real) {
          state[fields[i]] = f.$real;
        }
      }

      state.$invalid = !vld.isValid();
      state.$pristine = false;
      self.state.$check();
    }
  },
  onFieldErrorChange: function (vld, field, error) {
    this.onFieldStateChange(vld, field, field.isValid());
  },
  onFormReset: function (vld) {
    var self = this,
        state = self.stateData,
        i,
        l,
        f,
        fields = self.fields;

    for (i = 0, l = fields.length; i < l; i++) {
      f = state[fields[i]];
      f.$error = null;
      f.$errorMessage = null;
      f.$invalid = null;
      f.$pristine = true;
    }

    state.$invalid = false;
    state.$pristine = true;
    self.state.$check();
  },
  onFormStateChange: function (vld, valid) {
    var self = this,
        state = self.stateData;
    state.$invalid = valid === false && vld.isDisplayStateEnabled();
    state.$pristine = false;
    self.state.$check();
  },
  onFieldStateChange: function (vld, field, valid) {
    var self = this,
        state = self.stateData,
        name = field.getName(),
        ds = vld.isDisplayStateEnabled(),
        fstate = {
      $error: field.getErrorRule(),
      $errorMessage: field.getError(),
      $invalid: valid === false,
      $pristine: field.getExactValidState() === null
    };

    if (ds) {
      state[name] = fstate;
    } else {
      state[name].$real = fstate;
    }

    self.state.$check();
  },
  onDestroy: function () {
    var self = this;
    self.validator.$destroy();

    if (self.state) {
      delete self.state[self.formName];
    }
  }
}, {
  initConfig: function (config) {
    config.setDefaultMode("ref", MetaphorJs.lib.Config.MODE_STATIC);
  }
});

/***/ }),

/***/ "../metaphorjs-validator/src/validator/Field.js":
/*!******************************************************!*\
  !*** ../metaphorjs-validator/src/validator/Field.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      isBool = __webpack_require__(/*! metaphorjs-shared/src/func/isBool.js */ "../metaphorjs-shared/src/func/isBool.js");

__webpack_require__(/*! ../__init.js */ "../metaphorjs-validator/src/__init.js");

__webpack_require__(/*! metaphorjs/src/func/dom/data.js */ "../metaphorjs/src/func/dom/data.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! metaphorjs/src/func/dom/setAttr.js */ "../metaphorjs/src/func/dom/setAttr.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeAttr.js */ "../metaphorjs/src/func/dom/removeAttr.js");

__webpack_require__(/*! metaphorjs/src/func/dom/addClass.js */ "../metaphorjs/src/func/dom/addClass.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeClass.js */ "../metaphorjs/src/func/dom/removeClass.js");

__webpack_require__(/*! metaphorjs/src/func/dom/normalizeEvent.js */ "../metaphorjs/src/func/dom/normalizeEvent.js");

__webpack_require__(/*! metaphorjs/src/lib/Input.js */ "../metaphorjs/src/lib/Input.js");

__webpack_require__(/*! metaphorjs/src/lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");

__webpack_require__(/*! ../var/messages.js */ "../metaphorjs-validator/src/var/messages.js");

__webpack_require__(/*! ../var/methods.js */ "../metaphorjs-validator/src/var/methods.js");

__webpack_require__(/*! ../func/empty.js */ "../metaphorjs-validator/src/func/empty.js");

__webpack_require__(/*! ../func/format.js */ "../metaphorjs-validator/src/func/format.js");

module.exports = MetaphorJs.validator.Field = function () {
  /* ***************************** FIELD ****************************************** */

  /**
   * @object MetaphorJs.validator.Field.defaults
   */
  var defaults = {
    /**
     * @property {boolean} allowSubmit call form.submit() on field's ENTER keyup
     */
    allowSubmit: true,

    /**
     * @property {boolean} alwaysCheck run tests even the field is proven 
     * valid and hasn't changed since last check
     */
    alwaysCheck: false,

    /**
     * @property {boolean} alwaysDisplayState 
     */
    alwaysDisplayState: false,

    /**
     * @property {*} data User data to store with the field
     */
    data: null,

    /**
     * @property {boolean} ignore put ignore:true to field config to ignore the field completely
     */
    ignore: null,

    /**
     * @property {boolean} disabled make validator disabled for this field initially
     */
    disabled: false,

    /**
     * @object cls
     */
    cls: {
      /**
       * @property {string} valid css class for a valid state
       */
      valid: '',

      /**
       * @property {string} error css class for an error state
       */
      error: '',

      /**
       * @property {string} remote css class for the field with it is being checked remotely
       */
      remote: ''
      /**
       * @end-object
       */

    },
    // if string is provided, considered errorBox: {tag: '...'}

    /**
     * @object errorBox error box config
     */
    errorBox: {
      /**
       * @property {string} cls error box css class
       */
      cls: '',

      /**
       * @property {function} fn {
       *  Must return dom node (cancels auto creation)
       *  @param {MetaphorJs.validator.Field} f
       *  @returns {HTMLElement}
       * }
       */
      fn: null,

      /**
       * @property {string} tag Auto-create element with this tag
       */
      tag: '',

      /**
       * @property {string} position {
       *  before|after|appendParent where to put newly created element
       *  @default after
       * }
       */
      position: 'after',

      /**
       * @property {string|DomNode} elem {
       *  Use this element as error box. (Dom node or selector)
       * }
       */
      elem: null,

      /**
       * @property {boolean} enabled {
       *  Enable or disable error box
       *  @default true
       * }
       */
      enabled: true
      /**
       * @end-object
       */

    },
    // callbacks are case insensitive
    // you can use camel case if you like.

    /**
     * @object callback
     */
    callback: {
      /**
       * @property {object} state all callback's context
       */
      state: null,

      /**
       * @property {function} * {
       *  eventName: function(f); See class's events
       *  @param {MetaphorJs.validator.Field} f
       * }
       */
      destroy: null,
      // called when field's validator is being destroyed. fn(api)
      statechange: null,
      // when field's state has been changed. fn(api, (boolean) state)
      errorchange: null,
      // fn(api, error)
      submit: null,
      // when enter key was pressed. fn(api, event). return false to prevent submitting even
      // if the form is valid
      check: null,
      // called after each check (may not be relevant, if there is a remote check) fn(api, valid)
      beforeRemote: null,
      // when remote check is about to be executed. fn(api, requestData)
      afterRemote: null,
      // when remote check ended. fn(api)
      displaystate: null // use this to display custom field state: fn(api, valid, error)

      /**
       * @end-object
       */

    },

    /**
     * @property {object} rules {
     *  Keys of this object are validators from 
     *  <code>MetaphorJs.validator.methods</code>, values
     *  of this object are validator params.<br>
     *  Rule can also be a function (custom validator):
     *  fn(fieldValue, dom, ruleValue, field)<br>
     *  The function must return error message, false or true.
     * }
     */
    rules: {},

    /**
     * @property {object} messages {
     *  <code>rule: message</code>, error messages 
     * }
     */
    messages: {}
    /**
     * @end-object
     */

  };

  var fixFieldShorthands = function (options) {
    if (!options) {
      return {};
    }

    var fix = function (level1, level2, type) {
      var value = options[level1],
          yes = false;

      if (value === undefined) {
        return;
      }

      switch (type) {
        case "string":
          {
            yes = isString(value);
            break;
          }

        case "function":
          {
            yes = isFunction(value);
            break;
          }

        case "boolean":
          {
            yes = isBool(value);
            break;
          }
      }

      if (yes) {
        options[level1] = {};
        options[level1][level2] = value;
      }
    };

    fix("errorBox", "enabled", "boolean");
    fix("errorBox", "tag", "string");
    fix("errorBox", "fn", "function");
    return options;
  };

  var messages = MetaphorJs.validator.messages,
      methods = MetaphorJs.validator.methods,
      empty = MetaphorJs.validator.empty,
      format = MetaphorJs.validator.format;
  /**
   * @class MetaphorJs.validator.Field
   * @mixes MetaphorJs.mixin.Observable
   */

  return cls({
    /**
     * @event check {
     *  @param {MetaphorJs.validator.Field} f
     *  @param {boolean} valid
     * }
     */

    /**
     * @event display-state {
     *  @param {MetaphorJs.validator.Field} f
     *  @param {boolean} valid
     *  @param {string} error
     * }
     */

    /**
     * @event state-change {
     *  @param {MetaphorJs.validator.Field} f
     *  @param {boolean} valid
     * }
     */

    /**
     * @event error-change {
     *  @param {MetaphorJs.validator.Field} f
     *  @param {string} error 
     *  @param {string} rule
     * }
     */

    /**
     * @event submit {
     *  @param {MetaphorJs.validator.Field} f
     *  @param {MetaphorJs.lib.DomEvent} event
     *  @returns {boolean} return false to cancel
     * }
     */

    /**
     * @event before-remote {
     *  @param {MetaphorJs.validator.Field} f
     *  @param {object} remoteCfg
     * }
     */

    /**
     * @event after-remote {
     *  @param {MetaphorJs.validator.Field} f
     * }
     */
    $mixins: [MetaphorJs.mixin.Observable],
    vldr: null,
    elem: null,
    rules: null,
    cfg: null,
    input: null,
    enabled: true,
    valid: null,
    // the field has been checked and is valid (null - not checked yet)
    dirty: false,
    // the field's value changed, hasn't been rechecked yet
    id: null,
    prev: '',
    error: null,
    errorRule: null,
    pending: null,
    rulesNum: 0,
    displayState: false,
    data: null,
    checking: false,
    checkTmt: null,
    errorBox: null,
    customError: false,

    /**
     * @constructor
     * @method
     * @param {HTMLElement} elem 
     * @param {object} options See <code>MetaphorJs.validator.Field.defaults</code>
     * @param {MetaphorJs.validator.Validator} vldr 
     */
    $init: function (elem, options, vldr) {
      options = options || {};
      var self = this,
          cfg;
      self.cfg = cfg = extend({}, defaults, fixFieldShorthands(MetaphorJs.validator.Field.defaults), fixFieldShorthands(options), true, true);
      self.input = MetaphorJs.lib.Input.get(elem);
      self.input.onChange(self.onInputChange, self);
      self.input.onKey(13, self.onInputSubmit, self);
      self.elem = elem;
      self.vldr = vldr;
      self.enabled = !elem.disabled;
      self.id = MetaphorJs.dom.getAttr(elem, 'name') || MetaphorJs.dom.getAttr(elem, 'id');
      self.data = options.data;
      self.rules = {};
      cfg.messages = extend({}, messages, cfg.messages, true, true);
      MetaphorJs.dom.setAttr(elem, "data-validator", vldr.getVldId());

      if (self.input.radio) {
        self.initRadio();
      }

      if (cfg.rules) {
        self.setRules(cfg.rules, false);
      }

      self.readRules();
      self.prev = self.input.getValue();

      if (cfg.disabled) {
        self.disable();
      }
    },

    /**
     * @method
     * @returns {MetaphorJs.validator.Validator}
     */
    getValidator: function () {
      return this.vldr;
    },
    initRadio: function () {
      var self = this,
          radios = self.input.radio,
          vldId = self.vldr.getVldId(),
          i,
          l;

      for (i = 0, l = radios.length; i < l; i++) {
        MetaphorJs.dom.setAttr(radios[i], "data-validator", vldId);
      }
    },

    /**
     * Set/add field rules
     * @method
     * @param {object} list {
     *  name: value set of rules. See 
     *  <code>MetaphorJs.validator.Field.defaults.rules</code> 
     * }
     * @param {boolean} check {
     *  Re-check field's validity
     *  @default false
     * }
     */
    setRules: function (list, check) {
      var self = this;
      check = check == undefined ? true : check;

      for (var i in list) {
        self.setRule(i, list[i], false);
      }

      if (check) {
        self.check(false);
      } else {
        self.setValidState(null);
      }

      return self;
    },

    /**
     * Set/add field rule
     * @method
     * @param {string} rule Validator name
     * @param {*|function} value
     * @param {boolean} check {
     *  Re-check field's validity
     *  @default false
     * }
     */
    setRule: function (rule, value, check) {
      var self = this,
          rules = self.rules;
      check = check == undefined ? true : check;

      if (value === null) {
        if (rules[rule]) {
          self.rulesNum--;
        }

        delete rules[rule];
      } else {
        if (!rules[rule]) {
          self.rulesNum++;
        }

        rules[rule] = value;

        if (self.valid !== null) {
          self.setValidState(false);
        }
      }

      if (check) {
        self.check(false);
      } else {
        self.setValidState(null);
      }

      return self;
    },

    /**
     * Set rule message
     * @method
     * @param {string} rule
     * @param {string} message
     */
    setMessage: function (rule, message) {
      this.cfg.messages[rule] = message;
      return this;
    },

    /**
     * Set rule messages
     * @method
     * @param {object} messages {
     *  rule: message 
     * }
     */
    setMessages: function (messages) {
      var self = this;

      for (var i in messages) {
        self.setMessage(i, messages[i]);
      }

      return self;
    },

    /**
     * Get rule messages
     * @method 
     * @returns {object}
     */
    getMessages: function () {
      return extend({}, this.cfg.messages);
    },

    /**
     * @ignore
     * Read rules from attributes and classes
     * (this happens on init)
     */
    readRules: function () {
      var self = this,
          elem = self.elem,
          cls = elem.className,
          found = {},
          val,
          i,
          name,
          len;

      for (i in methods) {
        if (methods.hasOwnProperty(i)) {
          val = MetaphorJs.dom.getAttr(elem, i) || MetaphorJs.dom.getAttr(elem, "data-validate-" + i);

          if (val == undefined || val === false) {
            continue;
          }

          if ((i === 'minlength' || i === 'maxlength') && (val = parseInt(val, 10)) === -1) {
            continue;
          }

          found[i] = val;
          val = MetaphorJs.dom.getAttr(elem, "data-message-" + i);
          val && self.setMessage(i, val);
        }
      }

      if (val = MetaphorJs.dom.getAttr(elem, 'remote')) {
        found['remote'] = val;
      }

      if (cls) {
        cls = cls.split(" ");

        for (i = 0, len = cls.length; i < len; i++) {
          name = cls[i].trim();

          if (methods[name] || name === 'remote') {
            found[name] = true;
          }
        }
      }

      for (i in found) {
        self.setRule(i, found[i], false);
      }
    },
    setConfigRules: function (config) {
      var self = this,
          elem = self.elem,
          val,
          i;
      this.$self.deepInitConfig(config);

      for (i in methods) {
        if (methods.hasOwnProperty(i)) {
          val = config.get(i);

          if (val == undefined || val === false) {
            continue;
          }

          if ((i === 'minlength' || i === 'maxlength') && (val = parseInt(val, 10)) === -1) {
            continue;
          }

          self.setRule(i, val, false);
          val = (config ? config.get(i + ".msg") : null) || MetaphorJs.dom.getAttr(elem, "data-message-" + i);
          val && self.setMessage(i, val);
        }
      }
    },

    /**
     * Get field rules
     * @method
     * @returns {object}
     */
    getRules: function () {
      return this.rules;
    },

    /**
     * @method
     * @param {string} name
     * @return {boolean}
     */
    hasRule: function (name) {
      return this.rules[name] ? true : false;
    },

    /**
     * Get field value
     * @method
     * @returns {string}
     */
    getValue: function () {
      return this.input.getValue();
    },

    /**
     * Get user data
     * @method
     * @returns {*}
     */
    getUserData: function () {
      return this.data;
    },

    /**
     * Set user data
     * @method
     * @param {*} data
     */
    setUserData: function (data) {
      var self = this,
          old = self.data;
      self.data = data;
      return old;
    },

    /**
     * Is the field currently empty
     * @method
     * @returns {boolean}
     */
    isEmpty: function () {
      var self = this;
      return empty(self.getValue(), self.elem);
    },

    /**
     * Enable field validation
     * @method
     */
    enable: function () {
      var self = this;
      self.enabled = true;
      self.vldr.reset();
      return self;
    },

    /**
     * Disable field validation
     * @method
     */
    disable: function () {
      var self = this;
      self.enabled = false;

      if (self.valid === false) {
        self.setValidState(true);
        self.doDisplayState();
      }

      return self;
    },

    /**
     * @method
     */
    enableDisplayState: function () {
      this.displayState = true;
    },

    /**
     * @method
     */
    disableDisplayState: function () {
      this.displayState = false;
    },

    /**
     * @method
     * @returns {boolean}
     */
    isDisplayStateEnabled: function () {
      return this.displayState;
    },

    /**
     * @method
     * @param {boolean} state 
     */
    toggleErrorBox: function (state) {
      var self = this,
          cfg = self.cfg,
          prev = cfg.errorBox.enabled;
      cfg.errorBox.enabled = state;

      if (!prev && state && state.displayState && self.valid() === false) {
        self.doDisplayState();
      }
    },

    /**
     * @method
     * @returns {boolean}
     */
    isEnabled: function () {
      return this.enabled;
    },

    /**
     * Get field's dom node
     * @method
     * @returns {HTMLElement}
     */
    getElem: function () {
      return this.elem;
    },

    /**
     * @method
     * @returns {string}
     */
    getName: function () {
      return this.id;
    },

    /**
     * Get current error
     * @method
     * @returns {string|null}
     */
    getError: function () {
      return this.error;
    },

    /**
     * Get the name of last validator that invalidated the field
     * @method
     * @returns {string|null}
     */
    getErrorRule: function () {
      return this.errorRule;
    },

    /**
     * @method
     * @returns {boolean}
     */
    isValid: function () {
      var self = this;

      if (!self.isEnabled()) {
        return true;
      }

      if (self.customError) {
        return false;
      }

      return self.valid === true && !self.pending || self.rulesNum === 0;
    },
    getExactValidState: function () {
      return this.valid;
    },

    /**
     * Set custom error
     * @method
     * @param {string} error 
     * @param {string} rule 
     */
    setCustomError: function (error, rule) {
      var self = this;
      self.customError = error ? true : false;
      self.setValidState(error ? false : true);
      self.setError(error === true ? null : error, rule);
      self.doDisplayState();
    },

    /**
     * Reset field to untouched state
     * @method
     */
    reset: function () {
      var self = this;
      self.abort();
      self.dirty = false;
      self.prev = '';
      self.setValidState(null);
      self.setError(null);
      self.doDisplayState();
      return self;
    },

    /**
     * Abort remote check
     * @method
     */
    abort: function () {
      var self = this;

      if (self.pending) {
        console.error("Abort not implemented; Implement AbortController!"); //self.pending.abort();
        //self.pending = null;
      }

      return self;
    },

    /**
     * Check if field is valid
     * @method
     * @param {boolean} force Check even if field's value haven't changed
     * @returns {boolean}
     */
    check: function (force) {
      var self = this,
          rules = self.rules,
          cfg = self.cfg,
          elem = self.elem; // disabled field validator always returns true

      if (!self.isEnabled()) {
        return true;
      }

      if (self.customError) {
        return false;
      } // if there are no rules, we return true


      if (self.rulesNum == 0 && self.valid !== false) {
        return true;
      }

      if (self.checking) {
        if (!self.checkTmt) {
          self.checkTmt = setTimeout(bind(self.checkTimeout, self), 100);
        }

        return self.valid === true;
      }

      self.checking = true; // nothing changed since last check
      // we need to find a way to indicate that (if) this field depends on others
      // and state.dirty doesn't really work in this case

      if (force !== true && !rules.equalTo && !rules.notEqualTo && !self.dirty && self.valid !== null && !cfg.alwaysCheck) {
        if (!self.pending) {
          self.doDisplayState();
        }

        self.checking = false;
        return self.valid === true;
      }

      var valid = true,
          remote = false,
          val = self.getValue(),
          msg;

      for (var i in rules) {
        // we always call remote check after all others
        if (i === 'remote') {
          if (self.dirty || cfg.alwaysCheck || self.valid === null || force === true) {
            if (val || rules[i].checkEmpty) {
              remote = true;
            }
          }

          continue;
        }

        var fn = isFunction(rules[i]) ? rules[i] : methods[i];

        if ((msg = fn.call(self.$$callbackContext, val, elem, rules[i], self)) !== true) {
          valid = false;
          self.setError(format(msg || cfg.messages[i] || "", rules[i]), i);
          break;
        }
      }

      remote = remote && valid;

      if (valid) {
        self.setError(null);
      }

      if (!remote) {
        self.setValidState(valid);
        self.doDisplayState();
      } else {
        self.remoteCheck();
      }

      self.dirty = false;
      self.checking = false;
      self.trigger("check", self, self.valid);
      return self.valid === true && !remote;
    },
    doDisplayState: function () {
      var self = this,
          cfg = self.cfg,
          valid = self.isValid(),
          errorCls = cfg.cls.error,
          validCls = cfg.cls.valid,
          elem = self.elem;

      if (!self.displayState && !cfg.alwaysDisplayState) {
        valid = null;
      }

      if (self.valid === null) {
        valid = null;
      }

      if (errorCls) {
        valid === false ? MetaphorJs.dom.addClass(elem, errorCls) : MetaphorJs.dom.removeClass(elem, errorCls);
      }

      if (validCls) {
        valid === true ? MetaphorJs.dom.addClass(elem, validCls) : MetaphorJs.dom.removeClass(elem, validCls);
      }

      var box = self.getErrorBox(),
          error = self.error;

      if (box) {
        if (valid === false && error) {
          box.innerHTML = state.error;
        }

        box.style.display = valid !== false || !error || !cfg.errorBox.enabled ? 'none' : 'block';
      }

      self.trigger('display-state', self, valid, self.error);
    },

    /**
     * @method
     * @returns {HTMLElement}
     */
    getErrorBox: function () {
      var self = this,
          cfg = self.cfg,
          eb = cfg.errorBox;

      if (eb.tag || eb.fn || eb.selector) {
        if (!self.errorBox && eb.enabled) {
          self.createErrorBox();
        }

        return self.errorBox;
      } else {
        return null;
      }
    },
    onDestroy: function () {
      var self = this;
      MetaphorJs.dom.removeAttr(self.elem, "data-validator");

      if (self.errorBox) {
        self.errorBox.parentNode.removeChild(self.errorBox);
      }

      self.input.$destroy();
    },

    /**
     * Is this field still running remote check
     * @method
     * @returns {boolean}
     */
    isPending: function () {
      return this.pending !== null;
    },
    setValidState: function (valid) {
      var self = this;

      if (self.valid !== valid) {
        self.valid = valid;
        self.trigger('state-change', self, valid);
      }
    },
    setError: function (error, rule) {
      var self = this;

      if (self.error != error || self.errorRule != rule) {
        self.error = error;
        self.errorRule = rule;
        self.trigger('error-change', self, error, rule);
      }
    },
    checkTimeout: function () {
      var self = this;
      self.checkTmt = null;

      if (self.checking) {
        return;
      }

      self.check(false);
    },
    onInputChange: function (val) {
      var self = this,
          prev = self.prev;

      if (prev !== val) {
        self.dirty = true;
        self.customError = false;
        self.abort();

        if (!self.pending) {
          self.check(false);
        }

        self.prev = self.input.getValue();
      }
    },
    onInputSubmit: function (e) {
      e = MetaphorJs.dom.normalizeEvent(e);

      if (!e.isDefaultPrevented || !e.isDefaultPrevented()) {
        var res = this.trigger("submit", this, e);

        if (res === false) {
          e.preventDefault();
          return false;
        }
      }
    },
    createErrorBox: function () {
      var self = this,
          cfg = self.cfg,
          eb = cfg.errorBox,
          tag = eb.tag,
          cls = eb.cls,
          fn = eb.fn,
          pos = eb.position,
          dom = eb.elem;

      if (fn) {
        self.errorBox = fn.call(self.$$callbackContext, self);
      } else if (dom) {
        self.errorBox = dom;
      } else {
        self.errorBox = window.document.createElement(tag);
        self.errorBox.className = cls;
        var r = self.input.radio,
            f = r ? r[r - 1] : self.elem;

        if (pos == 'appendParent') {
          f.parentNode.appendChild(self.errorBox);
        } else if (pos == "before") {
          f.parentNode.insertBefore(self.errorBox, f);
        } else {
          f.parentNode.insertBefore(self.errorBox, f.nextSibling);
        }
      }
    },
    remoteCheck: function () {
      var self = this,
          rules = self.rules,
          elem = self.elem,
          rm = rules['remote'],
          val = self.getValue(),
          cfg = self.cfg;
      var acfg = extend({}, isString(rm) ? {
        url: rm
      } : rm, true);
      acfg.body = acfg.body || {};
      acfg.body[acfg.paramName || MetaphorJs.dom.getAttr(elem, 'name') || MetaphorJs.dom.getAttr(elem, 'id')] = val;

      if (acfg.fn) {
        if (cfg.cls.remote) {
          MetaphorJs.dom.addClass(elem, cfg.cls.remote);
        }

        self.trigger('before-remote', self, acfg);
        self.pending = acfg.fn(acfg.body).then(bind(self.onRemoteSuccess, self));
        return;
      }

      if (!acfg.handler) {
        acfg.dataType = 'text';
      }

      acfg.cache = false;

      if (cfg.cls.remote) {
        MetaphorJs.dom.addClass(elem, cfg.cls.remote);
      }

      self.trigger('before-remote', self, acfg);
      self.pending = fetch(acfg).then(r => r.text()).then(bind(self.onRemoteSuccess, self)).catch(bind(self.onRemoteError, self));
    },
    onRemoteSuccess: function (data) {
      var self = this,
          rules = self.rules,
          cfg = self.cfg;
      self.pending = null;
      var valid = true;

      if (rules['remote'].handler) {
        var res = rules['remote'].handler.call(self.$$callbackContext, self, data);

        if (res !== true) {
          self.setError(format(res || cfg.messages['remote'] || "", rules['remote']), 'remote');
          valid = false;
        }
      } else {
        if (data) {
          self.setError(data, 'remote');
          valid = false;
        } else {
          self.setError(null);
        }
      }

      if (cfg.cls.remote) {
        MetaphorJs.dom.removeClass(self.elem, cfg.cls.remote);
      }

      self.setValidState(valid);
      self.doDisplayState();
      self.trigger('after-remote', self);
    },
    onRemoteError: function (xhr, status) {
      var self = this,
          cfg = self.cfg,
          response = xhr.responseData,
          rules = self.rules;

      if (response && rules['remote'].handler) {
        var res = rules['remote'].handler.call(self.$$callbackContext, self, response);

        if (res !== true) {
          self.setError(format(res || cfg.messages['remote'] || "", rules['remote']), 'remote');
        }
      }

      if (cfg.cls.remote) {
        MetaphorJs.dom.removeClass(self.elem, cfg.cls.remote);
      }

      self.pending = null;

      if (status != 'abort' && xhr != "abort") {
        self.setValidState(false);
        self.doDisplayState();
        self.trigger('after-remote', self);
      }
    }
  }, {
    defaults: {},
    messages: {},
    deepInitConfig: function (config) {
      var ms = MetaphorJs.lib.Config.MODE_STATIC;

      for (var i in methods) {
        if (methods.hasOwnProperty(i)) {
          if (config.hasProperty(i)) {
            config.setDefaultMode(i, ms);
            config.setDefaultMode(i + ".msg", ms);
          }
        }
      }
    }
  });
}();

/***/ }),

/***/ "../metaphorjs-validator/src/validator/Group.js":
/*!******************************************************!*\
  !*** ../metaphorjs-validator/src/validator/Group.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js");

__webpack_require__(/*! ../__init.js */ "../metaphorjs-validator/src/__init.js");

__webpack_require__(/*! metaphorjs/src/func/dom/addClass.js */ "../metaphorjs/src/func/dom/addClass.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeClass.js */ "../metaphorjs/src/func/dom/removeClass.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");

__webpack_require__(/*! ../var/messages.js */ "../metaphorjs-validator/src/var/messages.js");

__webpack_require__(/*! ../var/methods.js */ "../metaphorjs-validator/src/var/methods.js");

__webpack_require__(/*! ../func/format.js */ "../metaphorjs-validator/src/func/format.js");

module.exports = MetaphorJs.validator.Group = function () {
  /* ***************************** GROUP ****************************************** */

  /**
   * @object MetaphorJs.validator.Group.defaults
   */
  var defaults = {
    /**
     * @property {boolean} alwaysCheck run tests even the group is proven 
     * valid and hasn't changed since last check
     */
    alwaysCheck: false,

    /**
     * @property {boolean} alwaysDisplayState 
     */
    alwaysDisplayState: false,

    /**
     * @property {boolean} disabled Make group disabled by default
     */
    disabled: false,

    /**
     * @property {function} value { 
     *  @param {object} values Field values - name:value
     *  @param {MetaphorJs.validator.Group} g 
     *  @returns {*} group value
     * }
     */
    value: null,

    /**
     * @property {HTMLElement} elem Group's dom node. 
     */
    elem: null,
    // dom node

    /**
     * @property {string|DomNode|function} errorBox {
     *  string: either field name/id or selector<br>
     *  function: fn(MetaphorJs.validator.Group)
     * }
     */
    errorBox: null,

    /**
     * @property {string} errorField field's name or id - where to display group's error
     */
    errorField: null,

    /**
     * @property {*} data User data
     */
    data: null,

    /**
     * @object cls
     */
    cls: {
      /**
       * @property {string} valid Css class for valid state
       */
      valid: '',

      /**
       * @property {string} error Css class for error state
       */
      error: ''
      /**
       * @end-object
       */

    },

    /**
     * @property {array} fields Array of field names/ids
     */
    fields: [],

    /**
     * @property {object} rules {
     *  Keys of this object are validators from 
     *  <code>MetaphorJs.validator.methods</code>, values
     *  of this object are validator params.<br>
     *  Rule can also be a function (custom validator):
     *  fn(fieldValue, dom, ruleValue, field)<br>
     *  The function must return error message, false or true.
     * }
     */
    rules: {},

    /**
     * @property {object} messages {
     *  <code>rule: message</code>, error messages 
     * }
     */
    messages: {},

    /**
     * @object callback
     */
    callback: {
      /**
       * @property {object} state all callback's context
       */
      state: null,

      /**
       * @property {function} * {
       *  eventName: function(f); See class's events
       *  @param {MetaphorJs.validator.Field} f
       * }
       */
      destroy: null,
      statechange: null,
      errorchange: null,
      displaystate: null
      /**
       * @end-object
       */

    }
    /**
     * @end-object
     */

  };
  var messages = MetaphorJs.validator.messages,
      methods = MetaphorJs.validator.methods,
      format = MetaphorJs.validator.format;
  /**
   * @class MetaphorJs.validator.Group
   * @mixes MetaphorJs.mixin.Observable
   */

  return cls({
    /**
     * @event error-change {
     *  @param {MetaphorJs.validator.Group} grp
     *  @param {string} error
     * }
     */

    /**
     * @event display-state {
     *  @param {MetaphorJs.validator.Group} grp
     *  @param {boolean} valid
     * }
     */

    /**
     * @event state-change {
     *  @param {MetaphorJs.validator.Group} grp
     *  @param {boolean} valid
     * }
     */

    /**
     * @event field-state-change {
     *  @param {MetaphorJs.validator.Group} grp
     *  @param {MetaphorJs.validator.Field} fld 
     *  @param {boolean} valid
     * }
     */
    $mixins: [MetaphorJs.mixin.Observable],
    fields: null,
    rules: null,
    cfg: null,
    vldr: null,
    enabled: false,
    invalid: null,
    valid: null,
    displayState: false,
    rulesNum: 0,
    error: null,
    data: null,
    errorBox: null,
    el: null,

    /**
     * @constructor
     * @method
     * @param {object} options See <code>MetaphorJs.validator.Group.defaults</code>
     * @param {MetaphorJs.validator.Validator} vldr 
     */
    $init: function (options, vldr) {
      options = options || {};
      var self = this,
          cfg;
      self._vldr = vldr;
      self.cfg = cfg = extend({}, defaults, MetaphorJs.validator.Group.defaults, options, true, true);
      self.data = options.data;
      self.el = options.elem;
      self.fields = {};
      self.rules = {};
      cfg.messages = extend({}, messages, cfg.messages, true, true);
      var i, len;

      if (cfg.rules) {
        self.setRules(cfg.rules, false);
      }

      if (cfg.fields) {
        for (i = 0, len = options.fields.length; i < len; i++) {
          self.add(vldr.getField(cfg.fields[i]));
        }
      }

      self.enabled = !cfg.disabled;
    },

    /**
     * Enable group (enabled by default)
     * @method
     */
    enable: function () {
      this.enabled = true;
      return this;
    },

    /**
     * Disable group
     * @method
     */
    disable: function () {
      this.enabled = false;
      return this;
    },

    /**
     * Is group enabled
     * @method
     * @return {boolean}
     */
    isEnabled: function () {
      return this.enabled;
    },

    /**
     * Are all fields in this group valid
     * @method
     * @return {boolean}
     */
    isValid: function () {
      var self = this;
      return !self.enabled || self.invalid === 0 && self.valid === true;
    },

    /**
     * @method
     * @return {boolean|null}
     */
    getExactValidState: function () {
      return this.valid;
    },

    /**
     * Reset group
     * @method
     */
    reset: function () {
      var self = this;
      self.invalid = 0;
      self.setValidState(null);
      self.setError(null);
      self.doDisplayState();
      return self;
    },

    /**
     * Get user data specified in group config
     * @method
     * @returns {*}
     */
    getUserData: function () {
      return this.data;
    },

    /**
     * Get group name
     * @method
     * @returns {string}
     */
    getName: function () {
      return this.cfg.name;
    },

    /**
     * Set group's rules
     * @method
     * @param {object} list {rule: param}
     * @param {bool} check Re-check group
     */
    setRules: function (list, check) {
      var self = this;
      check = check == undefined ? true : check;

      for (var i in list) {
        self.setRule(i, list[i], false);
      }

      if (check) {
        self.check();
      } else {
        self.setValidState(null);
      }

      return self;
    },

    /**
     * Add group rule
     * @method
     * @param {string} rule
     * @param {*} value
     * @param {boolean} check Re-check group
     */
    setRule: function (rule, value, check) {
      var self = this,
          rules = self.rules;
      check = check == undefined ? true : check;

      if (value === null) {
        if (rules[rule]) {
          self.rulesNum--;
        }

        delete rules[rule];
      } else {
        if (!rules[rule]) {
          self.rulesNum++;
        }

        rules[rule] = value;

        if (self.valid !== null) {
          self.setValidState(false);
        }
      }

      if (check) {
        self.check();
      } else {
        self.setValidState(null);
      }

      return self;
    },

    /**
     * Get group rules
     * @method
     * @returns {name: value}
     */
    getRules: function () {
      return extend({}, this.rules);
    },

    /**
     * @method
     * @param {string} name
     * @returns {boolean}
     */
    hasRule: function (name) {
      return this.rules[name] ? true : false;
    },

    /**
     * Set group custom error
     * @method
     * @param {string} error
     */
    setError: function (error) {
      var self = this,
          cfg = self.cfg;

      if (self.error != error) {
        if (cfg.errorField) {
          self.vldr.getField(cfg.errorField).setError(error);
          self.error = null;
        } else {
          self.error = error;
          self.trigger('error-change', self, error);
        }
      }
    },

    /**
     * Get current error
     * @method
     * @returns {string}
     */
    getError: function () {
      return this.error;
    },

    /**
     * @method 
     * @returns {object} 
     */
    getFields: function () {
      return this.fields;
    },

    /**
     * @method
     */
    enableDisplayState: function () {
      this.displayState = true;
      return this;
    },

    /**
     * @method
     */
    disableDisplayState: function () {
      this.displayState = false;
      return this;
    },

    /**
     * @method
     * @returns {boolean}
     */
    check: function () {
      var self = this,
          cfg = self.cfg,
          fields = self.fields,
          rules = self.rules;

      if (!self.enabled || self.rulesNum == 0) {
        self.setValidState(null);
        self.doDisplayState();
        return true;
      }

      self.countInvalid();

      if (self.invalid > 0) {
        self.setValidState(null);
        self.doDisplayState();
        return true;
      }

      var vals = {},
          valid = true,
          val = null,
          msg,
          i;

      if (cfg.value) {
        for (i in fields) {
          vals[i] = fields[i].getValue();
        }

        val = cfg.value.call(self.$$callbackContext, vals, self);
      }

      for (i in rules) {
        var fn = isFunction(rules[i]) ? rules[i] : methods[i];

        if ((msg = fn.call(self.$$callbackContext, val, null, rules[i], self, vals)) !== true) {
          valid = false;

          if (msg || cfg.messages[i]) {
            self.setError(format(msg || cfg.messages[i] || "", rules[i]));
          } else {
            self.setError(null);
          }

          break;
        }
      }

      if (valid) {
        self.setError(null);
      }

      self.setValidState(valid);
      self.doDisplayState();
      return self.valid === true;
    },
    doDisplayState: function () {
      var self = this,
          valid = self.valid,
          cfg = self.cfg;

      if (!self.displayState && !cfg.alwaysDisplayState) {
        valid = null;
      }

      if (cfg.errorBox) {
        var ebox = self.getErrorBox();

        if (valid !== null) {
          if (ebox) {
            ebox.innerHTML = self.error || '';
            ebox.style.display = self.valid === false ? 'block' : 'none';
          }
        } else {
          if (ebox) {
            ebox.style.display = "none";
          }
        }
      }

      var errorCls = cfg.cls.error,
          validCls = cfg.cls.valid;
      valid = self.valid;

      if (errorCls) {
        valid === false ? MetaphorJs.dom.addClass(self.el, errorCls) : MetaphorJs.dom.removeClass(self.el, errorCls);
      }

      if (validCls) {
        valid === true ? MetaphorJs.dom.addClass(self.el, validCls) : MetaphorJs.dom.removeClass(self.el, validCls);
      }

      self.trigger('display-state', self, self.valid);
    },

    /**
     * @method
     * @returns {HTMLElement}
     */
    getErrorBox: function () {
      var self = this,
          cfg = self.cfg,
          fields = self.fields,
          eb = cfg.errorBox;

      if (fields[eb]) {
        return fields[eb].getErrorBox();
      } else if (!self.errorBox) {
        if (isFunction(cfg.errorBox)) {
          self.errorBox = cfg.errorBox.call(self.$$callbackContext, self);
        } else {
          self.errorBox = cfg.errorBox;
        }
      }

      return self.errorBox;
    },
    onDestroy: function () {
      var self = this,
          fields = self.fields;

      for (var i in fields) {
        if (fields[i]) {
          self.setFieldEvents(fields[i], 'un');
        }
      }

      if (self.errorBox) {
        self.errorBox.parentNode.removeChild(self.errorBox);
      }
    },

    /**
     * Add field to the group
     * @method
     * @param {MetaphorJs.validator.Field} field 
     */
    add: function (field) {
      var self = this,
          fields = self.fields,
          id = field.getName();

      if (!fields[id]) {
        fields[id] = field;
        self.setFieldEvents(field, 'on');
      }
    },
    setFieldEvents: function (f, mode) {
      var self = this;
      f[mode]('state-change', self.onFieldStateChange, self);
    },

    /**
     * Remove field from the group
     * @method
     * @param {MetaphorJs.validator.Field} field 
     */
    remove: function (field) {
      var self = this,
          fields = self.fields,
          id = field.getName();

      if (fields[id]) {
        delete fields[id];
        self.setFieldEvents(field, 'un');
      }

      return self;
    },
    setValidState: function (valid) {
      var self = this;

      if (self.valid !== valid) {
        self.valid = valid;
        self.trigger('state-change', self, valid);
      }
    },
    countInvalid: function () {
      var self = this,
          fields = self.fields;
      self.invalid = 0;

      for (var i in fields) {
        self.invalid += fields[i].isValid() ? 0 : 1;
      }
    },
    onFieldStateChange: function (f, valid) {
      var self = this;
      self.trigger("field-state-change", self, f, valid);
      self.check();
    }
  }, {
    defaults: {}
  });
}();

/***/ }),

/***/ "../metaphorjs-validator/src/validator/Validator.js":
/*!**********************************************************!*\
  !*** ../metaphorjs-validator/src/validator/Validator.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js");

__webpack_require__(/*! ../__init.js */ "../metaphorjs-validator/src/__init.js");

__webpack_require__(/*! metaphorjs/src/func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

__webpack_require__(/*! metaphorjs/src/func/dom/addClass.js */ "../metaphorjs/src/func/dom/addClass.js");

__webpack_require__(/*! metaphorjs/src/func/dom/removeClass.js */ "../metaphorjs/src/func/dom/removeClass.js");

__webpack_require__(/*! metaphorjs/src/func/dom/select.js */ "../metaphorjs/src/func/dom/select.js");

__webpack_require__(/*! metaphorjs/src/func/dom/isField.js */ "../metaphorjs/src/func/dom/isField.js");

__webpack_require__(/*! metaphorjs/src/func/dom/normalizeEvent.js */ "../metaphorjs/src/func/dom/normalizeEvent.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! metaphorjs/src/func/dom/setAttr.js */ "../metaphorjs/src/func/dom/setAttr.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");

__webpack_require__(/*! ./Field.js */ "../metaphorjs-validator/src/validator/Field.js");

__webpack_require__(/*! ./Group.js */ "../metaphorjs-validator/src/validator/Group.js");

module.exports = MetaphorJs.validator.Validator = function () {
  var validators = {};
  var Field = MetaphorJs.validator.Field,
      Group = MetaphorJs.validator.Group;
  /**
   * @object MetaphorJs.validator.Validator.defaults
   */

  var defaults = {
    /**
     * @property {HTMLElement} form The form being validated
     */
    form: null,

    /**
     * @property {object} all All fields properties. 
     * See <code>MetaphorJs.validator.Field.defaults</code>
     */
    all: {},

    /**
     * @property {object} fields {
     *  <code>name: config</code>. 
     * For config see <code>MetaphorJs.validator.Field.defaults</code>.
     * }
     */
    fields: {},

    /**
     * @property {object} rules {
     *  <code>field: []</code> set of rules. 
     *  See <code>MetaphorJs.validator.Field.defaults</code> for rules description.
     * }
     */
    rules: {},
    // {field: rules}

    /**
     * Css classes to apply to the form
     * @object cls
     */
    cls: {
      /**
       * @property {string} valid Form is valid
       */
      valid: '',

      /**
       * @property {string} valid Form has an error
       */
      error: '',

      /**
       * @property {string} valid Form is being checked (async check)
       */
      checking: ''
      /**
       * @end-object
       */

    },

    /**
     * @property {object} groups {
     *  <code>name: cfg</code> set of options. 
     * See <code>MetaphorJs.validator.Group.defaults</code>.
     * }
     */
    groups: {},
    // see groupDefaults. {name: cfg}
    // callbacks are case insensitive
    // you can use camel case if you like.

    /**
     * @object callback
     */
    callback: {
      /**
       * @property {object} state all callback's context
       */
      state: null,

      /**
       * @property {function} * {
       *  eventName: function(v); See class's events
       *  @param {MetaphorJs.validator.Validator} v
       * }
       */
      destroy: null,
      // when validator is being destroyed. fn(api)
      reset: null,
      // when the form was resetted. fn(api)
      beforesubmit: null,
      // when form is about to be submitted: valid and non-valid. fn(api)
      submit: null,
      // when form is about to be submitted: only valid. fn(api).
      // return false to prevent submitting
      statechange: null,
      // when form's state has been changed. fn(api, state)
      check: null,
      // fn(api) performe some additional out-of-form checks
      // if false is returned, form becomes invalid
      displaystate: null,
      // fn(api, valid)
      displaystatechange: null // fn(api, state)

      /**
       * @end-object
       */

    }
    /**
     * @end-object
     */

  };
  /**
   * @class MetaphorJs.validator.Validator
   * @mixes MetaphorJs.mixin.Observable
   */

  var Validator = cls({
    /**
     * @event display-state-change {
     *  When displayState has been enabled or disabled
     *  @param {MetaphorJs.validator.Validator} v
     *  @param {boolean} state
     * }
     */

    /**
     * @event check {
     *  When form is being checked
     *  @param {MetaphorJs.validator.Validator} v
     *  @returns {boolean} return false to cancel check
     * }
     */

    /**
     * @event state-change {
     *  After form check, if it changed its state
     *  @param {MetaphorJs.validator.Validator} v
     *  @param {boolean} valid 
     * }
     */

    /**
     * @event reset {
     *  @param {MetaphorJs.validator.Validator} v
     * }
     */

    /**
     * @event before-submit {
     *  @param {MetaphorJs.validator.Validator} v
     *  @returns {boolean} return false to cancel submitting
     * }
     */

    /**
     * @event submit {
     *  @param {MetaphorJs.validator.Validator} v
     *  @returns {boolean} return false to cancel submitting
     * }
     */

    /**
     * @event failed-submit {
     *  @param {MetaphorJs.validator.Validator} v
     * }
     */

    /**
     * @event field-error-change {
     *  @param {MetaphorJs.validator.Validator} v
     *  @param {MetaphorJs.validator.Field} f 
     *  @param {string} error
     * }
     */

    /**
     * @event field-state-change {
     *  @param {MetaphorJs.validator.Validator} v
     *  @param {MetaphorJs.validator.Field} f 
     *  @param {boolean} valid
     * }
     */

    /**
     * @event display-state {
     *  @param {MetaphorJs.validator.Validator} v
     *  @param {boolean} valid
     * }
     */
    $mixins: [MetaphorJs.mixin.Observable],
    id: null,
    el: null,
    cfg: null,
    enabled: false,
    invalid: null,
    // array of invalid fields
    pending: 0,
    // number of pending requests
    grps: 0,
    // number of invalid groups
    outside: true,
    // true - outside check passed or not present
    submitted: false,
    displayState: false,
    isForm: false,
    isField: false,
    submitButton: null,
    hidden: null,
    preventFormSubmit: false,
    fields: null,
    groups: null,

    /**
     * @constructor
     * @method
     * @param {HTMLElement} el 
     * @param {object} options See <code>MetaphorJs.validator.Validator.defaults</code>
     */

    /**
     * @constructor
     * @method
     * @param {HTMLElement} el 
     * @param {string} preset Preset name to take options from. 
     * (Preset options will be overriden by <code>options</code>)
     * @param {object} options See <code>MetaphorJs.validator.Validator.defaults</code>
     */
    $init: function (el, preset, options) {
      var self = this,
          tag = el.nodeName.toLowerCase(),
          cfg;
      self.id = nextUid();
      validators[self.id] = self;
      MetaphorJs.dom.setAttr(el, "data-validator", self.id);
      self.el = el;

      if (preset && !isString(preset)) {
        options = preset;
        preset = null;
      }

      self.cfg = cfg = extend({}, defaults, Validator.defaults, Validator[preset], options, true, true);
      self.$initObservable(cfg);
      self.isForm = tag === 'form';
      self.isField = /input|select|textarea/.test(tag);
      self.fields = {};
      self.groups = {};
      self.$$observable.createEvent("submit", false);
      self.$$observable.createEvent("beforesubmit", false);
      self.onRealSubmitClickDelegate = bind(self.onRealSubmitClick, self);
      self.resetDelegate = bind(self.reset, self);
      self.onSubmitClickDelegate = bind(self.onSubmitClick, self);
      self.onFormSubmitDelegate = bind(self.onFormSubmit, self);
      var i;
      self.initFields();
      var fields = self.fields;

      for (i in cfg.rules) {
        if (!fields[i]) {
          continue;
        }

        fields[i].setRules(cfg.rules[i], false);
      }

      cfg.rules = null;

      for (i in cfg.groups) {
        self.addGroup(i, cfg.groups[i]);
      }

      self.initForm('bind');
      delete cfg.rules;
      delete cfg.fields;
      delete cfg.groups;
      self.enabled = true;
    },

    /**
     * Get validator id
     * @method
     * @returns {string}
     */
    getVldId: function () {
      return this.id;
    },

    /**
     * Get form element
     * @method
     * @returns {HTMLElement}
     */
    getElem: function () {
      return this.el;
    },

    /**
     * Get group by its name
     * @method
     * @param {string} name
     * @returns {MetaphorJs.validator.Group}
     */
    getGroup: function (name) {
      return this.groups[name] || null;
    },

    /**
     * Get field by name or id
     * @method
     * @param {string} id
     * @return {MetaphorJs.validator.Field}
     */
    getField: function (id) {
      return this.fields[id] || null;
    },

    /**
     * Enable validator (enabled by default)
     * @method
     */
    enable: function () {
      this.enabled = true;
      return this;
    },

    /**
     * Disable validator
     * @method
     */
    disable: function () {
      this.enabled = false;
      return this;
    },

    /**
     * Is this validator enabled
     * @method
     * @returns {boolean}
     */
    isEnabled: function () {
      return this.enabled;
    },

    /**
     * Make validator show form errors and other messages. (Enabled by default)
     * @method
     */
    enableDisplayState: function () {
      var self = this,
          fields = self.fields,
          groups = self.groups,
          i;

      if (self.displayState !== true) {
        self.displayState = true;

        for (i in fields) {
          fields[i].enableDisplayState();
        }

        for (i in groups) {
          groups[i].enableDisplayState();
        }

        self.trigger('display-state-change', self, true);
      }

      return self;
    },

    /**
     * Make validator not show form errors and other messages
     * @method
     */
    disableDisplayState: function () {
      var self = this,
          groups = self.groups,
          fields = self.fields,
          i;

      if (self.displayState !== false) {
        self.displayState = false;

        for (i in fields) {
          fields[i].disableDisplayState();
        }

        for (i in groups) {
          groups[i].disableDisplayState();
        }

        self.trigger('display-state-change', self, false);
      }

      return self;
    },

    /**
     * Check if form shows errors and messages
     * @method
     * @return {boolean}
     */
    isDisplayStateEnabled: function () {
      return this.displayState;
    },

    /**
     * Is the form valid
     * @return {boolean}
     */
    isValid: function () {
      var self = this;

      if (self.enabled === false) {
        return true;
      }

      return self.invalid === 0 && self.pending === 0 && self.grps === 0 && self.outside === true;
    },

    /**
     * Get form errors
     * @method 
     * @param {boolean} plain {
     *  If plain=true, will return array [err, err], if false (default),
     *  object: (field: err, field: err)
     * }
     * @returns {array|object}
     */
    getErrors: function (plain) {
      var self = this,
          ers = plain === true ? [] : {},
          err,
          i,
          j,
          all = [self.fields, self.groups],
          curr;

      if (!self.isEnabled()) {
        return ers;
      }

      for (j = 0; j < 2; j++) {
        curr = all[j];

        for (i in curr) {
          if (curr[i].getExactValidState() === null) {
            curr[i].check();
          }

          if (!curr[i].isValid()) {
            err = curr[i].getError(); // it can be invalid, but have no error

            if (err) {
              if (plain) {
                ers.push(err);
              } else {
                ers[i] = err;
              }
            }
          }
        }
      }

      return ers;
    },

    /**
     * Check form for errors
     * @method
     * @returns {boolean} returns current form state 
     * (it may change in a second after remote checks)
     */
    check: function () {
      var self = this,
          fields = self.fields,
          groups = self.groups; // disabled field validator always returns true

      if (!self.isEnabled()) {
        return true;
      }

      var prevValid = self.isValid(),
          nowValid,
          i;

      for (i in fields) {
        fields[i].check();
      }

      for (i in groups) {
        groups[i].check();
      }

      self.outside = self.trigger('check', self) !== false;
      nowValid = self.isValid();

      if (prevValid != nowValid) {
        self.doDisplayState();
        self.trigger('state-change', self, false);
      }

      return nowValid;
    },

    /**
     * Add field
     * @method 
     * @param {HTMLElement} node
     * @param {object} fieldCfg See <code>MetaphorJs.validator.Field.defaults</code>
     * @returns {MetaphorJs.validator.Validator}
     */
    add: function (node, fieldCfg) {
      var self = this;

      if (!MetaphorJs.dom.isField(node)) {
        return self;
      }

      if (MetaphorJs.dom.getAttr(node, "data-no-validate") !== null) {
        return self;
      }

      if (MetaphorJs.dom.getAttr(node, "data-validator") !== null) {
        return self;
      }

      var id = MetaphorJs.dom.getAttr(node, 'name') || MetaphorJs.dom.getAttr(node, 'id'),
          cfg = self.cfg,
          fields = self.fields,
          fcfg,
          f;

      if (!id) {
        return self;
      }

      fcfg = cfg.fields && cfg.fields[id] ? cfg.fields[id] : fieldCfg || {};

      if (isString(fcfg)) {
        fcfg = {
          rules: [fcfg]
        };
      }

      fcfg = extend({}, cfg.all || {}, fcfg, true, true);

      if (fcfg.ignore) {
        return self;
      }

      if (!fcfg.callback) {
        fcfg.callback = {
          context: self.$$callbackContext
        };
      }

      f = new Field(node, fcfg, self);
      fcfg = null;
      id = f.getName();

      if (fields[id]) {
        return self; // already added
      }

      fields[id] = f;
      self.setFieldEvents(f, 'on');

      if (self.displayState) {
        f.enableDisplayState();
      }

      if (self.isEnabled() && self.invalid !== null) {
        f.check();
      }

      return self;
    },

    /**
     * Add group of fields
     * @method
     * @param {string} name
     * @param {object} cfg See <code>MetaphorJs.validator.Group.defaults</code>
     * @returns {MetaphorJs.validator.Validator}
     */
    addGroup: function (name, cfg) {
      var self = this,
          groups = self.groups;

      if (!groups[name]) {
        cfg.name = name;
        groups[name] = new Group(cfg, self);
        self.setGroupEvents(groups[name], 'on');

        if (self.isEnabled() && self.invalid !== null) {
          groups[name].check();
        }
      }

      return self;
    },

    /**
     * Focus first invalid field
     * @method
     */
    focusInvalid: function () {
      var fields = this.fields;

      for (var i in fields) {
        if (!fields[i].isValid()) {
          fields[i].getElem().focus();
          return;
        }
      }
    },

    /**
     * Reset validator: reset all groups and fields to untouched state.
     * @method
     */
    reset: function () {
      var self = this,
          fields = self.fields,
          groups = self.groups,
          i;
      self.submitted = false;
      self.disableDisplayState();

      for (i in groups) {
        groups[i].reset();
      }

      for (i in fields) {
        fields[i].reset();
      }

      self.pending = 0;
      self.invalid = null;
      self.grps = 0;
      self.outside = false;
      self.doDisplayState();
      self.trigger('reset', self);
      return self;
    },

    /**
     * Submit form or display errors
     * @method
     */
    submit: function () {
      var self = this,
          el = self.el;

      if (!self.isForm) {
        self.onSubmit();
        return;
      }

      if (isFunction(el.submit)) {
        if (self.trigger('before-submit', self) !== false && self.trigger('submit', self) !== false) {
          el.submit();
        }
      } else {
        self.onSubmit();
      }
    },
    setFieldEvents: function (v, mode) {
      var self = this;
      v[mode]('state-change', self.onFieldStateChange, self);
      v[mode]('before-remote', self.onBeforeRemote, self);
      v[mode]('after-remote', self.onAfterRemote, self);
      v[mode]('submit', self.onFieldSubmit, self);
      v[mode]('destroy', self.onFieldDestroy, self);
      v[mode]('error-change', self.onFieldErrorChange, self);
    },
    setGroupEvents: function (g, mode) {
      g[mode]('state-change', this.onGroupStateChange, this);
    },
    initFields: function () {
      var self = this,
          el = self.el,
          els,
          i,
          l;

      if (self.isField) {
        self.add(el);
        return self;
      }

      els = MetaphorJs.dom.select("input, textarea, select", el);

      for (i = -1, l = els.length; ++i < l; self.add(els[i])) {}

      return self;
    },
    initForm: function (mode) {
      var self = this,
          el = self.el,
          nodes = el.getElementsByTagName("input"),
          submits = MetaphorJs.dom.select(".submit", el),
          resets = MetaphorJs.dom.select(".reset", el),
          fn = mode === "bind" ? MetaphorJs.dom.addListener : MetaphorJs.dom.removeListener,
          i,
          l,
          type,
          node;

      for (i = 0, l = nodes.length; i < l; i++) {
        node = nodes[i];
        type = node.type;

        if (type === "submit") {
          fn(node, "click", self.onRealSubmitClickDelegate);
        } else if (type === "reset") {
          fn(node, "click", self.resetDelegate);
        }
      }

      for (i = -1, l = submits.length; ++i < l;) {
        if (submits[i].type !== "submit" || submits[i].tagName.toLowerCase() === "button") {
          fn(submits[i], "click", self.onSubmitClickDelegate);
        }
      }

      for (i = -1, l = resets.length; ++i < l; resets[i].type !== "reset" && fn(resets[i], "click", self.resetDelegate)) {}

      if (self.isForm) {
        fn(el, "submit", self.onFormSubmitDelegate);
      }
    },
    onRealSubmitClick: function (e) {
      e = MetaphorJs.dom.normalizeEvent(e || window.event);
      this.submitButton = e.target || e.srcElement;
      this.preventFormSubmit = false;
      return this.onSubmit(e);
    },
    onSubmitClick: function (e) {
      this.preventFormSubmit = false;
      return this.onSubmit(MetaphorJs.dom.normalizeEvent(e || window.event));
    },
    onFormSubmit: function (e) {
      e = MetaphorJs.dom.normalizeEvent(e);

      if (!this.isValid() || this.preventFormSubmit) {
        e.preventDefault();
        return false;
      }
    },
    onFieldSubmit: function (fapi, e) {
      var self = this;
      self.preventFormSubmit = false;
      self.enableDisplayState();
      self.submitted = true;
      return self.onSubmit(e);
    },
    onSubmit: function (e) {
      var self = this;
      self.enableDisplayState();

      if (!self.isForm) {
        e && e.preventDefault();
        e && e.stopPropagation();
      }

      if (self.pending) {
        e && e.preventDefault();
        return false;
      }

      var buttonClicked = !!self.submitButton;

      if (self.isForm) {
        if (self.hidden) {
          self.el.removeChild(self.hidden);
          self.hidden = null;
        } // submit button's value is only being sent with the form if you click the button.
        // since there can be a delay due to remote checks and the form will be submitted later
        // automatically, we need to create a hidden field


        if (self.submitButton && /input|button/.test(self.submitButton.nodeName)) {
          self.hidden = window.document.createElement("input");
          self.hidden.type = "hidden";
          MetaphorJs.dom.setAttr(self.hidden, "name", self.submitButton.name);
          self.hidden.value = self.submitButton.value;
          self.el.appendChild(self.hidden);
        }
      }

      self.submitButton = null;

      if (!self.isValid()) {
        self.check();
        self.onFieldStateChange();

        if (self.pending) {
          // TODO: find out why this flag is not being set in all onSubmit handlers
          self.submitted = true;
          e && e.preventDefault();
          return false;
        }
      }

      if (self.trigger('before-submit', self) === false || !self.isValid()) {
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }

        if (!self.pending) {
          self.focusInvalid();
          self.submitted = false;
        }

        self.trigger('failed-submit', self, buttonClicked);
        return false;
      }

      if (!self.pending) {
        self.submitted = false;
      }

      var res = self.trigger('submit', self);
      self.preventFormSubmit = res === false;
      return !self.isForm ? false : res;
    },
    onFieldDestroy: function (f) {
      var elem = f.getElem(),
          id = MetaphorJs.dom.getAttr(elem, 'name') || MetaphorJs.dom.getAttr(elem, 'id');
      delete this.fields[id];
    },
    onFieldErrorChange: function (f, error) {
      this.trigger("field-error-change", this, f, error);
    },
    onFieldStateChange: function (f, valid) {
      var self = this,
          num = self.invalid,
          fields = self.fields;
      self.invalid = 0;

      for (var i in fields) {
        self.invalid += fields[i].isValid() ? 0 : 1;
      }

      if (f) {
        self.trigger('field-state-change', self, f, valid);
      }

      if (num === null || num !== null && self.invalid !== num) {
        self.doDisplayState();
        self.trigger('state-change', self, self.isValid());
      }
    },
    onGroupStateChange: function () {
      var self = this,
          groups = self.groups,
          num = self.grps;
      self.grps = 0;

      for (var i in groups) {
        self.grps += groups[i].isValid() ? 0 : 1;
      }

      if (num === null || num !== null && self.grps !== num) {
        self.doDisplayState();
        self.trigger('state-change', self, self.isValid());
      }
    },
    doDisplayState: function () {
      var self = this,
          cfg = self.cfg,
          valid = self.isValid(),
          errorCls = cfg.cls.error,
          validCls = cfg.cls.valid,
          el = self.el;

      if (self.isField || !self.displayState) {
        valid = null;
      }

      if (self.invalid === null) {
        valid = null;
      }

      if (errorCls) {
        valid === false ? MetaphorJs.dom.addClass(el, errorCls) : MetaphorJs.dom.removeClass(el, errorCls);
      }

      if (validCls) {
        valid === true ? MetaphorJs.dom.addClass(el, validCls) : MetaphorJs.dom.removeClass(el, validCls);
      }

      self.trigger('display-state', self, valid);
    },
    onBeforeRemote: function () {
      var self = this;
      self.pending++;

      if (self.cfg.cls.remote) {
        MetaphorJs.dom.addClass(self.el, self.cfg.cls.remote);
      }
    },
    onAfterRemote: function () {
      var self = this,
          fields = self.fields,
          cfg = self.cfg;
      self.pending = 0;

      for (var i in fields) {
        self.pending += fields[i].isPending() ? 1 : 0;
      }

      self.doDisplayState();

      if (cfg.cls.remote) {
        MetaphorJs.dom.removeClass(self.el, cfg.cls.remote);
      }

      if (self.submitted && self.pending == 0) {
        self.submitted = false;

        if (self.isValid()) {
          self.submit();
        } else {
          self.focusInvalid();
        }
      }
    },
    onDestroy: function () {
      var self = this,
          groups = self.groups,
          fields = self.fields,
          i;
      self.reset(); //self.trigger('destroy', self);

      delete validators[self.id];

      for (i in groups) {
        if (groups.hasOwnProperty(i) && groups[i]) {
          self.setGroupEvents(groups[i], 'un');
          groups[i].$destroy();
        }
      }

      for (i in fields) {
        if (fields.hasOwnProperty(i) && fields[i]) {
          self.setFieldEvents(fields[i], 'un');
          fields[i].$destroy();
        }
      }

      self.initForm('unbind');
      self.fields = null;
      self.groups = null;
      self.el = null;
      self.cfg = null;
    }
  }, {
    defaults: {},

    /**
     * Add validator
     * @static
     * @method
     * @param {string} name 
     * @param {function} fn {
     *  @param {string} value
     *  @param {HTMLElement} node
     *  @param {string|*} param {
     *      Validator's attribute value. <br>
     *      <pre><input minlength="10"></pre><br>
     *      param=10
     *  }
     *  @returns {boolean} Return false to invalidate field
     * }
     * @param {string} message Error message to display if the field is invalid
     */
    addMethod: function (name, fn, message) {
      var methods = ns.get("MetaphorJs.validator.methods");

      if (!methods[name]) {
        methods[name] = fn;

        if (message) {
          Validator.messages[name] = message;
        }
      }
    },

    /**
     * Check if dom element already has validator initialized
     * @static
     * @method
     * @param {HTMLElement} el 
     * @returns {MetaphorJs.validator.Validator|null}
     */
    getValidator: function (el) {
      var vldId = MetaphorJs.dom.getAttr(el, "data-validator");
      return validators[vldId] || null;
    }
  });
  return Validator;
}();

/***/ }),

/***/ "../metaphorjs-validator/src/var/messages.js":
/*!***************************************************!*\
  !*** ../metaphorjs-validator/src/var/messages.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs-validator/src/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @var {object} MetaphorJs.validator.messages {
 *  Validator error messages. _validator_: "_message_".
 * }
 */


module.exports = MetaphorJs.validator.messages = {
  required: "This field is required.",
  remote: "Please fix this field.",
  email: "Please enter a valid email address.",
  url: "Please enter a valid URL.",
  date: "Please enter a valid date.",
  dateISO: "Please enter a valid date (ISO).",
  number: "Please enter a valid number.",
  digits: "Please enter only digits.",
  creditcard: "Please enter a valid credit card number.",
  equalTo: "Please enter the same value again.",
  accept: "Please enter a value with a valid extension.",
  maxlength: "Please enter no more than {0} characters.",
  minlength: "Please enter at least {0} characters.",
  rangelength: "Please enter a value between {0} and {1} characters long.",
  range: "Please enter a value between {0} and {1}.",
  max: "Please enter a value less than or equal to {0}.",
  min: "Please enter a value greater than or equal to {0}."
};

/***/ }),

/***/ "../metaphorjs-validator/src/var/methods.js":
/*!**************************************************!*\
  !*** ../metaphorjs-validator/src/var/methods.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs-validator/src/__init.js");

__webpack_require__(/*! ../func/empty.js */ "../metaphorjs-validator/src/func/empty.js");

__webpack_require__(/*! ../func/getLength.js */ "../metaphorjs-validator/src/func/getLength.js");

__webpack_require__(/*! metaphorjs/src/func/dom/getInputValue.js */ "../metaphorjs/src/func/dom/getInputValue.js");

__webpack_require__(/*! metaphorjs-shared/src/var/regexp/url.js */ "../metaphorjs-shared/src/var/regexp/url.js");

__webpack_require__(/*! metaphorjs-shared/src/var/regexp/email.js */ "../metaphorjs-shared/src/var/regexp/email.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js");

module.exports = function () {
  var empty = MetaphorJs.validator.empty,
      getLength = MetaphorJs.validator.getLength; // from http://bassistance.de/jquery-plugins/jquery-plugin-validation/
  // i've changed most of the functions, but the result is the same.
  // this === field's api.

  return MetaphorJs.validator.methods = {
    /**
     * Checks that field value is not empty
     * @validator required
     * @param {boolean} param 
     */
    required: function (value, element, param) {
      if (param === false) {
        return true;
      }

      return !empty(value, element);
    },

    /**
     * Test field's value using this regular expression. 
     * Empty value passes as success.
     * @validator regexp
     * @param {string|Regexp} param 
     */
    regexp: function (value, element, param) {
      var reg = param instanceof RegExp ? param : new RegExp(param);
      return empty(value, element) || reg.test(value);
    },

    /**
     * Same as validator.regexp but with the opposite result.
     * Empty value passes as success.
     * @validator notregexp
     * @param {string|Regexp} param 
     */
    notregexp: function (value, element, param) {
      var reg = param instanceof RegExp ? param : new RegExp(param);
      return empty(value, element) || !reg.test(value);
    },

    /**
     * Check if field's value length more than param. 
     * Empty value passes as success.
     * @validator minlength
     * @param {string|int} param 
     */
    minlength: function (value, element, param) {
      return empty(value, element) || (element ? getLength(value.trim(), element) >= param : value.toString().length >= param);
    },

    /**
     * Check if field's value length less than param.
     * Empty value passes as success.
     * @validator maxlength
     * @param {string|int} param 
     */
    maxlength: function (value, element, param) {
      return empty(value, element) || (element ? getLength(value.trim(), element) <= param : value.toString().length <= param);
    },

    /**
     * Check if field's value length between given range.
     * Empty value passes as success.
     * @validator rangelength
     * @param {array} param [min, max]
     */
    rangelength: function (value, element, param) {
      var length = element ? getLength(value.trim(), element) : value.toString().length;
      return empty(value, element) || length >= param[0] && length <= param[1];
    },

    /**
     * Check if field's value is greater than given number.
     * Empty value passes as success.
     * @validator min
     * @param {int} param 
     */
    min: function (value, element, param) {
      return empty(value, element) || parseInt(value, 10) >= param;
    },

    /**
     * Check if field's value is lesser than given number.
     * Empty value passes as success.
     * @validator max
     * @param {int} param 
     */
    max: function (value, element, param) {
      return empty(value, element) || parseInt(value, 10) <= param;
    },

    /**
     * Check if field's value is between given range.
     * Empty value passes as success.
     * @validator range
     * @param {array} param [min, max]
     */
    range: function (value, element, param) {
      value = parseInt(value, 10);
      return empty(value, element) || value >= param[0] && value <= param[1];
    },
    // http://docs.jquery.com/Plugins/Validation/Methods/email

    /**
     * Check is field's value matches email regexp. 
     * Empty value passes as success.
     * @validator email
     */
    email: function (value, element) {
      // contributed by Scott Gonzalez: http://projects.scottsplayground.com/email_address_validation/
      return empty(value, element) || MetaphorJs.regexp.email.test(value);
    },
    // http://docs.jquery.com/Plugins/Validation/Methods/url

    /**
     * Check is field's value matches url regexp. 
     * Empty value passes as success.
     * @validator email
     */
    url: function (value, element) {
      // contributed by Scott Gonzalez: http://projects.scottsplayground.com/iri/
      return empty(value, element) || MetaphorJs.regexp.url.test(value);
    },
    // http://docs.jquery.com/Plugins/Validation/Methods/date

    /**
     * Check if field's value can be parsed as a date.
     * Empty value passes as success.
     * @validator date
     */
    date: function (value, element) {
      return empty(value, element) || !/Invalid|NaN/.test(new Date(value));
    },
    // http://docs.jquery.com/Plugins/Validation/Methods/dateISO

    /**
     * Check if field's value can be parsed as a yyyy-mm-dd date.
     * Empty value passes as success.
     * @validator dateiso
     */
    dateiso: function (value, element) {
      return empty(value, element) || /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(value);
    },
    // http://docs.jquery.com/Plugins/Validation/Methods/number

    /**
     * Check if field's value is a number. Empty value passes as success.
     * @validator number
     */
    number: function (value, element) {
      return empty(value, element) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/.test(value);
    },
    // http://docs.jquery.com/Plugins/Validation/Methods/digits

    /**
     * Check if field's value only consists of digits. Empty value passes as success.
     * @validator digits
     */
    digits: function (value, element) {
      return empty(value, element) || /^\d+$/.test(value);
    },
    // http://docs.jquery.com/Plugins/Validation/Methods/creditcard
    // based on http://en.wikipedia.org/wiki/Luhn

    /**
     * Check if field's value passes for credit card number. Empty value passes as success.
     * @validator creditcard
     */
    creditcard: function (value, element) {
      if (empty(value, element)) {
        return true;
      } // accept only digits and dashes


      if (/[^0-9-]+/.test(value)) {
        return false;
      }

      var nCheck = 0,
          bEven = false,
          nDigit,
          cDigit;
      value = value.replace(/\D/g, "");

      for (var n = value.length - 1; n >= 0; n--) {
        cDigit = value.charAt(n);
        nDigit = parseInt(cDigit, 10);

        if (bEven) {
          if ((nDigit *= 2) > 9) {
            nDigit -= 9;
          }
        }

        nCheck += nDigit;
        bEven = !bEven;
      }

      return nCheck % 10 == 0;
    },
    // http://docs.jquery.com/Plugins/Validation/Methods/accept

    /**
     * Makes a file upload accept only specified mime-types. 
     * Empty value passes as success.
     * @param {string} param mime type string
     */
    accept: function (value, element, param) {
      param = isString(param) ? param.replace(/,/g, '|') : "png|jpe?g|gif";
      return empty(value, element) || value.match(new RegExp(".(" + param + ")$", "i"));
    },
    // http://docs.jquery.com/Plugins/Validation/Methods/equalTo

    /**
     * Check if field's value equals to another field's value
     * @validator equalto
     * @param {*} param Another field's name or id
     */
    equalto: function (value, element, param, api) {
      // bind to the blur event of the target in order to revalidate 
      // whenever the target field is updated
      var f = api.getValidator().getField(param),
          target = f ? f.getElem() : param;
      return value == MetaphorJs.dom.getInputValue(target);
    },

    /**
     * Check if field's value does not equal another field's value
     * @validator notequalto
     * @param {*} param Another field's name or id
     */
    notequalto: function (value, element, param, api) {
      var f = api.getValidator().getField(param),
          target = f ? f.getElem() : param;
      return value != MetaphorJs.dom.getInputValue(target);
    },
    // this is handled separately, but should be here
    // so that validator knew that remote method exists
    remote: function () {
      return false;
    },

    /**
     * Password strength estimator. Expects zxcvbn() 
     * func to be available globally. 
     * @param {*} param 
     */
    zxcvbn: function (value, element, param) {
      return zxcvbn(value).score >= parseInt(param);
    }
  };
}();

/***/ }),

/***/ "../metaphorjs/src/app/App.js":
/*!************************************!*\
  !*** ../metaphorjs/src/app/App.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/State.js */ "../metaphorjs/src/lib/State.js");

__webpack_require__(/*! ./Renderer.js */ "../metaphorjs/src/app/Renderer.js");

__webpack_require__(/*! ../func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ../func/dom/removeAttr.js */ "../metaphorjs/src/func/dom/removeAttr.js");

__webpack_require__(/*! ../func/dom/onReady.js */ "../metaphorjs/src/func/dom/onReady.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/LocalText.js */ "../metaphorjs-shared/src/lib/LocalText.js");

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

__webpack_require__(/*! metaphorjs-shared/src/mixin/Provider.js */ "../metaphorjs-shared/src/mixin/Provider.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js"),
      toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js");
/**
 * @class MetaphorJs.app.App
 */


module.exports = MetaphorJs.app.App = cls({
  $mixins: [MetaphorJs.mixin.Observable, MetaphorJs.mixin.Provider],
  lang: null,
  state: null,
  renderer: null,
  cmpPromises: null,
  cmpListeners: null,
  components: null,
  sourceObs: null,

  /**
   * @constructor
   * @method
   * @param {HTMLElement} node 
   * @param {object} data 
   */
  $init: function (node, data) {
    const self = this,
          state = data instanceof MetaphorJs.lib.State ? data : new MetaphorJs.lib.State(data);
    let args;
    MetaphorJs.dom.removeAttr(node, "mjs-app");
    state.$app = self;
    self.$super();
    self.lang = new MetaphorJs.lib.LocalText();
    self.node = node;
    self.state = state;
    self.cmpListeners = {};
    self.components = {};
    self.cmpPromises = {};
    self.$refs = {
      node: {},
      cmp: {}
    };
    self.factory('$parentCmp', ['$node', self.getParentCmp], self);
    self.value('$app', self);
    self.value('$rootState', state.$root);
    self.value('$lang', self.lang);
    self.value('$locale', self.lang);
    self.renderer = new MetaphorJs.app.Renderer();
    self.renderer.on("rendered", self.afterRender, self);
    self.renderer.on("reference", self._onChildReference, self);
    args = toArray(arguments);
    args[1] = state;
    self.initApp.apply(self, args);
  },
  initApp: emptyFn,
  afterRender: function () {},
  _onChildReference: function (type, ref, item) {
    const self = this;

    if (!self.$refs[type]) {
      self.$refs[type] = {};
    }

    self.$refs[type][ref] = item;
  },

  /**
   * Start processing the DOM
   * @method
   */
  run: function () {
    this.renderer.process(this.node, this.state);
  },

  /**
   * Create data source gate
   * @param {string} name Source name
   * @param {string|bool} returnResult See MetaphorJs.lib.Observable.createEvent()
   */
  createSource: function (name, returnResult) {
    var key = "source-" + name,
        self = this;

    if (!self.$$observable.getEvent(key)) {
      self.$$observable.createEvent(key, returnResult || "nonempty");
    }
  },

  /**
   * Register data source
   * @param {string} name Source name
   * @param {function} fn Function yielding the data
   * @param {object} context fn's context
   */
  registerSource: function (name, fn, context) {
    this.on("source-" + name, fn, context);
  },

  /**
   * Unregister data source
   * @param {string} name Source name
   * @param {function} fn Data function
   * @param {object} context fn's context
   */
  unregisterSource: function (name, fn, context) {
    this.un("source-" + name, fn, context);
  },

  /**
   * Collect data from data source
   * @param {string} name Source name
   * @returns {object|array}
   */
  collect: function (name) {
    arguments[0] = "source-" + arguments[0];
    return this.trigger.apply(this, arguments);
  },

  /**
   * Get parent component for given node
   * @param {HTMLElement} node 
   * @param {bool} includeSelf 
   * @returns {MetaphorJs.app.Component}
   */
  getParentCmp: function (node, includeSelf) {
    const self = this;
    let parent = includeSelf ? node : node.parentNode,
        id;

    while (parent && parent !== window.document.documentElement) {
      //if (id = (MetaphorJs.dom.getAttr(parent, "cmp-id") || parent.$$cmpId)) {
      if (id = parent.$$cmpId) {
        return self.getCmp(id);
      }

      parent = parent.parentNode;
    }

    return null;
  },

  /**
   * Get referenced node from top level
   * @param {string} name 
   * @returns Node|null
   */
  getRefEl: function (name) {
    return this.$refs['node'][name];
  },

  /**
   * Register callback for when component becomes available
   * @param {string} id 
   * @param {function} fn 
   * @param {object} context 
   * @returns {MetaphorJs.lib.Promise}
   */
  onAvailable: function (id, fn, context) {
    const self = this,
          promises = self.cmpPromises,
          components = self.components,
          ev = "available-" + id;
    self.$$observable.createEvent(ev);

    if (fn) {
      self.$$observable.on(ev, fn, context);
    }

    if (!promises[id]) {
      promises[id] = new MetaphorJs.lib.Promise();
      self.$$observable.once(ev, promises[id].resolve, promises[id]);
    }

    if (components[id]) {
      self.$$observable.trigger(ev, components[id]);
    }

    return promises[id];
  },

  /**
   * Get component
   * @param {string} id 
   * @returns {MetaphorJs.app.Component}
   */
  getCmp: function (id) {
    return this.components[id] || null;
  },

  /**
   * Register component
   * @param {MetaphorJs.app.Component} cmp 
   * @param {string} byKey 
   */
  registerCmp: function (cmp, byKey) {
    const self = this,
          id = cmp[byKey],
          ev = "available-" + id,
          deregister = function () {
      delete self.cmpPromises[id];
      delete self.components[id];
    };

    self.components[id] = cmp;
    self.$$observable.trigger(ev, cmp);

    if (cmp.on) {
      cmp.on("destroy", deregister);
    }
  },
  onDestroy: function () {
    const self = this;
    self.renderer.$destroy();
    self.state.$destroy();
    self.lang.$destroy();
    self.$super();
  }
});

/***/ }),

/***/ "../metaphorjs/src/app/Component.js":
/*!******************************************!*\
  !*** ../metaphorjs/src/app/Component.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ../func/dom/setAttr.js */ "../metaphorjs/src/func/dom/setAttr.js");

__webpack_require__(/*! ../func/dom/removeAttr.js */ "../metaphorjs/src/func/dom/removeAttr.js");

__webpack_require__(/*! ../func/dom/isAttached.js */ "../metaphorjs/src/func/dom/isAttached.js");

__webpack_require__(/*! ./Template.js */ "../metaphorjs/src/app/Template.js");

__webpack_require__(/*! ./Directive.js */ "../metaphorjs/src/app/Directive.js");

__webpack_require__(/*! ./Renderer.js */ "../metaphorjs/src/app/Renderer.js");

__webpack_require__(/*! ../func/dom/addClass.js */ "../metaphorjs/src/func/dom/addClass.js");

__webpack_require__(/*! ../func/dom/removeClass.js */ "../metaphorjs/src/func/dom/removeClass.js");

__webpack_require__(/*! ../lib/State.js */ "../metaphorjs/src/lib/State.js");

__webpack_require__(/*! ../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

__webpack_require__(/*! ./Controller.js */ "../metaphorjs/src/app/Controller.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js");

htmlTags = __webpack_require__(/*! ../var/dom/htmlTags.js */ "../metaphorjs/src/var/dom/htmlTags.js");
/**
 * @class MetaphorJs.app.Component
 */

module.exports = MetaphorJs.app.Component = MetaphorJs.app.Controller.$extend({
  /**
   * @var {boolean}
   * @access protected
   */
  useShadowDOM: false,

  /**
   * @var {boolean}
   * @access protected
   */
  replaceCustomNode: true,

  /**
   * @var {string|HtmlElement}
   * @access protected
   */
  renderTo: null,

  /**
   * @var {boolean}
   */
  autoRender: false,

  /**
   * @var {boolean}
   */
  autoAttach: false,

  /**
   * @var {bool}
   * @access protected
   */
  destroyEl: true,

  /**
   * @var {Template}
   */
  template: null,

  /**
   * @var {boolean}
   * @access private
   */
  _nodeReplaced: false,

  /**
   * @var {boolean}
   * @access private
   */
  _nodeCreated: false,

  /**
   * @var {bool}
   * @access protected
   */
  _rendered: false,

  /**
   * @var {bool}
   * @access protected
   */
  _attached: false,
  __nodeId: "$$cmpId",
  __idPfx: "cmp-",
  __initInstance: "_initComponent",
  $constructor: function (cfg) {
    var self = this,
        viewCls = self.$view || (cfg ? cfg.$view : null); // see MetaphorJs.app.component.View

    viewCls && self.$plugins.push(viewCls);
    self.$super();
  },

  /**
   * @constructor
   * @param {object} cfg
   */
  $init: function () {
    var self = this;
    self.$super.apply(self, arguments);
    self.config.getAll(); // calc all values into $cfg

    self._initTemplate();

    self.afterInitComponent.apply(self, arguments);

    if (self.autoRender) {
      self.template.resolve().done(self.template.render, self.template).done(self.render, self);
    }
  },
  // this gets called inside parent's $init
  _initComponent: function () {
    var self = this;

    if (self.$view) {
      self.state.$view = self.$view;
    }

    self.initComponent.apply(self, arguments);
  },
  _initTemplate: function () {
    var self = this,
        tpl = self.template,
        rootNode = null,
        replaceNode = null,
        attachTo = null,
        config = self.config;

    if (self.node) {
      self._nodeReplaced = self.replaceCustomNode && htmlTags.indexOf(self.node.tagName.toLowerCase()) === -1;

      if (self._nodeReplaced) {
        replaceNode = self.node;
        self.node = null;
        self.$refs.node.main = null;
      } else {
        attachTo = self.node;
      }
    }

    if (!tpl && config.has("template")) {
      tpl = config.get("template");
    }

    if (!self.node && config.has("tag")) {
      rootNode = window.document.createElement(config.get("tag"));
      self.node = rootNode;
      self.$refs.node.main = rootNode;
      self._nodeCreated = true;

      if (self._nodeReplaced && replaceNode.parentNode) {
        replaceNode.parentNode.replaceChild(replaceNode, rootNode);
        rootNode = null;
        attachTo = self.node;
      }
    }

    var tplConfig = new MetaphorJs.lib.Config({
      deferRendering: true,
      runRenderer: true,
      useShadow: config.copyProperty("useShadow"),
      makeTranscludes: config.copyProperty("makeTranscludes")
    }, {
      state: self.state
    });
    attachTo && tplConfig.setStatic("useComments", false);
    MetaphorJs.app.Template.prepareConfig(tplConfig, tpl);

    self._initTplConfig(tplConfig);

    self.template = tpl = new MetaphorJs.app.Template({
      state: self.state,
      config: tplConfig,
      rootNode: rootNode,
      attachTo: attachTo,
      replaceNode: replaceNode,
      callback: {
        context: self,
        reference: self._onChildReference,
        rendered: self._onRenderingFinished,
        attached: self._onTemplateAttached
      }
    });

    if (self._nodeCreated) {
      self.template.setNamedNode("main", self.node);
    }
  },
  _initTplConfig: function (config) {},
  initConfig: function () {
    var self = this;
    self.$super();
    self.$self.initConfig(self.config);
  },
  hasDirective: function (name) {
    return this.directives && !!this.directives[name];
  },
  applyDirective: function (name, cfg) {
    var self = this,
        support = self.$self.supportsDirectives,
        dir;

    if (!support) {
      return;
    }

    if (support !== true && !support[name]) {
      return;
    }

    if (self._rendered) {
      dir = MetaphorJs.app.Directive.getDirective("attr", name);

      if (dir) {
        MetaphorJs.app.Renderer.applyDirective(dir.handler, self._getDirectiveState(), self, self._prepareDirectiveCfg(dirCfg));
      } else {
        throw new Error("Directive " + name + " not found");
      }
    } else {
      if (!self.directives) {
        self.directives = {};
      }

      if (!self.directives[name]) {
        self.directives[name] = [cfg];
      } else {
        self.directives[name].push(cfg);
      }
    }
  },
  _getDirectiveState: function () {
    const dirs = this.directives || {};
    return dirs.state || this.parentState || this.state.$parent || this.config.getOption("state") || this.state;
  },
  _prepareDirectiveCfg: function (cfg) {
    if (cfg instanceof MetaphorJs.lib.Config) {
      return cfg;
    }

    var self = this,
        config;

    if (typeof cfg === "string") {
      cfg = {
        value: {
          value: cfg
        }
      };
    }

    config = new MetaphorJs.lib.Config(cfg, {
      state: self._getDirectiveState()
    });
    self.on("destroy", config.$destroy, config);
    return config;
  },
  _initDirectives: function () {
    var self = this,
        dirs = self.directives,
        support = self.$self.supportsDirectives,
        ds,
        handlers = MetaphorJs.app.Directive.getAttributes(),
        i,
        len,
        name,
        j,
        jlen;

    if (!support) {
      return;
    }

    for (i = 0, len = handlers.length; i < len; i++) {
      name = handlers[i].name;

      if (!(support === true || support[name])) {
        continue;
      }

      if ((ds = dirs[name]) !== undefined) {
        !isArray(ds) && (ds = [ds]);

        for (j = 0, jlen = ds.length; j < jlen; j++) {
          MetaphorJs.app.Renderer.applyDirective(handlers[i].handler, self._getDirectiveState(), self, self._prepareDirectiveCfg(ds[j]));
        }
      }
    }
  },
  _onChildReference: function (type, ref, item) {
    var self = this; // change comment's reference name so
    // that it won't get referenced twice

    if (item) {
      if (item.nodeType && item.nodeType === window.document.COMMENT_NODE) {
        item.textContent = "*" + self.id + "*" + ref + "*";
      } else {
        if (!self.node && type === "node" && ref === "main") {
          self.node = item;

          self._claimNode();
        }

        if (self.template instanceof MetaphorJs.app.Template) {
          self.template.setNamedNode(ref, item);
        }
      }
    }

    self.$super.apply(self, arguments);
  },
  render: function (parent, before) {
    var self = this;

    if (parent && parent.nodeType === window.document.COMMENT_NODE) {
      before = parent;
      parent = parent.parentNode;
    }

    if (self._rendered) {
      parent && self.attach(parent, before);
    } else if (parent) {
      self.renderTo = parent;
      self.renderBefore = before;
    }

    self.onBeforeRender();
    self.trigger('render', self);

    if (self.template) {
      self.template.render();
    }
  },
  isAttached: function (parent) {
    return this.template.isAttached(parent);
  },
  attach: function (parent, before) {
    var self = this;

    if (!parent) {
      throw new Error("Parent node is required");
    }

    self.template.attach(parent, before);
  },
  detach: function () {
    var self = this;

    if (self.template.isAttached()) {
      self.template.detach();
    }
  },
  onBeforeRender: function () {},
  _onRenderingFinished: function () {
    var self = this;
    self._rendered = true;
    self.afterRender();
    self.trigger('after-render', self);

    if (self.renderTo) {
      self.template.attach(self.renderTo, self.renderBefore);
    }

    if (self.directives) {
      self._initDirectives();
    }
  },
  _onTemplateAttached: function () {
    this._attached = true;
    this.afterAttached();
    this.trigger('after-attached', this);
  },

  /**
   * @access public
   * @return bool
   */
  isRendered: function () {
    return this._rendered;
  },

  /**
   * @access public
   * @return bool
   */
  isDestroyed: function () {
    return this.$destroyed;
  },

  /**
   * Returns api (in a simplest case - dom element) 
   * for directive to work with
   * @param {string} directive 
   */
  getDomApi: function (directive) {
    var sup = this.$self.supportsDirectives;

    if (!sup || !sup[directive]) {
      return null;
    }

    var ref = sup[directive] === true ? "main" : sup[directive];
    return this.getRefEl(ref) || this.getRefElPromise(ref);
  },
  getInputApi: function () {
    return null;
  },
  getApi: function (type, directive) {
    if (type === "node") {
      return this.getDomApi(directive);
    } else if (type === "input") {
      return this.getInputApi();
    }
  },

  /**
   * @method
   * @access protected
   */
  beforeInitComponent: emptyFn,

  /**
   * @method
   * @access protected
   */
  initComponent: emptyFn,

  /**
   * @method
   * @access protected
   */
  afterInitComponent: emptyFn,

  /**
   * @method
   * @access protected
   */
  afterRender: emptyFn,

  /**
   * @method
   * @access protected
   */
  afterAttached: emptyFn,

  /**
   * @method
   * @access protected
   */
  afterDetached: emptyFn,
  onDestroy: function () {
    var self = this;

    if (self.template) {
      self.template.$destroy();
    }

    if (self.node) {
      if (self.destroyEl) {
        if (MetaphorJs.dom.isAttached(self.node)) {
          self.node.parentNode.removeChild(self.node);
        }
      } else {
        self._releaseNode();
      }
    }

    self.$super();
  }
}, {
  initConfig: function (config) {
    var mst = MetaphorJs.lib.Config.MODE_STATIC;
    config.setType("makeTranscludes", "bool", mst, false);
    config.setType("useShadow", "bool", mst, false);
    config.setDefaultMode("tag", mst);
  },
  registerWebComponent: function (tagName) {
    var cls = this;
    Directive.registerComponent(tagName, cls);
    return MetaphorJs.dom.webComponentWrapper(tagName, cls);
  },
  registerDirective: function (cmp) {
    if (typeof cmp === "string") {
      Directive.registerComponent(cmp);
    } else {
      Directive.registerComponent(cmp.prototype.$class, cmp);
    }
  },

  /**
   * @static
   * @var {object|bool}
   */
  supportsDirectives: false,
  configProps: [],
  createFromPlainObject: function (obj) {
    if (obj instanceof this) {
      return obj;
    }

    if (!obj.config) {
      var config = {},
          props = this.configProps,
          i,
          l,
          name;
      obj.config = config;

      for (i = 0, l = props.length; i < l; i++) {
        name = props[i];

        if (obj[name]) {
          config[name] = obj[name];
          delete obj[name];
        }
      }
    }

    return new this(obj);
  }
});

/***/ }),

/***/ "../metaphorjs/src/app/Container.js":
/*!******************************************!*\
  !*** ../metaphorjs/src/app/Container.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/app/__init.js");

__webpack_require__(/*! ./Component.js */ "../metaphorjs/src/app/Component.js");

__webpack_require__(/*! ./Template.js */ "../metaphorjs/src/app/Template.js");

__webpack_require__(/*! ./Renderer.js */ "../metaphorjs/src/app/Renderer.js");

__webpack_require__(/*! ../func/app/resolve.js */ "../metaphorjs/src/func/app/resolve.js");

__webpack_require__(/*! ../func/dom/getAttrSet.js */ "../metaphorjs/src/func/dom/getAttrSet.js");

__webpack_require__(/*! ../func/dom/is.js */ "../metaphorjs/src/func/dom/is.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      isPlainObject = __webpack_require__(/*! metaphorjs-shared/src/func/isPlainObject.js */ "../metaphorjs-shared/src/func/isPlainObject.js"),
      toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      isThenable = __webpack_require__(/*! metaphorjs-shared/src/func/isThenable.js */ "../metaphorjs-shared/src/func/isThenable.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      ns = __webpack_require__(/*! metaphorjs-namespace/src/var/ns.js */ "../metaphorjs-namespace/src/var/ns.js");

module.exports = MetaphorJs.app.Container = MetaphorJs.app.Component.$extend({
  $mixinEvents: ["$initChildItem"],
  _itemsInitialized: false,
  defaultAddTo: "main",
  _initComponent: function () {
    var self = this;
    self.$super.apply(self, arguments);

    if (self.node && self.template && self.node.firstChild) {
      self._prepareDeclaredItems(toArray(self.node.childNodes));
    }

    self._initItems();
  },
  _initTplConfig: function (tplConfig) {
    tplConfig.setStatic("makeTranscludes", false);
    tplConfig.setFinal("makeTranscludes");
  },
  _prepareDeclaredItems: function (nodes) {
    var self = this,
        i,
        l,
        node,
        renderer,
        found = false,
        idkey = self._getIdKey(),
        renderRef,
        attrSet,
        foundCmp,
        foundPromise,
        state = self.state,
        items = self.items || [],
        def,
        refCallback = function (type, ref, cmp, cfg, attrSet) {
      if (cfg.node === node) {
        foundCmp = cmp;
        renderRef = attrSet.at;
      }
    },
        promiseCallback = function (promise, cmpName, cfg, attrSet) {
      if (cfg.node === node) {
        foundPromise = promise;
        renderRef = attrSet.at;
      }
    };

    if (!self._itemsInitialized && isArray(items)) {
      items = {
        body: items
      };
    }

    for (i = 0, l = nodes.length; i < l; i++) {
      node = nodes[i];

      if (!node) {
        continue;
      }

      def = null;

      if (node.nodeType === window.document.ELEMENT_NODE) {
        if (node[idkey]) {
          continue;
        } // detach node


        node.parentNode && !node.hasAttribute("slot") && node.parentNode.removeChild(node);
        foundCmp = null;
        foundPromise = null;
        renderRef = null;
        renderer = new MetaphorJs.app.Renderer();
        state.$on("destroy", renderer.$destroy, renderer);
        renderer.on("reference", refCallback);
        renderer.on("reference-promise", promiseCallback);
        renderer.process(node, state);

        if (foundCmp || foundPromise) {
          if (!renderRef) {
            renderRef = self.defaultAddTo;
          }

          def = extend({
            type: "component",
            renderRef: renderRef,
            renderer: renderer,
            component: foundCmp || foundPromise,
            resolved: !!foundCmp
          }, self._createDefaultItemDef());
          node[idkey] = def.id;
        } else {
          attrSet = MetaphorJs.dom.getAttrSet(node);
          renderRef = attrSet.at || attrSet.rest.slot || self.defaultAddTo;
          def = extend({
            type: "node",
            renderRef: renderRef,
            node: node
          }, self._createDefaultItemDef());
        }

        found = true;
        renderer.un("reference", refCallback);
        renderer.un("reference-promise", promiseCallback);

        if (!self._itemsInitialized) {
          if (!items[renderRef]) {
            items[renderRef] = [];
          }

          items[renderRef].push(def);
        } else {
          self.addItem(def);
        }
      }
    }

    if (found && !self._itemsInitialized) {
      self.items = items;
    }
  },
  _initItems: function () {
    var self = this,
        items = self.items || [],
        p2i = self.$self.propsToItems,
        defs,
        list = [],
        item,
        name,
        i,
        l,
        ref;
    self._itemsInitialized = true;
    self.itemsMap = {};

    if (isArray(items)) {
      var tmp = {};
      tmp[self.defaultAddTo] = items;
      items = tmp;
    }

    if (p2i) {
      for (name in p2i) {
        if (self[name]) {
          self._initIntoItems(self[name], p2i[name]);
        }
      }
    }

    for (ref in items) {
      defs = items[ref];

      if (!isArray(defs)) {
        defs = [defs];
      }

      for (i = -1, l = defs.length; ++i < l;) {
        item = self._processItemDef(defs[i]);

        if (item) {
          item.renderRef = ref;
          list.push(item);
        }
      }
    }

    self.items = list;
  },
  _getIdKey: function () {
    return "$$container_" + this.id;
  },
  _createDefaultItemDef: function () {
    var id = nextUid();
    return {
      __containerItemDef: true,
      type: "component",
      placeholder: window.document.createComment("*" + this.id + "*" + id + "*"),
      id: id,
      resolved: true,
      processed: false,
      attached: false
    };
  },
  _processItemDef: function (def, ext) {
    var self = this,
        idkey = self._getIdKey(),
        item;

    if (def.__containerItemDef) {
      item = def;
      self.itemsMap[item.id] = item;
    } else {
      item = self._createDefaultItemDef();

      if (ext) {
        extend(item, ext, false, false);
      }

      self.itemsMap[item.id] = item; // component[idkey] = item.id
      // every child component contains `idkey` field
      // holding its id in parent container;
      // and by idkey itself we can identify container

      if (typeof def === "string") {
        def = self._initStringItem(def);
      }

      if (isPlainObject(def)) {
        def = self._initObjectItem(def);
      }

      if (isPlainObject(def)) {
        item = extend({}, def, item, false, false);
        self.itemsMap[item.id] = item; // rewrite item map
      } else if (typeof def === "function") {
        item.component = new def({
          state: self.state.$new()
        });
      } else if (def instanceof MetaphorJs.app.Component) {
        item.component = def;
      } else if (def instanceof window.Node) {
        item.type = "node";
        item.node = def;
      } else if (def instanceof MetaphorJs.app.Template) {
        item.component = new MetaphorJs.app.Component({
          state: self.state,
          template: def
        });
      } else if (typeof def === "string") {
        var cfg = {
          state: self.state
        };
        item.component = MetaphorJs.app.resolve(def, cfg);
      } else if (isThenable(def)) {
        item.component = def;
      } else {
        throw new Error("Failed to initialize item");
      }
    }

    if (!item.processed) {
      var prevItem = item;

      if (!self._allowChildItem(item)) {
        return null;
      }

      if (item.type === "node") {
        item = self._wrapChildItem(item);
        item.node[idkey] = item.id;
      } else if (item.type === "component") {
        if (isThenable(item.component)) {
          item.resolved = false;
          item.component.done(function (cmp) {
            item.component = cmp;

            if (!self._allowChildItem(item)) {
              return null;
            }

            item = self._wrapChildItem(item);
            item.component[idkey] = item.id;

            self._onChildResolved(item.component);
          });
        } else {
          item = self._wrapChildItem(item);
          item.component[idkey] = item.id;

          self._onChildResolved(item.component);
        }
      } // item got wrapped


      if (prevItem !== item) {
        delete self.itemsMap[prevItem.id];
        self.itemsMap[item.id] = item;
      }

      self._initChildItem(item);

      self.$callMixins("$initChildItem", item);
      item.processed = true;
    }

    return item;
  },
  _initChildItem: function (item) {},
  _allowChildItem: function (item) {
    var allow = this.$self.allowItems || ["*"];
    typeof allow === "string" && (allow = [allow]);

    if (allow.indexOf("*") !== -1) {
      return true;
    }

    if (item.type === "component") {
      return allow.indexOf(item.component.$class) !== -1;
    }

    return true;
  },
  _wrapChildItem: function (item) {
    var self = this,
        cls = self.$self,
        allow = cls.allowUnwrapped || [],
        wrapper = cls.wrapper,
        wrapCls;
    typeof allow === "string" && (allow = [allow]);

    if (!wrapper || allow.indexOf("*") !== -1) {
      return item;
    }

    if (item.type === "component") {
      if (allow.indexOf(item.component.$class) !== -1) {
        return item;
      }

      wrapCls = typeof wrapper === "string" || typeof wrapper === "function" ? wrapper : wrapper[item.component.$class] || wrapper["*"];
      wrapCls = typeof wrapper === "string" ? ns.get(wrapper) : wrapper;

      var newItem = self._createDefaultItemDef();

      newItem.component = new wrapCls({
        state: self.state,
        items: [item.component]
      });
      return newItem;
    }

    return item;
  },
  _initObjectItem: function (def) {
    return def;
  },
  _initStringItem: function (def) {
    if (def.substring(0, 1) === '<') {
      var div = document.createElement("div");
      div.innerHTML = def;
      return div.firstChild;
    }

    return def;
  },
  _initChildEvents: function (mode, cmp) {
    var self = this;
    cmp[mode]("remove-from-container", self._onChildRemove, self);
  },
  _onChildRemove: function (cmp) {
    var self = this,
        idkey = self._getIdKey(),
        itemid = cmp[idkey],
        item,
        inx;

    if (itemid && (item = self.itemsMap[itemid])) {
      delete cmp[idkey];
      delete self.itemsMap[itemid];
      inx = self.items.indexOf(item);

      if (cmp instanceof MetaphorJs.app.Component) {
        self._initChildEvents("un", cmp);
      }

      if (inx !== -1) {
        self.items.splice(inx, 1);
      }

      self._detachChildItem(item);
    }
  },
  _onChildResolved: function (cmp) {
    var self = this,
        idkey = self._getIdKey(),
        itemid = cmp[idkey],
        item,
        ref;

    if (itemid && (item = self.itemsMap[itemid])) {
      item.resolved = true;
      item.component = cmp;

      if (ref = cmp.config.get("ref")) {
        self._onChildReference("cmp", ref, cmp);
      }

      self._initChildEvents("on", cmp);

      if (self._rendered) {
        item.component.render();

        self._putItemInPlace(item);
      }
    }
  },
  _initIntoItems: function (smth, cls) {
    var self = this,
        item = self._createDefaultItemDef();

    typeof cls === "string" && (cls = ns.get(cls));

    if (!(smth instanceof cls)) {
      smth = cls.createFromPlainObject(smth);
    }

    item.component = smth;
    item.resolved = !isThenable(smth);
    !self.items && (self.items = []);

    if (isArray(self.items)) {
      self.items.push(item);
    } else {
      self.items.body.push(item);
    }
  },
  render: function () {
    var self = this,
        items = self.items || [],
        i,
        l;

    for (i = -1, l = items.length; ++i < l;) {
      if (items[i].type === "component" && items[i].resolved) {
        items[i].component.render();
      }
    }

    self.$super.apply(self, arguments);
  },
  _onTemplateAttached: function () {
    var self = this,
        i,
        l,
        items = self.items; // insert all placeholders, but
    // attach only resolved items

    for (i = -1, l = items.length; ++i < l;) {
      self._putItemInPlace(items[i]);
    }

    self.$super();
  },
  _putItemInPlace: function (item) {
    var self = this;

    if (item.placeholder && !item.placeholder.parentNode) {
      self._preparePlaceholder(item);
    }

    if (item.resolved && !item.attached) {
      if (item.renderRef) {
        self.template.setNamedNode(item.renderRef, item.node || item.component);
      }

      self._attachChildItem(item);
    }
  },
  _preparePlaceholder: function (item) {
    var self = this,
        refnode = self.getRefEl(item.renderRef);

    if (item.type === "node" && item.node.hasAttribute("slot")) {
      return;
    }

    if (!refnode) {
      throw new Error("Can't find referenced node: " + item.renderRef);
    } // if refnode is <slot> we do nothing;
    // when attaching, we just set "slot" attribute on item


    if (refnode instanceof window.HTMLSlotElement) {
      return;
    } // comment


    if (refnode.nodeType === window.document.COMMENT_NODE) {
      refnode.parentNode.insertBefore(item.placeholder, refnode);
    } else refnode.appendChild(item.placeholder);
  },
  // only resolved components get here; so do attach
  _attachChildItem: function (item) {
    var self = this,
        refnode = self.getRefEl(item.renderRef);

    if (item.attached) {
      return;
    }

    if (item.type === "node") {
      if (item.node.hasAttribute("slot")) {
        item.attached = true;
        return;
      }

      if (refnode instanceof window.HTMLSlotElement) {
        item.node.setAttribute("slot", refnode.getAttribute("name"));
      } else if (refnode.nodeType === window.document.COMMENT_NODE) {
        refnode.parentNode.insertBefore(item.node, item.placeholder);
      } else {
        refnode.insertBefore(item.node, item.placeholder);
      }
    } else if (item.type === "component") {
      if (refnode.nodeType === window.document.COMMENT_NODE) item.component.render(refnode.parentNode, item.placeholder);else item.component.render(refnode, item.placeholder);
    }

    item.attached = true;
  },
  _detachChildItem: function (item) {
    if (!item.attached) {
      return;
    }

    if (item.type === "node") {
      item.node.parentNode && item.node.parentNode.removeChild(item.node);
    } else if (item.type === "component") {
      item.component.detach();
      item.placeholder.parentNode && item.placeholder.parentNode.removeChild(item.placeholder);
    }

    item.attached = false;
  },
  hasItem: function (cmp) {
    var self = this,
        idkey = self._getIdKey(),
        id,
        item;

    if (typeof cmp === "string" || typeof cmp === "function") {
      for (id in self.itemMap) {
        item = self.itemMap[id];

        if (item.type === "component" && (item.componet.id === cmp || item.component.$is(cmp))) {
          return true;
        }
      }

      return false;
    } else return !!cmp[idkey];
  },
  hasItemIn: function (ref, smth) {
    if (!this.items[ref] || this.items[ref].length === 0) {
      return false;
    }

    var i, l, item;

    for (i = 0, l = this.items[ref].length; i < l; i++) {
      item = this.items[ref][i];

      if (item.type === "component") {
        if (item.component.$is(smth)) {
          return true;
        }
      }
    }

    return false;
  },
  addItem: function (cmp, to) {
    var self = this,
        item;

    if (self.hasItem(cmp)) {
      return;
    }

    if (cmp instanceof MetaphorJs.app.Component) {
      cmp.trigger("remove-from-container", cmp);
    }

    item = self._processItemDef(cmp, {
      renderRef: to || self.defaultAddTo
    });
    self.items.push(item); // component item got attached via onChildResolved

    if (item.type === "node" && self._attached) {
      self._putItemInPlace(item);
    }
  },
  removeItem: function (cmp) {
    var self = this;

    if (!self.hasItem(cmp)) {
      return;
    }

    if (cmp instanceof MetaphorJs.app.Component) {
      cmp.trigger("remove-from-container", cmp);
    } else {
      self._onChildRemove(cmp);
    }
  },
  onDestroy: function () {
    var self = this,
        i,
        l,
        item;

    for (i = 0, l = self.items.length; i < l; i++) {
      item = self.items[i];

      if (item.renderer) {
        item.renderer.$destroy();
      }

      if (item.type === "component") {
        item.component.$destroy && item.component.$destroy();
      }
    }

    self.items = null;
    self.$super();
  }
}, {
  allowItems: ["*"],
  allowUnwrapped: ["*"],
  wrapper: null
});

/***/ }),

/***/ "../metaphorjs/src/app/Controller.js":
/*!*******************************************!*\
  !*** ../metaphorjs/src/app/Controller.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/State.js */ "../metaphorjs/src/lib/State.js");

__webpack_require__(/*! ../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      isThenable = __webpack_require__(/*! metaphorjs-shared/src/func/isThenable.js */ "../metaphorjs-shared/src/func/isThenable.js");
/**
 * @class MetaphorJs.app.Controller
 */


module.exports = MetaphorJs.app.Controller = cls({
  $mixins: [MetaphorJs.mixin.Observable],
  $mixinEvents: ["$initConfig"],

  /**
   * @access protected
   * @var {string}
   */
  id: null,

  /**
   * @var {HtmlElement}
   * @access protected
   */
  node: null,

  /**
   * @var {MetaphorJs.lib.State}
   */
  state: null,

  /**
   * @var {MetaphorJs.app.Renderer}
   */
  parentRenderer: null,

  /**
   * @var {MetaphorJs.lib.Config}
   */
  config: null,

  /**
   * @var {bool}
   */
  destroyState: false,
  __nodeId: "$$ctrlId",
  __idPfx: "ctrl-",
  __initInstance: "initController",

  /**
   * @constructor
   * @param {object} cfg
   */
  $init: function (cfg) {
    let self = this,
        state,
        config;
    cfg = cfg || {};
    self._protoCfg = self.config;
    self.config = null;
    self.$super(cfg);
    extend(self, cfg, true, false);

    if (!self.state || typeof self.state === "string" && self.state.indexOf(":new") !== -1) {
      self.destroyState = true;
    }

    state = self.state = MetaphorJs.lib.State.$produce(self.state); // We initialize config with current state or change config's state
    // to current so that all new properties that come from initConfig
    // are bound to local state. 
    // All pre-existing properties are already bound to outer state;
    // Also, each property configuration can have its own state specified

    config = self.config = MetaphorJs.lib.Config.create(self.config, {
      state
    },
    /*scalarAs: */
    "defaultValue");
    config.setOption("state", state);
    state.$cfg = {};
    config.setTo(state.$cfg);
    self.initConfig();
    self.$callMixins("$initConfig", config);

    if (self._protoCfg) {
      config.addProperties(self._protoCfg,
      /*scalarAs: */
      "defaultValue");
    }

    self.id = config.get("id");
    self.$refs = {
      node: {},
      cmp: {}
    };

    if (self.node) {
      self.$refs.node.main = self.node;
    }

    if (config.has("init")) {
      config.get("init")(state);
    }

    if (config.has("as")) {
      state[config.get("as")] = self;
    }

    self[self.__initInstance].apply(self, arguments);

    if (state.$app) {
      state.$app.registerCmp(self, "id");
    }

    if (self.parentRenderer) {
      self.parentRenderer.on("destroy", self._onParentRendererDestroy, self);
    }

    self._claimNode();
  },
  initConfig: function () {
    var self = this,
        state = self.state,
        config = self.config,
        mst = MetaphorJs.lib.Config.MODE_STATIC;
    config.setType("id", "string", mst, self.id || self.__idPfx + nextUid());
    self.$self.initConfig(config);

    if (self.as) {
      config.setDefaultValue("as", self.as);
    }

    MetaphorJs.lib.Observable.$initHostConfig(self, config, state, self.node);
  },
  _claimNode: function () {
    var self = this;
    self.node && (self.node[self.__nodeId] = self.id);
  },
  _releaseNode: function () {
    var self = this;
    self.node && (self.node[self.__nodeId] = null);
  },
  _onChildReference: function (type, ref, item) {
    var self = this;

    if (!self.$refs[type]) {
      self.$refs[type] = {};
    }

    var th = self.$refs[type][ref];

    if (!th) {
      self.$refs[type][ref] = item;
    }

    if (isThenable(th)) {
      th.resolve(item);
    }
  },
  getRefEl: function (name) {
    return this.$refs['node'][name];
  },
  getRefCmp: function (name) {
    return this.$refs['cmp'][name];
  },
  _getRefPromise: function (type, name) {
    var ref = this.$refs[type][name];

    if (!ref) {
      return this.$refs[type][name] = new MetaphorJs.lib.Promise();
    } else if (isThenable(ref)) {
      return ref;
    } else {
      return MetaphorJs.lib.Promise.resolve(ref);
    }
  },
  getRefElPromise: function (name) {
    return this._getRefPromise("node", name);
  },
  getRefCmpPromise: function (name) {
    return this._getRefPromise("cmp", name);
  },

  /**
   * @access public
   * @return Element
   */
  getEl: function () {
    return this.node;
  },

  /**
   * @access public
   * @return bool
   */
  isDestroyed: function () {
    return this.$$destroyed;
  },

  /**
   * @method
   * @access protected
   */
  initController: emptyFn,
  _onParentRendererDestroy: function () {
    this.$destroy();
  },
  onDestroy: function () {
    if (this.destroyState && this.state) {
      this.state.$destroy();
    }

    this._releaseNode();

    this.config.$destroy();
    this.$super();
  }
}, {
  initConfig: function (config) {
    const mst = MetaphorJs.lib.Config.MODE_STATIC;
    config.setMode("init", MetaphorJs.lib.Config.MODE_FUNC);
    config.setDefaultMode("as", mst);
    config.setDefaultMode("state", mst);
  }
});

/***/ }),

/***/ "../metaphorjs/src/app/Directive.js":
/*!******************************************!*\
  !*** ../metaphorjs/src/app/Directive.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

__webpack_require__(/*! ../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ../lib/MutationObserver.js */ "../metaphorjs/src/lib/MutationObserver.js");

__webpack_require__(/*! ../func/dom/commentWrap.js */ "../metaphorjs/src/func/dom/commentWrap.js");

__webpack_require__(/*! ../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../func/dom/isField.js */ "../metaphorjs/src/func/dom/isField.js");

__webpack_require__(/*! ../lib/Input.js */ "../metaphorjs/src/lib/Input.js");

__webpack_require__(/*! metaphorjs-observable/src/lib/Observable.js */ "../metaphorjs-observable/src/lib/Observable.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");

const isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      isThenable = __webpack_require__(/*! metaphorjs-shared/src/func/isThenable.js */ "../metaphorjs-shared/src/func/isThenable.js"),
      async = __webpack_require__(/*! metaphorjs-shared/src/func/async.js */ "../metaphorjs-shared/src/func/async.js"),
      cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      ns = __webpack_require__(/*! metaphorjs-namespace/src/var/ns.js */ "../metaphorjs-namespace/src/var/ns.js");

module.exports = MetaphorJs.app.Directive = function () {
  var attr = {},
      tag = {},
      component = {},
      attributes = [],
      attributesSorted = false,
      compare = function (a, b) {
    return a.priority - b.priority;
  };

  MetaphorJs.directive = MetaphorJs.directive || {
    attr: attr,
    tag: tag,
    component: component
  };
  return cls({
    $mixins: [MetaphorJs.mixin.Observable],
    state: null,
    node: null,
    component: null,
    attrSet: null,
    renderer: null,
    wrapperOpen: null,
    wrapperClose: null,
    _apis: ["node"],
    _autoOnChange: true,
    _initPromise: null,
    _nodeAttr: null,
    _initial: true,
    _asyncInit: false,
    $init: function (state, node, config, renderer, attrSet) {
      var self = this;
      self.state = state;
      self.config = config;
      self.renderer = renderer;
      self.attrSet = attrSet;
      self._nodeAttr = node;
      self.initConfig();
      self.initState();
      self._asyncInit && self.initAsyncInit();
      self.initNodeAttr();
      self._initPromise ? self._initPromise.done(self.initDirective, self) : self.initDirective();
    },
    initAsyncInit: function () {
      var self = this;
      self._initPromise = new MetaphorJs.lib.Promise();
      var asnc = new MetaphorJs.lib.Promise();

      self._initPromise.after(asnc);

      async(function () {
        if (!self.$destroyed) {
          asnc.resolve();
        }
      });
    },
    initNodeAttr: function () {
      var self = this,
          node = self._nodeAttr;

      if (node instanceof window.Node) {
        self.node = node;
        self.initNode(node);
        self._initPromise && self._initPromise.resolve();
      } else if (node.$is && node.$is("MetaphorJs.app.Component")) {
        self.component = node;
        self.initComponent(node);
        self._initPromise && self._initPromise.resolve();
      } else if (isThenable(node)) {
        node.done(function (node) {
          self._nodeAttr = node;
        }).done(self.initNodeAttr, self);
      }
    },
    initConfig: function () {
      var config = this.config;
      this.$self.initConfig(config, this);
      MetaphorJs.lib.Observable.$initHostConfig(this, config, this.state);
    },
    initState: function () {
      this.state.$on("destroy", this.onStateDestroy, this);
      this.state.$on("reset", this.onStateReset, this);
    },
    initComponent: function (component) {
      var self = this,
          apis = self._apis,
          i,
          l,
          res;

      for (i = 0, l = apis.length; i < l; i++) {
        res = self.initApi(component, apis[i]);

        if (isThenable(res)) {
          !self._initPromise && (self._initPromise = new MetaphorJs.lib.Promise());

          self._initPromise.after(res);
        }
      }
    },
    initNode: function (node) {
      if (this._apis.indexOf("input") !== -1 && MetaphorJs.dom.isField(node)) {
        this.input = MetaphorJs.lib.Input.get(node, this.state);
      }
    },
    initApi: function (component, apiType) {
      var self = this,
          api = component.getApi(apiType, self.id);

      if (isThenable(api)) {
        return api.done(function (api) {
          self._onApiResolved(apiType, api);
        });
      } else self._onApiResolved(apiType, api);
    },
    _onApiResolved: function (apiType, api) {
      this[apiType] = api;
    },
    initDirective: function () {
      this.initChange();
    },
    initChange: function () {
      var self = this,
          val;
      self.config.on("value", self.onStateChange, self);

      if (self._autoOnChange && (val = self.config.get("value")) !== undefined) {
        self.onStateChange(val, undefined);
      }
    },
    createCommentWrap: function (node, name) {
      var cmts = MetaphorJs.dom.commentWrap(node, name || this.$class);
      this.wrapperOpen = cmts[0];
      this.wrapperClose = cmts[1];
    },
    onStateDestroy: function () {
      this.$destroy();
    },
    onStateReset: function () {},
    onStateChange: function (val) {
      this.saveStateOnChange(val);
    },
    saveStateOnChange: function (val) {
      if (this._prevState !== undefined) {
        this.trigger("change", val, this._prevState);
      }

      this._prevState = val;
    },
    onDestroy: function () {
      var self = this;

      if (isThenable(self.node)) {
        self.node.$destroy();
      }

      if (self._initPromise) {
        self._initPromise.$destroy();
      }

      if (self.state) {
        self.state.$un("destroy", self.onStateDestroy, self);
        self.state.$un("reset", self.onStateReset, self);
      }

      if (self.config) {
        self.config.$destroy();
      }

      if (self.wrapperOpen && self.wrapperOpen.parentNode) {
        self.wrapperOpen.parentNode.removeChild(self.wrapperOpen);
      }

      if (self.wrapperClose && self.wrapperClose.parentNode) {
        self.wrapperClose.parentNode.removeChild(self.wrapperClose);
      }

      self.$super();
    }
  }, {
    attr: {},
    tag: {},

    /**
     * Get directive by name
     * @static
     * @method
     * @param {string} type 
     * @param {string} name 
     */
    getDirective: function (type, name) {
      return ns.get("MetaphorJs.directive." + type + "." + name);
    },

    /**
     * Register attribute directive
     * @param {string} name Attribute name
     * @param {int} priority 
     * @param {function|MetaphorJs.app.Directive} handler 
     */
    registerAttribute: function registerAttribute(name, priority, handler) {
      if (!attr[name]) {
        attributes.push({
          priority: priority,
          name: name,
          handler: attr[name] = handler
        });
        attributesSorted = false;
      }
    },

    /**
     * Get attribute directives sorted by priority
     * @static
     * @method
     * @returns {array}
     */
    getAttributes: function getAttributes() {
      if (!attributesSorted) {
        attributes.sort(compare);
        attributesSorted = true;
      }

      return attributes;
    },

    /**
     * Register tag directive
     * @param {string} name Tag name (case insensitive)
     * @param {function|MetaphorJs.app.Directive} handler 
     */
    registerTag: function registerTag(name, handler) {
      if (!tag[name]) {
        tag[name] = handler;
      }
    },

    /**
     * Register tag component
     * @param {string} name Tag name (case sensitive)
     * @param {MetaphorJs.app.Component} cmp 
     */
    registerComponent: function (name, cmp) {
      if (!cmp) {
        cmp = name;
      }

      if (isString(cmp)) {
        cmp = ns.get(cmp, true);
      }

      if (!component[name]) {
        component[name] = cmp;
      }
    },

    /**
     * Resolve received something into a dom node.
     * @param {Promise|Node|Component} node 
     * @param {string} directive Directive name
     * @param {function} cb {
     *  @param {Node} node
     *  @param {MetaphorJs.app.Component} cmp
     * }
     * @param {string} apiType {
     *  node|input|...
     *  @default resolveNode
     * }
     */
    resolveNode: function (node, directive, cb, apiType) {
      if (node instanceof window.Node) {
        cb(node);
      } else if (node.getApi) {
        var cmp = node;
        node = node.getApi(apiType || "node", directive);

        if (isThenable(node)) {
          node.done(function (node) {
            cb(node, cmp);
          });
        } else if (node) {
          cb(node, cmp);
        }
      }
    },

    /**
     * Static config initializer called from instance's initConfig
     * or from template prebuilder
     * @static
     * @protected
     * @method
     * @param {MetaphorJs.lib.Config} config
     * @param {function|Metaphor.app.Directive} instance
     */
    initConfig: function (config, instance) {
      var msl = MetaphorJs.lib.Config.MODE_LISTENER;
      config.setDefaultMode("callbackContext", MetaphorJs.lib.Config.MODE_SINGLE);
      config.eachProperty(function (name) {
        if (name.substring(0, 4) === 'on--') {
          config.setMode(name, msl);
        }
      });
    }
  });
}();

/***/ }),

/***/ "../metaphorjs/src/app/ListRenderer.js":
/*!*********************************************!*\
  !*** ../metaphorjs/src/app/ListRenderer.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../func/dom/commentWrap.js */ "../metaphorjs/src/func/dom/commentWrap.js");

__webpack_require__(/*! ../func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ../func/dom/toFragment.js */ "../metaphorjs/src/func/dom/toFragment.js");

__webpack_require__(/*! ./Renderer.js */ "../metaphorjs/src/app/Renderer.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Queue.js */ "../metaphorjs-shared/src/lib/Queue.js");

__webpack_require__(/*! ../lib/MutationObserver.js */ "../metaphorjs/src/lib/MutationObserver.js");

__webpack_require__(/*! ../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/animate.js */ "../metaphorjs-animate/src/animate/animate.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/isCssSupported.js */ "../metaphorjs-animate/src/animate/isCssSupported.js");

__webpack_require__(/*! ../func/app/prebuilt.js */ "../metaphorjs/src/func/app/prebuilt.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js"),
      isNull = __webpack_require__(/*! metaphorjs-shared/src/func/isNull.js */ "../metaphorjs-shared/src/func/isNull.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      isNumber = __webpack_require__(/*! metaphorjs-shared/src/func/isNumber.js */ "../metaphorjs-shared/src/func/isNumber.js"),
      isPrimitive = __webpack_require__(/*! metaphorjs-shared/src/func/isPrimitive.js */ "../metaphorjs-shared/src/func/isPrimitive.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      levenshteinDiff = __webpack_require__(/*! metaphorjs-shared/src/func/levenshteinDiff.js */ "../metaphorjs-shared/src/func/levenshteinDiff.js"),
      levenshteinMove = __webpack_require__(/*! metaphorjs-shared/src/func/levenshteinMove.js */ "../metaphorjs-shared/src/func/levenshteinMove.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.app.ListRenderer = cls({
  id: null,
  config: null,
  state: null,
  listSourceExpr: null,
  itemStateName: null,
  _tagMode: false,
  _animateMove: false,
  _animate: false,
  _buffered: false,
  _trackBy: null,
  _parentRenderer: null,
  _template: null,
  _items: null,
  _prevEl: null,
  _nextEl: null,
  _renderQueue: null,
  _attachQueue: null,
  _mo: null,
  _trackByFn: null,
  _filterFn: null,
  _localTrack: false,
  _griDelegate: null,
  $constructor: function (state, node, config, parentRenderer, attrSet) {
    var self = this;
    self.config = config;
    self.state = state;
    self.initConfig();
    self._tagMode = node.nodeName.toLowerCase() === "mjs-each";
    self._animateMove = !self._tagMode && !config.hasValue("buffered") && config.get("animateMove") && MetaphorJs.animate.isCssSupported();
    self._animate = !self._tagMode && !config.hasValue("buffered") && config.get("animate");

    if (self._animate) {
      self.$plugins.push(config.get("animatePlugin"));
    }

    if (config.hasValue("observable")) {
      self.$plugins.push("MetaphorJs.plugin.Observable");
    }

    if (config.hasValue("buffered") && !self._tagMode) {
      self._buffered = true;
      var buff = config.get("buffered");
      buff === true && (buff = config.getProperty("buffered").defaultValue);
      self.$plugins.push(buff);
    }

    if (config.has('plugin')) {
      self.$plugins.push(config.get("plugin"));
    }

    if (config.has("filter")) {
      self._filterFn = config.get("filter");

      if (typeof self._filterFn !== "function") {
        throw new Error("{each.$filter} must be a function");
      }
    }

    self._trackBy = config.get("trackBy");
  },
  $init: function (state, node, config, parentRenderer, attrSet) {
    var self = this,
        expr = self._tagMode ? MetaphorJs.dom.getAttr(node, "value") : config.getExpression("value");

    self._parseExpr(expr);

    self._template = self._tagMode ? MetaphorJs.dom.toFragment(node.childNodes) : node;
    self._items = [];
    self.id = config.has('id') ? config.get('id') : nextUid();

    if (!self._trackBy && self._trackBy !== false) {
      self._localTrack = true;
    }

    var cmts = MetaphorJs.dom.commentWrap(node, "list-" + self.id);
    self._prevEl = cmts[0];
    self._nextEl = cmts[1];
    self._parentRenderer = parentRenderer;
    self._renderQueue = new MetaphorJs.lib.Queue({
      async: false,
      auto: true,
      thenable: true,
      stack: false,
      context: self,
      mode: MetaphorJs.lib.Queue.ONCE
    });
    self._attachQueue = new MetaphorJs.lib.Queue({
      async: "raf",
      auto: true,
      thenable: true,
      stack: false,
      context: self,
      mode: MetaphorJs.lib.Queue.ONCE
    });
    node.parentNode.removeChild(node);
    self.initDataSource();
    self.state.$app.registerCmp(self, "id");

    self._renderQueue.add(self.render, self, [self.getList()]);
  },
  getList: function () {
    var list = toArray(this._mo.getValue()),
        i,
        l,
        filter = this._filterFn;

    if (filter) {
      var all = list;
      list = [];

      for (i = 0, l = all.length; i < l; i++) {
        if (filter(all[i])) {
          list.push(all[i]);
        }
      }
    }

    return list;
  },
  initConfig: function () {
    var config = this.config,
        ms = MetaphorJs.lib.Config.MODE_STATIC;
    config.setType("animate", "bool", ms, false);
    config.setType("animateMove", "bool", ms, false);
    config.setDefaultMode("trackBy", ms);
    config.setDefaultMode("id", ms);
    config.setDefaultMode("plugin", ms);
    config.setType("observable", "bool", ms, false);
    config.setDefaultValue("buffered", "MetaphorJs.plugin.ListBuffered");
    config.setType("animatePlugin", null, ms, "MetaphorJs.plugin.ListAnimated");
  },
  initDataSource: function () {
    var self = this;
    self._mo = MetaphorJs.lib.MutationObserver.get(self.state, self.listSourceExpr, self.onChange, self, {
      localFilter: bind(self.localTracklistFilter, self)
    });

    if (self._localTrack && !self._trackBy) {
      self._trackBy = "$$" + self._mo.id;
    }

    self._griDelegate = bind(self.stateGetRawIndex, self);
  },
  trigger: emptyFn,

  /*
   * <!-- render and re-render
   */
  render: function (list) {
    var self = this,
        items = self._items,
        tpl = self._template,
        i,
        len;

    for (i = 0, len = list.length; i < len; i++) {
      items.push(self.createItem(tpl.cloneNode(true), list, i));
    }

    self.renderOrUpdate();

    self._attachQueue.add(self.attachAllItems, self);
  },
  createItem: function (el, list, index) {
    var self = this,
        iname = self.itemStateName,
        itemState = self.state.$new(),
        tm = self._tagMode;
    itemState.$on("changed", self.state.$check, self.state);
    itemState[iname] = self.getListItem(list, index);
    el = tm ? toArray(el.childNodes) : el;
    return {
      index: index,
      action: "enter",
      el: el,
      placeholder: window.document.createComment("*list*" + index + "*"),
      state: itemState,
      attached: false,
      rendered: false,
      hidden: false
    };
  },
  attachAllItems: function () {
    var self = this,
        fragment = window.document.createDocumentFragment(),
        items = self._items,
        tm = self._tagMode,
        i,
        len;

    for (i = 0, len = items.length; i < len; i++) {
      if (!items[i].hidden) {
        if (tm) {
          fragment.appendChild(MetaphorJs.dom.toFragment(items[i].el));
        } else {
          fragment.appendChild(items[i].el);
        }

        items[i].attached = true;
        fragment.appendChild(items[i].placeholder);
      }
    }

    self._nextEl.parentNode && self._nextEl.parentNode.insertBefore(fragment, self._nextEl);
    self.trigger("attached", self);
  },
  renderOrUpdate: function (start, end, action, renderOnly) {
    var self = this,
        items = self._items,
        index = start || 0,
        cnt = items.length,
        x = end || cnt - 1,
        list = self.getList(),
        trackByFn = self.getTrackByFunction();

    if (x > cnt - 1) {
      x = cnt - 1;
    }

    for (; index <= x; index++) {
      if (action && items[index].action !== action) {
        continue;
      }

      self.renderItem(index, items, list, trackByFn, renderOnly);
    }
  },
  renderItem: function (index, items, list, trackByFn, renderOnly) {
    const self = this;
    list = list || self.getList();
    items = items || self._items;
    trackByFn = trackByFn || self.getTrackByFunction();
    const item = items[index],
          state = item.state,
          last = items.length - 1,
          even = !(index % 2);

    if (renderOnly && item.rendered) {
      return;
    }

    state.$index = index;
    state.$first = index === 0;
    state.$last = index === last;
    state.$even = even;
    state.$odd = !even;
    state.$trackId = trackByFn(list[index]);
    state.$getRawIndex = self.griDelegate;

    if (!item.renderer) {
      item.renderer = new MetaphorJs.app.Renderer();
      state.$on("destroy", item.renderer.$destroy, item.renderer);
      item.renderer.process(item.el, state);
      item.rendered = true;
    } else {
      state.$check();
    }
  },

  /*
   * render and re-render -->
   */

  /*
   * <!-- reflect changes
   */
  onChange: function (current, prev) {
    var self = this;

    self._renderQueue.prepend(self.applyChanges, self, [prev], MetaphorJs.lib.Queue.REPLACE);
  },
  applyChanges: function (prevList) {
    var self = this,
        items = self._items,
        tpl = self._template,
        index = 0,
        list = self.getList(),
        updateStart = null,
        animateMove = self._animateMove,
        newItems = [],
        iname = self.itemStateName,
        origItems = items.slice(),
        doesMove = false,
        prevItem,
        prevItemInx,
        i,
        len,
        item,
        action; // if we don't track items, we just re-render the whole list

    if (!self._trackBy) {
      items = self._items.slice();
      updateStart = 0;
      doesMove = false;

      for (i = 0, len = list.length; i < len; i++) {
        item = self.createItem(tpl.cloneNode(true), list, i);
        newItems.push(item);
      }
    } // if items are tracked
    else {
      // we generate a move prescription
      // by finding an array difference.
      // But we don't compare original arrays, 
      // we only compare list of ids - 
      // since we only care about position change.
      var prevTrackList = self.getTrackList(prevList),
          trackList = self.getTrackList(list),
          prs = levenshteinDiff(prevTrackList, trackList),
          movePrs = levenshteinMove(prevTrackList, trackList, prs.prescription, function (item) {
        return item;
      }); // move prescription is a list of instructions
      // of the same length as new list of items.
      // it either contains number - index of 
      // item in the old list, or something else
      // which basically means - create a new item

      for (i = 0, len = movePrs.length; i < len; i++) {
        action = movePrs[i]; // int entry is a position of old item
        // in the new order of things.

        if (isNumber(action)) {
          prevItemInx = action;
          prevItem = items[prevItemInx];

          if (prevItemInx !== index && isNull(updateStart)) {
            updateStart = i;
          }

          prevItem.action = "move";
          prevItem.state[iname] = self.getListItem(list, i);
          doesMove = animateMove;
          newItems.push(prevItem);
          items[prevItemInx] = null;
          index++;
        } else {
          if (isNull(updateStart)) {
            updateStart = i;
          }

          item = self.createItem(tpl.cloneNode(true), list, i);
          newItems.push(item); // add new elements to old renderers
          // so that we could correctly determine positions
        }
      }
    }

    self._items = newItems;
    self.reflectChanges({
      oldItems: items,
      updateStart: updateStart,
      newItems: newItems,
      origItems: origItems,
      doesMove: doesMove
    });
  },
  reflectChanges: function (vars) {
    var self = this;
    self.renderOrUpdate();
    self.applyDomPositions(vars.oldItems);
    self.removeOldElements(vars.oldItems);
    self.trigger("change", self);
  },
  removeOldElements: function (items) {
    var i,
        len,
        item,
        j,
        jl,
        self = this,
        tm = self._tagMode;

    for (i = 0, len = items.length; i < len; i++) {
      item = items[i];

      if (item && item.attached) {
        item.attached = false;

        if (!tm) {
          item.el.parentNode && item.el.parentNode.removeChild(item.el);
        } else {
          for (j = 0, jl = item.el.length; j < jl; j++) {
            if (item.el[j].parentNode) {
              item.el[j].parentNode.removeChild(item.el[j]);
            }
          }
        }

        item.placeholder.parentNode && item.placeholder.parentNode.removeChild(item.placeholder);
      }

      if (item && item.state) {
        item.state.$destroy();
        item.rendered = false;
      }
    }
  },
  applyDomPositions: function () {
    var self = this,
        items = self._items,
        tm = self._tagMode,
        nc = self._nextEl,
        next,
        parent,
        i,
        j,
        l,
        el,
        item,
        first;

    for (i = 0, l = items.length; i < l; i++) {
      item = items[i];
      el = item.el;
      next = null;

      if (item.hidden) {
        if (tm) {
          MetaphorJs.dom.toFragment(el);
        } else if (el.parentNode) {
          el.parentNode.removeChild(el);
        }

        item.placeholder.parentNode && item.placeholder.parentNode.removeChild(item.placeholder);
        item.attached = false;
        continue;
      }

      for (j = Math.max(i - 1, 0); j >= 0; j--) {
        if (items[j].attached) {
          next = items[j].placeholder.nextSibling;
          break;
        }
      }

      if (!next) {
        next = nc;
      }

      first = tm ? el[0] : el;
      parent = next.parentNode;

      if (first !== next) {
        if (next && item.placeholder.nextSibling !== next) {
          parent.insertBefore(tm ? MetaphorJs.dom.toFragment(el) : el, next);
          parent.insertBefore(item.placeholder, next);
        } else if (!next) {
          parent.appendChild(tm ? MetaphorJs.dom.toFragment(el) : el);
          parent.appendChild(item.placeholder);
        }
      }

      item.attached = true;
    }
  },

  /*
   * reflect changes -->
   */

  /*
   * <!-- configurable item functions
   */
  getListItem: function (list, index) {
    return list[index];
  },
  getTrackByFunction: function () {
    var self = this,
        trackBy;

    if (!self._trackByFn) {
      trackBy = self._trackBy;

      if (!trackBy || trackBy === '$') {
        self._trackByFn = function (item) {
          return isPrimitive(item) ? item : undefined;
        };
      } else if (isFunction(trackBy)) {
        self._trackByFn = trackBy;
      } else {
        self._trackByFn = function (item) {
          if (item && !isPrimitive(item)) {
            if (self._localTrack && !item[trackBy]) {
              item[trackBy] = nextUid();
            }

            return item[trackBy];
          } else return undefined; //return item && !isPrimitive(item) ? item[trackBy] : undefined;

        };
      }
    }

    return self._trackByFn;
  },
  localTracklistFilter: function (rawList, mo) {
    if (!rawList) {
      return [];
    }

    if (!isArray(rawList)) {
      rawList = [rawList];
    }

    var self = this;

    if (self._trackBy !== false && self._localTrack) {
      if (!self._trackBy) {
        self._trackBy = "$$" + mo.id;
      }

      self.getTrackList(rawList);
    }

    return rawList;
  },
  getTrackList: function (list) {
    var trackByFn = this.getTrackByFunction(),
        trackList = [],
        i,
        l;

    for (i = -1, l = list.length; ++i < l; trackList.push(trackByFn(list[i]))) {}

    return trackList;
  },
  stateGetRawIndex: function (id) {
    if (id === undefined) {
      return -1;
    }

    var self = this,
        list = self.getList(),
        trackByFn = self.getTrackByFunction(),
        i,
        l;

    for (i = 0, l = list.length; i < l; i++) {
      if (trackByFn(list[i]) === id) {
        return i;
      }
    }

    return -1;
  },

  /*
   * configurable item functions -->
   */
  _parseExpr: function (expr) {
    var parts, pb;

    if (MetaphorJs.app.prebuilt.isKey(expr)) {
      pb = MetaphorJs.app.prebuilt.get("config", expr);
      parts = {
        model: pb,
        name: pb.inflate.itemName
      };
      this.listSourceExpr = pb;
    } else {
      parts = MetaphorJs.app.Directive.getDirective("attr", "each").splitExpression(expr);
      this.listSourceExpr = parts.model;
    }

    this.itemStateName = parts.name;
  },
  onDestroy: function () {
    var self = this,
        items = self._items,
        i,
        len;

    for (i = 0, len = items.length; i < len; i++) {
      if (items[i].renderer && !items[i].renderer.$destroyed) {
        items[i].renderer.$destroy();
      }
    }

    self._renderQueue.$destroy();

    self._attachQueue.$destroy();

    if (self._mo) {
      self._mo.unsubscribe(self.onChange, self);

      self._mo.$destroy(true);
    }
  }
});

/***/ }),

/***/ "../metaphorjs/src/app/Renderer.js":
/*!*****************************************!*\
  !*** ../metaphorjs/src/app/Renderer.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/State.js */ "../metaphorjs/src/lib/State.js");

__webpack_require__(/*! metaphorjs-observable/src/lib/Observable.js */ "../metaphorjs-observable/src/lib/Observable.js");

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

__webpack_require__(/*! ../lib/Text.js */ "../metaphorjs/src/lib/Text.js");

__webpack_require__(/*! ../func/dom/setAttr.js */ "../metaphorjs/src/func/dom/setAttr.js");

__webpack_require__(/*! ./Directive.js */ "../metaphorjs/src/app/Directive.js");

__webpack_require__(/*! ../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../func/dom/removeAttr.js */ "../metaphorjs/src/func/dom/removeAttr.js");

__webpack_require__(/*! ../func/dom/getAttrSet.js */ "../metaphorjs/src/func/dom/getAttrSet.js");

const nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      isThenable = __webpack_require__(/*! metaphorjs-shared/src/func/isThenable.js */ "../metaphorjs-shared/src/func/isThenable.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js");

module.exports = MetaphorJs.app.Renderer = function () {
  let handlers = null;

  const dirs = MetaphorJs.directive,
        nodeCmt = window.document.COMMENT_NODE,
        nodeText = window.document.TEXT_NODE,
        nodeElem = window.document.ELEMENT_NODE,
        collectNodes = function (coll, add) {
    if (add) {
      if (add.nodeType) {
        coll.push(add);
      } else if (isArray(add)) {
        for (var i = -1, l = add.length; ++i < l; collectNodes(coll, add[i])) {}
      }
    }
  },
        skipMap = {
    "script": true,
    "template": true,
    "mjs-template": true,
    "style": true,
    "link": true
  },
        applyDirective = function (dir, parentState, node, config, attrs, renderer) {
    config.setDefaultMode("state", MetaphorJs.lib.Config.MODE_STATIC);

    const state = config.has("state") ? MetaphorJs.lib.State.$produce(config.get("state"), parentState) : parentState,
          app = parentState.$app || state.$app,
          inject = {
      $state: state,
      $node: node,
      $config: config,
      $attrSet: attrs,
      $renderer: renderer
    },
          args = [state, node, config, renderer, attrs],
          processRes = function (res) {
      if (res && res.$destroy) {
        if (renderer) {
          if (renderer.$destroyed) res.$destroy();else renderer.on("destroy", res.$destroy, res);
        } else parentState.$on("destroy", res.$destroy, res);
      } else if (typeof res === "function") {
        if (renderer) {
          if (renderer.$destroyed) res();else renderer.on("destroy", res);
        } else parentState.$on("destroy", res);
      }
    };

    let res;

    if (config.has("state")) {
      config.setOption("state", state);
    }

    if (app) {
      res = app.inject(dir, null, inject, args);
    } else if (dir.$instantiate) {
      res = dir.$instantiate.apply(dir, args);
    } else {
      res = dir.apply(null, args);
    }

    if (isThenable(res)) {
      res.done(processRes);
    } else processRes(res);

    return res;
  },
        observer = new MetaphorJs.lib.Observable();

  var Renderer = function (parent) {
    var self = this;
    self.id = nextUid();
    self.parent = parent;
    self._texts = [];
    self._flowControlState = {};
    self._treeState = {
      countdown: 0
    };
    observer.createEvent("transclude-sources-" + self.id, "all");
    observer.createEvent("rendered-" + self.id, {
      limit: 1
    });

    if (parent) {
      parent.on("destroy", self.$destroy, self);
    }
  };

  extend(Renderer.prototype, {
    id: null,
    parent: null,
    _flowControlState: null,
    _treeState: null,
    _texts: null,
    $destroyed: false,
    on: function (event, fn, context, opt) {
      return observer.on(event + '-' + this.id, fn, context, opt);
    },
    un: function (event, fn, context) {
      return observer.un(event + '-' + this.id, fn, context);
    },
    trigger: function (event) {
      arguments[0] = event + "-" + this.id;
      return observer.trigger.apply(observer, arguments);
    },
    attached: function (to) {
      this.trigger("attached", this, to);
    },
    detached: function () {
      this.trigger("detached", this);
    },
    flowControl: function (key, value) {
      this._flowControlState[key] = value;
    },
    _resetFC: function () {
      var fc = this._flowControlState;
      fc.waitFor = null;
      fc.nodes = null;
      fc.stop = false;
      fc.ignoreInside = false;
      fc.newState = null;
    },
    _checkFCState: function (defers, nodes, attrs) {
      var fc = this._flowControlState;
      fc.waitFor && defers && defers.push(fc.waitFor);
      fc.nodes && nodes && collectNodes(nodes, fc.nodes);
      fc.ignoreInside && attrs && (attrs.renderer.ignoreInside = true);
      fc.newState && (this._treeState.newState = fc.newState);

      this._resetFC();
    },
    _processCommentNode: function (node) {
      var cmtData = node.textContent || node.data;

      if (cmtData.substring(0, 2) === '##') {
        this.trigger("reference", "node", cmtData.substring(2), node);
      }
    },
    _processTextNode: function (node) {
      var self = this,
          texts = self._texts,
          textStr = node.textContent || node.nodeValue,
          textRenderer;

      if (MetaphorJs.lib.Text.applicable(textStr)) {
        textRenderer = new MetaphorJs.lib.Text(self._treeState.state, textStr);
        textRenderer.subscribe(self._onTextChange, self, {
          append: [texts.length]
        });
        texts.push({
          node: node,
          tr: textRenderer
        });

        self._renderText(texts.length - 1);
      }
    },
    // skip <slot> but reference it same way as ##ref
    _processSlotNode: function (node) {
      this.trigger("reference", "node", node.getAttribute("name"), node);
      return false;
    },
    _processComponent: function (component, node, attrs) {
      var self = this,
          config = new MetaphorJs.lib.Config(attrs.config, {
        state: self._treeState.state
      });
      var directive = MetaphorJs.app.Directive.getDirective("attr", "cmp");
      config.setProperty("value", {
        mode: MetaphorJs.lib.Config.MODE_STATIC,
        expression: component
      });
      self.on("destroy", config.$destroy, config);
      return applyDirective(directive, self._treeState.state, node, config, attrs, self);
    },
    _processTag: function (directive, node, attrs) {
      var self = this,
          config = new MetaphorJs.lib.Config(attrs.config, {
        state: self._treeState.state
      });
      self.on("destroy", config.$destroy, config);
      return applyDirective(directive, self._treeState.state, node, config, attrs, self);
    },
    _processDirAttribute: function (node, directive, name, dcfg, attrs) {
      var self = this,
          config = new MetaphorJs.lib.Config(dcfg, {
        state: self._treeState.state
      });
      self.on("destroy", config.$destroy, config);
      return applyDirective(directive, self._treeState.state, node, config, attrs, self);
    },
    _processReferences: function (node, attrs) {
      var self = this,
          i,
          len,
          ref,
          state = self._treeState.state;

      for (i = 0, len = attrs.references.length; i < len; i++) {
        ref = attrs.references[i];

        if (ref[0] === '#') {
          self.trigger("reference", "node", ref.substring(1), node);
        } else {
          state[ref] = node;
        }

        MetaphorJs.dom.removeAttr(node, '#' + ref);
      }
    },
    _processAttribute: function (node, name, attrs) {
      var self = this,
          texts = self._texts,
          textStr = attrs['attributes'][name],
          textRenderer = new MetaphorJs.lib.Text(self._treeState.state, textStr, {
        recursive: !!attrs.renderer.recursive,
        fullExpr: !MetaphorJs.lib.Text.applicable(textStr)
      });
      MetaphorJs.dom.removeAttr(node, attrs['__attributes'][name]);
      textRenderer.subscribe(self._onTextChange, self, {
        append: [texts.length]
      });
      texts.push({
        node: node,
        attr: name,
        tr: textRenderer
      });

      self._renderText(texts.length - 1);
    },
    _processNode: function (node, _attrs) {
      var self = this,
          nodeType = node.nodeType;

      if (nodeType === nodeCmt) {
        self._processCommentNode(node);
      } else if (nodeType === nodeText) {
        self._processTextNode(node);
      } else if (nodeType === nodeElem) {
        self._resetFC();

        var tag = node.tagName.toLowerCase(),
            defers = [],
            nodes = [],
            fc = self._flowControlState,
            component,
            directive,
            name,
            ds,
            i,
            len,
            j,
            jlen,
            attrs = _attrs || MetaphorJs.dom.getAttrSet(node);

        if (tag.substr(0, 4) === "mjs-") {
          tag = tag.substr(4);
        }

        if (tag === "slot") {
          return this._processSlotNode(node);
        }

        if (attrs.renderer.ignore) {
          return false;
        }

        if (attrs.__plain && !dirs.component[tag] && !dirs.tag[tag]) {
          return;
        } // this tag represents component
        // we just pass it to attr.cmp directive
        // by adding it to the attr map


        if (component = dirs.component[tag]) {
          attrs.__remove(node, "config");

          self._processComponent(component, node, attrs);
        } else if (directive = dirs.tag[tag]) {
          self._processTag(directive, node, attrs);
        }

        if (fc.stop) return false;

        self._checkFCState(defers, nodes, attrs);

        if (attrs.references && attrs.references.length) {
          self._processReferences(node, attrs);
        } // this is an attribute directive


        for (i = 0, len = handlers.length; i < len; i++) {
          name = handlers[i].name;

          if ((ds = attrs['directives'][name]) !== undefined && !attrs['__directives'][name].handled) {
            attrs.__remove(node, "directive", name);

            attrs.__directives[name].handled = true;

            for (j = 0, jlen = ds.length; j < jlen; j++) {
              self._processDirAttribute(node, handlers[i].handler, name, ds[j], attrs);

              if (fc.stop) return false;

              self._checkFCState(defers, nodes, attrs);
            }
          }
        }

        for (i in attrs['attributes']) {
          self._processAttribute(node, i, attrs);
        }

        if (attrs.renderer.ignoreInside) {
          return false;
        }

        if (defers.length) {
          var deferred = new MetaphorJs.lib.Promise();
          MetaphorJs.lib.Promise.all(defers).done(function (values) {
            collectNodes(nodes, values);
            deferred.resolve(nodes);
          });
          return deferred;
        }

        return nodes.length ? nodes : true;
      }

      return true;
    },

    /**
     * Processes one single node and gives glues on there to go next.<br>
     * Return false to skip this branch. Do not go inside this node.<br>
     * Return a Node or array of Nodes to add to processing list
     * along with this node's children<br>
     * Return a Promise resolving in any of the above
     * @param {Node} node 
     * @param {MetaphorJs.lib.State} state
     * @returns {boolean|array|Promise|Node}
     */
    processNode: function (node, state,
    /*system private attr */
    _attrs) {
      var self = this;
      self._treeState.state = state;

      self._processNode(node, _attrs);
    },
    process: function (smth, state) {
      var self = this;

      if (!handlers) {
        handlers = MetaphorJs.app.Directive.getAttributes();
      }

      if (!smth) {
        return;
      }

      self._treeState.state = state;

      if (smth.nodeType) {
        self._treeState.countdown++;

        self._eachNode(smth);
      } else {
        if (self._nodeChildren(null, smth) === 0 && self._treeState.countdown === 0) {
          self._onProcessingFinished();
        }
      }
    },
    _nodeChildren: function (res, el) {
      var children = [],
          i,
          len,
          ts = this._treeState;

      if (res && res !== true) {
        if (res.nodeType) {
          ts.countdown += 1;

          this._eachNode(res);

          return 1;
        } else {
          children = res.slice();
        }
      }

      if (!children.length) {
        children = toArray(el.childNodes || el);
      }

      len = children.length;
      ts.countdown += len;

      for (i = -1; ++i < len; this._eachNode(children[i])) {}

      return len;
    },
    _eachNode: function (el) {
      if (!el) {
        return;
      }

      var res,
          self = this,
          tag = el.nodeName,
          subState = {
        thisLevelState: null,
        childLevelState: null
      },
          ts = self._treeState;

      if (tag && skipMap[tag.toLowerCase()]) {
        --ts.countdown === 0 && self._onProcessingFinished();
        return;
      }

      res = self._processNode(el);

      if (ts.newState) {
        subState.thisLevelState = ts.state;
        subState.childLevelState = ts.newState;
        delete ts.newState;
      }

      isThenable(res) ? res.done(function (res) {
        self._eachNodeRun(res, el, subState);
      }) : self._eachNodeRun(res, el, subState);
    },
    _eachNodeRun: function (res, el, sub) {
      var self = this,
          ts = self._treeState;

      if (res !== false) {
        sub.childLevelState && (ts.state = sub.childLevelState);

        self._nodeChildren(res, el);

        sub.thisLevelState && (ts.state = sub.thisLevelState);
      }

      --ts.countdown === 0 && self._onProcessingFinished();
    },
    _onProcessingFinished: function () {
      observer.trigger("rendered-" + this.id, this);
    },
    _onTextChange: function (textRenderer, inx) {
      this._renderText(inx);
    },
    _renderText: function (inx) {
      var self = this,
          text = self._texts[inx],
          res = text.tr.getString(),
          attrName = text.attr;

      if (res === undefined || res === null) {
        res = "";
      }

      if (attrName) {
        if (attrName === "value") {
          text.node.value = res;
        } else if (attrName === "class") {
          text.node.className = res;
        } else if (attrName === "src") {
          text.node.src = res;
        }

        if (res === false) {
          MetaphorJs.dom.removeAttr(text.node, attrName);
        } else {
          MetaphorJs.dom.setAttr(text.node, attrName, res);
        }
      } else {
        //text.node.textContent = res;
        text.node.nodeValue = res;
      }
    },
    $destroy: function () {
      var self = this,
          texts = self._texts,
          i,
          len;

      if (self.$destroyed) {
        return;
      }

      for (i = -1, len = texts.length; ++i < len; texts[i].tr.$destroy()) {}

      if (self.parent) {
        self.parent.un("destroy", self.$destroy, self);
      }

      observer.trigger("destroy-" + self.id);
      observer.destroyEvent("transclude-sources-" + self.id);
      observer.destroyEvent("destroy-" + self.id);
      observer.destroyEvent("rendered-" + self.id);
      observer.destroyEvent("reference-" + self.id);
      observer.destroyEvent("reference-promise-" + self.id);
      observer.destroyEvent("attached-" + self.id);

      for (var k in self) {
        if (self.hasOwnProperty(k)) {
          self[k] = null;
        }
      }

      self.$destroyed = true;
    }
  });

  Renderer.skip = function (tag, value) {
    skipMap[tag] = value;
  };

  Renderer.applyDirective = applyDirective;
  return Renderer;
}();

/***/ }),

/***/ "../metaphorjs/src/app/StoreRenderer.js":
/*!**********************************************!*\
  !*** ../metaphorjs/src/app/StoreRenderer.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../lib/MutationObserver.js */ "../metaphorjs/src/lib/MutationObserver.js");

__webpack_require__(/*! ../app/ListRenderer.js */ "../metaphorjs/src/app/ListRenderer.js");

__webpack_require__(/*! ../func/app/prebuilt */ "../metaphorjs/src/func/app/prebuilt.js");

const bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.app.StoreRenderer = MetaphorJs.app.ListRenderer.$extend({
  store: null,
  $constructor: function (state, node, config, parentRenderer, attrSet) {
    config.setDefaultMode("pullNext", MetaphorJs.lib.Config.MODE_STATIC);

    if (config.hasValue("pullNext") && config.get("pullNext")) {
      if (config.hasValue("buffered")) {
        config.setStatic("bufferedPullNext", true);
        config.setStatic("buffered", false);
      }

      var plg = config.get("pullNext");
      this.$plugins.push(typeof plg === "string" ? plg : "MetaphorJs.plugin.ListPullNext");
    }

    this.$super(state, node, config, parentRenderer, attrSet);
  },
  initDataSource: function () {
    var self = this,
        store;
    self.store = store = MetaphorJs.lib.Expression.get(self.listSourceExpr, self.state);

    if (self._trackBy !== false) {
      self._trackByFn = bind(store.getRecordId, store);
    }

    self._mo = MetaphorJs.lib.MutationObserver.get(store, "current", self.onChange, self);
    self._griDelegate = bind(store.indexOfId, store);
    self.bindStore(store, "on");
  },
  bindStore: function (store, fn) {
    var self = this;
    store[fn]("update", self.onStoreUpdate, self);
    store[fn]("clear", self.onStoreUpdate, self);
    store[fn]("destroy", self.onStoreDestroy, self);
  },
  onStoreUpdate: function () {
    this._mo.check();
  },
  getListItem: function (list, index) {
    return this.store.getRecordData(list[index]);
  },
  onStoreDestroy: function () {
    var self = this;

    if (self._mo) {
      self.onStoreUpdate();

      self._mo.unsubscribe(self.onChange, self);

      self._mo.$destroy(true);

      self._mo = null;
    }
  },
  onDestroy: function () {
    var self = this;

    if (!self.store.$destroyed) {
      self.bindStore(self.store, "un");
    }

    self.$super();
  }
});

/***/ }),

/***/ "../metaphorjs/src/app/Template.js":
/*!*****************************************!*\
  !*** ../metaphorjs/src/app/Template.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../func/dom/data.js */ "../metaphorjs/src/func/dom/data.js");

__webpack_require__(/*! ../func/dom/toFragment.js */ "../metaphorjs/src/func/dom/toFragment.js");

__webpack_require__(/*! ../func/dom/clone.js */ "../metaphorjs/src/func/dom/clone.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/animate.js */ "../metaphorjs-animate/src/animate/animate.js");

__webpack_require__(/*! ../func/dom/select.js */ "../metaphorjs/src/func/dom/select.js");

__webpack_require__(/*! ../func/dom/getAttrSet.js */ "../metaphorjs/src/func/dom/getAttrSet.js");

__webpack_require__(/*! ../func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ../func/dom/setAttr.js */ "../metaphorjs/src/func/dom/setAttr.js");

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

__webpack_require__(/*! metaphorjs-observable/src/lib/Observable.js */ "../metaphorjs-observable/src/lib/Observable.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Cache.js */ "../metaphorjs-shared/src/lib/Cache.js");

__webpack_require__(/*! ../lib/State.js */ "../metaphorjs/src/lib/State.js");

__webpack_require__(/*! ../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ../lib/MutationObserver.js */ "../metaphorjs/src/lib/MutationObserver.js");

__webpack_require__(/*! ../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ./Renderer.js */ "../metaphorjs/src/app/Renderer.js");

__webpack_require__(/*! ../func/dom/commentWrap.js */ "../metaphorjs/src/func/dom/commentWrap.js");

__webpack_require__(/*! metaphorjs-observable/src/lib/Observable.js */ "../metaphorjs-observable/src/lib/Observable.js");

__webpack_require__(/*! ../func/dom/isAttached.js */ "../metaphorjs/src/func/dom/isAttached.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      copy = __webpack_require__(/*! metaphorjs-shared/src/func/copy.js */ "../metaphorjs-shared/src/func/copy.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js");

module.exports = MetaphorJs.app.Template = function () {
  var observable = new MetaphorJs.lib.Observable(),
      cache = new MetaphorJs.lib.Cache(),
      options = {},
      shadowSupported = !!(window.document.head && window.document.head.attachShadow),
      pblt,
      pbltOpt,
      //TODO: Check if this is a performance issue
  getFragmentContent = function (frg) {
    var div = window.document.createElement("div");
    div.appendChild(MetaphorJs.dom.clone(frg));
    return div.innerHTML;
  },
      resolveInclude = function (cmt, tplId) {
    var frg = getTemplate(tplId.trim());

    if (!frg) {
      return "";
    }

    if (typeof frg === "string") {
      return frg;
    }

    return getFragmentContent(frg);
  },
      resolveIncludes = function (tpl) {
    return tpl.replace(/<!--\s*include (.+?)-->/ig, resolveInclude);
  },
      getTemplate = function (tplId) {
    var tpl = cache.get(tplId),
        opt = options[tplId] || {};

    if (typeof tpl === "function") {
      tpl = tpl(tplId);
    }

    if (typeof tpl === "string" && !opt.text) {
      if (!opt.processed) {
        tpl = processTextTemplate(tplId, tpl);
      }

      tpl = MetaphorJs.dom.toFragment(tpl);
      cache.add(tplId, tpl);
    } else if (tpl && tpl.nodeType) {
      // do not re-create fragments;
      if (tpl.nodeType !== window.document.DOCUMENT_FRAGMENT_NODE) {
        // document fragment
        if ("content" in tpl) {
          tpl = tpl.content;
        } else {
          tpl = MetaphorJs.dom.toFragment(tpl.childNodes);
        }

        cache.add(tplId, tpl);
      }
    }

    return tpl;
  },
      processTextTemplate = function (tplId, tpl) {
    var opt, inx;

    if (tpl.substring(0, 5) === "<!--{") {
      inx = tpl.indexOf("-->");
      opt = MetaphorJs.lib.Expression.get(tpl.substr(4, inx - 4), {});
      options[tplId] = opt;
      tpl = tpl.substr(inx + 3);
    }

    if (!options[tplId]) {
      options[tplId] = {};
    }

    opt = options[tplId];
    opt.processed = true; //if (opt.includes) {

    tpl = resolveIncludes(tpl); //}

    if (opt.text) {
      return tpl;
    }

    return MetaphorJs.dom.toFragment(tpl);
  },
      findInPrebuilt = function (tplId) {
    var tpl;

    if (!pblt) {
      pblt = MetaphorJs.prebuilt.templates;
      pbltOpt = MetaphorJs.prebuilt.templateOptions;
    }

    if (tpl = pblt[tplId]) {
      delete pblt[tplId];
      /*if (pbltOpt[tplId]) {
          options[tplId] = pbltOpt[tplId];
          delete pbltOpt[tplId];
      }*/

      return tpl;
    }
  },
      findInScripts = function (tplId) {
    var tplNode = window.document.getElementById(tplId),
        tpl,
        tag;

    if (tplNode) {
      tag = tplNode.tagName.toLowerCase();

      if (tag === "script") {
        tpl = tplNode.innerHTML;
        tplNode.parentNode.removeChild(tplNode);
        return tpl;
      } else {
        return tplNode;
      }
    }
  },
      loadPromises = {},
      loadTemplate = function (name, url) {
    if (!cache.exists(name)) {
      if (!loadPromises[url]) {
        loadPromises[url] = fetch(url).then(r => r.text()).then(response => {
          return MetaphorJs.dom.toFragment(response);
        }).then(fragment => {
          cache.add(name, fragment);
          delete loadPromises[url];
          return fragment;
        });
      }

      return loadPromises[url];
    }

    return MetaphorJs.lib.Promise.resolve(cache.get(name));
  };

  if (MetaphorJs.prebuilt && MetaphorJs.prebuilt.templates) {
    cache.addFinder(findInPrebuilt);
  }

  cache.addFinder(findInScripts);

  var Template = function (cfg) {
    var self = this;
    extend(self, cfg, true, false);

    if (self.parentRenderer) {
      self._parentRenderer = self.parentRenderer;
      delete self.parentRenderer;
    }

    self.id = nextUid();
    self._virtualSets = {};
    self._namedNodes = {};
    observable.createEvent("rendered-" + self.id, {
      returnResult: false,
      autoTrigger: true
    });
    observable.createEvent("attached-" + self.id);
    self.state = MetaphorJs.lib.State.$produce(self.state);
    self.config = MetaphorJs.lib.Config.create(self.config, {
      state: self.state
    });
    MetaphorJs.lib.Observable.$initHost(this, cfg, observable);
    var config = self.config,
        sm = MetaphorJs.lib.Config.MODE_STATIC;
    config.on("name", self._onNameChange, self);
    config.on("html", self._onHtmlChange, self);
    Template.initConfig(config);
    !shadowSupported && config.setStatic("useShadow", false);
    config.get("useShadow") && config.setStatic("useComments", false);
    config.get("useShadow") && config.setStatic("makeTranscludes", false);
    /*if (config.get("runRenderer") && self._parentRenderer) {
        self._parentRenderer.on("destroy",
            self._onParentRendererDestroy, self
        );
    }*/

    self.state.$on("destroy", self._onStateDestroy, self);

    self._collectInitialNodes(self.attachTo || self.replaceNode);

    self.resolve();

    if (!config.get("deferRendering")) {
      self.render();
    }
  };

  extend(Template.prototype, {
    _rendering: false,
    _rendered: false,
    _renderer: null,
    _attached: false,
    _initial: true,
    _fragment: null,
    _template: null,
    _nodes: null,
    _prevEl: null,
    _nextEl: null,
    _attachTo: null,
    _attachBefore: null,
    _replaceNode: null,
    _shadowRoot: null,
    _resolvePromise: null,
    _pubResolvePromise: null,
    _parentRenderer: null,
    _virtualSets: null,
    _namedNodes: null,
    attachTo: null,
    attachBefore: null,
    replaceNode: null,
    rootNode: null,

    /**
     * @var {MetpahorJs.lib.State}
     */
    state: null,

    /**
     * @var {MetpahorJs.lib.Config}
     */
    config: null,
    render: function () {
      var self = this;

      if (self._rendering || !self._initial) {
        return;
      }

      self._rendering = true;
      self.config.setStatic("deferRendering", false);

      if (self.config.has("name") || self.config.has("html")) {
        self._prepareTranscludes();

        self.resolve().done(self._runRenderer, self).done(self.attachOrReplace, self);
      } else {
        self._runRenderer();

        self.attachOrReplace();
      }

      self._initial = false;
      self._rendering = false;
    },
    attach: function (parent, before) {
      var self = this;

      if (self._attachTo !== parent) {
        self._attached && self.detach();
        self._nextEl && self._removeComments();
        self._shadowRoot && self._destroyShadow();
        delete self.attachTo;
        delete self.attachBefore;
        self._attachTo = parent;
        self._attachBefore = before;

        if (self._rendered) {
          if (window.requestAnimationFrame && MetaphorJs.dom.isAttached(self._attachTo)) {
            window.requestAnimationFrame(function () {
              self._rafAttach();
            });
          } else {
            self._rafAttach();
          }
        }
      }
    },
    _rafAttach: function () {
      var self = this;

      if (self.$destroyed) {
        return;
      }

      self._createShadow();

      self._createComments();

      if (self._nodes) {
        self._doAttach();
      } else {
        self._setAttached();
      }
    },
    replace: function (node, attachTo) {
      var self = this;

      if (self._replaceNode !== node || self._attachTo !== attachTo) {
        // can't replace node if it is not attached
        if (!node.parentNode) {
          return;
        }

        self._attached && self.detach();
        self._nextEl && self._removeComments();
        self._shadowRoot && self._destroyShadow();
        delete self.replaceNode;
        delete self.attachTo;
        self._replaceNode = node;
        self._attachTo = attachTo;
        self._attachBefore = null;

        if (self._rendered) {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(function () {
              self._rafReplace();
            });
          } else self._rafReplace();
        }

        return true;
      }
    },
    _rafReplace: function () {
      var self = this;

      if (self.$destroyed) {
        return;
      }

      if (self._attachTo) {
        self._replaceNodeWithNode(node, self._attachTo);

        self._createShadow();
      } else {
        self._replaceNodeWithComments(self._replaceNode);
      }

      if (self._nodes) {
        self._doAttach();
      } else self._setAttached();
    },
    attachOrReplace: function () {
      var self = this;

      if (self._attached || !self._rendered) {
        return;
      } // new attachment via replace


      if (self.replaceNode && self.replaceNode.parentNode) {
        self.replace(self.replaceNode, self.attachTo);
      } // new attachment via append
      else if (self.attachTo) {
        if (self.attachBefore) {
          self.attachBefore.parentNode && self.attach(self.attachTo, self.attachBefore);
        } else {
          self.attach(self.attachTo);
        }
      } // reattaching to previous
      else if (self._nextEl || self._attachTo || self._shadowRoot) {
        self._doAttach();
      } else if (self._nodes && self._nodes.length && MetaphorJs.dom.isAttached(self._nodes[0])) {
        self._setAttached();
      }
    },
    isAttached: function () {
      return this._attached;
    },
    detach: function () {
      var self = this;

      if (!self._attached) {
        return;
      }

      self._nodes = self._clear();
    },
    resolve: function (renew) {
      var self = this,
          config = self.config;

      if (self._resolvePromise) {
        if (renew) {
          self._resolvePromise.$destroy();

          self._resolvePromise = null;

          self._pubResolvePromise.$destroy();

          self._pubResolvePromise = null;
          self._nodes = null;
          self._template = null;
          self._fragment = null;
        } else {
          return self._pubResolvePromise;
        }
      }

      self._pubResolvePromise = new MetaphorJs.lib.Promise();

      if (config.has("name")) {
        config.get("name") && (self._resolvePromise = self._resolveTemplate());
      } else if (config.has("html")) {
        config.get("html") && (self._resolvePromise = self._resolveHtml());
      }

      !self._resolvePromise && (self._resolvePromise = MetaphorJs.lib.Promise.resolve());

      self._resolvePromise.fail(self._onTemplateNotFound, self);

      return self._resolvePromise.done(self._onTemplateResolved, self);
    },
    getVirtualSet: function (ref) {
      return this._virtualSets[ref] ? copy(this._virtualSets[ref]) : null;
    },
    setNamedNode: function (ref, node) {
      var self = this,
          nodes = self._namedNodes[ref];

      if (node['__namedRenderer'] && node['__namedRenderer'][ref]) {
        return;
      }

      if (!nodes) {
        nodes = self._namedNodes[ref] = [];
      }

      if (node && nodes.indexOf(node) === -1) {
        nodes.push(node);

        if (self._renderer && self._virtualSets[ref]) {
          self._renderer.processNode(node, self.state, self.getVirtualSet(ref));
        }
      }
    },
    removeNamedNode: function (ref, node) {
      var nodes = this._namedNodes[ref],
          inx;

      if (!nodes || (inx = nodes.indexOf(node)) !== -1) {
        nodes.splice(inx, 1);
      }
    },
    _extractVirtualSets: function (frag) {
      var self = this,
          node = frag.firstChild,
          cmtType = window.document.COMMENT_NODE,
          data,
          next;

      while (node) {
        next = node.nextSibling;

        if (node.nodeType === cmtType) {
          data = node.textContent || node.data;

          if (data.substring(0, 1) === '<' && data.substring(data.length - 1) === '>') {
            self._processVirtualSet(data);

            frag.removeChild(node);
          }
        }

        node = next;
      }
    },
    _processVirtualSet: function (data) {
      var div = window.document.createElement("div");
      div.innerHTML = data;
      var node = div.firstChild;

      if (node) {
        var ref = node.tagName.toLowerCase(),
            attrSet = MetaphorJs.dom.getAttrSet(node);
        this._virtualSets[ref] = attrSet;
      }
    },
    _onTemplateResolved: function (fragment) {
      var self = this,
          root = self.rootNode;

      if (self._attached) {
        self._clear();
      }

      if (fragment) {
        self._template = typeof fragment === "string" ? MetaphorJs.dom.toFragment(fragment) : fragment;
        self._fragment = MetaphorJs.dom.clone(self._template);

        self._extractVirtualSets(self._fragment);

        if (root) {
          while (root.firstChild) {
            root.removeChild(root.firstChild);
          }

          root.appendChild(self._fragment);

          if (!root.parentNode) {
            self._fragment.appendChild(root);
          }

          self._nodes = [root];
        } else {
          self._nodes = toArray(self._fragment.childNodes);
        }
      } else if (root) {
        self._nodes = [root];
      }

      self._pubResolvePromise.resolve();
    },
    _onTemplateNotFound: function () {
      throw new Error("Template " + this.config.get("name") + " not found");
    },
    _collectInitialNodes: function (parent) {
      var self = this;

      if (!self.config.has("name") && !self.config.has("html")) {
        parent = parent || self._attachTo || self.attachTo;
        parent && (self._nodes = toArray(parent.childNodes));
      }
    },
    createEvent: function (event, opt) {
      return observable.createEvent(event + "-" + this.id, opt);
    },
    on: function (event, fn, context, opt) {
      return observable.on(event + "-" + this.id, fn, context, opt);
    },
    un: function (event, fn, context) {
      return observable.un(event + "-" + this.id, fn, context);
    },
    _prepareTranscludes: function () {
      var self = this,
          saveIn,
          takeFrom;

      if (self.replaceNode) {
        saveIn = self.replaceNode.parentNode;
        takeFrom = self.replaceNode;
      } else if (self.attachTo) {
        saveIn = takeFrom = self.attachTo;
      }

      if (saveIn && takeFrom && self.config.get("makeTranscludes") && takeFrom.firstChild && !MetaphorJs.dom.data(saveIn, "mjs-transclude")) {
        MetaphorJs.dom.data(saveIn, "mjs-transclude", MetaphorJs.dom.toFragment(takeFrom.childNodes));
      }
    },
    _replaceNodeWithComments: function (node) {
      var self = this,
          cmts = MetaphorJs.dom.commentWrap(node, self.id);
      node.parentNode && node.parentNode.removeChild(node);
      self._prevEl = cmts[0];
      self._nextEl = cmts[1];
    },
    _replaceNodeWithNode: function (replacedNode, withNode) {
      var frg = MetaphorJs.dom.toFragment(replacedNode.childNodes);
      replacedNode.parentNode && replacedNode.parentNode.replaceChild(replacedNode, withNode);
      withNode.appendChild(frg);
    },
    _createComments: function () {
      var self = this,
          parent = self._attachTo,
          before = self._attachBefore;

      if (parent && !self._prevEl && self.config.get("useComments")) {
        var cmts = [window.document.createComment("<" + self.id), window.document.createComment(self.id + ">")];
        parent.insertBefore(cmts[0], before);
        parent.insertBefore(cmts[1], before);
        self._prevEl = cmts[0];
        self._nextEl = cmts[1];
      }
    },
    _removeComments: function () {
      var self = this,
          next = self._nextEl,
          prev = self._prevEl;
      next.parentNode && next.parentNode.removeChild(next);
      prev.parentNode && prev.parentNode.removeChild(prev);
      self._nextEl = null;
      self._prevEl = null;
    },
    _createShadow: function () {
      var self = this;

      if (self._attachTo && !self._shadowRoot && self.config.get("useShadow")) {
        self._shadowRoot = self._attachTo.shadowRoot || self._attachTo.attachShadow({
          mode: "open"
        });
      }
    },
    _destroyShadow: function () {
      this._shadowRoot = null;
    },
    _runRenderer: function () {
      var self = this;

      if (self.config.get("runRenderer")) {
        self._destroyRenderer();

        observable.trigger("before-render-" + self.id, self);
        self._renderer = new MetaphorJs.app.Renderer();

        if (self.config.get("passReferences") && self._parentRenderer) {
          self._renderer.on("reference", self._parentRenderer.trigger, self._parentRenderer, {
            prepend: ["reference"]
          });
        }

        self._renderer.on("transclude-sources", self._onTranscludeSource, self); // after renderer had its course, the list of nodes may have changed.
        // we need to reflect this in _nodes before attaching stuff


        self._renderer.on("rendered", self._collectedNodesAfterRendered, self); // then we apply directives to all named nodes we have at the moment


        self._renderer.on("rendered", self._processNamedNodes, self); // then send the 'rendered' signal up the chain


        observable.relayEvent(self._renderer, "rendered", "rendered-" + self.id);
        observable.relayEvent(self._renderer, "reference", "reference-" + self.id);

        if (self._nodes) {
          self._renderer.process(self._nodes, self.state);
        } else {
          self._renderer.trigger("rendered", self._renderer);
        }
      }
    },
    _onTranscludeSource: function () {
      return this._replaceNode || this.replaceNode || this._attachTo || this.attachTo;
    },
    _collectedNodesAfterRendered: function () {
      var self = this;
      self._rendered = true;

      if (self._fragment) {
        this._nodes = toArray(self._fragment.childNodes);
      }
    },
    _processNamedNodes: function () {
      var self = this,
          vnodes = self._namedNodes,
          vsets = self._virtualSets,
          ref,
          i,
          l,
          node,
          nr,
          attrSet,
          attr;

      for (ref in vnodes) {
        if (vsets[ref]) {
          for (i = 0, l = vnodes[ref].length; i < l; i++) {
            node = vnodes[ref][i];
            nr = node['__namedRenderer'] || {};
            nr[ref] = self._renderer.id;
            node['__namedRenderer'] = nr;
            attrSet = self.getVirtualSet(ref);

            if (attrSet.rest && node.nodeType === window.document.ELEMENT_NODE) {
              for (attr in attrSet.rest) {
                node.setAttribute(attr, attrSet.rest[attr]);
              }
            }

            self._renderer.processNode(node, self.state, attrSet);
          }
        }
      }
    },
    _destroyRenderer: function () {
      var self = this;
      self._rendered = false;

      if (self._renderer) {
        var id = self._renderer.id,
            vnodes = self._namedNodes,
            ref,
            i,
            l,
            node,
            nr;

        self._renderer.$destroy();

        self._renderer = null;

        for (ref in vnodes) {
          for (i = 0, l = vnodes[ref].length; i < l; i++) {
            node = vnodes[ref][i];
            nr = node['__namedRenderer'];
            nr && nr[ref] === id && (nr[ref] = null);
          }
        }

        self._namedNodes = {};
      }
    },
    _resolveTemplate: function () {
      var tpl = this.config.get("name");
      return new MetaphorJs.lib.Promise(function (resolve, reject) {
        if (tpl) {
          tpl = getTemplate(tpl);
          tpl ? resolve(tpl) : reject();
        } else reject();
      });
    },
    _resolveHtml: function () {
      var html = this.config.get("html");
      return new MetaphorJs.lib.Promise(function (resolve, reject) {
        html ? resolve(html) : reject();
      });
    },
    _onHtmlChange: function () {
      var self = this;

      if (!self.config.get("deferRendering")) {
        self.resolve(true).done(self._runRenderer, self).done(self.attachOrReplace, self);
      }
    },
    _onNameChange: function () {
      var self = this;

      if (!self.config.get("deferRendering")) {
        self.resolve(true).done(self._runRenderer, self).done(self.attachOrReplace, self);
      }
    },
    _collectBetweenComments: function () {
      var next = this._nextEl,
          prev = this._prevEl,
          node = prev,
          els = [];

      if (prev && next) {
        while (node && node.nextSibling && node.nextSibling !== next) {
          els.push(node.nextSibling);
          node = node.nextSibling;
        }
      }

      return els;
    },
    _doAttach: function () {
      var self = this,
          i,
          l,
          nodes = self._nodes,
          child,
          attached = false,
          next = self._nextEl,
          parent = self._shadowRoot || self._attachTo,
          before = self._attachBefore;

      if (!nodes || self._attached) {
        return;
      } // without the fragment we're in no-template mode
      // processing parent's children


      if (self._fragment || self.rootNode) {
        // if we have children in the fragment,
        // we use them (they might have changed since)
        // this template has been rendered
        // because of inner templates and renderers
        if (self._fragment && self._fragment.firstChild) {
          self._nodes = nodes = toArray(self._fragment.childNodes);
        }

        for (i = 0, l = nodes.length; i < l; i++) {
          child = nodes[i]; // between comments mode

          if (next) {
            next.parentNode.insertBefore(child, next);
            attached = true;
          } // shadow or normal parent
          else if (parent) {
            if (before) {
              parent.insertBefore(child, before);
            } else {
              parent.appendChild(child);
            }

            attached = true;
          }
        }
      } else {
        attached = true;
      }

      self._attached = attached;

      if (attached) {
        self._setAttached(nodes);
      }
    },
    _setAttached: function (nodes) {
      var self = this;
      self._attached = true;
      observable.trigger("attached-" + self.id, self, nodes);

      if (self._renderer) {
        self._renderer.attached(self._attachTo);
      }
    },
    _collectNodes: function () {
      var self = this,
          nodes = [],
          parent; // remove all children between prev and next

      if (self._nextEl) {
        nodes = self._collectBetweenComments();
      } else {
        // remove all children of main node
        var parent = self._shadowRoot || self._attachTo;

        if (parent) {
          nodes = toArray(parent.childNodes);
        }
      }

      return nodes;
    },
    _clear: function () {
      var self = this,
          nodes = self._collectNodes(),
          i,
          l,
          n;

      for (i = 0, l = nodes.length; i < l; i++) {
        n = nodes[i];
        n.parentNode && n.parentNode.removeChild(n);
      }

      self._attached = false;

      if (self._renderer) {
        self._renderer.detached();

        observable.trigger("detached-" + self.id, self, nodes);
      }

      return nodes;
    },

    /*_onParentRendererDestroy: function() {
        //var self = this;
         if (!self.$destroyed && self._renderer &&
            !self._renderer.$destroyed) {
            self._renderer.$destroy();
        }
         this.$destroy();
    },*/
    _onStateDestroy: function () {
      this.$destroy();
    },
    $destroy: function () {
      var self = this;
      self.$destroyed = true;

      if (self._nextEl && self._nextEl.parentNode) {
        self._nextEl.parentNode.removeChild(self._nextEl);
      }

      if (self._prevEl && self._prevEl.parentNode) {
        self._prevEl.parentNode.removeChild(self._prevEl);
      }

      if (self._renderer) {
        self._renderer.$destroy();
      }

      observable.destroyEvent("rendered-" + self.id);
      observable.destroyEvent("attached-" + self.id);

      if (self.config) {
        self.config.clear();
        self.config = null;
      }
    }
  });
  Template.load = loadTemplate;
  Template.cache = cache;

  Template.add = function (name, tpl) {
    Template.cache.add(name, tpl);
  };

  Template.get = getTemplate;

  Template.prepareConfig = function (config, values) {
    if (typeof values === 'string') {
      config.setDefaultValue("name", values);
    } else if (values) {
      if (!values.name && !values.html && values.expression) {
        values.name = {
          expression: values.expression
        };
      }

      config.addProperties(values, "defaultValue");
    }
  };

  Template.initConfig = function (config) {
    var sm = MetaphorJs.lib.Config.MODE_STATIC;
    config.setDefaultMode("value", sm);
    config.setDefaultMode("name", sm);
    config.setDefaultMode("html", sm);
    config.setType("runRenderer", "bool", sm);
    config.setType("useComments", "bool", sm);
    config.setType("useShadow", "bool", sm);
    config.setType("deferRendering", "bool", sm);
    config.setType("makeTranscludes", "bool", sm);
    config.setType("passReferences", "bool", sm);
    config.setProperty("useComments", "defaultValue", true,
    /*override: */
    false);
    config.setProperty("makeTranscludes", "defaultValue", true,
    /*override: */
    false);
    config.setProperty("passReferences", "defaultValue", false,
    /*override: */
    false);
  };

  return Template;
}();

/***/ }),

/***/ "../metaphorjs/src/app/__init.js":
/*!***************************************!*\
  !*** ../metaphorjs/src/app/__init.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

MetaphorJs.app.view = MetaphorJs.app.view || {};
MetaphorJs.app.component = MetaphorJs.app.component || {};

/***/ }),

/***/ "../metaphorjs/src/app/component/View.js":
/*!***********************************************!*\
  !*** ../metaphorjs/src/app/component/View.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs/src/app/__init.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.app.component.View = cls({
  $init: function (host) {
    this.component = host;
    this.component.$view = this;
  }
});

/***/ }),

/***/ "../metaphorjs/src/app/view/Base.js":
/*!******************************************!*\
  !*** ../metaphorjs/src/app/view/Base.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs/src/app/__init.js");

__webpack_require__(/*! ../../func/dom/data.js */ "../metaphorjs/src/func/dom/data.js");

__webpack_require__(/*! ../../func/dom/toFragment.js */ "../metaphorjs/src/func/dom/toFragment.js");

__webpack_require__(/*! ../../func/dom/addClass.js */ "../metaphorjs/src/func/dom/addClass.js");

__webpack_require__(/*! ../../func/dom/removeClass.js */ "../metaphorjs/src/func/dom/removeClass.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/animate.js */ "../metaphorjs-animate/src/animate/animate.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../../func/app/resolve.js */ "../metaphorjs/src/func/app/resolve.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      raf = __webpack_require__(/*! metaphorjs-animate/src/func/raf.js */ "../metaphorjs-animate/src/func/raf.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      isObject = __webpack_require__(/*! metaphorjs-shared/src/func/isObject.js */ "../metaphorjs-shared/src/func/isObject.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js");

module.exports = MetaphorJs.app.view.Base = cls({
  $mixins: [MetaphorJs.mixin.Observable],
  $init: function (cfg) {
    var self = this;
    extend(self, cfg, true, false);

    if (!self.config) {
      self.config = new MetaphorJs.lib.Config(null, {
        state: self.state
      });
    }

    self.initConfig();
    var node = self.node;

    if (node && node.firstChild) {
      MetaphorJs.dom.data(node, "mjs-transclude", MetaphorJs.dom.toFragment(node.childNodes));
    }

    if (!self.id) {
      self.id = self.config.get("id") || nextUid();
    }

    self.state.$app.registerCmp(self, "id");
    self.initView();
  },
  initView: function () {},
  initConfig: function () {
    var config = this.config,
        s = MetaphorJs.lib.Config.MODE_STATIC;
    config.setType("scrollOnChange", "bool", s);
    config.setDefaultMode("defaultCmp", s);
    config.setDefaultMode("id", s);
  },
  clearComponent: function () {
    var self = this,
        node = self.node,
        curr = self.currentComponent;

    if (curr) {
      var anim = null,
          cfg = self.config;

      if (cfg && !cfg.$isDestroyed() && cfg.get("animate")) {
        anim = "leave";
      }

      MetaphorJs.animate.animate(node, anim).done(function () {
        curr && !curr.$isDestroyed() && curr.$destroy();

        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }

        self.currentComponent = null;
      });
    }
  },
  onCmpDestroy: function (cmp) {},
  setComponent: function (cmp) {
    var self = this,
        node = self.node;
    self.beforeCmpChange(cmp);
    MetaphorJs.animate.stop(self.node);
    self.clearComponent();
    MetaphorJs.animate.animate(node, self.config.get("animate") ? "enter" : null, function () {
      var cfg = isObject(cmp) ? cmp : {},
          cls = (isString(cmp) ? cmp : null) || "MetaphorJs.app.Component",
          state = cfg.state || self.state.$new();
      cfg.destroyEl = false;
      cfg.autoRender = true;
      cfg.state = state;
      return MetaphorJs.app.resolve(cls, cfg, node, [cfg]).done(function (newCmp) {
        newCmp.on("destroy", self.onCmpDestroy, self);
        self.currentComponent = newCmp;
        self.afterCmpChange();
      });
    });
  },
  currentIs: function (cls) {
    return this.currentComponent && this.currentComponent.$is(cls);
  },
  beforeCmpChange: function (cmpCls) {},
  afterCmpChange: function () {
    var self = this;
    self.trigger("change", self);

    if (self.config.get("scrollOnChange")) {
      raf(function () {
        self.node.scrollTop = 0;
      });
    }
  },
  onDestroy: function () {
    var self = this;
    self.clearComponent();

    if (self.node) {
      MetaphorJs.dom.data(self.node, "mjs-transclude", null, "remove");
    }

    self.state = null;
    self.currentComponent = null;
    self.currentView = null;
    self.$super();
  }
});

/***/ }),

/***/ "../metaphorjs/src/app/view/Component.js":
/*!***********************************************!*\
  !*** ../metaphorjs/src/app/view/Component.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ./Base.js */ "../metaphorjs/src/app/view/Base.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.app.view.Component = MetaphorJs.app.view.Base.$extend({
  initConfig: function () {
    this.config.setDefaultMode("value", MetaphorJs.lib.Config.MODE_DYNAMIC);
    this.$super();
  },
  initView: function () {
    var self = this;
    self.config.on("value", self.onCmpChange, self);
    self.onCmpChange();
  },
  onCmpChange: function () {
    var self = this,
        cmp = self.config.get("value") || self.config.get("defaultCmp");

    if (!cmp) {
      self.currentComponent && self.clearComponent();
    } else {
      self.setComponent(cmp);
    }
  }
});

/***/ }),

/***/ "../metaphorjs/src/app/view/Router.js":
/*!********************************************!*\
  !*** ../metaphorjs/src/app/view/Router.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs/src/app/__init.js");

__webpack_require__(/*! ../../lib/History.js */ "../metaphorjs/src/lib/History.js");

__webpack_require__(/*! ../../lib/UrlParam.js */ "../metaphorjs/src/lib/UrlParam.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/animate.js */ "../metaphorjs-animate/src/animate/animate.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/stop.js */ "../metaphorjs-animate/src/animate/stop.js");

__webpack_require__(/*! metaphorjs-shared/src/func/browser/parseLocation.js */ "../metaphorjs-shared/src/func/browser/parseLocation.js");

__webpack_require__(/*! ../../func/dom/data.js */ "../metaphorjs/src/func/dom/data.js");

__webpack_require__(/*! ../../func/dom/toFragment.js */ "../metaphorjs/src/func/dom/toFragment.js");

__webpack_require__(/*! ../../func/app/resolve.js */ "../metaphorjs/src/func/app/resolve.js");

__webpack_require__(/*! ../../func/dom/addClass.js */ "../metaphorjs/src/func/dom/addClass.js");

__webpack_require__(/*! ../../func/dom/removeClass.js */ "../metaphorjs/src/func/dom/removeClass.js");

__webpack_require__(/*! ../../lib/MutationObserver.js */ "../metaphorjs/src/lib/MutationObserver.js");

__webpack_require__(/*! ./Base.js */ "../metaphorjs/src/app/view/Base.js");

const extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      async = __webpack_require__(/*! metaphorjs-shared/src/func/async.js */ "../metaphorjs-shared/src/func/async.js"),
      isThenable = __webpack_require__(/*! metaphorjs-shared/src/func/isThenable.js */ "../metaphorjs-shared/src/func/isThenable.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.app.view.Router = MetaphorJs.app.view.Base.$extend({
  initView: function () {
    var self = this;
    self.routeMap = {};
    self.cmpCache = {};
    self.domCache = {};
    self.route = self.route || [];
    MetaphorJs.lib.History.init();
    MetaphorJs.lib.History.on("location-change", self.onLocationChange, self);
    self.initRoutes();
    self.onLocationChange();
  },
  initRoutes: function () {
    var self = this,
        routes = self.route,
        params,
        param,
        route,
        i,
        l,
        j,
        z;

    for (i = 0, l = routes.length; i < l; i++) {
      route = routes[i];
      route.id = route.id || nextUid();

      if (route.params) {
        params = {};

        for (j = 0, z = route.params.length; j < z; j++) {
          param = route.params[j];

          if (param.name) {
            params[param.name] = new MetaphorJs.lib.UrlParam(extend({}, param, {
              enabled: false
            }, true, false));
          }
        }

        route.params = params;
      }

      self.routeMap[route.id] = route;
    }
  },
  onLocationChange: function () {
    if (this.$destroyed || this.$destroying) {
      return;
    }

    var self = this,
        url = MetaphorJs.lib.History.current(),
        loc = MetaphorJs.browser.parseLocation(url),
        path = loc.pathname + loc.search + loc.hash,
        routes = self.route,
        def,
        i,
        len,
        r,
        matches;

    for (i = 0, len = routes.length; i < len; i++) {
      r = routes[i];

      if (r.regexp && (matches = loc.pathname.match(r.regexp))) {
        self.resolveRoute(r, matches);
        return;
      } else if (r.regexpFull && (matches = path.match(r.regexp))) {
        self.resolveRoute(r, matches);
        return;
      }

      if (r['default'] && !def) {
        def = r;
      }
    }

    var tmp = self.onNoMatchFound(loc);

    if (tmp) {
      if (isThenable(tmp)) {
        tmp.done(self.resolveRoute, self);
        tmp.fail(function () {
          self.finishOnLocationChange(def);
        });
      } else {
        self.resolveRoute(tmp);
      }
    } else {
      self.finishOnLocationChange(def);
    }
  },
  finishOnLocationChange: function (def) {
    var self = this;

    if (self.$destroyed || self.$destroying) {
      return;
    }

    if (def) {
      self.resolveRoute(def);
    } else if (self.config.hasExpression("defaultCmp")) {
      self.setComponent(self.config.get("defaultCmp"));
    }
  },
  resolveRoute: function (route, matches) {
    var self = this;
    matches = matches || [];

    if (route.resolve) {
      var promise = route.resolve.call(self, route, matches);

      if (isThenable(promise)) {
        promise.done(function () {
          self.setRouteComponent(route, matches);
        });
      } else if (promise) {
        self.setRouteComponent(route, matches);
      }
    } else {
      self.setRouteComponent(route, matches);
    }
  },
  onNoMatchFound: function () {},
  toggleRouteParams: function (route, fn) {
    if (route.params) {
      for (var i in route.params) {
        route.params[i][fn]();
      }
    }
  },
  setRouteClasses: function (route) {
    var self = this;

    if (route.cls) {
      self.currentCls = route.cls;
      MetaphorJs.dom.addClass(self.node, route.cls);
    }

    if (route.htmlCls) {
      self.currentHtmlCls = route.htmlCls;
      MetaphorJs.dom.addClass(window.document.documentElement, route.htmlCls);
    }
  },
  onRouteFail: function (route) {},
  onRouteParamChange: function () {},
  setRouteComponent: function (route, matches, force) {
    var self = this,
        node = self.node,
        params = route.params,
        cview = self.currentView || {};

    if (self.$destroyed || self.$destroying) {
      return;
    }

    if (route.id === cview.id && !route.resetOnParamChange) {
      if (self.currentComponent && self.currentComponent.onViewRepeat) {
        self.currentComponent.onViewRepeat();
      }

      return;
    }

    if (route.ttlTmt) {
      clearTimeout(route.ttlTmt);
    }

    self.beforeRouteCmpChange(route);
    self.toggleRouteParams(cview, "disable");
    self.toggleRouteParams(route, "enable");
    MetaphorJs.animate.stop(self.node);
    self.clearComponent();

    if (cview.teardown) {
      cview.teardown(cview, route, matches);
    }

    self.setRouteClasses(route);
    self.currentView = route;
    MetaphorJs.animate.animate(node, self.config.get("animate") ? "enter" : null, function () {
      var args = matches || [],
          cfg = {
        destroyEl: false,
        autoRender: true,
        node: node,
        destroyState: true,
        state: self.state.$new()
      };

      if (route.config) {
        cfg.config = route.config;
      }

      if (route.template) {
        cfg.template = route.template;
      }

      args.shift();

      if (params) {
        extend(cfg, params, false, false);
      }

      args.unshift(cfg);

      if (self.cmpCache[route.id]) {
        self.currentComponent = self.cmpCache[route.id];
        node.appendChild(self.domCache[route.id]);
        self.currentComponent.unfreeze(self);
        self.afterRouteCmpChange();
        self.afterCmpChange();
      } else {
        if (route.setup) {
          route.setup(route, matches);
        } else {
          return MetaphorJs.app.resolve(route.cmp || "MetaphorJs.app.Component", cfg, node, args).done(function (newCmp) {
            self.currentComponent = newCmp;

            if (route.keepAlive) {
              newCmp[self.id] = route.id;
              self.cmpCache[route.id] = newCmp;
              self.domCache[route.id] = window.document.createDocumentFragment();
              newCmp.on("destroy", self.onCmpDestroy, self);
            }

            self.afterRouteCmpChange();
            self.afterCmpChange();
          }).fail(function () {
            self.onRouteFail(route);
          });
        }
      }
    });
  },
  currentIs: function (cls) {
    if (this.currentView && this.currentView.id == cls) {
      return true;
    }

    return this.$super(cls);
  },
  clearComponent: function () {
    var self = this,
        node = self.node,
        cview = self.currentView || {};

    if (self.$destroyed || self.$destroying) {
      return;
    }

    if (self.currentCls) {
      MetaphorJs.dom.removeClass(self.node, self.currentCls);
    }

    self.currentView = null;

    if (self.currentHtmlCls) {
      MetaphorJs.dom.removeClass(window.document.documentElement, self.currentHtmlCls);
    }

    if (self.currentComponent) {
      MetaphorJs.animate.animate(node, self.config.get("animate") ? "leave" : null).done(function () {
        if (!cview.keepAlive) {
          if (self.currentComponent && !self.currentComponent.$destroyed && !self.currentComponent.$destroying) {
            self.currentComponent.$destroy();
          }

          while (node.firstChild) {
            node.removeChild(node.firstChild);
          }
        } else {
          self.currentComponent.freeze(self);
          var frg = self.domCache[cview.id];

          while (node.firstChild) {
            frg.appendChild(node.firstChild);
          }

          if (cview.ttl) {
            cview.ttlTmt = async(self.onCmpTtl, self, [cview], cview.ttl);
          }
        }

        self.currentComponent = null;
      });
    }
  },
  onCmpTtl: function (currentView) {
    var self = this,
        id = currentView.id;
    route.ttlTmt = null;

    if (self.$destroyed || self.$destroying) {
      return;
    }

    if (self.cmpCache[id]) {
      self.cmpCache[id].$destroy();
      delete self.cmpCache[id];
      delete self.domCache[id];
    }
  },
  onCmpDestroy: function (cmp) {
    var self = this,
        id = cmp[self.id];

    if (self.$destroyed || self.$destroying) {
      return;
    }

    if (id && self.cmpCache[id]) {
      delete self.cmpCache[id];
      delete self.domCache[id];
    }
  },
  beforeRouteCmpChange: function (route) {},
  afterRouteCmpChange: function () {},
  onDestroy: function () {
    var self = this,
        i,
        l,
        j;
    MetaphorJs.lib.History.un("location-change", self.onLocationChange, self);

    for (i = 0, l = self.route.length; i < l; i++) {
      if (self.route[i].params) {
        for (j in self.route[i].params) {
          self.route[i].params[j].$destroy();
        }
      }
    }

    self.route = null;
    self.$super();
  }
});

/***/ }),

/***/ "../metaphorjs/src/bootstrap/apps.js":
/*!*******************************************!*\
  !*** ../metaphorjs/src/bootstrap/apps.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const run = __webpack_require__(/*! ../func/app/run.js */ "../metaphorjs/src/func/app/run.js");

run();

/***/ }),

/***/ "../metaphorjs/src/directive/attr/app.js":
/*!***********************************************!*\
  !*** ../metaphorjs/src/directive/attr/app.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

const appDirective = function (state, node, config, renderer) {
  renderer && renderer.flowControl("stop", true);
};

appDirective.$prebuild = {
  defaultMode: MetaphorJs.lib.Config.MODE_STATIC,
  ignore: true
};
MetaphorJs.app.Directive.registerAttribute("app", 100, appDirective);

/***/ }),

/***/ "../metaphorjs/src/directive/attr/autofocus.js":
/*!*****************************************************!*\
  !*** ../metaphorjs/src/directive/attr/autofocus.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      async = __webpack_require__(/*! metaphorjs-shared/src/func/async.js */ "../metaphorjs-shared/src/func/async.js");

Directive.registerAttribute("in-focus", 500, Directive.$extend({
  $class: "MetaphorJs.app.Directive.attr.Autofocus",
  id: "autofocus",
  initChange: function () {},
  initDirective: function () {
    var self = this,
        val = self.config.get("value");

    if ("" + parseInt(val) === val) {
      val = parseInt(val);
    } else {
      if (val === "false") val = false;else val = !!val;
    }

    if (val) {
      var set = function () {
        self.node.focus();
        self.$destroy();
      };

      async(set, null, [], val === true ? 300 : val);
    }
  }
}));

/***/ }),

/***/ "../metaphorjs/src/directive/attr/bind-html.js":
/*!*****************************************************!*\
  !*** ../metaphorjs/src/directive/attr/bind-html.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./bind.js */ "../metaphorjs/src/directive/attr/bind.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js");

Directive.registerAttribute("bind-html", 1000, Directive.attr.Bind.$extend({
  $class: "MetaphorJs.app.Directive.attr.BindHtml",
  id: "bind-html",
  _apis: ["node"],
  updateElement: function (val) {
    this.node.innerHTML = val;
  }
}));

/***/ }),

/***/ "../metaphorjs/src/directive/attr/bind.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/directive/attr/bind.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../lib/State.js */ "../metaphorjs/src/lib/State.js");

__webpack_require__(/*! ../../lib/Text.js */ "../metaphorjs/src/lib/Text.js");

__webpack_require__(/*! ../../func/dom/isField.js */ "../metaphorjs/src/func/dom/isField.js");

__webpack_require__(/*! ../../lib/Input.js */ "../metaphorjs/src/lib/Input.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../../func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! ../../func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js");

Directive.registerAttribute("bind", 1000, Directive.$extend({
  $class: "MetaphorJs.app.Directive.attr.Bind",
  id: "bind",
  _apis: ["node", "input"],
  input: null,
  textRenderer: null,
  initDirective: function () {
    var self = this,
        config = self.config;

    if (self.input) {
      self.input.onChange(self.onInputChange, self);
    }

    self.optionsChangeDelegate = bind(self.onOptionsChange, self);
    MetaphorJs.dom.addListener(self.node, "optionschange", self.optionsChangeDelegate);

    if (config.has("if")) {
      config.on("if", self.onIfChange, self);
    }

    if (config.get("recursive")) {
      config.disableProperty("value");
      config.disableProperty("recursive");
      self.textRenderer = new MetaphorJs.lib.Text(self.state, config.getExpression("value"), {
        recursive: true,
        fullExpr: true,
        once: config.get("once")
      });
      self.textRenderer.subscribe(self.onTextRendererChange, self);
      self.onTextRendererChange();
    } else {
      self.$super();
    }
  },
  initNode: function (node) {
    var self = this;

    if (MetaphorJs.dom.isField(node)) {
      self.input = MetaphorJs.lib.Input.get(node);
    }
  },
  onInputChange: function () {
    var self = this,
        config = self.config,
        stateVal,
        inputVal;

    if (config.has("locked") && config.get("locked")) {
      stateVal = self.config.get("value") || null;
      inputVal = self.input.getValue() || null;

      if (stateVal != inputVal) {
        self.onStateChange();
      }
    }
  },
  onTextRendererChange: function () {
    this.onStateChange();
  },
  onOptionsChange: function () {
    this.onStateChange();
  },
  onIfChange: function (val) {
    if (this.config.get("if")) {
      this.onStateChange();
    }
  },
  onStateChange: function () {
    var config = this.config;

    if (config.has("if") && !config.get("if")) {
      return;
    }

    var val = this.textRenderer ? this.textRenderer.getString() : this.config.get("value");
    this.updateElement(val);
  },
  updateElement: function (val) {
    var self = this;

    if (self.input) {
      if (self.input.getValue() != val) {
        self.input.setValue(val);
      }
    } else {
      self.node[typeof self.node.textContent === "string" ? "textContent" : "innerText"] = val;
    }
  },
  onDestroy: function () {
    var self = this;
    MetaphorJs.dom.removeListener(self.node, "optionschange", self.optionsChangeDelegate);

    if (self.textRenderer) {
      self.textRenderer.$destroy();
      self.textRenderer = null;
    }

    if (self.input) {
      self.input.unChange(self.onInputChange, self);
      self.input.$destroy();
      self.input = null;
    }

    self.$super();
  }
}, {
  initConfig: function (config, instance) {
    config.setType("if", "bool");
    config.setType("recursive", "bool");
    config.setType("once", "bool", MetaphorJs.lib.Config.MODE_STATIC);
    config.setType("locked", "bool");
  }
}));

/***/ }),

/***/ "../metaphorjs/src/directive/attr/class.js":
/*!*************************************************!*\
  !*** ../metaphorjs/src/directive/attr/class.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-animate/src/animate/animate.js */ "../metaphorjs-animate/src/animate/animate.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/stop.js */ "../metaphorjs-animate/src/animate/stop.js");

__webpack_require__(/*! ../../func/dom/addClass.js */ "../metaphorjs/src/func/dom/addClass.js");

__webpack_require__(/*! ../../func/dom/removeClass.js */ "../metaphorjs/src/func/dom/removeClass.js");

__webpack_require__(/*! ../../func/dom/hasClass.js */ "../metaphorjs/src/func/dom/hasClass.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js");
/*
value is always an object in the end
{class: "condition", class: "condition"}

array turns into _: []
{_: [class, class]}
(which is then turned into {class: true, class: true}
DO NOT put class="{}" when using class.name="{}"
 */


(function () {
  var toggleClass = function (node, cls, toggle, doAnim) {
    var has;

    if (!node.className) {
      node.className = "";
    }

    if (toggle !== null) {
      if (toggle === MetaphorJs.dom.hasClass(node, cls)) {
        return;
      }

      has = !toggle;
    } else {
      has = MetaphorJs.dom.hasClass(node, cls);
    }

    if (has) {
      if (doAnim) {
        MetaphorJs.animate.animate(node, [cls + "-remove"]).done(function () {
          MetaphorJs.dom.removeClass(node, cls);
        });
      } else {
        MetaphorJs.dom.removeClass(node, cls);
      }
    } else {
      if (doAnim) {
        MetaphorJs.animate.animate(node, [cls + "-add"]).done(function () {
          MetaphorJs.dom.addClass(node, cls);
        });
      } else {
        MetaphorJs.dom.addClass(node, cls);
      }
    }
  };

  var flatten = function (values) {
    var clss = {},
        i,
        l,
        val,
        j,
        jl;

    for (i = 0, l = values.length; i < l; i++) {
      val = values[i];

      if (typeof val === 'string') {
        clss[val] = true;
        continue;
      } else if (isArray(val)) {
        for (j = -1, jl = val.length; ++j < jl; clss[val[j]] = true) {}
      }

      for (j in val) {
        if (j === '_') {
          for (j = -1, jl = val._.length; ++j < jl; clss[val._[j]] = true) {}
        } else {
          clss[j] = val[j];
        }
      }
    }

    return clss;
  };

  Directive.registerAttribute("class", 1000, Directive.$extend({
    $class: "MetaphorJs.app.Directive.attr.Class",
    id: "class",
    _initial: true,
    _prev: null,
    initConfig: function () {
      var self = this,
          config = self.config;
      config.eachProperty(function (k) {
        if (k === 'value' || k.indexOf("value.") === 0) {
          config.on(k, self.onStateChange, self);
        }
      });
      self.$super();
    },
    initChange: function () {
      var self = this;

      if (self._autoOnChange) {
        self.onStateChange();
      }
    },
    getCurrentValue: function () {
      var all = this.config.getAllValues(),
          values = [];

      if (all[""]) {
        values.push(all['']);
        delete all[''];
      }

      values.push(all);
      return flatten(values);
    },
    onStateChange: function () {
      var self = this,
          node = self.node,
          clss = self.getCurrentValue(),
          prev = self._prev,
          i;
      MetaphorJs.animate.stop(node);

      if (prev) {
        for (i in prev) {
          if (prev.hasOwnProperty(i)) {
            if (clss[i] === undefined) {
              toggleClass(node, i, false, false);
            }
          }
        }
      }

      for (i in clss) {
        if (clss.hasOwnProperty(i)) {
          toggleClass(node, i, !!clss[i], !self._initial && self.config.get("animate"));
        }
      }

      self._prev = clss;
      self._initial = false;
    }
  }, {
    initConfig: function (config, instance) {
      config.setType("animate", "bool");
    }
  }));
})();

/***/ }),

/***/ "../metaphorjs/src/directive/attr/cmp.js":
/*!***********************************************!*\
  !*** ../metaphorjs/src/directive/attr/cmp.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../func/app/resolve.js */ "../metaphorjs/src/func/app/resolve.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../../lib/State.js */ "../metaphorjs/src/lib/State.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      ns = __webpack_require__(/*! metaphorjs-namespace/src/var/ns.js */ "../metaphorjs-namespace/src/var/ns.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

(function () {
  var cmpAttr = function (state, node, config, renderer, attrSet) {
    if (!(node instanceof window.Node)) {
      throw new Error("cmp directive can only work with DOM nodes");
    } // if there is no instructions regarding component's state,
    // we create a new child state by default


    if (!config.has("state")) {
      state = state.$new();
    }

    cmpAttr.initConfig(config);
    var cmpName = config.get("value"),
        tag = node.tagName.toLowerCase();
    config.removeProperty("value");
    var cfg = {
      state: state,
      node: node,
      config: config,
      parentRenderer: renderer,
      autoRender: true
    };

    if (MetaphorJs.directive.component[tag]) {
      cfg.directives = attrSet.directives;
      renderer.flowControl("stop", true);
    }

    var promise = MetaphorJs.app.resolve(cmpName, cfg, node, [cfg]).done(function (cmp) {
      if (renderer.$destroyed || state.$$destroyed) {
        cmp.$destroy();
      } else {
        renderer.on("destroy", cmp.$destroy, cmp);
        renderer.trigger("reference", "cmp", config.get("ref") || cmp.id, cmp, cfg, attrSet);
      }
    });
    renderer.trigger("reference-promise", promise, cmpName, cfg, attrSet);
    renderer.flowControl("ignoreInside", true);
  };

  cmpAttr.initConfig = function (config, instance) {
    var ms = MetaphorJs.lib.Config.MODE_STATIC;
    config.setDefaultMode("value", ms);
    config.setDefaultMode("init", MetaphorJs.lib.Config.MODE_FUNC);
    config.setDefaultMode("as", ms);
    config.setDefaultMode("ref", ms);
    config.setDefaultMode("state", ms);
    config.setMode("into", ms);
    config.setType("cloak", "bool", ms);
  };

  cmpAttr.deepInitConfig = function (config) {
    var cmpName = config.get("value");
    var constr = typeof cmpName === "string" ? ns.get(cmpName) : cmpName;

    if (!constr) {
      return;
    }

    if (constr.initConfig) {
      constr.initConfig(config);
    }
  };

  Directive.registerAttribute("cmp", 200, cmpAttr);
})();

/***/ }),

/***/ "../metaphorjs/src/directive/attr/controller.js":
/*!******************************************************!*\
  !*** ../metaphorjs/src/directive/attr/controller.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../func/app/resolve.js */ "../metaphorjs/src/func/app/resolve.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../../lib/State.js */ "../metaphorjs/src/lib/State.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      ns = __webpack_require__(/*! metaphorjs-namespace/src/var/ns.js */ "../metaphorjs-namespace/src/var/ns.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

(function () {
  var ctrlAttr = function (state, node, config, renderer, attrSet) {
    ctrlAttr.initConfig(config);
    var ctrlName = config.get("value");
    config.removeProperty("value"); // if there is instructions regarding controller's state
    // we set this state for all children of current node

    if (config.has("state")) {
      renderer.flowControl("newState", state);
    }

    var cfg = {
      state: state,
      node: node,
      config: config,
      parentRenderer: renderer,
      attrSet: attrSet
    };
    MetaphorJs.app.resolve(ctrlName, cfg, node, [cfg]).done(function (ctrl) {
      if (renderer.$destroyed || state.$$destroyed) {
        ctrl.$destroy();
      } else {
        renderer.on("destroy", ctrl.$destroy, ctrl);
      }
    });
  };

  ctrlAttr.initConfig = function (config, instance) {
    var ms = MetaphorJs.lib.Config.MODE_STATIC;
    config.setDefaultMode("value", ms);
    config.setDefaultMode("as", ms);
    config.setDefaultMode("state", ms);
  };

  ctrlAttr.deepInitConfig = function (config) {
    const ctrlName = config.get("value");
    const constr = typeof ctrlName === "string" ? ns.get(ctrlName) : ctrlName;

    if (!constr) {
      return;
    }

    if (constr.initConfig) {
      constr.initConfig(config);
    }
  };

  Directive.registerAttribute("controller", 200, ctrlAttr);
})();

/***/ }),

/***/ "../metaphorjs/src/directive/attr/each.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/directive/attr/each.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ../../app/ListRenderer.js */ "../metaphorjs/src/app/ListRenderer.js");

__webpack_require__(/*! ../../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ../../func/app/prebuilt.js */ "../metaphorjs/src/func/app/prebuilt.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      split = __webpack_require__(/*! metaphorjs-shared/src/func/split.js */ "../metaphorjs-shared/src/func/split.js");

(function () {
  var types = [];

  function detectModelType(expr, state) {
    var i = 0,
        l = types.length,
        pb;

    if (MetaphorJs.app.prebuilt.isKey(expr)) {
      pb = MetaphorJs.app.prebuilt.get("config", expr);
    } else if (typeof expr !== "string") {
      pb = expr;
    }

    if (pb) {
      var getter = MetaphorJs.lib.Expression.construct(pb, {
        getterOnly: true
      });
      var obj = getter(state);
    } else {
      var tmp = expr.split(" in "),
          model = tmp.length === 1 ? expr : tmp[1],
          obj = MetaphorJs.lib.Expression.get(model, state);
    }

    for (; i < l; i++) {
      if (obj instanceof types[i][0]) {
        return types[i][1];
      }
    }

    return null;
  }

  var eachDirective = function eachDirective(state, node, config, renderer, attrSet) {
    if (!(node instanceof window.Node)) {
      throw new Error("'each' directive can only work with DOM nodes");
    }

    renderer && renderer.flowControl("stop", true);
    config.disableProperty("value");
    var tagMode = node.nodeName.toLowerCase() === "mjs-each",
        expr;

    if (tagMode) {
      expr = MetaphorJs.dom.getAttr(node, "value");
    } else {
      expr = config.getExpression("value");
    }

    var handler = detectModelType(expr, state) || MetaphorJs.app.ListRenderer;
    return new handler(state, node, config, renderer, attrSet);
  };

  eachDirective.registerType = function (objectClass, handlerClass) {
    types.push([objectClass, handlerClass]);
  };

  eachDirective.deepInitConfig = function (config) {
    var prop = config.getProperty("value"),
        parts = this.splitExpression(prop.expression);
    prop.expression = parts.model;
    prop.inflate = prop.inflate || {};
    prop.inflate.itemName = parts.name;
  };

  eachDirective.splitExpression = function (expr) {
    var tmp = expr.split(" "),
        i,
        len,
        model,
        name,
        row;

    for (i = 0, len = tmp.length; i < len; i++) {
      row = tmp[i];

      if (row === "" || row === "in") {
        continue;
      }

      if (!name) {
        name = row;
      } else {
        model = tmp.slice(i).join(" ");
        break;
      }
    }

    return {
      model: model,
      name: name || "item"
    };
  };

  eachDirective.registerType(Array, MetaphorJs.app.ListRenderer);
  Directive.registerAttribute("each", 100, eachDirective);
  Directive.registerTag("each", eachDirective);
})();

/***/ }),

/***/ "../metaphorjs/src/directive/attr/events.js":
/*!**************************************************!*\
  !*** ../metaphorjs/src/directive/attr/events.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../lib/EventHandler.js */ "../metaphorjs/src/lib/EventHandler.js");

__webpack_require__(/*! ../../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ../../lib/Input.js */ "../metaphorjs/src/lib/Input.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../../func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! ../../func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

(function () {
  const events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'keydown', 'keyup', 'keypress', 'change', 'focus', 'blur', 'copy', 'cut', 'paste', 'load', 'mousewheel', 'touchstart', 'touchend', 'touchcancel', 'touchleave', 'touchmove', 'dragstart', 'dragenter', 'dragleave', 'dragend', 'drop'];
  let i, len;

  const prepareConfig = function (config) {
    const ms = MetaphorJs.lib.Config.MODE_STATIC;
    config.setProperty("preventDefault", {
      type: "bool",
      defaultValue: true,
      defaultMode: ms
    });
    config.setDefaultMode("state", ms);
    config.setType("stopPropagation", "bool", ms);
    config.setType("stopImmediatePropagation", "bool", ms);
    config.setType("if", "bool");
    config.setType("passive", "bool");
    config.setType("not", "string", ms);
    config.eachProperty(function (k) {
      if (k === 'value' || k.indexOf('value.') === 0) {
        config.setMode(k, MetaphorJs.lib.Config.MODE_FUNC);
      }
    });
    return config;
  };

  const createHandler = function (name, state, node, config) {
    return new MetaphorJs.lib.EventHandler(name, state, node, prepareConfig(config));
  };

  const getNode = function (node, config, directive, cb) {
    Directive.resolveNode(node, directive, function (node, cmp) {
      if (cmp) {
        config.setProperty("targetComponent", {
          mode: MetaphorJs.lib.Config.MODE_STATIC,
          value: cmp
        });
      }

      cb(node);
    });
  };

  for (i = 0, len = events.length; i < len; i++) {
    (function (name) {
      var dir = function (state, node, config, renderer, attrSet) {
        var eh,
            destroyed = false,
            rs = window.document.readyState,
            init = function (node) {
          if (!destroyed) {
            eh = createHandler(name, state, node, config);
          }
        };

        if (rs === "complete" || rs === undefined) {
          getNode(node, config, name, init);
        } else MetaphorJs.dom.addListener(window, "load", function () {
          getNode(node, config, name, init);
        });

        return function () {
          destroyed = true;

          if (eh) {
            eh.$destroy();
            eh = null;
          }
        };
      };

      dir.initConfig = function (config, instance) {
        prepareConfig(config);
      };

      Directive.registerAttribute(name, 1000, dir);
    })(events[i]);
  }

  const dir = function (state, node, config) {
    prepareConfig(config);

    var fn = config.get("value"),
        handler = function () {
      fn(state);
      config.checkState("value");
    },
        resolvedNode,
        init = function (node) {
      if (handler) {
        resolvedNode = node;
        MetaphorJs.lib.Input.get(node).onKey(13, handler);
      }
    };

    if (window.document.readyState === "complete") {
      getNode(node, config, "submit", init);
    }

    MetaphorJs.dom.addListener(window, "load", function () {
      getNode(node, config, "submit", init);
    });
    return function () {
      if (resolvedNode) {
        MetaphorJs.lib.Input.get(resolvedNode).unKey(13, handler);
      }

      handler = null;
      fn = null;
    };
  };

  dir.initConfig = prepareConfig;
  Directive.registerAttribute("submit", 1000, dir);
})();

/***/ }),

/***/ "../metaphorjs/src/directive/attr/focused.js":
/*!***************************************************!*\
  !*** ../metaphorjs/src/directive/attr/focused.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! ../../func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("focused", 600, Directive.$extend({
  $class: "MetaphorJs.app.Directive.attr.InFocus",
  id: "focused",
  initChange: function () {},
  initDirective: function () {
    this.focusDelegate = bind(this.onInputFocus, this);
    this.blurDelegate = bind(this.onInputBlur, this);
    MetaphorJs.dom.addListener(this.node, "focus", this.focusDelegate);
    MetaphorJs.dom.addListener(this.node, "blur", this.blurDelegate);
  },
  onInputFocus: function () {
    this.config.get("value")(this.state, true);
    this.state.$check();
  },
  onInputBlur: function () {
    this.config.get("value")(this.state, false);
    this.state.$check();
  },
  onDestroy: function () {
    MetaphorJs.dom.removeListener(this.node, "focus", this.focusDelegate);
    MetaphorJs.dom.removeListener(this.node, "blur", this.blurDelegate);
    this.$super();
  }
}, {
  initConfig: function (config) {
    config.setMode("value", MetaphorJs.lib.Config.MODE_SETTER);
  }
}));

/***/ }),

/***/ "../metaphorjs/src/directive/attr/hide.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/directive/attr/hide.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./show.js */ "../metaphorjs/src/directive/attr/show.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js");

Directive.registerAttribute("hide", 500, Directive.attr.Show.$extend({
  $class: "MetaphorJs.app.Directive.attr.Hide",
  id: "hide",
  onStateChange: function (val) {
    var self = this;
    self.runAnimation(!val);
    self._initial = false;
    self.saveStateOnChange(val);
  }
}));

/***/ }),

/***/ "../metaphorjs/src/directive/attr/if.js":
/*!**********************************************!*\
  !*** ../metaphorjs/src/directive/attr/if.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-animate/src/animate/animate.js */ "../metaphorjs-animate/src/animate/animate.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      raf = __webpack_require__(/*! metaphorjs-animate/src/func/raf.js */ "../metaphorjs-animate/src/func/raf.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("if", 500, Directive.$extend({
  $class: "MetaphorJs.app.Directive.attr.If",
  id: "if",
  _initial: true,
  initDirective: function () {
    this.createCommentWrap(this.node, "if");
    this.$super();
  },
  onStateChange: function () {
    var self = this,
        config = self.config,
        val = config.get("value"),
        node = self.node,
        initial = self._initial,
        show = function () {
      self.wrapperClose.parentNode.insertBefore(node, self.wrapperClose);

      if (!initial) {
        raf(self.trigger, self, ["show", node]);
      }
    },
        hide = function () {
      node.parentNode.removeChild(node);

      if (!initial) {
        raf(self.trigger, self, ["hide", node]);
      }
    };

    if (val) {
      initial || !self.config.get("animate") ? initial ? show() : raf(show) : MetaphorJs.animate.animate(node, "enter", show);
    } else {
      if (node.parentNode) {
        initial || !self.config.get("animate") ? initial ? hide() : raf(hide) : MetaphorJs.animate.animate(node, "leave").done(hide);
      }
    }

    self.$super(val);

    if (self._initial) {
      self._initial = false;
    } else {
      if (self.config.get("once")) {
        self.$destroy();
      }
    }
  }
}, {
  initConfig: function (config) {
    config.setType("animate", "bool", MetaphorJs.lib.Config.MODE_STATIC);
    config.setType("value", "bool");
    config.setType("once", "bool", MetaphorJs.lib.Config.MODE_STATIC);
  }
}));

/***/ }),

/***/ "../metaphorjs/src/directive/attr/include.js":
/*!***************************************************!*\
  !*** ../metaphorjs/src/directive/attr/include.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../app/Template.js */ "../metaphorjs/src/app/Template.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("include", 1100, function () {
  const dir = function include_directive(state, node, config, renderer, attrSet) {
    if (!(node instanceof window.Node)) {
      throw new Error("'include' directive can only work with Node");
    }

    config.disableProperty("value");
    config.setProperty("name", config.getProperty("value"));
    config.removeProperty("value");
    config.enableProperty("name");
    config.set("passReferences", true);
    dir.initConfig(config);
    var tpl = new MetaphorJs.app.Template({
      state: state,
      attachTo: node,
      parentRenderer: renderer,
      config: config
    });
    renderer.on("destroy", function () {
      tpl.$destroy();
      tpl = null;
    });
    renderer.flowControl("ignoreInside", true);
  };

  dir.initConfig = function (config) {
    config.setType("asis", "bool", MetaphorJs.lib.Config.MODE_STATIC);
    config.setDefaultValue("runRenderer", !config.get("asis"));
  };

  dir.deepInitConfig = function (config) {
    MetaphorJs.app.Template.initConfig(config);
  };

  return dir;
}());

/***/ }),

/***/ "../metaphorjs/src/directive/attr/init.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/directive/attr/init.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("init", 250, function () {
  const initDir = function (state, node, config) {
    initDir.initConfig(config);
    config.eachProperty(function (k, prop) {
      if (k === 'value' || k.indexOf('value.') === 0) {
        var fn = config.get(k);
        fn && fn(state);
      }
    });
    config.clear();
  };

  initDir.initConfig = function (config) {
    var mf = MetaphorJs.lib.Config.MODE_FUNC;
    config.eachProperty(function (k, prop) {
      if (k === 'value' || k.indexOf('value.') === 0) {
        config.setDefaultMode(k, mf);
      }
    });
  };

  return initDir;
}());

/***/ }),

/***/ "../metaphorjs/src/directive/attr/input.js":
/*!*************************************************!*\
  !*** ../metaphorjs/src/directive/attr/input.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../lib/State.js */ "../metaphorjs/src/lib/State.js");

__webpack_require__(/*! ../../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ../../lib/MutationObserver.js */ "../metaphorjs/src/lib/MutationObserver.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../../func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! ../../func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("input", 1000, Directive.$extend({
  $class: "MetaphorJs.app.Directive.attr.Model",
  id: "input",
  _apis: ["node", "input"],
  _inProg: false,
  _prev: null,
  initDirective: function () {
    var self = this;
    self.input.onChange(self.onInputChange, self);
    self._prev = self.input.getValue();
    self.$super();
  },
  initChange: emptyFn,
  onOptionsChange: function () {
    this.onStateChange();
  },
  onInputChange: function (val) {
    const self = this,
          state = self.state,
          config = self.config;

    if (config.has("if") && !config.get("if")) {
      return;
    }

    if (self._prev == val || self._inProg) {
      return;
    }

    self._inProg = true;
    var fn = config.get("value");
    state.$prev = self._prev;
    state.$value = val;
    fn(state);
    state.$prev = null;
    state.$value = null;
    config.checkState("value");
    self._prev = val;
    self._inProg = false;
  },
  onDestroy: function () {
    var self = this;
    self.input.unChange(self.onInputChange, self);
    self.input.$destroy();
    self.input = null;
    self.$super();
  }
}, {
  initConfig: function (config) {
    config.setType("if", "bool");
    config.setMode("value", MetaphorJs.lib.Config.MODE_FUNC);
  },
  $prebuild: {
    skip: true
  }
}));

/***/ }),

/***/ "../metaphorjs/src/directive/attr/key.js":
/*!***********************************************!*\
  !*** ../metaphorjs/src/directive/attr/key.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ../../lib/Input.js */ "../metaphorjs/src/lib/Input.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../../func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! ../../func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

(function () {
  const keys = {
    "enter": 13,
    "esc": 27,
    "escape": 27,
    "backspace": 8,
    "tab": 9,
    "shift": 16,
    "ctrl": 17,
    "alt": 18,
    "pause": 19,
    "caps": 20,
    "space": 32,
    "pageup": 33,
    "pagedown": 34,
    "end": 35,
    "home": 36,
    "left": 37,
    "up": 38,
    "right": 39,
    "down": 40,
    "insert": 45,
    "delete": 46,
    "0": 48,
    "1": 49,
    "2": 50,
    "3": 51,
    "4": 52,
    "5": 53,
    "6": 54,
    "7": 55,
    "8": 56,
    "9": 57,
    "a": 65,
    "b": 66,
    "c": 67,
    "d": 68,
    "e": 69,
    "f": 70,
    "g": 71,
    "h": 72,
    "i": 73,
    "j": 74,
    "k": 75,
    "l": 76,
    "m": 77,
    "n": 78,
    "o": 79,
    "p": 80,
    "q": 81,
    "r": 82,
    "s": 83,
    "t": 84,
    "u": 85,
    "v": 86,
    "w": 87,
    "x": 88,
    "y": 89,
    "z": 90,
    "f1": 112,
    "f2": 113,
    "f3": 114,
    "f4": 115,
    "f5": 116,
    "f6": 117,
    "f7": 118,
    "f8": 119,
    "f9": 120,
    "f10": 121,
    "f11": 122,
    "f12": 123,
    "leftwin": 91,
    "rightwin": 92,
    "select": 93,
    "num0": 96,
    "num1": 97,
    "num2": 98,
    "num3": 99,
    "num4": 100,
    "num5": 101,
    "num6": 102,
    "num7": 103,
    "num8": 104,
    "num9": 105,
    "*": 106,
    "multiply": 106,
    "+": 107,
    "add": 107,
    "-": 109,
    "subtract": 109,
    "decimal": 110,
    "/": 111,
    "divide": 111,
    "numlock": 144,
    "scrolllock": 145,
    "semicolon": 186,
    "equal": 187,
    "comma": 188,
    "dash": 189,
    "period": 190,
    "forwardslash": 191,
    "graveaccent": 192,
    "openbracket": 219,
    "backslash": 220,
    "closebracket": 221,
    "quote": 222
  };
  /*
  value is always an array in the end:
  [{keyCode: 1, handler: fn}, {...}]
  
  DO NOT MIX {key}="{...}" with  {key.enter}="{...}"
  
  NO:
  {key}="{...}"
  {key.enter}="{...}"
  
  YES:
  {key}="{...}"
  
  or
  
  {key}="[{...}]"
  {key.enter}="{...}"
  
   */

  const getNode = function (node, config, cb) {
    Directive.resolveNode(node, "key", function (node, cmp) {
      if (cmp) {
        config.setProperty("targetComponent", {
          mode: MetaphorJs.lib.Config.MODE_STATIC,
          value: cmp
        });
      }

      cb(node);
    });
  };

  const dir = function key_directive(state, node, config, renderer, attrSet) {
    dir.initConfig(config);

    var createHandler = function (node, name, cfg) {
      if (typeof cfg === "function") {
        cfg = {
          handler: cfg
        };
      }

      var h = cfg.handler;
      var context = cfg.context || state;
      delete cfg.handler;
      delete cfg.context;

      if (!cfg.keyCode) {
        cfg.keyCode = keys[name] || parseInt(name, 10);
      }

      var handler = function (e) {
        state.$event = e;
        state.$eventCmp = config.get("targetComponent");
        h(state);
        state.$event = null;
        state.$eventCmp = null;
        state.$check();
      };

      MetaphorJs.lib.Input.get(node).onKey(cfg, handler, context);
      return function () {
        MetaphorJs.lib.Input.get(node).unKey(cfg, handler, context);
      };
    };

    var cfgs = config.getAllValues(),
        name,
        uninstall = [],
        init = function (node) {
      if (cfgs) {
        for (name in cfgs) {
          if (cfgs.hasOwnProperty(name) && cfgs[name]) {
            uninstall.push(createHandler(node, name, cfgs[name]));
          }
        }
      }
    };

    if (window.document.readyState === "complete") {
      getNode(node, config, init);
    }

    MetaphorJs.dom.addListener(window, "load", function () {
      getNode(node, config, init);
    });
    return function () {
      var i, l;

      for (i = 0, l = uninstall.length; i < l; i++) {
        uninstall[i]();
      }

      uninstall = null;
    };
  };

  dir.initConfig = function (config) {
    config.disableProperty("value");
    config.eachProperty(function (k, prop) {
      if (k.indexOf('value.') === 0) {
        if (prop.expression.charAt(0) !== '{') {
          config.setMode(k, MetaphorJs.lib.Config.MODE_FUNC);
        }
      }
    });
  };

  Directive.registerAttribute("key", 1000, dir);
})();

/***/ }),

/***/ "../metaphorjs/src/directive/attr/model.js":
/*!*************************************************!*\
  !*** ../metaphorjs/src/directive/attr/model.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../lib/State.js */ "../metaphorjs/src/lib/State.js");

__webpack_require__(/*! ../../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ../../lib/MutationObserver.js */ "../metaphorjs/src/lib/MutationObserver.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../../func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! ../../func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

const async = __webpack_require__(/*! metaphorjs-shared/src/func/async.js */ "../metaphorjs-shared/src/func/async.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      isIE = __webpack_require__(/*! ../../func/browser/isIE.js */ "../metaphorjs/src/func/browser/isIE.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("model", 1000, Directive.$extend({
  $class: "MetaphorJs.app.Directive.attr.Model",
  id: "model",
  _apis: ["node", "input"],
  _binding: null,
  _inProg: false,
  initDirective: function () {
    var self = this,
        expr = self.config.getExpression("value");
    self.mo = MetaphorJs.lib.MutationObserver.get(self.state, expr, null, null, {
      setter: true
    });
    self.mo.subscribe(self.onStateChange, self);
    self.input.onChange(self.onInputChange, self);
    self.optionsChangeDelegate = bind(self.onOptionsChange, self);
    MetaphorJs.dom.addListener(self.node, "optionschange", self.optionsChangeDelegate);
    self.$super();
    var inputValue = self.input.getValue(),
        stateValue = self.mo.getValue(),
        binding = self.config.get("binding");

    if (stateValue !== inputValue) {
      // state value takes priority
      if (binding !== "input" && stateValue !== undefined) {
        self.onStateChange(stateValue);
      } else if (binding !== "state" && inputValue !== undefined) {
        self.onInputChange(inputValue);
      }
    }
  },
  initChange: emptyFn,
  onOptionsChange: function () {
    this.onStateChange();
  },
  onInputChange: function (val) {
    var self = this,
        config = self.config,
        binding = self._binding || config.get("binding");

    if (binding !== "state") {
      if (config.has("if") && !config.get("if")) {
        return;
      }

      if (val && isString(val) && val.indexOf('\\{') !== -1) {
        val = val.replace(/\\{/g, '{');
      }

      if (self.mo.getValue() == val) {
        return;
      }

      self.mo.setValue(val);
      self._inProg = true;
      self.config.checkState("value");
      self._inProg = false;
      self.saveStateOnChange(val);
    }
  },
  onStateChange: function () {
    var self = this,
        config = self.config,
        val = self.mo.getValue(),
        binding = self._binding || config.get("binding"),
        ie;

    if (binding !== "input" && !self._inProg) {
      if (config.has("if") && !config.get("if")) {
        return;
      } // when state value changed but this field
      // is not in focus, it should try to
      // change input's value, but not react
      // to input's 'change' and 'input' events --
      // fields like select or radio may not have
      // this value in its options. that will change
      // value to undefined and bubble back to state


      if (window.document.activeElement !== self.node) {
        self._binding = "state";
      }

      if ((ie = isIE()) && ie < 8) {
        async(self.input.setValue, self.input, [val]);
      } else {
        self.input.setValue(val);
      }

      self._binding = null;
      self.saveStateOnChange(val);
    }
  },
  onDestroy: function () {
    var self = this;
    MetaphorJs.dom.removeListener(self.node, "optionschange", self.optionsChangeDelegate);
    self.input.unChange(self.onInputChange, self);
    self.input.$destroy();
    self.input = null;

    if (self.mo) {
      self.mo.unsubscribe(self.onStateChange, self);
      self.mo.$destroy(true);
    }

    self.$super();
  }
}, {
  initConfig: function (config) {
    config.setMode("value", MetaphorJs.lib.Config.MODE_FNSET);
    config.setType("if", "bool");
    config.setProperty("binding", {
      defaultValue: "both",
      defaultMode: MetaphorJs.lib.Config.MODE_STATIC
    });
  },
  $prebuild: {}
}));

/***/ }),

/***/ "../metaphorjs/src/directive/attr/options.js":
/*!***************************************************!*\
  !*** ../metaphorjs/src/directive/attr/options.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../../lib/MutationObserver.js */ "../metaphorjs/src/lib/MutationObserver.js");

__webpack_require__(/*! ../../func/dom/getInputValue.js */ "../metaphorjs/src/func/dom/getInputValue.js");

__webpack_require__(/*! ../../func/dom/setInputValue.js */ "../metaphorjs/src/func/dom/setInputValue.js");

__webpack_require__(/*! ../../func/dom/setAttr.js */ "../metaphorjs/src/func/dom/setAttr.js");

__webpack_require__(/*! ../../func/browser/isIE.js */ "../metaphorjs/src/func/browser/isIE.js");

__webpack_require__(/*! ../../func/dom/triggerEvent.js */ "../metaphorjs/src/func/dom/triggerEvent.js");

__webpack_require__(/*! ../../func/app/prebuilt.js */ "../metaphorjs/src/func/app/prebuilt.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      error = __webpack_require__(/*! metaphorjs-shared/src/func/error.js */ "../metaphorjs-shared/src/func/error.js"),
      Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("options", 100, Directive.$extend({
  $class: "MetaphorJs.app.Directive.attr.Options",
  id: "options",
  model: null,
  store: null,
  _getterFn: null,
  _defOption: null,
  _prevGroup: null,
  _groupEl: null,
  _fragment: null,
  _initial: false,
  $init: function (state, node, config, renderer, attrSet) {
    if (!(node instanceof window.HTMLSelectElement)) {
      throw new Error("'options' directive can only work with <select>");
    }

    this.$super(state, node, config, renderer, attrSet);
  },
  initConfig: function () {
    var self = this,
        config = self.config,
        expr;
    config.disableProperty("value");
    expr = config.getExpression("value");
    config.on("placeholderName", self.onPlaceholderChange, self);
    config.on("placeholderValue", self.onPlaceholderChange, self);
    self.parseExpr(expr);
    self.$super();
  },
  initDirective: function () {
    var self = this,
        node = self.node;
    self._defOption = node.options.length ? node.options[0] : null;

    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }

    if (self.config.get("keepDefault")) {
      self._defOption && MetaphorJs.dom.setAttr(self._defOption, "default-option", "");
    } else self._defOption = null;

    try {
      var value = MetaphorJs.lib.Expression.get(self.model, self.state);

      if (cls.isInstanceOf(value, "MetaphorJs.model.Store")) {
        self.bindStore(value, "on");
      } else {
        self.watcher = MetaphorJs.lib.MutationObserver.get(self.state, self.model, self.onStateChange, self);
      }
    } catch (thrownError) {
      error(thrownError);
    }

    if (self.watcher) {
      self.renderAll();
    } else if (self.store) {
      self.renderStore();
    }
  },
  bindStore: function (store, mode) {
    var self = this;
    store[mode]("update", self.renderStore, self);
    self.store = store;
  },
  getSourceList: function () {
    return this.store ? this.store.toArray() : toArray(this.watcher.getValue());
  },
  renderStore: function () {
    var self = this;
    self.render(this.getSourceList());
    self.dispatchOptionsChange();
  },
  renderAll: function () {
    this.render(this.getSourceList());
    this.dispatchOptionsChange();
  },
  onStateChange: function () {
    var self = this;
    self.renderAll();
  },
  onPlaceholderChange: function () {
    var list = this.getSourceList();

    if (!list || list.length === 0) {
      this.render(list);
    }
  },
  dispatchOptionsChange: function () {
    var self = this;

    if (!self._initial && self.node.dispatchEvent) {
      MetaphorJs.dom.triggerEvent(self.node, "optionschange");
    }

    self._initial = false;
  },
  renderOption: function (item, index, state) {
    var self = this,
        parent = self._groupEl || self._fragment,
        msie = MetaphorJs.browser.isIE(),
        config,
        option;
    state.item = item;
    state.$index = index;
    config = self._getterFn(state);
    config.group !== undefined && (config.group = "" + config.group);

    if (config.group !== self.prevGroup) {
      if (config.group) {
        self._groupEl = parent = window.document.createElement("optgroup");
        MetaphorJs.dom.setAttr(parent, "label", config.group);

        if (config.disabledGroup) {
          MetaphorJs.dom.setAttr(parent, "disabled", "disabled");
        }

        self._fragment.appendChild(parent);
      } else {
        parent = self._fragment;
        self._groupEl = null;
      }
    }

    self._prevGroup = config.group;
    option = window.document.createElement("option");
    MetaphorJs.dom.setAttr(option, "value", "" + config.value || "");
    option.text = config.name || "" + config.value || "";

    if (msie && msie < 9) {
      option.innerHTML = config.name || "" + config.value || "";
    }

    if (config.disabled) {
      MetaphorJs.dom.setAttr(option, "disabled", "disabled");
    }

    parent.appendChild(option);
  },
  render: function (list) {
    var self = this,
        node = self.node,
        value = MetaphorJs.dom.getInputValue(node),
        def = self._defOption,
        tmpState = self.state.$new(),
        msie = MetaphorJs.browser.isIE(),
        phValue = self.config.get("placeholderValue"),
        phName = self.config.get("placeholderName") || phValue,
        parent,
        next,
        i,
        len,
        ph;
    self._fragment = window.document.createDocumentFragment();
    self.prevGroup = null;
    self.groupEl = null;

    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }

    for (i = 0, len = list.length; i < len; i++) {
      self.renderOption(list[i], i, tmpState);
    }

    if (def) {
      node.insertBefore(def, node.firstChild);
    }

    if (phValue && !len && !def) {
      ph = document.createElement("option");
      ph.value = phValue;
      ph.text = phName;
      node.insertBefore(ph, node.firstChild);
    }

    tmpState.$destroy(); // ie6 gives "unspecified error when trying to set option.selected"
    // on node.appendChild(fragment);
    // somehow this get fixed by detaching dom node
    // and attaching it back

    if (msie && msie < 8) {
      next = node.nextSibling;
      parent = node.parentNode;
      parent.removeChild(node);
    }

    node.appendChild(self._fragment);
    self._fragment = null;

    if (msie && msie < 8) {
      parent.insertBefore(node, next);
    }

    MetaphorJs.dom.setInputValue(node, value);
  },
  parseExpr: function (expr) {
    var parts = this.$self.splitExpression(expr);
    this.model = parts.model;

    if (parts.item) {
      this._getterFn = typeof parts.item === "function" ? parts.item : MetaphorJs.lib.Expression.getter(parts.item);
    }
  },
  onDestroy: function () {
    var self = this;

    if (self.store) {
      self.bindStore(self.store, "un");
    }

    if (self.watcher) {
      self.watcher.unsubscribe(self.onStateChange, self);
      self.watcher.$destroy(true);
    }

    self.$super();
  }
}, {
  splitExpression: function (expr) {
    var model, item, splitIndex;

    if (MetaphorJs.app.prebuilt.isKey(expr)) {
      var pb = MetaphorJs.app.prebuilt.get("config", expr);
      model = pb; //item = MetaphorJs.app.prebuilt.get("func", pb.inflate.item);

      item = pb.inflate.item;
    } else {
      splitIndex = expr.indexOf(" in ");

      if (splitIndex === -1) {
        model = expr;
        item = '{name: this.item, value: this.$index}';
      } else {
        model = expr.substr(splitIndex + 4);
        item = expr.substr(0, splitIndex);
      }
    }

    return {
      model: model,
      item: item
    };
  },
  initConfig: function (config) {
    config.setType("keepDefault", "bool", MetaphorJs.lib.Config.MODE_STATIC, true);
  },
  deepInitConfig: function (config) {
    var prop = config.getProperty("value");
    parts = this.splitExpression(prop.expression);
    prop.expression = parts.model;
    prop.inflate = prop.inflate || {};
    prop.inflate.item = MetaphorJs.lib.Expression.expression(parts.item);
  }
}));

/***/ }),

/***/ "../metaphorjs/src/directive/attr/properties.js":
/*!******************************************************!*\
  !*** ../metaphorjs/src/directive/attr/properties.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../func/dom/removeAttr.js */ "../metaphorjs/src/func/dom/removeAttr.js");

__webpack_require__(/*! ../../func/dom/setAttr.js */ "../metaphorjs/src/func/dom/setAttr.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

(function () {
  const booleanAttrs = ["selected", "checked", "disabled", "readonly", "open", "required"];
  let i, l;
  const PropertyDirective = Directive.$extend({
    $init: function (name, state, node, config, renderer, attrSet) {
      this.id = name;
      this.$super(state, node, config, renderer, attrSet);
    },
    onStateChange: function (val) {
      var name = this.id;
      val = !!val;

      if (val) {
        MetaphorJs.dom.setAttr(this.node, name, name);
      } else {
        MetaphorJs.dom.removeAttr(this.node, name);
      }
    }
  }, {
    initConfig: function (config) {
      config.setType("value", "bool");
    }
  });

  for (i = 0, l = booleanAttrs.length; i < l; i++) {
    (function (name) {
      var dir = function (state, node, config, renderer, attrSet) {
        return new PropertyDirective(name, state, node, config, renderer, attrSet);
      };

      dir.initConfig = PropertyDirective.initConfig;
      Directive.registerAttribute("" + name, 1000, dir);
    })(booleanAttrs[i]);
  }
})();

/***/ }),

/***/ "../metaphorjs/src/directive/attr/router.js":
/*!**************************************************!*\
  !*** ../metaphorjs/src/directive/attr/router.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js");

__webpack_require__(/*! ../../func/app/resolve.js */ "../metaphorjs/src/func/app/resolve.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

MetaphorJs.app.Directive.registerAttribute("router", 200, function () {
  const dir = function router_directive(state, node, config, renderer, attrSet) {
    dir.initConfig(config);
    var routes = [],
        r;
    config.eachProperty(function (k) {
      if (k.indexOf("value.") === 0) {
        r = config.get(k);
        r['id'] = k.replace('value.', '');
        routes.push(r);
      }
    });
    MetaphorJs.app.Directive.resolveNode(node, "router", function (node) {
      if (!renderer.$destroyed) {
        const cfg = {
          state,
          node,
          config
        };

        if (routes.length !== 0) {
          cfg['route'] = routes;
        }

        MetaphorJs.app.resolve(config.get("value"), cfg, node, [cfg]).done(function (view) {
          if (renderer.$destroyed || state.$$destroyed) {
            view.$destroy();
          } else {
            renderer.on("destroy", view.$destroy, view);
            state.$on("destroy", view.$destroy, view);
          }
        });
      }
    });
    renderer.flowControl("ignoreInside", true);
  };

  dir.initConfig = function (config) {
    var ms = MetaphorJs.lib.Config.MODE_STATIC;
    config.setDefaultMode("state", ms);
    config.setDefaultMode("id", ms);
    config.setProperty("value", {
      defaultMode: ms,
      defaultValue: "MetaphorJs.app.view.Router"
    });
    config.eachProperty(function (k) {
      if (k.indexOf("value.") === 0) {
        config.setDefaultMode(k, MetaphorJs.lib.Config.MODE_SINGLE);
      }
    });
  };

  return dir;
}());

/***/ }),

/***/ "../metaphorjs/src/directive/attr/show.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/directive/attr/show.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/animate.js */ "../metaphorjs-animate/src/animate/animate.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const raf = __webpack_require__(/*! metaphorjs-animate/src/func/raf.js */ "../metaphorjs-animate/src/func/raf.js"),
      Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("show", 500, Directive.$extend({
  $class: "MetaphorJs.app.Directive.attr.Show",
  id: "show",
  _initial: true,
  runAnimation: function (show) {
    var self = this,
        style = self.node.style,
        initial = this._initial,
        done = function () {
      if (!show) {
        style.display = "none";
      } else {
        style.display = self.config.get("display");
      }

      if (!initial) {
        self.trigger(show ? "show" : "hide", self.node);
      }
    };

    initial || !self.config.get("animate") ? initial ? done() : raf(done) : MetaphorJs.animate.animate(self.node, show ? "show" : "hide", function () {
      if (show) {
        return new MetaphorJs.lib.Promise(function (resolve) {
          raf(function () {
            style.display = self.config.get("display");
            resolve();
          });
        });
      }
    }).done(done);
  },
  onStateChange: function (val) {
    var self = this;
    self.runAnimation(val);
    self._initial = false;
    self.$super(val);
  }
}, {
  initConfig: function (config) {
    config.setType("display", "string", MetaphorJs.lib.Config.MODE_STATIC, "");
    config.setType("animate", "bool", MetaphorJs.lib.Config.MODE_STATIC, false);
  }
}));

/***/ }),

/***/ "../metaphorjs/src/directive/attr/source-src.js":
/*!******************************************************!*\
  !*** ../metaphorjs/src/directive/attr/source-src.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../func/dom/select.js */ "../metaphorjs/src/func/dom/select.js");

__webpack_require__(/*! ../../func/dom/setAttr.js */ "../metaphorjs/src/func/dom/setAttr.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("source-src", 1000, Directive.$extend({
  $class: "MetaphorJs.app.Directive.attr.SourceSrc",
  id: "source-src",
  usePreload: true,
  attr: null,
  lastPromise: null,
  src: null,
  $constructor: function (state, node, config, renderer, attrSet) {
    var self = this;
    self.$self.initConfig(config);

    if (config.get("deferred")) {
      self.$plugins.push("plugin.SrcDeferred");
    }

    if (config.get("plugin")) {
      var tmp = config.get("plugin").split(","),
          i,
          l;

      for (i = 0, l = tmp.length; i < l; i++) {
        self.$plugins.push(tmp[i].trim());
      }
    }

    self.$super(state, node, config, renderer, attrSet);
  },
  initConfig: function () {},
  onStateChange: function () {
    this.doChange();
  },
  doChange: function () {
    var self = this;

    if (self.$destroyed || self.$destroying) {
      return;
    }

    var src = self.config.get("value");

    if (!src) {
      return;
    }

    self.src = src;

    if (self.config.get("noCache")) {
      src += (src.indexOf("?") !== -1 ? "&amp;" : "?") + "_" + new Date().getTime();
    }

    self.doChangeSource(src);
    self.onSrcChanged();
  },
  doChangeSource: function (src) {
    var self = this,
        node = self.node,
        srcs = MetaphorJs.dom.select("source", node),
        source = window.document.createElement("source"),
        i,
        l;

    if (srcs.length) {
      for (i = 0, l = srcs.length; i < l; i++) {
        node.removeChild(srcs[i]);
      }
    }

    MetaphorJs.dom.setAttr(source, "src", src);
    node.appendChild(source);
  },
  onSrcChanged: function () {}
}, {
  initConfig: function (config) {
    var ms = MetaphorJs.lib.Config.MODE_STATIC;
    config.setType("deferred", "bool", ms);
    config.setType("noCache", "bool", ms);
    config.setDefaultMode("plugin", ms);
  }
}));

/***/ }),

/***/ "../metaphorjs/src/directive/attr/src.js":
/*!***********************************************!*\
  !*** ../metaphorjs/src/directive/attr/src.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-shared/src/lib/Queue.js */ "../metaphorjs-shared/src/lib/Queue.js");

__webpack_require__(/*! ../../func/dom/preloadImage.js */ "../metaphorjs/src/func/dom/preloadImage.js");

__webpack_require__(/*! ../../func/dom/setAttr.js */ "../metaphorjs/src/func/dom/setAttr.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const raf = __webpack_require__(/*! metaphorjs-animate/src/func/raf.js */ "../metaphorjs-animate/src/func/raf.js"),
      Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("src", 1000, Directive.$extend({
  $class: "MetaphorJs.app.Directive.attr.Src",
  queue: null,
  usePreload: true,
  noCache: false,
  attr: null,
  lastPromise: null,
  src: null,
  $constructor: function (state, node, config, renderer, attrSet) {
    var self = this;
    self.$self.initConfig(config);

    if (config.get("deferred")) {
      self.$plugins.push("MetaphorJs.plugin.SrcDeferred");
    }

    if (config.get("preloadSize")) {
      self.$plugins.push("MetaphorJs.plugin.SrcSize");
    }

    if (config.get("plugin")) {
      var tmp = config.get("plugin").split(","),
          i,
          l;

      for (i = 0, l = tmp.length; i < l; i++) {
        self.$plugins.push(tmp[i].trim());
      }
    }

    self.$super(state, node, config);
  },
  initDirective: function (state, node, config, renderer, attrSet) {
    var self = this;
    self.usePreload = !config.get("noPreload");

    if (self.usePreload) {
      node.style.visibility = "hidden";
    }

    self.queue = new MetaphorJs.lib.Queue({
      auto: true,
      async: true,
      mode: MetaphorJs.lib.Queue.REPLACE,
      thenable: true
    });
    self.$super(state, node, config, renderer, attrSet);
  },
  onStateChange: function () {
    var self = this;
    self.cancelPrevious();

    if (self.usePreload) {
      self.node.style.visibility = "hidden";
    }

    self.queue.add(self.doChange, self);
  },
  doChange: function () {
    var self = this;

    if (self.$destroyed || self.$destroying) {
      return;
    }

    var src = self.config.get("value");

    if (!src) {
      return;
    }

    self.src = src;

    if (self.config.get("noCache")) {
      src += (src.indexOf("?") !== -1 ? "&amp;" : "?") + "_" + new Date().getTime();
    }

    if (self.usePreload) {
      self.lastPromise = MetaphorJs.dom.preloadImage(src);

      if (self.lastPromise) {
        self.lastPromise.done(self.onImagePreloaded, self);
      }
    } else {
      if (self.node) {
        self.node.src = src;
        MetaphorJs.dom.setAttr(self.node, "src", src);
        self.onSrcChanged();
      }
    }
  },
  cancelPrevious: function () {
    var self = this;

    if (self.lastPromise) {
      if (self.lastPromise.isPending()) {
        self.lastPromise.abort();
      }

      self.lastPromise = null;
    }
  },
  onImagePreloaded: function () {
    var self = this,
        src = self.src;

    if (self && self.node) {
      raf(function () {
        if (self.node) {
          self.node.src = src;
          MetaphorJs.dom.setAttr(self.node, "src", src);
          self.onSrcChanged();
          self.node.style.visibility = "";
          self.state.$scheduleCheck(50);
        }
      });
    }

    self.lastPromise = null;
  },
  onSrcChanged: function () {},
  onStateReset: function () {
    this.cancelPrevious();
    this.$super();
  },
  onDestroy: function () {
    var self = this;

    if (!self.$destroyed) {
      self.cancelPrevious();
      self.queue.$destroy();
      self.$super();
    }
  }
}, {
  initConfig: function (config) {
    var ms = MetaphorJs.lib.Config.MODE_STATIC;
    config.setType("deferred", "bool", ms);
    config.setType("noCache", "bool", ms);
    config.setType("noPreload", "bool", ms);
    config.setDefaultMode("preloadSize", ms);
    config.setDefaultMode("plugin", ms);
  }
}));

/***/ }),

/***/ "../metaphorjs/src/directive/attr/state.js":
/*!*************************************************!*\
  !*** ../metaphorjs/src/directive/attr/state.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

__webpack_require__(/*! ../../lib/State.js */ "../metaphorjs/src/lib/State.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("state", 1000, function () {
  const dir = function state_directive(state, node, config, renderer, attrSet) {
    dir.initConfig(config);
    var newState = MetaphorJs.lib.State.$produce(config.get("value"), state);
    renderer.flowControl("newState", newState);
    config.clear();
  };

  dir.initConfig = function (config) {
    config.setDefaultMode("value", MetaphorJs.lib.Config.MODE_STATIC);
  };

  return dir;
}());

/***/ }),

/***/ "../metaphorjs/src/directive/attr/style.js":
/*!*************************************************!*\
  !*** ../metaphorjs/src/directive/attr/style.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../func/dom/removeStyle.js */ "../metaphorjs/src/func/dom/removeStyle.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      async = __webpack_require__(/*! metaphorjs-shared/src/func/async.js */ "../metaphorjs-shared/src/func/async.js"),
      toBool = __webpack_require__(/*! metaphorjs-shared/src/func/toBool.js */ "../metaphorjs-shared/src/func/toBool.js"),
      toCamelCase = __webpack_require__(/*! metaphorjs-shared/src/func/toCamelCase.js */ "../metaphorjs-shared/src/func/toCamelCase.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("style", 1000, Directive.$extend({
  $class: "MetaphorJs.app.Directive.attr.Style",
  id: "style",
  initDirective: function () {
    var self = this,
        config = self.config;
    config.on("value", self.onStateChange, self);
    config.eachProperty(function (k) {
      if (k.indexOf("value.") === 0) {
        config.on(k, self.onStateChange, self);
      }
    });
    this.$super();
  },
  initChange: function () {
    this.onStateChange();
  },
  getCurrentValue: function () {
    var style = this.config.getAllValues();

    if (style[""]) {
      extend(style, style[""]);
      delete style[''];
    }

    return style;
  },
  _applyStyle: function () {
    var self = this,
        node = self.node,
        style = node.style,
        props = self.getCurrentValue(),
        prev = self.prev,
        k,
        trg;

    for (k in prev) {
      if (!props || props[k] === undefined) {
        MetaphorJs.dom.removeStyle(node, k);
      }
    }

    if (props) {
      for (k in props) {
        trg = toCamelCase(k);

        if (props[k] !== undefined && props[k] !== null) {
          style[trg] = props[k];
        } else {
          MetaphorJs.dom.removeStyle(node, k);
        }
      }
    }

    self.prev = props;
  },
  onStateChange: function () {
    var tmt = this.config.get("async");

    if (toBool(tmt)) {
      tmt = parseInt(tmt) == tmt ? parseInt(tmt) : null;
      async(this._applyStyle, this, [], tmt);
    } else {
      this._applyStyle();
    }
  }
}, {
  initConfig: function (config, instance) {
    config.setDefaultMode("async", MetaphorJs.lib.Config.MODE_STATIC);
  }
}));

/***/ }),

/***/ "../metaphorjs/src/directive/attr/transclude.js":
/*!******************************************************!*\
  !*** ../metaphorjs/src/directive/attr/transclude.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../func/dom/transclude.js */ "../metaphorjs/src/func/dom/transclude.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerAttribute("transclude", 1000, function (state, node, config, renderer, attrSet) {
  if (!(node instanceof window.Node)) {
    throw new Error("'transclude' directive can only work with Node");
  }

  renderer.flowControl("nodes", MetaphorJs.dom.transclude(node, null, renderer.trigger("transclude-sources")));
});

/***/ }),

/***/ "../metaphorjs/src/directive/attr/view.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/directive/attr/view.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js");

__webpack_require__(/*! ../../func/app/resolve.js */ "../metaphorjs/src/func/app/resolve.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

MetaphorJs.app.Directive.registerAttribute("view", 200, function (state, node, config, renderer) {
  MetaphorJs.app.Directive.resolveNode(node, "view", function (node) {
    if (!renderer.$destroyed) {
      const cfg = {
        state,
        node,
        config
      };
      MetaphorJs.app.resolve("MetaphorJs.app.view.Component", cfg, node, [cfg]).done(function (view) {
        if (renderer.$destroyed || state.$$destroyed) {
          view.$destroy();
        } else {
          renderer.on("destroy", view.$destroy, view);
          state.$on("destroy", view.$destroy, view);
        }
      });
    }
  });
  renderer.flowControl("ignoreInside", true);
});

/***/ }),

/***/ "../metaphorjs/src/directive/tag/transclude.js":
/*!*****************************************************!*\
  !*** ../metaphorjs/src/directive/tag/transclude.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../func/dom/transclude.js */ "../metaphorjs/src/func/dom/transclude.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerTag("transclude", function (state, node, config, renderer) {
  renderer && renderer.flowControl("nodes", MetaphorJs.dom.transclude(node, true));
});

/***/ }),

/***/ "../metaphorjs/src/extra-directives/attr/break-if.js":
/*!***********************************************************!*\
  !*** ../metaphorjs/src/extra-directives/attr/break-if.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js");

Directive.registerAttribute("break-if", 500, function (state, node, config, renderer) {
  config.setType("value", "bool");
  var res = config.get("value");

  if (res) {
    node.parentNode.removeChild(node);
  }

  renderer && renderer.flowControl("stop", !!res);
});

/***/ }),

/***/ "../metaphorjs/src/extra-directives/attr/ignore.js":
/*!*********************************************************!*\
  !*** ../metaphorjs/src/extra-directives/attr/ignore.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js");

Directive.registerAttribute("ignore", 0, function (state, node, config, renderer) {
  renderer && renderer.flowControl("stop", true);
});

/***/ }),

/***/ "../metaphorjs/src/extra-directives/attr/stylesheet.js":
/*!*************************************************************!*\
  !*** ../metaphorjs/src/extra-directives/attr/stylesheet.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../directive/attr/style.js */ "../metaphorjs/src/directive/attr/style.js");

__webpack_require__(/*! ../../lib/Stylesheet.js */ "../metaphorjs/src/lib/Stylesheet.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/*
value is always an object in the end
DO NOT MIX style="{}" with style.prop="expression".
 */


Directive.registerAttribute("stylesheet", 1000, MetaphorJs.app.Directive.attr.Style.$extend({
  $class: "MetaphorJs.app.Directive.attr.Stylesheet",
  id: "stylesheet",
  initDirective: function () {
    this.styleId = "stylesheet_" + nextUid();
    this.stylesheet = new MetaphorJs.lib.Stylesheet({
      id: "for_" + this.styleId
    });
    this.stylesheet.append();
    this.$super(arguments);
  },
  getSelector: function () {
    var node = this.node;

    if (!node.id) {
      node.setAttribute("id", this.styleId);
    }

    return '#' + node.id;
  },
  escapeProperty: function (val, k) {
    val = "" + val;

    if (k === "content") {
      return '"' + val + '"';
    }

    return val;
  },
  getCssText: function () {
    var props = this.getCurrentValue(),
        selector = this.getSelector(),
        state,
        prop,
        k,
        lines = [],
        css = {
      "": [selector + " {"]
    };

    if (props) {
      for (k in props) {
        prop = k.split(".", 2);
        state = prop.length > 1 ? prop[0] || "" : "";
        prop = prop[1];

        if (!css[state]) {
          css[state] = [selector + ":" + state + " {"];
        }

        css[state].push(prop + ": " + this.escapeProperty(props[k], prop) + ";");
      }
    }

    for (state in css) {
      css[state].push("}");
      lines.push(css[state].join("\n"));
    }

    return lines.join("\n");
  },
  onStateChange: function () {
    this.stylesheet.setContent(this.getCssText());
  },
  onDestroy: function () {
    this.stylesheet.$destroy();
    this.$super();
  }
}));

/***/ }),

/***/ "../metaphorjs/src/extra-directives/attr/update-on.js":
/*!************************************************************!*\
  !*** ../metaphorjs/src/extra-directives/attr/update-on.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

const Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js");
/*
    Update state on given event.
    Not exactly template's business, but still
*/


Directive.registerAttribute("update-on", 1000, function (state, node, config, renderer, attrSet) {
  var toggle = function (mode) {
    config.eachProperty(function (k) {
      if (k.indexOf("value.") === 0) {
        var event = k.replace('value.', ''),
            obj = config.get(k);

        if (obj.$destroyed || obj.$destroying) {
          return;
        }

        if (obj && (fn = obj[mode] || obj['$' + mode])) {
          fn.call(obj, event, state.$check, state);
        }
      }
    });
  };

  toggle("on");
  return function () {
    if (toggle) {
      toggle("un");
      cfgs = null;
      toggle = null;
    }
  };
});

/***/ }),

/***/ "../metaphorjs/src/extra-directives/tag/bind-html.js":
/*!***********************************************************!*\
  !*** ../metaphorjs/src/extra-directives/tag/bind-html.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../func/dom/toFragment.js */ "../metaphorjs/src/func/dom/toFragment.js");

__webpack_require__(/*! ../../func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ../../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

var Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
    toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
    MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerTag("bind-html", function (state, node, config, renderer) {
  var expr = MetaphorJs.dom.getAttr(node, "value"),
      text = MetaphorJs.lib.Expression.get(expr, state),
      frg = MetaphorJs.dom.toFragment(text),
      nodes = toArray(frg.childNodes);
  node.parentNode.replaceChild(node, frg);
  renderer && renderer.flowControl("nodes", nodes);
});

/***/ }),

/***/ "../metaphorjs/src/extra-directives/tag/bind.js":
/*!******************************************************!*\
  !*** ../metaphorjs/src/extra-directives/tag/bind.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ../../func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

var Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
    MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerTag("bind", function (state, node, config, renderer) {
  var expr = MetaphorJs.dom.getAttr(node, "value"),
      text = MetaphorJs.lib.Expression.get(expr, state),
      frg = window.document.createTextNode(text);
  node.parentNode.replaceChild(node, frg);
  renderer && renderer.flowControl("nodes", [frg]);
});

/***/ }),

/***/ "../metaphorjs/src/extra-directives/tag/if.js":
/*!****************************************************!*\
  !*** ../metaphorjs/src/extra-directives/tag/if.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../func/dom/toFragment.js */ "../metaphorjs/src/func/dom/toFragment.js");

__webpack_require__(/*! ../../func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

var Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
    toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
    MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerTag("if", Directive.attr.If.$extend({
  $class: "MetaphorJs.app.Directive.tag.If",
  _autoOnChange: false,
  children: null,
  childrenFrag: null,
  initDirective: function (state, node, config, renderer, attrSet) {
    var self = this;
    self.children = toArray(node.childNodes);
    self.childrenFrag = MetaphorJs.dom.toFragment(self.children);
    renderer && renderer.flowControl("nodes", self.children);
    self.createCommentWrap();
    self.$super(state, node, config, renderer, attrSet);

    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  },
  initConfig: function () {
    this.config.setProperty("value", {
      expression: MetaphorJs.dom.getAttr(this.node, "value")
    });
    this.$super();
  },
  onStateChange: function () {
    var self = this,
        val = self.config.get("value"),
        prev = self.wrapperOpen,
        next = self.wrapperClose,
        parent = prev.parentNode;

    if (val) {
      parent.insertBefore(self.childrenFrag, next);
    } else if (!self.initial) {
      var children = [],
          sib;
      self.childrenFrag = window.document.createDocumentFragment();

      while (prev.nextSibling && prev.nextSibling !== next) {
        sib = prev.nextSibling;
        parent.removeChild(sib);
        children.push(sib);
        self.childrenFrag.appendChild(sib);
      }

      self.children = children;
    }

    if (self.initial) {
      self.initial = false;
    } else {
      if (self.config.get("once")) {
        self.$destroy();
      }
    }
  },
  onDestroy: function () {
    this.children = null;
    this.childrenFrag = null;
    this.$super();
  }
}, {
  initConfig: function (config) {
    config.setType("once", "bool", MetaphorJs.lib.Config.MODE_STATIC);
    config.setType("value", "bool");
  }
}));

/***/ }),

/***/ "../metaphorjs/src/extra-directives/tag/include.js":
/*!*********************************************************!*\
  !*** ../metaphorjs/src/extra-directives/tag/include.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ../../app/Template.js */ "../metaphorjs/src/app/Template.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

var Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
    MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerTag("include", function () {
  var dir = function tag_include_directive(state, node, config, renderer) {
    dir.initConfig(config);
    var tpl = new MetaphorJs.app.Template({
      state,
      replaceNode: node,
      config,
      parentRenderer: renderer
    });

    if (renderer) {
      renderer.on("destroy", function () {
        tpl.$destroy();
        tpl = null;
      });
      renderer.flowControl("ignoreInside", true);
    }
  };

  dir.initConfig = function (config) {
    config.setType("asis", "bool", MetaphorJs.lib.Config.MODE_STATIC);
    config.setDefaultValue("runRenderer", !config.get("asis"));
    config.set("useComments", true);
    config.set("passReferences", true);
  };

  return dir;
}());

/***/ }),

/***/ "../metaphorjs/src/extra-directives/tag/tag.js":
/*!*****************************************************!*\
  !*** ../metaphorjs/src/extra-directives/tag/tag.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ../../func/dom/setAttr.js */ "../metaphorjs/src/func/dom/setAttr.js");

__webpack_require__(/*! ../../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

var Directive = __webpack_require__(/*! ../../app/Directive.js */ "../metaphorjs/src/app/Directive.js"),
    MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

Directive.registerTag("tag", function directive_tag_tag(state, node, config, renderer) {
  var expr = getAttr(node, "value"),
      tag = MetaphorJs.lib.Expression.get(expr, state),
      i,
      l,
      a;

  if (!tag) {
    node.parentNode.removeChild(node);
    renderer && renderer.flowControl("stop", true);
  } else {
    var el = window.document.createElement(tag),
        next = node.nextSibling,
        attrs = node.attributes;

    while (node.firstChild) {
      el.appendChild(node.firstChild);
    }

    for (i = 0, l = attrs.length; i < l; i++) {
      a = attrs[i];

      if (a.name !== "value") {
        MetaphorJs.dom.setAttr(el, a.name, a.value);
      }
    }

    node.parentNode.insertBefore(el, next);
    node.parentNode.removeChild(node);
    renderer && renderer.flowControl("nodes", [el]);
  }
});

/***/ }),

/***/ "../metaphorjs/src/filter/__init.js":
/*!******************************************!*\
  !*** ../metaphorjs/src/filter/__init.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

MetaphorJs.filter = MetaphorJs.filter || {};

/***/ }),

/***/ "../metaphorjs/src/filter/collect.js":
/*!*******************************************!*\
  !*** ../metaphorjs/src/filter/collect.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @filter collect
 * @param {array} input Array of objects
 * @param {string} field Field name to collect from objects
 * @returns {array}
 */


MetaphorJs.filter.collect = function (input, state, prop) {
  var res = [],
      i,
      l,
      val;

  if (!input) {
    return res;
  }

  for (i = 0, l = input.length; i < l; i++) {
    val = input[i][prop];

    if (val != undefined) {
      res.push(val);
    }
  }

  return res;
};

/***/ }),

/***/ "../metaphorjs/src/filter/filter.js":
/*!******************************************!*\
  !*** ../metaphorjs/src/filter/filter.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      filterArray = __webpack_require__(/*! metaphorjs-shared/src/func/filterArray.js */ "../metaphorjs-shared/src/func/filterArray.js");
/**
 * @filter filter
 * See <code>filterArray</code> function
 * @param {array} input
 * @param {string|boolean|regexp|function} by
 * @param {string|boolean|null} opt true | false | "strict"
 * @returns {array}
 */


MetaphorJs.filter.filter = function (val, state, by, opt) {
  return filterArray(val, by, opt);
};

/***/ }),

/***/ "../metaphorjs/src/filter/get.js":
/*!***************************************!*\
  !*** ../metaphorjs/src/filter/get.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @filter get
 * @param {object} input
 * @param {string} prop {   
 *  Property name or path to property ("a.b.c")
 * }
 * @returns {*}
 */


MetaphorJs.filter.get = function (val, state, prop) {
  var tmp = ("" + prop).split("."),
      key;

  while (key = tmp.shift()) {
    val = val[key];

    if (val === undefined) {
      return undefined;
    }
  }

  return val;
};

/***/ }),

/***/ "../metaphorjs/src/filter/join.js":
/*!****************************************!*\
  !*** ../metaphorjs/src/filter/join.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js");
/**
 * @filter join
 * @param {array} input
 * @param {string} separator
 * @returns {string}
 */


MetaphorJs.filter.join = function (input, state, separator) {
  separator = separator || ", ";

  if (input && input.length) {
    if (!isArray(input)) {
      input = toArray(input);
    }

    return input.join(separator);
  }

  return "";
};

/***/ }),

/***/ "../metaphorjs/src/filter/l.js":
/*!*************************************!*\
  !*** ../metaphorjs/src/filter/l.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @filter l
 * @param {string} input Get text value from MetaphorJs.lib.LocalText
 * @returns {string}
 */


MetaphorJs.filter.l = function (key, state) {
  return state.$app.lang.get(key);
};

/***/ }),

/***/ "../metaphorjs/src/filter/limitTo.js":
/*!*******************************************!*\
  !*** ../metaphorjs/src/filter/limitTo.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js");
/**
 * @filter limitTo
 * Limit array size or string length
 * @param {array|string} input
 * @param {int} limit
 * @return {array|string}
 */


MetaphorJs.filter.limitTo = function (input, state, limit) {
  var isS = isString(input);

  if (!isArray(input) && !isS) {
    return input;
  }

  if (Math.abs(Number(limit)) === Infinity) {
    limit = Number(limit);
  } else {
    limit = parseInt(limit, 10);
  }

  if (isS) {
    //NaN check on limit
    if (limit) {
      return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);
    } else {
      return "";
    }
  }

  var out = [],
      i,
      n; // if abs(limit) exceeds maximum length, trim it

  if (limit > input.length) limit = input.length;else if (limit < -input.length) limit = -input.length;

  if (limit > 0) {
    i = 0;
    n = limit;
  } else {
    i = input.length + limit;
    n = input.length;
  }

  for (; i < n; i++) {
    out.push(input[i]);
  }

  return out;
};

/***/ }),

/***/ "../metaphorjs/src/filter/linkify.js":
/*!*******************************************!*\
  !*** ../metaphorjs/src/filter/linkify.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @filter linkify
 * Transform text links into html links
 * @param {string} input Text
 * @param {string} target Optional target parameter
 * @returns {string}
 */


MetaphorJs.filter.linkify = function (input, state, target) {
  target = target ? ' target="' + target + '"' : "";

  if (input) {
    var exp = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
    return input.replace(exp, '<a href="$1"' + target + '>$1</a>');
  }

  return "";
};

/***/ }),

/***/ "../metaphorjs/src/filter/lowercase.js":
/*!*********************************************!*\
  !*** ../metaphorjs/src/filter/lowercase.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @filter lowercase
 * Transform to lower case
 * @param {string} input
 * @returns {string}
 */


MetaphorJs.filter.lowercase = function (val) {
  return ("" + val).toLowerCase();
};

/***/ }),

/***/ "../metaphorjs/src/filter/map.js":
/*!***************************************!*\
  !*** ../metaphorjs/src/filter/map.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

__webpack_require__(/*! ../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      ns = __webpack_require__(/*! metaphorjs-namespace/src/var/ns.js */ "../metaphorjs-namespace/src/var/ns.js");
/**
 * @filter map
 * @param {array} input
 * @param {string} fnName {
 *  Either a namespace entry, or global function name or 
 *  expression to try against current state. In any case
 *  it must resolve into a function that accepts 
 *  mapped item as first argument.
 *  @param {*} item
 *  @returns {*}
 * }
 * @returns {array} new array
 */


MetaphorJs.filter.map = function (array, state, fnName) {
  var i,
      l,
      res = [],
      fn = ns.get(fnName, true) || window[fnName] || MetaphorJs.lib.Expression.get(fnName, state);
  array = array || [];

  if (fn) {
    for (i = 0, l = array.length; i < l; i++) {
      res.push(fn(array[i]));
    }
  }

  return res;
};

/***/ }),

/***/ "../metaphorjs/src/filter/moment.js":
/*!******************************************!*\
  !*** ../metaphorjs/src/filter/moment.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Cache.js */ "../metaphorjs-shared/src/lib/Cache.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @filter moment
 * Pass given input value through moment.js lib
 * @param {string|int|Date} input date value
 * @param {string} format date format
 * @returns {string}
 */


MetaphorJs.filter.moment = function (val, state, format) {
  return val ? moment(val).format(MetaphorJs.lib.Cache.global().get(format, format)) : "";
};

/***/ }),

/***/ "../metaphorjs/src/filter/numeral.js":
/*!*******************************************!*\
  !*** ../metaphorjs/src/filter/numeral.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Cache.js */ "../metaphorjs-shared/src/lib/Cache.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @filter moment
 * Pass given input value through numeral.js lib
 * @param {string|int} input 
 * @param {string} format number format
 * @returns {string}
 */


MetaphorJs.filter.numeral = function (val, state, format) {
  return numeral(val).format(MetaphorJs.lib.Cache.global().get(format, format));
};

/***/ }),

/***/ "../metaphorjs/src/filter/offset.js":
/*!******************************************!*\
  !*** ../metaphorjs/src/filter/offset.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js");
/**
 * @filter offset
 * Get slice of array or string starting from offset
 * @param {array|string} input
 * @param {int} offset
 * @returns {array|string}
 */


MetaphorJs.filter.offset = function (input, state, offset) {
  var isS = isString(input);

  if (!isArray(input) && !isS) {
    return input;
  }

  if (Math.abs(Number(offset)) === Infinity) {
    offset = Number(offset);
  } else {
    offset = parseInt(offset, 10);
  }

  if (isS) {
    return input.substr(offset);
  } else {
    return input.slice(offset);
  }
};

/***/ }),

/***/ "../metaphorjs/src/filter/p.js":
/*!*************************************!*\
  !*** ../metaphorjs/src/filter/p.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @filter p 
 * Get plural text form from LocalText lib
 * @param {string} input Lang key
 * @param {int} number Number to find text form for
 * @returns {string}
 */


MetaphorJs.filter.p = function (key, state, number) {
  return state.$app.lang.plural(key, parseInt(number, 10) || 0);
};

/***/ }),

/***/ "../metaphorjs/src/filter/pl.js":
/*!**************************************!*\
  !*** ../metaphorjs/src/filter/pl.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @filter p 
 * Get plural text form from LocalText lib
 * @param {int} input Number to find text form for
 * @param {string} key Lang key
 * @returns {string}
 */


MetaphorJs.filter.pl = function (number, state, key) {
  return state.$app.lang.plural(key, parseInt(number, 10) || 0);
};

/***/ }),

/***/ "../metaphorjs/src/filter/preloaded.js":
/*!*********************************************!*\
  !*** ../metaphorjs/src/filter/preloaded.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

__webpack_require__(/*! ../func/dom/preloadImage.js */ "../metaphorjs/src/func/dom/preloadImage.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      isThenable = __webpack_require__(/*! metaphorjs-shared/src/func/isThenable.js */ "../metaphorjs-shared/src/func/isThenable.js");

(function () {
  /**
   * @filter preloaded
   * Will return true once image is loaded. It will trigger state check 
   * automatically once the image is loaded.
   * @param {string} input Image url
   * @returns {boolean} 
   */
  var preloaded = MetaphorJs.filter.preloaded = function (val, state) {
    if (!val) {
      return false;
    }

    var promise = MetaphorJs.dom.preloadImage.check(val);

    if (promise === true || !promise) {
      return !!promise;
    }

    if (isThenable(promise)) {
      promise.always(function () {
        state.$check();
      });
      return false;
    } else {
      return true;
    }
  };

  preloaded.$undeterministic = true;
  return preloaded;
})();

/***/ }),

/***/ "../metaphorjs/src/filter/r.js":
/*!*************************************!*\
  !*** ../metaphorjs/src/filter/r.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @filter r
 * @param {string} input Render text recursively
 * @returns {string}
 */


MetaphorJs.filter.r = function (input, state) {
  return state.$app.lang.get(key);
};

/***/ }),

/***/ "../metaphorjs/src/filter/sortBy.js":
/*!******************************************!*\
  !*** ../metaphorjs/src/filter/sortBy.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      sortArray = __webpack_require__(/*! metaphorjs-shared/src/func/sortArray.js */ "../metaphorjs-shared/src/func/sortArray.js");
/**
 * @filter sortBy
 * Sort array of objects by object field
 * @param {array} input
 * @param {function|string|object} field {
 *  See <code>sortArray()</code> function
 * }
 * @param {string} dir
 * @returns {array}
 */


MetaphorJs.filter.sortBy = function (val, state, field, dir) {
  return sortArray(val, field, dir);
};

/***/ }),

/***/ "../metaphorjs/src/filter/split.js":
/*!*****************************************!*\
  !*** ../metaphorjs/src/filter/split.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      getRegExp = __webpack_require__(/*! metaphorjs-shared/src/func/getRegExp.js */ "../metaphorjs-shared/src/func/getRegExp.js");
/**
 * @filter split
 * Split string into parts
 * @param {string} input
 * @param {string|RegExp} separator {
 *  Can also pass "/regexp/" as a string 
 * }
 * @param {int} limit
 * @returns {array}
 */


MetaphorJs.filter.split = function (input, state, sep, limit) {
  limit = limit || undefined;
  sep = sep || "/\\n|,/";

  if (!input) {
    return [];
  }

  input = "" + input;

  if (sep.substr(0, 1) === '/' && sep.substr(sep.length - 1) === "/") {
    sep = getRegExp(sep.substring(1, sep.length - 1));
  }

  var list = input.split(sep, limit),
      i,
      l;

  for (i = -1, l = list.length; ++i < l; list[i] = list[i].trim()) {}

  return list;
};

/***/ }),

/***/ "../metaphorjs/src/filter/toArray.js":
/*!*******************************************!*\
  !*** ../metaphorjs/src/filter/toArray.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      isPlainObject = __webpack_require__(/*! metaphorjs-shared/src/func/isPlainObject.js */ "../metaphorjs-shared/src/func/isPlainObject.js");
/**
 * @filter toArray
 * @code src-docs/code/filter/toArray.js
 * @param {*} input
 * @returns {array}
 */


MetaphorJs.filter.toArray = function (input) {
  if (isPlainObject(input)) {
    var list = [],
        k;

    for (k in input) {
      if (input.hasOwnProperty(k)) {
        list.push({
          key: k,
          value: input[k]
        });
      }
    }

    return list;
  }

  return toArray(input);
};

/***/ }),

/***/ "../metaphorjs/src/filter/ucfirst.js":
/*!*******************************************!*\
  !*** ../metaphorjs/src/filter/ucfirst.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @filter ucfirst
 * Transform first character to upper case
 * @param {string} input
 * @returns {string}
 */


MetaphorJs.filter.ucfirst = function (val) {
  return val.substr(0, 1).toUpperCase() + val.substr(1);
};

/***/ }),

/***/ "../metaphorjs/src/filter/uppercase.js":
/*!*********************************************!*\
  !*** ../metaphorjs/src/filter/uppercase.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/filter/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @filter uppercase
 * Transform to upper case
 * @param {string} input
 * @returns {string}
 */


MetaphorJs.filter.uppercase = function (val) {
  return ("" + val).toUpperCase();
};

/***/ }),

/***/ "../metaphorjs/src/func/app/__init.js":
/*!********************************************!*\
  !*** ../metaphorjs/src/func/app/__init.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

MetaphorJs.app = MetaphorJs.app || {};

/***/ }),

/***/ "../metaphorjs/src/func/app/init.js":
/*!******************************************!*\
  !*** ../metaphorjs/src/func/app/init.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/app/__init.js");

__webpack_require__(/*! ./resolve.js */ "../metaphorjs/src/func/app/resolve.js");

__webpack_require__(/*! ../dom/getAttrSet.js */ "../metaphorjs/src/func/dom/getAttrSet.js");

__webpack_require__(/*! ../dom/removeAttr.js */ "../metaphorjs/src/func/dom/removeAttr.js");

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

const error = __webpack_require__(/*! metaphorjs-shared/src/func/error.js */ "../metaphorjs-shared/src/func/error.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.app.init = function app_init(node, cls, data, autorun) {
  const attrs = MetaphorJs.dom.getAttrSet(node);
  const cfg = attrs.directives.app || {};

  attrs.__remove("directive", node, "app");

  try {
    const p = MetaphorJs.app.resolve(cls || "MetaphorJs.app.App", extend({
      state: data
    }, cfg), node, [node, data]);

    if (autorun !== false) {
      return p.done(function (app) {
        app.run();
      });
    } else {
      return p;
    }
  } catch (thrownError) {
    error(thrownError);
    return MetaphorJs.lib.Promise.reject(thrownError);
  }
};

/***/ }),

/***/ "../metaphorjs/src/func/app/prebuilt.js":
/*!**********************************************!*\
  !*** ../metaphorjs/src/func/app/prebuilt.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      isPlainObject = __webpack_require__(/*! metaphorjs-shared/src/func/isPlainObject.js */ "../metaphorjs-shared/src/func/isPlainObject.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js");

module.exports = MetaphorJs.app.prebuilt = function () {
  let pb = MetaphorJs.prebuilt || {};
  const fnMap = {}; // used when building

  const unspace = function (fn) {
    fn = fn.replace(/[\n\r]/g, '');
    fn = fn.replace(/\s+/g, ' ');
    fn = fn.replace(' anonymous', '');
    return fn;
  };

  const traverse = function (s, fn) {
    if (isArray(s)) {
      let i, l;

      for (i = 0, l = s.length; i < l; i++) {
        s[i] = traverse(s[i], fn);
      }
    } else if (isPlainObject(s)) {
      let k;

      for (k in s) {
        s[k] = traverse(s[k], fn);
      }
    }

    return fn(s);
  };

  const extractFuncs = function (s) {
    if (typeof s === "function") {
      let fnstr = unspace(s.toString());

      if (!fnMap[fnstr]) {
        fnMap[fnstr] = api.add("func", s);
        let descr = MetaphorJs.lib.Expression.describeExpression(fnstr);

        if (descr) {
          api.add("funcDescr", descr, fnMap[fnstr]);
        }
      }

      s = fnMap[fnstr];
    }

    return s;
  };

  const importFuncs = function (s) {
    return api.isKey(s) ? pb.func[s] : s;
  };

  const deflate = function (s) {
    let k,
        keys = 0;

    for (k in s) {
      if (!s[k] || k === "expr") {
        delete s[k];
      } else if (isArray(s[k]) && s[k].length === 0) {
        delete s[k];
      } else {
        keys++;
      }
    }

    if (keys === 1 && s.getterFn) {
      s = s.getterFn;
    }

    return s;
  };

  const inflate = function (s) {
    s = traverse(s, importFuncs);

    if (typeof s === "function") {
      s = {
        getterFn: s
      };
    }

    !s.inputPipes && (s.inputPipes = []);
    !s.pipes && (s.pipes = []);
    s.inflated = true;
    return s;
  };

  const api = {
    /**
     * @function MetaphorJs.app.prebuilt.deflate
     * @param {object} data
     * @returns {object}
     */
    deflate: function (s) {
      return deflate(s);
    },

    /**
     * @function MetaphorJs.app.prebuilt.inflate
     * @param {object} data
     * @returns {object}
     */
    inflate: function (s) {
      return inflate(s);
    },

    /**
     * @function MetaphorJs.app.prebuilt.get
     * @param {string} type
     * @param {string} k
     * @returns {object|undefined}
     */
    get: function (type, k) {
      var data = pb[type] ? pb[type][k] : undefined;

      if (data) {
        !data.inflated && (data = inflate(data));
      }

      return data;
    },

    /**
     * @function MetaphorJs.app.prebuilt.add
     * @param {string} type
     * @param {object} data
     * @param {string} key {
     *  @optional if not provided, will generate a unique key
     * }
     * @returns {string} new (or provided) key
     */
    add: function (type, data, k) {
      k = k || "~" + nextUid() + "~";
      !pb[type] && (pb[type] = {});
      type !== "func" && (data = traverse(data, extractFuncs));
      pb[type][k] = deflate(data);
      return k;
    },

    /**
     * @function MetaphorJs.app.prebuilt.isKey
     * @param {string} k
     * @returns {boolean}
     */
    isKey: function (k) {
      return typeof k === "string" && k[0] === "~" && k[k.length - 1] === "~";
    },

    /**
     * @function MetaphorJs.app.prebuilt.getStorage
     * @returns {object}
     */
    getStorage: function () {
      return pb;
    },

    /**
     * @function MetaphorJs.app.prebuilt.setStorage
     * @param {object} storage
     */
    setStorage: function (storage) {
      pb = storage;
    }
  };
  return api;
}();

/***/ }),

/***/ "../metaphorjs/src/func/app/resolve.js":
/*!*********************************************!*\
  !*** ../metaphorjs/src/func/app/resolve.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/app/__init.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Provider.js */ "../metaphorjs-shared/src/lib/Provider.js");

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

__webpack_require__(/*! ../dom/toFragment.js */ "../metaphorjs/src/func/dom/toFragment.js");

__webpack_require__(/*! ../dom/data.js */ "../metaphorjs/src/func/dom/data.js");

__webpack_require__(/*! ../dom/addClass.js */ "../metaphorjs/src/func/dom/addClass.js");

__webpack_require__(/*! ../dom/removeClass.js */ "../metaphorjs/src/func/dom/removeClass.js");

__webpack_require__(/*! ../../app/Template.js */ "../metaphorjs/src/app/Template.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      error = __webpack_require__(/*! metaphorjs-shared/src/func/error.js */ "../metaphorjs-shared/src/func/error.js"),
      ns = __webpack_require__(/*! metaphorjs-namespace/src/var/ns.js */ "../metaphorjs-namespace/src/var/ns.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.app.resolve = function app_resolve(cmp, cfg, node, args) {
  cfg = cfg || {};
  args = args || [];
  node = node || cfg.node;
  let state = cfg.state;
  let config = cfg.config || null;
  cfg.config = config;
  cfg.state = cfg.state || state;
  cfg.node = cfg.node || node;

  if (args.length === 0) {
    args.push(cfg);
  }

  if (config) {
    if (!(config instanceof MetaphorJs.lib.Config)) {
      config = new MetaphorJs.lib.Config(config, {
        state
      },
      /*scalarAs: */
      "defaultValue");
    }
  }

  var constr = isString(cmp) ? ns.get(cmp) : cmp;

  if (!constr) {
    throw new Error("Component " + cmp + " not found");
  }

  let i;
  const defers = [],
        app = state ? state.$app : null,
        gProvider = MetaphorJs.lib.Provider.global(),
        injectFn = app ? app.inject : gProvider.inject,
        injectCt = app ? app : gProvider,
        cloak = config && config.has("cloak") ? config.get("cloak") : null,
        inject = {
    $node: node || null,
    $state: state || null,
    $config: config || null,
    $args: args || null
  };

  if (constr.resolve) {
    for (i in constr.resolve) {
      (function (name) {
        const d = new MetaphorJs.lib.Promise();
        let fn;
        defers.push(d.done(function (value) {
          inject[name] = value;
          cfg[name] = value;
          args.push(value);
        }));
        fn = constr.resolve[i];

        if (isFunction(fn)) {
          d.resolve(fn(state, node, config));
        } else {
          d.resolve(injectFn.call(injectCt, fn, null, extend({}, inject, cfg, false, false)));
        }

        d.fail(function (reason) {
          if (reason instanceof Error) {
            error(reason);
          }
        });
      })(i);
    }
  }

  let p;

  if (defers.length) {
    p = new MetaphorJs.lib.Promise();
    MetaphorJs.lib.Promise.all(defers).done(function (values) {
      p.resolve(injectFn.call(injectCt, constr, null, extend({}, inject, cfg, false, false), args));
    }).fail(p.reject, p);
  } else {
    p = MetaphorJs.lib.Promise.resolve(injectFn.call(injectCt, constr, null, extend({}, inject, cfg, false, false), args));
  }

  if (node && p.isPending() && cloak !== null) {
    cloak !== true ? MetaphorJs.dom.addClass(node, cloak) : node.style.visibility = "hidden";
    p.then(function () {
      cloak !== true ? MetaphorJs.dom.removeClass(node, cloak) : node.style.visibility = "";
    });
  }

  if (node) {
    p.then(function () {
      MetaphorJs.dom.removeClass(node, "mjs-cloak");
    });
  }

  return p;
};

/***/ }),

/***/ "../metaphorjs/src/func/app/run.js":
/*!*****************************************!*\
  !*** ../metaphorjs/src/func/app/run.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/app/__init.js");

__webpack_require__(/*! ./init.js */ "../metaphorjs/src/func/app/init.js");

__webpack_require__(/*! ../dom/onReady.js */ "../metaphorjs/src/func/dom/onReady.js");

__webpack_require__(/*! ../dom/select.js */ "../metaphorjs/src/func/dom/select.js");

__webpack_require__(/*! ../dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Run application
 * @function MetaphorJs.app.run
 * @param {Window} win
 * @param {object} appData
 */


module.exports = MetaphorJs.app.run = function app_run(w, appData) {
  const win = w || window;

  if (!win) {
    throw new Error("Window object neither defined nor provided");
  }

  MetaphorJs.dom.onReady(function () {
    const appNodes = MetaphorJs.dom.select("[mjs-app]", win.document);
    let i, l, el;

    for (i = -1, l = appNodes.length; ++i < l;) {
      el = appNodes[i];
      MetaphorJs.app.init(el, MetaphorJs.dom.getAttr(el, "mjs-app"), appData, true);
    }
  }, win);
};

/***/ }),

/***/ "../metaphorjs/src/func/browser/__init.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/func/browser/__init.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

MetaphorJs.browser = MetaphorJs.browser || {};

/***/ }),

/***/ "../metaphorjs/src/func/browser/hasEvent.js":
/*!**************************************************!*\
  !*** ../metaphorjs/src/func/browser/hasEvent.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/browser/__init.js");

__webpack_require__(/*! ./isIE.js */ "../metaphorjs/src/func/browser/isIE.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Check if current browser supports event
 * @function MetaphorJs.browser.hasEvent
 * @param {string} event
 * @return {boolean}
 */


module.exports = MetaphorJs.browser.hasEvent = function () {
  var eventSupport = {},
      divElm;
  return function browser_hasEvent(event) {
    // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have
    // it. In particular the event is not fired when backspace or delete key are pressed or
    // when cut operation is performed.
    if (eventSupport[event] === undefined) {
      if (event === 'input' && MetaphorJs.browser.isIE() == 9) {
        return eventSupport[event] = false;
      }

      if (!divElm) {
        divElm = window.document.createElement('div');
      }

      eventSupport[event] = !!('on' + event in divElm);
    }

    return eventSupport[event];
  };
}();

/***/ }),

/***/ "../metaphorjs/src/func/browser/isAndroid.js":
/*!***************************************************!*\
  !*** ../metaphorjs/src/func/browser/isAndroid.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/browser/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.browser.isAndroid = function () {
  var android = null;
  return function browser_isAndroid() {
    if (android === null) {
      android = parseInt((/android (\d+)/i.exec(navigator.userAgent) || [])[1], 10) || false;
    }

    return android;
  };
}();

/***/ }),

/***/ "../metaphorjs/src/func/browser/isIE.js":
/*!**********************************************!*\
  !*** ../metaphorjs/src/func/browser/isIE.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/browser/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.browser.isIE = function () {
  var msie;
  return function browser_isIE() {
    if (msie === null) {
      var ua = navigator.userAgent;
      msie = parseInt((/msie (\d+)/i.exec(ua) || [])[1], 10);

      if (isNaN(msie)) {
        msie = parseInt((/trident\/.*; rv:(\d+)/i.exec(ua) || [])[1], 10) || false;
      }
    }

    return msie;
  };
}();

/***/ }),

/***/ "../metaphorjs/src/func/dom/_/_boxSizingReliable.js":
/*!**********************************************************!*\
  !*** ../metaphorjs/src/func/dom/_/_boxSizingReliable.js ***!
  \**********************************************************/
/***/ ((module) => {

module.exports = function () {
  var boxSizingReliableVal;

  var computePixelPositionAndBoxSizingReliable = function () {
    var doc = window.document,
        container = doc.createElement("div"),
        div = doc.createElement("div"),
        body = doc.body;

    if (!div.style || !window.getComputedStyle) {
      return false;
    }

    container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
    container.appendChild(div);
    div.style.cssText = // Support: Firefox<29, Android 2.3
    // Vendor-prefix box-sizing
    "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
    div.innerHTML = "";
    body.appendChild(container);
    var divStyle = window.getComputedStyle(div, null),
        ret = divStyle.width === "4px";
    body.removeChild(container);
    return ret;
  };

  return function boxSizingReliable() {
    if (boxSizingReliableVal === undefined) {
      boxSizingReliableVal = computePixelPositionAndBoxSizingReliable();
    }

    return boxSizingReliableVal;
  };
}();

/***/ }),

/***/ "../metaphorjs/src/func/dom/_/_getDimensions.js":
/*!******************************************************!*\
  !*** ../metaphorjs/src/func/dom/_/_getDimensions.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ../getStyle.js */ "../metaphorjs/src/func/dom/getStyle.js");

const _boxSizingReliable = __webpack_require__(/*! ./_boxSizingReliable.js */ "../metaphorjs/src/func/dom/_/_boxSizingReliable.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = function (type, name) {
  // from jQuery
  var rnumnonpx = new RegExp("^([+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|))(?!px)[a-z%]+$", "i"),
      cssExpand = ["Top", "Right", "Bottom", "Left"],
      defaultExtra = !type ? "content" : type === "inner" ? "padding" : "";

  var augmentWidthOrHeight = function (elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? "border" : "content") ? // If we already have the right measurement, avoid augmentation
    4 : // Otherwise initialize for horizontal or vertical properties
    name === "width" ? 1 : 0,
        val = 0;

    for (; i < 4; i += 2) {
      // Both box models exclude margin, so add it if we want it
      if (extra === "margin") {
        val += parseFloat(styles[extra + cssExpand[i]]);
      }

      if (isBorderBox) {
        // border-box includes padding, so remove it if we want content
        if (extra === "content") {
          val -= parseFloat(styles["padding" + cssExpand[i]]);
        } // At this point, extra isn't border nor margin, so remove border


        if (extra !== "margin") {
          val -= parseFloat(styles["border" + cssExpand[i] + "Width"]);
        }
      } else {
        // At this point, extra isn't content, so add padding
        val += parseFloat(styles["padding" + cssExpand[i]]); // At this point, extra isn't content nor padding, so add border

        if (extra !== "padding") {
          val += parseFloat(styles["border" + cssExpand[i] + "Width"]);
        }
      }
    }

    return val;
  };

  var getWidthOrHeight = function (elem, name, extra, styles) {
    // Start with offset property, which is equivalent to the border-box value
    var valueIsBorderBox = true,
        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        isBorderBox = styles["boxSizing"] === "border-box"; // Some non-html elements return undefined for offsetWidth, so check for null/undefined
    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668

    if (val <= 0 || val == null) {
      val = elem.style[name]; // Computed unit is not pixels. Stop here and return.

      if (rnumnonpx.test(val)) {
        return val;
      } // Check for style in case a browser which returns unreliable values
      // for getComputedStyle silently falls back to the reliable elem.style


      valueIsBorderBox = isBorderBox && (_boxSizingReliable() || val === elem.style[name]); // Normalize "", auto, and prepare for extra

      val = parseFloat(val) || 0;
    } // Use the active box-sizing model to add/subtract irrelevant styles


    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles);
  };

  return function dom_getDimensions(elem, margin) {
    if (elem === window) {
      return elem.document.documentElement["client" + name];
    } // Get document width or height


    if (elem.nodeType === window.document.DOCUMENT_NODE) {
      var doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
      // whichever is greatest

      return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
    }

    return getWidthOrHeight(elem, name.toLowerCase(), defaultExtra || (margin === true ? "margin" : "border"), MetaphorJs.dom.getStyle(elem));
  };
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/_/_getScrollTopOrLeft.js":
/*!***********************************************************!*\
  !*** ../metaphorjs/src/func/dom/_/_getScrollTopOrLeft.js ***!
  \***********************************************************/
/***/ ((module) => {

module.exports = function (vertical) {
  var defaultST,
      wProp = vertical ? "pageYOffset" : "pageXOffset",
      sProp = vertical ? "scrollTop" : "scrollLeft",
      doc = window.document,
      body = doc.body,
      html = doc.documentElement;

  var ret = function (scroll, allowNegative) {
    if (scroll < 0 && allowNegative === false) {
      return 0;
    }

    return scroll;
  };

  if (window[wProp] !== undefined) {
    //most browsers except IE before #9
    defaultST = function () {
      return window[wProp];
    };
  } else {
    if (html.clientHeight) {
      defaultST = function () {
        return html[sProp];
      };
    } else {
      defaultST = function () {
        return body[sProp];
      };
    }
  }

  return function (node, allowNegative) {
    if (!node || node === window) {
      return ret(defaultST(), allowNegative);
    } else if (node && node.nodeType == window.document.ELEMENT_NODE && node !== body && node !== html) {
      return ret(node[sProp], allowNegative);
    } else {
      return ret(defaultST(), allowNegative);
    }
  };
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/_/_mousewheelHandler.js":
/*!**********************************************************!*\
  !*** ../metaphorjs/src/func/dom/_/_mousewheelHandler.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// from jquery.mousewheel plugin
__webpack_require__(/*! ../normalizeEvent.js */ "../metaphorjs/src/func/dom/normalizeEvent.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = function (e) {
  function shouldAdjustOldDeltas(orgEvent, absDelta) {
    // If this is an older event and the delta is divisable by 120,
    // then we are assuming that the browser is treating this as an
    // older mouse wheel event and that we should divide the deltas
    // by 40 to try and get a more usable deltaFactor.
    // Side note, this actually impacts the reported scroll distance
    // in older browsers and can cause scrolling to be slower than native.
    // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
    return orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
  }

  function nullLowestDelta() {
    lowestDelta = null;
  }

  var nullLowestDeltaTimeout, lowestDelta;

  var mousewheelHandler = function (fn) {
    return function mousewheelHandler(e) {
      var event = MetaphorJs.dom.normalizeEvent(e || window.event),
          args = slice.call(arguments, 1),
          delta = 0,
          deltaX = 0,
          deltaY = 0,
          absDelta = 0,
          offsetX = 0,
          offsetY = 0;
      event.type = 'mousewheel'; // Old school scrollwheel delta

      if ('detail' in event) {
        deltaY = event.detail * -1;
      }

      if ('wheelDelta' in event) {
        deltaY = event.wheelDelta;
      }

      if ('wheelDeltaY' in event) {
        deltaY = event.wheelDeltaY;
      }

      if ('wheelDeltaX' in event) {
        deltaX = event.wheelDeltaX * -1;
      } // Firefox < 17 horizontal scrolling related to DOMMouseScroll event


      if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
        deltaX = deltaY * -1;
        deltaY = 0;
      } // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy


      delta = deltaY === 0 ? deltaX : deltaY; // New school wheel delta (wheel event)

      if ('deltaY' in event) {
        deltaY = event.deltaY * -1;
        delta = deltaY;
      }

      if ('deltaX' in event) {
        deltaX = event.deltaX;

        if (deltaY === 0) {
          delta = deltaX * -1;
        }
      } // No change actually happened, no reason to go any further


      if (deltaY === 0 && deltaX === 0) {
        return;
      } // Store lowest absolute delta to normalize the delta values


      absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));

      if (!lowestDelta || absDelta < lowestDelta) {
        lowestDelta = absDelta; // Adjust older deltas if necessary

        if (shouldAdjustOldDeltas(event, absDelta)) {
          lowestDelta /= 40;
        }
      } // Adjust older deltas if necessary


      if (shouldAdjustOldDeltas(event, absDelta)) {
        // Divide all the things by 40!
        delta /= 40;
        deltaX /= 40;
        deltaY /= 40;
      } // Get a whole, normalized value for the deltas


      delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
      deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
      deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta); // Normalise offsetX and offsetY properties

      if (this.getBoundingClientRect) {
        var boundingRect = this.getBoundingClientRect();
        offsetX = event.clientX - boundingRect.left;
        offsetY = event.clientY - boundingRect.top;
      } // Add information to the event object


      event.deltaX = deltaX;
      event.deltaY = deltaY;
      event.deltaFactor = lowestDelta;
      event.offsetX = offsetX;
      event.offsetY = offsetY; // Go ahead and set deltaMode to 0 since we converted to pixels
      // Although this is a little odd since we overwrite the deltaX/Y
      // properties with normalized deltas.

      event.deltaMode = 0; // Add event and delta to the front of the arguments

      args.unshift(event, delta, deltaX, deltaY); // Clearout lowestDelta after sometime to better
      // handle multiple device types that give different
      // a different lowestDelta
      // Ex: trackpad = 3 and mouse wheel = 120

      if (nullLowestDeltaTimeout) {
        clearTimeout(nullLowestDeltaTimeout);
      }

      nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
      return fn.apply(this, args);
    };
  };

  mousewheelHandler.events = function () {
    var doc = window.document;
    return 'onwheel' in doc || doc.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'];
  };

  return mousewheelHandler;
}();

/***/ }),

/***/ "../metaphorjs/src/func/dom/__init.js":
/*!********************************************!*\
  !*** ../metaphorjs/src/func/dom/__init.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

MetaphorJs.dom = MetaphorJs.dom || {};

/***/ }),

/***/ "../metaphorjs/src/func/dom/addClass.js":
/*!**********************************************!*\
  !*** ../metaphorjs/src/func/dom/addClass.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./hasClass.js */ "../metaphorjs/src/func/dom/hasClass.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @function MetaphorJs.dom.addClass
 * @param {HTMLElement} el
 * @param {string} cls
 */


module.exports = MetaphorJs.dom.addClass = function dom_addClass(el, cls) {
  if (cls && !MetaphorJs.dom.hasClass(el, cls)) {
    if (el.classList) {
      cls = cls.split(" ");
      el.classList.add(...cls);
    } else el.className += " " + cls;
  }
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/addListener.js":
/*!*************************************************!*\
  !*** ../metaphorjs/src/func/dom/addListener.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const _mousewheelHandler = __webpack_require__(/*! ./_/_mousewheelHandler.js */ "../metaphorjs/src/func/dom/_/_mousewheelHandler.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @function MetaphorJs.dom.addListener
 * @param {HTMLElement} el
 * @param {string} eventName
 * @param {function} func {
 *  @param {object} event
 * }
 */


module.exports = MetaphorJs.dom.addListener = function () {
  var fn = null,
      prefix = null;
  return function dom_addListener(el, event, func, opt) {
    if (fn === null) {
      if (el.addEventListener) {
        fn = "addEventListener";
        prefix = "";
      } else {
        fn = "attachEvent";
        prefix = "on";
      } //fn = el.attachEvent ? "attachEvent" : "addEventListener";
      //prefix = el.attachEvent ? "on" : "";

    }

    opt = opt || {};
    opt.capture = opt.capture || false;

    if (event === "mousewheel") {
      func = _mousewheelHandler(func);

      var events = _mousewheelHandler.events(),
          i,
          l;

      for (i = 0, l = events.length; i < l; i++) {
        el[fn](prefix + events[i], func, opt);
      }
    } else {
      el[fn](prefix + event, func, opt);
    }

    return func;
  };
}();

/***/ }),

/***/ "../metaphorjs/src/func/dom/clone.js":
/*!*******************************************!*\
  !*** ../metaphorjs/src/func/dom/clone.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Clone dom node (or array of nodes)
 * @function MetaphorJs.dom.clone
 * @param {[]|Element} node
 * @returns {[]|Element}
 */


module.exports = MetaphorJs.dom.clone = function dom_clone(node) {
  var i, len, cloned;

  if (isArray(node)) {
    cloned = [];

    for (i = 0, len = node.length; i < len; i++) {
      cloned.push(dom_clone(node[i]));
    }

    return cloned;
  } else if (node) {
    switch (node.nodeType) {
      // element
      case window.document.ELEMENT_NODE:
        return node.cloneNode(true);
      // text node

      case window.document.TEXT_NODE:
        return window.document.createTextNode(node.innerText || node.textContent);
      // document fragment

      case window.document.DOCUMENT_FRAGMENT_NODE:
        return node.cloneNode(true);

      default:
        return null;
    }
  }

  return null;
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/commentWrap.js":
/*!*************************************************!*\
  !*** ../metaphorjs/src/func/dom/commentWrap.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dom.commentWrap = function commentWrap(node, name) {
  name = name || "";
  var before = window.document.createComment("<" + name),
      after = window.document.createComment(name + ">"),
      parent = node.parentNode;
  parent.insertBefore(before, node);

  if (node.nextSibling) {
    parent.insertBefore(after, node.nextSibling);
  } else {
    parent.appendChild(after);
  }

  return [before, after];
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/data.js":
/*!******************************************!*\
  !*** ../metaphorjs/src/func/dom/data.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get dom data value
 * @function MetaphorJs.dom.data
 * @param {HTMLElement} el
 * @param {string} key
 */

/**
 * Set dom data value
 * @function MetaphorJs.dom.data
 * @param {HTMLElement} el
 * @param {string} key
 * @param {*} value
 * @param {string|null} action Pass "remove" to delete one data key or all keys
 * @returns {*}
 */


module.exports = MetaphorJs.dom.data = function () {
  //dataCache   = {},
  var getNodeKey = function (key) {
    return '$$mjs-' + key;
  }
  /*,
  getNodeId   = function(el) {
     return el._mjsid || (el._mjsid = nextUid());
  }*/
  ;

  return function dom_data(el, key, value, action) {
    //var id  = getNodeId(el),
    //    obj = dataCache[id];
    var nodekey = getNodeKey(key);

    if (action === 'remove') {
      if (key) {
        //obj && (delete obj[key]);
        delete el[nodekey];
      } else {//delete dataCache[id];
      }

      return;
    }

    if (value !== undefined) {
      /*if (!obj) {
          obj = dataCache[id] = {};
      }
      obj[key] = value;*/
      el[nodekey] = value;
      return value;
    } else {
      //return obj ? obj[key] : undefined;
      return el[nodekey];
    }
  };
}();

/***/ }),

/***/ "../metaphorjs/src/func/dom/delegate.js":
/*!**********************************************!*\
  !*** ../metaphorjs/src/func/dom/delegate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Cache.js */ "../metaphorjs-shared/src/lib/Cache.js");

__webpack_require__(/*! ./is.js */ "../metaphorjs/src/func/dom/is.js");

__webpack_require__(/*! ./addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! ./normalizeEvent.js */ "../metaphorjs/src/func/dom/normalizeEvent.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Delegate dom event
 * @function MetaphorJs.dom.delegate
 * @param {HTMLElement} el Dom node to add event listener to
 * @param {string} selector Event target selector
 * @param {string} event Event name
 * @param {function} fn {
 *  Event handler
 *  @param {object} event
 * }
 */


module.exports = MetaphorJs.dom.delegate = function dom_delegate(el, selector, event, fn) {
  var delegates = MetaphorJs.lib.Cache.global().get("dom/delegates", []);

  var key = selector + "-" + event,
      listener = function (e) {
    e = MetaphorJs.dom.normalizeEvent(e);
    var trg = e.target;

    while (trg) {
      if (MetaphorJs.dom.is(trg, selector)) {
        return fn(e);
      }

      trg = trg.parentNode;
    }

    return null;
  };

  if (!delegates[key]) {
    delegates[key] = [];
  }

  delegates[key].push({
    el: el,
    ls: listener,
    fn: fn
  });
  MetaphorJs.dom.addListener(el, event, listener);
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/eachNode.js":
/*!**********************************************!*\
  !*** ../metaphorjs/src/func/dom/eachNode.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Walk dom tree
 * @function MetaphorJs.dom.eachNode
 * @param {HTMLElement} el
 * @param {function} fn {
 *  @param {HTMLElement} el
 * }
 * @param {object} context fn's context
 */


module.exports = MetaphorJs.dom.eachNode = function dom_eachNode(el, fn, context) {
  var i,
      len,
      children = el.childNodes;

  if (fn.call(context, el) !== false) {
    for (i = -1, len = children.length >>> 0; ++i !== len; dom_eachNode(children[i], fn, context)) {}
  }
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/getAttr.js":
/*!*********************************************!*\
  !*** ../metaphorjs/src/func/dom/getAttr.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get node attribute value
 * @function MetaphorJs.dom.getAttr
 * @param {HTMLElement} node
 * @returns {string}
 */


module.exports = MetaphorJs.dom.getAttr = function dom_getAttr(el, name) {
  return el.getAttribute ? el.getAttribute(name) : null;
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/getAttrSet.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/func/dom/getAttrSet.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./removeAttr.js */ "../metaphorjs/src/func/dom/removeAttr.js");

__webpack_require__(/*! ../../lib/Config.js */ "../metaphorjs/src/lib/Config.js");

const toCamelCase = __webpack_require__(/*! metaphorjs-shared/src/func/toCamelCase.js */ "../metaphorjs-shared/src/func/toCamelCase.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get node attributes classified by directive
 * @function MetaphorJs.dom.getAttrSet
 * @param {HTMLElement} node
 * @returns {object}
 */


module.exports = MetaphorJs.dom.getAttrSet = function () {
  // regular expression seems to be a few milliseconds faster
  // than plain parsing
  var reg = /^([\[({#$@!])([^)\]}"':\*!]+)[\])}]?([:\*!]?)$/;

  var removeDirective = function removeDirective(node, directive) {
    var ds = this.__directives,
        i,
        l,
        d,
        j,
        jl,
        ns;

    if (!this.inflated && ds[directive]) {
      for (i = 0, l = ds[directive].length; i < l; i++) {
        d = ds[directive][i];

        if (d.original) {
          MetaphorJs.dom.removeAttr(node, d.original);
        }

        if (ns = d.names) {
          for (j = 0, jl = ns.length; j < jl; j++) {
            MetaphorJs.dom.removeAttr(node, ns[j]);
          }
        }
      }
    } //delete ds[directive];

  };

  var removeAttributes = function (node, what, param) {
    var names, i, l;

    if (what === "all") {
      removeAttributes(node, "directives");
      removeAttributes(node, "attributes");
      removeAttributes(node, "config");
    } else if (what === "directives") {
      for (i in this.__directives) {
        removeDirective.call(this, node, i);
      }

      return;
    } else if (what === "directive") {
      removeDirective.call(this, node, param);
      return;
    } else if (what === "attributes") {
      names = this.__attributes;
    } else if (what === "attribute" && this.__attributes[param]) {
      names = [this.__attributes[param]];
    } else if (what === "config") {
      names = this.__config;
    } else if (what === "reference") {
      names = ["#" + param];
    } else if (what === "references") {
      names = [];

      for (i = 0, l = this.references.length; i < l; i++) {
        names.push("#" + this.references[i]);
      }
    } else if (what === "at") {
      names = ["@" + this.at];
    }

    if (names) {
      if (isArray(names)) {
        for (i = 0, l = names.length; i < l; i++) {
          MetaphorJs.dom.removeAttr(node, names[i]);
        }
      } else {
        for (i in names) {
          MetaphorJs.dom.removeAttr(node, names[i]);
        }
      }
    }
  };

  var execModes = {
    '*': MetaphorJs.lib.Config.MODE_DYNAMIC,
    ':': MetaphorJs.lib.Config.MODE_STATIC,
    '!': MetaphorJs.lib.Config.MODE_SINGLE,
    '': null
  };
  var dtypes = {
    '{': "dir",
    '(': "event",
    '[': "attr",
    '$': "cfg",
    '!': "renderer"
  };

  var getEmpty = function () {
    return {
      directives: {},
      attributes: {},
      config: {},
      rest: {},
      references: [],
      renderer: {},
      at: null,
      __plain: true,
      __directives: {},
      __attributes: {},
      __config: [],
      __remove: removeAttributes
    };
  };

  var inflate = function (set) {
    extend(set, getEmpty(), false, false);
    set.inflated = true;
    return set;
  };

  var ccName = function (name) {
    return name.indexOf('--') !== -1 ? name : toCamelCase(name);
  };

  return function dom_getAttrSet(node) {
    var set = getEmpty(),
        i,
        l,
        name,
        value,
        indexName,
        match,
        parts,
        ds = set.directives,
        __ds = set.__directives,
        plain = true,
        mode,
        subname,
        prop,
        execMode,
        attrs = isArray(node) ? node : node.attributes;
    /**
     * mjs="<id>" - attribute always present, even after cloning 
     * data-mjscfg - copy of original config, id always present
     * node._mjscfg - equals data-mjscfg. After cloning, this property
     *  disappears and we must make a new copy of config
     *  from data-mjscfg version
     */

    if (node.nodeType && node.hasAttribute && node.hasAttribute("mjs")) {
      set = MetaphorJs.prebuilt.configs[node.getAttribute("mjs")]; //MetaphorJs.dom.removeAttr(node, "mjs");

      return inflate(set);
    }

    for (i = 0, l = attrs.length; i < l; i++) {
      indexName = null;
      name = attrs[i].name;
      value = attrs[i].value;
      mode = null;
      execMode = null;
      match = name.match(reg);

      if (match) {
        plain = false;
        name = match[2];
        mode = match[1];
        execMode = execModes[match[3]];

        if (mode === '#') {
          set.references.push(name);
          continue;
        }

        if (mode === '@') {
          set.at = name;
          continue;
        }

        if (mode === "!") {
          set.renderer[ccName(name)] = true;
          continue;
        }
      } else {
        if (name.substr(0, 4) === "mjs-") {
          name = name.substr(4);
          mode = '{';
          plain = false;
        } else {
          set['rest'][name] = value;
          continue;
        }
      }

      if (mode === '$') {
        if (value === "") {
          value = true;
        }

        set['config'][ccName(name)] = {
          expression: value,
          mode: execMode
        };

        set.__config.push(attrs[i].name);
      } else if (mode === '(' || mode === '{') {
        parts = name.split(".");
        name = parts.shift();
        subname = parts.length ? parts.join(".") : null;
        value === "" && (value = true);

        if (!ds[name]) {
          ds[name] = {};
          __ds[name] = {
            type: dtypes[mode],
            original: null,
            names: []
          };
        }

        if (!subname) {
          __ds[name].original = attrs[i].name;
        }

        if (subname && subname[0] === '$') {
          prop = ccName(subname.substr(1));
          ds[name][prop] = {
            mode: execMode,
            expression: value,
            attr: attrs[i].name
          };

          __ds[name].names.push(attrs[i].name);
        } else {
          if (subname) {
            prop = "value." + parts.join("."); // directive value keys are not camelcased
            // do this inside directive if needed
            // ('class' directive needs originals)

            ds[name][prop] = {
              mode: execMode,
              expression: value,
              attr: attrs[i].name
            };

            __ds[name].names.push(attrs[i].name);
          } else {
            ds[name]['value'] = {
              mode: execMode,
              expression: value,
              attr: attrs[i].name
            };
          }
        }
      } else if (mode === '[') {
        set.attributes[name] = value;
        set.__attributes[name] = attrs[i].name;
      }
    }

    for (name in ds) {
      if (name.indexOf('|') !== -1) {
        parts = name.split('|');
        indexName = parts[1];

        if (name !== indexName && indexName) {
          if (ds[indexName]) {
            if (!isArray(ds[indexName])) {
              ds[indexName] = [ds[indexName]];
              __ds[indexName] = [__ds[indexName]];
            }
          } else {
            ds[indexName] = [];
            __ds[indexName] = [];
          }

          if (isArray(ds[indexName])) {
            ds[indexName].push(ds[name]);

            __ds[indexName].push(__ds[name]);

            delete ds[name];
            delete __ds[name];
          }
        }
      }

      if (ds[name] && !isArray(ds[name])) {
        ds[name] = [ds[name]];
        __ds[name] = [__ds[name]];
      }
    }

    set.directives = ds;
    set.__directives = __ds;
    set.__plain = plain;
    return set;
  };
}();

/***/ }),

/***/ "../metaphorjs/src/func/dom/getClsReg.js":
/*!***********************************************!*\
  !*** ../metaphorjs/src/func/dom/getClsReg.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const getRegExp = __webpack_require__(/*! metaphorjs-shared/src/func/getRegExp.js */ "../metaphorjs-shared/src/func/getRegExp.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @param {String} cls
 * @returns {RegExp}
 */


module.exports = MetaphorJs.dom.getClsReg = function (cls) {
  return getRegExp('(?:^|\\s)' + cls + '(?!\\S)');
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/getHeight.js":
/*!***********************************************!*\
  !*** ../metaphorjs/src/func/dom/getHeight.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const _dom_getDimensions = __webpack_require__(/*! ./_/_getDimensions.js */ "../metaphorjs/src/func/dom/_/_getDimensions.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get element height
 * @function MetaphorJs.dom.getHeight
 * @param {HTMLElement} el
 * @returns {int}
 */


module.exports = MetaphorJs.dom.getHeight = _dom_getDimensions("", "Height");

/***/ }),

/***/ "../metaphorjs/src/func/dom/getInnerHeight.js":
/*!****************************************************!*\
  !*** ../metaphorjs/src/func/dom/getInnerHeight.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const _dom_getDimensions = __webpack_require__(/*! ./_/_getDimensions.js */ "../metaphorjs/src/func/dom/_/_getDimensions.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get element inner height
 * @function MetaphorJs.dom.getInnerHeight
 * @param {HTMLElement} el
 * @returns {int}
 */


module.exports = MetaphorJs.dom.getInnerHeight = _dom_getDimensions("inner", "Height");

/***/ }),

/***/ "../metaphorjs/src/func/dom/getInnerWidth.js":
/*!***************************************************!*\
  !*** ../metaphorjs/src/func/dom/getInnerWidth.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const _dom_getDimensions = __webpack_require__(/*! ./_/_getDimensions.js */ "../metaphorjs/src/func/dom/_/_getDimensions.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get element inner width
 * @function MetaphorJs.dom.getInnerWidth
 * @param {HTMLElement} el
 * @returns {int}
 */


module.exports = MetaphorJs.dom.getInnerWidth = _dom_getDimensions("inner", "Width");

/***/ }),

/***/ "../metaphorjs/src/func/dom/getInputValue.js":
/*!***************************************************!*\
  !*** ../metaphorjs/src/func/dom/getInputValue.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const isNull = __webpack_require__(/*! metaphorjs-shared/src/func/isNull.js */ "../metaphorjs-shared/src/func/isNull.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @function MetaphorJs.dom.getInputValue
 * @param {HTMLElement} elem
 * @returns {string}
 */


module.exports = MetaphorJs.dom.getInputValue = function () {
  var rreturn = /\r/,
      hooks = {
    option: function (elem) {
      var val = elem.getAttribute("value") || elem.value;
      return val !== undefined ? val : (elem.innerText || elem.textContent).trim();
    },
    select: function (elem) {
      var value,
          option,
          options = elem.options,
          index = elem.selectedIndex,
          one = elem.type === "select-one" || index < 0,
          values = one ? null : [],
          max = one ? index + 1 : options.length,
          disabled,
          i = index < 0 ? max : one ? index : 0; // Loop through all the selected options

      for (; i < max; i++) {
        option = options[i];
        disabled = option.disabled || option.parentNode.disabled; // IE6-9 doesn't update selected after form reset (#2551)

        if ((option.selected || i === index) && !disabled) {
          // Get the specific value for the option
          value = MetaphorJs.dom.getInputValue(option); // We don't need an array for one selects

          if (one) {
            return value;
          } // Multi-Selects return an array


          values.push(value);
        }
      }

      return values;
    },
    radio: function (elem) {
      return isNull(elem.getAttribute("value")) ? "on" : elem.value;
    },
    checkbox: function (elem) {
      return isNull(elem.getAttribute("value")) ? "on" : elem.value;
    }
  };
  return function dom_getInputValue(elem) {
    var hook, ret;
    hook = hooks[elem.type] || hooks[elem.nodeName.toLowerCase()];

    if (hook && (ret = hook(elem, "value")) !== undefined) {
      return ret;
    }

    ret = elem.value;
    return isString(ret) ? // Handle most common string cases
    ret.replace(rreturn, "") : // Handle cases where value is null/undef or number
    ret == null ? "" : ret;
  };
}();

/***/ }),

/***/ "../metaphorjs/src/func/dom/getOffset.js":
/*!***********************************************!*\
  !*** ../metaphorjs/src/func/dom/getOffset.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./isAttached.js */ "../metaphorjs/src/func/dom/isAttached.js");

__webpack_require__(/*! ./getScrollTop.js */ "../metaphorjs/src/func/dom/getScrollTop.js");

__webpack_require__(/*! ./getScrollLeft.js */ "../metaphorjs/src/func/dom/getScrollLeft.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get element's offset
 * @function MetaphorJs.dom.getOffet
 * @param {HTMLElement} node
 * @returns {object} {
 *  @type {int} top
 *  @type {int} left
 * }
 */


module.exports = MetaphorJs.dom.getOffset = function dom_getOffset(node) {
  var box = {
    top: 0,
    left: 0
  },
      html = window.document.documentElement; // Make sure it's not a disconnected DOM node

  if (!MetaphorJs.dom.isAttached(node) || node === window) {
    return box;
  } // Support: BlackBerry 5, iOS 3 (original iPhone)
  // If we don't have gBCR, just use 0,0 rather than error


  if (node.getBoundingClientRect) {
    box = node.getBoundingClientRect();
  }

  return {
    top: box.top + MetaphorJs.dom.getScrollTop() - html.clientTop,
    left: box.left + MetaphorJs.dom.getScrollLeft() - html.clientLeft
  };
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/getOffsetParent.js":
/*!*****************************************************!*\
  !*** ../metaphorjs/src/func/dom/getOffsetParent.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./getStyle.js */ "../metaphorjs/src/func/dom/getStyle.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get element's offset parent
 * @function MetaphorJs.dom.getOffsetParent
 * @param {HTMLElement} node 
 * @returns {HTMLElement}
 */


module.exports = MetaphorJs.dom.getOffsetParent = function dom_getOffsetParent(node) {
  var html = window.document.documentElement,
      offsetParent = node.offsetParent || html;

  while (offsetParent && offsetParent != html && MetaphorJs.dom.getStyle(offsetParent, "position") === "static") {
    offsetParent = offsetParent.offsetParent;
  }

  return offsetParent || html;
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/getOuterHeight.js":
/*!****************************************************!*\
  !*** ../metaphorjs/src/func/dom/getOuterHeight.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const _dom_getDimensions = __webpack_require__(/*! ./_/_getDimensions.js */ "../metaphorjs/src/func/dom/_/_getDimensions.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get element outer height
 * @function MetaphorJs.dom.getOuterHeight
 * @param {HTMLElement} el
 * @returns {int}
 */


module.exports = MetaphorJs.dom.getOuterHeight = _dom_getDimensions("outer", "Height");

/***/ }),

/***/ "../metaphorjs/src/func/dom/getOuterWidth.js":
/*!***************************************************!*\
  !*** ../metaphorjs/src/func/dom/getOuterWidth.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const _dom_getDimensions = __webpack_require__(/*! ./_/_getDimensions.js */ "../metaphorjs/src/func/dom/_/_getDimensions.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get element outer width
 * @function MetaphorJs.dom.getOuterWidth
 * @param {HTMLElement} el
 * @returns {int}
 */


module.exports = MetaphorJs.dom.getOuterWidth = _dom_getDimensions("outer", "Width");

/***/ }),

/***/ "../metaphorjs/src/func/dom/getParentDocument.js":
/*!*******************************************************!*\
  !*** ../metaphorjs/src/func/dom/getParentDocument.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dom.getParentDocument = function dom_getParentDocument(node) {
  var fragType = window.document.DOCUMENT_FRAGMENT_NODE,
      parent = node.parentNode;

  while (parent) {
    if (parent.nodeType === fragType) {
      return parent;
    }

    parent = parent.parentNode;
  }

  return node.ownerDocument;
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/getPosition.js":
/*!*************************************************!*\
  !*** ../metaphorjs/src/func/dom/getPosition.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./getStyle.js */ "../metaphorjs/src/func/dom/getStyle.js");

__webpack_require__(/*! ./getOffsetParent.js */ "../metaphorjs/src/func/dom/getOffsetParent.js");

__webpack_require__(/*! ./getOffset.js */ "../metaphorjs/src/func/dom/getOffset.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get node position relative to offset parent or specific node
 * @function MetaphorJs.dom.getPosition
 * @param {HTMLElement} node 
 * @param {HTMLElement} to 
 * @return {object} {
 *  @type {int} top
 *  @type {int} left
 * }
 */


module.exports = MetaphorJs.dom.getPosition = function dom_getPosition(node, to) {
  var offsetParent,
      offset,
      parentOffset = {
    top: 0,
    left: 0
  },
      html = window.document.documentElement;

  if (node === window || node === html) {
    return parentOffset;
  } // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
  // because it is its only offset parent


  if (MetaphorJs.dom.getStyle(node, "position") == "fixed") {
    // Assume getBoundingClientRect is there when computed position is fixed
    offset = node.getBoundingClientRect();
  } else if (to) {
    var thisOffset = MetaphorJs.dom.getOffset(node),
        toOffset = MetaphorJs.dom.getOffset(to),
        position = {
      left: thisOffset.left - toOffset.left,
      top: thisOffset.top - toOffset.top
    };

    if (position.left < 0) {
      position.left = 0;
    }

    if (position.top < 0) {
      position.top = 0;
    }

    return position;
  } else {
    // Get *real* offsetParent
    offsetParent = MetaphorJs.dom.getOffsetParent(node); // Get correct offsets

    offset = MetaphorJs.dom.getOffset(node);

    if (offsetParent !== html) {
      parentOffset = MetaphorJs.dom.getOffset(offsetParent);
    } // Add offsetParent borders


    parentOffset.top += MetaphorJs.dom.getStyle(offsetParent, "borderTopWidth", true);
    parentOffset.left += MetaphorJs.dom.getStyle(offsetParent, "borderLeftWidth", true);
  } // Subtract parent offsets and element margins


  return {
    top: offset.top - parentOffset.top - MetaphorJs.dom.getStyle(node, "marginTop", true),
    left: offset.left - parentOffset.left - MetaphorJs.dom.getStyle(node, "marginLeft", true)
  };
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/getScrollLeft.js":
/*!***************************************************!*\
  !*** ../metaphorjs/src/func/dom/getScrollLeft.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const _getScrollTopOrLeft = __webpack_require__(/*! ./_/_getScrollTopOrLeft.js */ "../metaphorjs/src/func/dom/_/_getScrollTopOrLeft.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get element's horizontal scroll position
 * @function MetaphorJs.dom.getScrollLeft
 * @param {HTMLElement} element
 * @returns {int}
 */


module.exports = MetaphorJs.dom.getScrollLeft = _getScrollTopOrLeft(false);

/***/ }),

/***/ "../metaphorjs/src/func/dom/getScrollParent.js":
/*!*****************************************************!*\
  !*** ../metaphorjs/src/func/dom/getScrollParent.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./getStyle.js */ "../metaphorjs/src/func/dom/getStyle.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get element's scrolling parent
 * @function MetaphorJs.dom.getScrollParent
 * @param {HTMLElement} node
 * @returns {HTMLElement}
 */


module.exports = MetaphorJs.dom.getScrollParent = function () {
  var rOvf = /(auto|scroll)/,
      body,
      overflow = function (node) {
    var style = MetaphorJs.dom.getStyle(node);
    return style ? style["overflow"] + style["overflowY"] + style["overflowY"] : "";
  },
      scroll = function (node) {
    return rOvf.test(overflow(node));
  };

  return function dom_getScrollParent(node) {
    if (!body) {
      body = window.document.body;
    }

    var parent = node;

    while (parent) {
      if (parent === body) {
        return window;
      }

      if (scroll(parent)) {
        return parent;
      }

      parent = parent.parentNode;
    }

    return window;
  };
}();

/***/ }),

/***/ "../metaphorjs/src/func/dom/getScrollTop.js":
/*!**************************************************!*\
  !*** ../metaphorjs/src/func/dom/getScrollTop.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const _getScrollTopOrLeft = __webpack_require__(/*! ./_/_getScrollTopOrLeft.js */ "../metaphorjs/src/func/dom/_/_getScrollTopOrLeft.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get element's vertical scroll position
 * @function MetaphorJs.dom.getScrollTop
 * @param {HTMLElement} element
 * @returns {int}
 */


module.exports = MetaphorJs.dom.getScrollTop = _getScrollTopOrLeft(true);

/***/ }),

/***/ "../metaphorjs/src/func/dom/getStyle.js":
/*!**********************************************!*\
  !*** ../metaphorjs/src/func/dom/getStyle.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get element's style object
 * @function MetaphorJs.dom.getStyle
 * @param {HTMLElement} node
 * @returns {DomStyle}
 */

/**
* Get element's style property
* @function MetaphorJs.dom.getStyle
* @param {HTMLElement} node
* @param {string} prop
* @param {boolean} numeric return as number
* @returns {string|int}
*/


module.exports = MetaphorJs.dom.getStyle = function dom_getStyle(node, prop, numeric) {
  var style, val;

  if (window.getComputedStyle) {
    if (node === window) {
      return prop ? numeric ? 0 : null : {};
    }

    style = window.getComputedStyle(node, null);
    val = prop ? style[prop] : style;
  } else {
    style = node.currentStyle || node.style || {};
    val = prop ? style[prop] : style;
  }

  return numeric ? parseFloat(val) || 0 : val;
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/getWidth.js":
/*!**********************************************!*\
  !*** ../metaphorjs/src/func/dom/getWidth.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const _dom_getDimensions = __webpack_require__(/*! ./_/_getDimensions.js */ "../metaphorjs/src/func/dom/_/_getDimensions.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Get element width
 * @function MetaphorJs.dom.getWidth
 * @param {HTMLElement} el
 * @returns {int}
 */


module.exports = MetaphorJs.dom.getWidth = _dom_getDimensions("", "Width");

/***/ }),

/***/ "../metaphorjs/src/func/dom/hasClass.js":
/*!**********************************************!*\
  !*** ../metaphorjs/src/func/dom/hasClass.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./getClsReg.js */ "../metaphorjs/src/func/dom/getClsReg.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @function MetaphorJs.dom.hasClass
 * @param {HTMLElement} el
 * @param {String} cls
 * @returns {boolean}
 */


module.exports = MetaphorJs.dom.hasClass = function (el, cls) {
  return cls ? el.classList ? el.classList.contains(cls) : MetaphorJs.dom.getClsReg(cls).test(el.className) : false;
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/is.js":
/*!****************************************!*\
  !*** ../metaphorjs/src/func/dom/is.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./select.js */ "../metaphorjs/src/func/dom/select.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Check if given element matches selector
 * @function MetaphorJs.dom.is
 * @param {HTMLElement} el
 * @param {string} selector
 * @returns {boolean}
 */


module.exports = MetaphorJs.dom.is = function (el, selector) {
  if (!selector) {
    return false;
  }

  if (typeof selector === "function") {
    return el instanceof selector;
  }

  var els = MetaphorJs.dom.select(selector, el.parentNode),
      i,
      l;

  for (i = -1, l = els.length; ++i < l;) {
    if (els[i] === el) {
      return true;
    }
  }

  return false;
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/isAttached.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/func/dom/isAttached.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Is node attached to DOM
 * @function MetaphorJs.dom.isAttached
 * @param {HTMLElement} node
 * @returns {boolean}
 */


module.exports = MetaphorJs.dom.isAttached = function dom_isAttached(node) {
  if (node === window) {
    return true;
  }

  if (node.nodeType == window.document.TEXT_NODE) {
    if (node.parentElement) {
      return dom_isAttached(node.parentElement);
    } else {
      return true;
    }
  }

  var html = window.document.documentElement;
  return node === html ? true : html.contains(node);
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/isField.js":
/*!*********************************************!*\
  !*** ../metaphorjs/src/func/dom/isField.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Is given element a field
 * @function MetaphorJs.dom.isField
 * @param {HTMLElement} node
 * @returns {boolean}
 */


module.exports = MetaphorJs.dom.isField = function dom_isField(el) {
  var tag = el && el.nodeName ? el.nodeName.toLowerCase() : null,
      type = el.type;

  if (tag == 'input' || tag == 'textarea' || tag == 'select') {
    if (type != "submit" && type != "reset" && type != "button") {
      return true;
    }
  }

  return false;
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/isVisible.js":
/*!***********************************************!*\
  !*** ../metaphorjs/src/func/dom/isVisible.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Is element visible on the page
 * @function MetaphorJs.dom.isVisible
 * @param {HTMLElement} el
 * @returns {boolean}
 */


module.exports = MetaphorJs.dom.isVisible = function dom_isVisible(el) {
  return el && !(el.offsetWidth <= 0 || el.offsetHeight <= 0);
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/normalizeEvent.js":
/*!****************************************************!*\
  !*** ../metaphorjs/src/func/dom/normalizeEvent.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ../../lib/DomEvent.js */ "../metaphorjs/src/lib/DomEvent.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dom.normalizeEvent = function (originalEvent) {
  return originalEvent instanceof MetaphorJs.lib.DomEvent ? originalEvent : new MetaphorJs.lib.DomEvent(originalEvent);
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/onReady.js":
/*!*********************************************!*\
  !*** ../metaphorjs/src/func/dom/onReady.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

__webpack_require__(/*! ./addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Execute callback when window is ready
 * @function MetaphorJs.dom.onReady
 * @param {function} fn {
 *  @param {Window} win
 * }
 * @param {Window} w optional window object
 */


module.exports = MetaphorJs.dom.onReady = function dom_onReady(fn, w) {
  var done = false,
      top = true,
      win = w || window,
      root,
      doc,
      init = function (e) {
    if (e.type == 'readystatechange' && doc.readyState != 'complete') {
      return;
    }

    MetaphorJs.dom.removeListener(e.type == 'load' ? win : doc, e.type, init);

    if (!done && (done = true)) {
      fn.call(win, e.type || e);
    }
  },
      poll = function () {
    try {
      root.doScroll('left');
    } catch (thrownError) {
      setTimeout(poll, 50);
      return;
    }

    init('poll');
  };

  doc = win.document;
  root = doc.documentElement;

  if (doc.readyState == 'complete') {
    fn.call(win, 'lazy');
  } else {
    if (doc.createEventObject && root.doScroll) {
      try {
        top = !win.frameElement;
      } catch (thrownError) {}

      top && poll();
    }

    MetaphorJs.dom.addListener(doc, 'DOMContentLoaded', init);
    MetaphorJs.dom.addListener(doc, 'readystatechange', init);
    MetaphorJs.dom.addListener(win, 'load', init);
  }
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/preloadImage.js":
/*!**************************************************!*\
  !*** ../metaphorjs/src/func/dom/preloadImage.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dom.preloadImage = function () {
  var cache = {},
      loading = {},
      cacheCnt = 0;

  function dom_preloadImage(src) {
    if (cache[src] !== undefined) {
      if (cache[src] === false) {
        return MetaphorJs.lib.Promise.reject(src);
      } else {
        return MetaphorJs.lib.Promise.resolve(cache[src]);
      }
    }

    if (loading[src]) {
      return loading[src];
    }

    if (cacheCnt > 1000) {
      cache = {};
      cacheCnt = 0;
    }

    var doc = window.document,
        img = doc.createElement("img"),
        style = img.style,
        deferred = new MetaphorJs.lib.Promise();
    loading[src] = deferred;
    deferred.always(function () {
      delete loading[src];
    });
    MetaphorJs.dom.addListener(img, "load", function () {
      if (!cache[src]) {
        cache[src] = {
          src: src,
          width: img ? img.width : null,
          height: img ? img.height : null
        };
        cacheCnt++;
      }

      if (deferred) {
        deferred.resolve(cache[src]);
      }

      if (img && img.parentNode) {
        img.parentNode.removeChild(img);
      }

      img = null;
      style = null;
      deferred = null;
    });
    MetaphorJs.dom.addListener(img, "error", function () {
      cache[src] = false;

      if (img && img.parentNode) {
        img.parentNode.removeChild(img);
      }

      if (deferred) {
        deferred.reject(src);
      }
    });

    deferred.abort = function () {
      if (img && img.parentNode) {
        img.parentNode.removeChild(img);
      }

      if (deferred) {
        deferred.reject(src);
      }

      img = null;
      style = null;
      deferred = null;
    };

    style.position = "absolute";
    style.visibility = "hidden";
    style.left = "-10000px";
    style.top = "0";
    doc.body.appendChild(img);
    img.src = src;
    return deferred;
  }

  ;

  dom_preloadImage.check = function (src) {
    if (cache[src] !== undefined) {
      return cache[src];
    }

    return loading[src] || null;
  };

  return dom_preloadImage;
}();

/***/ }),

/***/ "../metaphorjs/src/func/dom/removeAttr.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/func/dom/removeAttr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Remove element's attribute
 * @function MetaphorJs.dom.removeAttr
 * @param {HTMLElement} node 
 * @param {string} name
 */


module.exports = MetaphorJs.dom.removeAttr = function dom_removeAttr(el, name) {
  return el.removeAttribute(name);
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/removeClass.js":
/*!*************************************************!*\
  !*** ../metaphorjs/src/func/dom/removeClass.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./getClsReg.js */ "../metaphorjs/src/func/dom/getClsReg.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Remove element's class
 * @function MetaphorJs.dom.removeClass
 * @param {HTMLElement} el
 * @param {string} cls
 */


module.exports = MetaphorJs.dom.removeClass = function (el, cls) {
  if (cls) {
    if (el.classList) {
      cls = cls.split(" ");
      el.classList.remove(...cls);
    } else el.className = el.className.replace(MetaphorJs.dom.getClsReg(cls), '');
  }
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/removeListener.js":
/*!****************************************************!*\
  !*** ../metaphorjs/src/func/dom/removeListener.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Remove listeners from element's events
 * @function MetaphorJs.dom.removeListener
 * @param {HTMLElement} el 
 * @param {string} eventName
 * @param {function} fn
 */


module.exports = MetaphorJs.dom.removeListener = function () {
  var fn = null,
      prefix = null;
  return function dom_removeListener(el, event, func) {
    if (fn === null) {
      if (el.removeEventListener) {
        fn = "removeEventListener";
        prefix = "";
      } else {
        fn = "detachEvent";
        prefix = "on";
      } //fn = el.detachEvent ? "detachEvent" : "removeEventListener";
      //prefix = el.detachEvent ? "on" : "";

    }

    el[fn](prefix + event, func);
  };
}();

/***/ }),

/***/ "../metaphorjs/src/func/dom/removeStyle.js":
/*!*************************************************!*\
  !*** ../metaphorjs/src/func/dom/removeStyle.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Remove specific style from element
 * @function MetaphorJs.dom.removeStyle
 * @param {HTMLElement} node
 * @param {string} name Style property name
 */


module.exports = MetaphorJs.dom.removeStyle = function () {
  var div = window.document.createElement("div");

  if (div.style && div.style.removeProperty) {
    return function (node, name) {
      node.style.removeProperty(name);
    };
  } else {
    return function (node, name) {
      node.style.removeAttribute(name);
    };
  }
}();

/***/ }),

/***/ "../metaphorjs/src/func/dom/select.js":
/*!********************************************!*\
  !*** ../metaphorjs/src/func/dom/select.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Returns array of nodes or an empty array
 * @function MetaphorJs.dom.select
 * @param {string} selector
 * @param {HTMLElement} root to look into
 */


module.exports = MetaphorJs.dom.select = function dom_select(selector, root) {
  root = root || window.document;
  return toArray(root.querySelectorAll(selector));
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/setAttr.js":
/*!*********************************************!*\
  !*** ../metaphorjs/src/func/dom/setAttr.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dom.setAttr = function (el, name, value) {
  return el.setAttribute(name, value);
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/setInputValue.js":
/*!***************************************************!*\
  !*** ../metaphorjs/src/func/dom/setInputValue.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./getInputValue.js */ "../metaphorjs/src/func/dom/getInputValue.js");

__webpack_require__(/*! ./getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ./setAttr.js */ "../metaphorjs/src/func/dom/setAttr.js");

__webpack_require__(/*! ./removeAttr.js */ "../metaphorjs/src/func/dom/removeAttr.js");

const toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      isNumber = __webpack_require__(/*! metaphorjs-shared/src/func/isNumber.js */ "../metaphorjs-shared/src/func/isNumber.js"),
      isNull = __webpack_require__(/*! metaphorjs-shared/src/func/isNull.js */ "../metaphorjs-shared/src/func/isNull.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @function MetaphorJs.dom.setInputValue
 * @param {HTMLElement} el
 * @param {*} val
 */


module.exports = MetaphorJs.dom.setInputValue = function () {
  var hooks = {
    select: function (elem, value) {
      var optionSet,
          option,
          options = elem.options,
          values = toArray(value),
          i = options.length,
          selected,
          setIndex = -1;

      while (i--) {
        option = options[i];
        selected = values.indexOf(option.value) !== -1;

        if (selected) {
          MetaphorJs.dom.setAttr(option, "selected", "selected");
          option.selected = true;
          optionSet = true;
        } else {
          MetaphorJs.dom.removeAttr(option, "selected");
        }

        if (!selected && !isNull(MetaphorJs.dom.getAttr(option, "default-option"))) {
          setIndex = i;
        }
      } // Force browsers to behave consistently when non-matching value is set


      if (!optionSet) {
        elem.selectedIndex = setIndex;
      }

      return values;
    }
  };

  hooks["radio"] = hooks["checkbox"] = function (elem, value) {
    if (isArray(value)) {
      return elem.checked = value.indexOf(MetaphorJs.dom.getInputValue(elem)) !== -1;
    }
  };

  return function (el, val) {
    if (el.nodeType !== window.document.ELEMENT_NODE) {
      return;
    } // Treat null/undefined as ""; convert numbers to string


    if (isNull(val)) {
      val = "";
    } else if (isNumber(val)) {
      val += "";
    }

    var hook = hooks[el.type] || hooks[el.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

    if (!hook || hook(el, val, "value") === undefined) {
      el.value = val;
    }
  };
}();

/***/ }),

/***/ "../metaphorjs/src/func/dom/setStyle.js":
/*!**********************************************!*\
  !*** ../metaphorjs/src/func/dom/setStyle.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Set element's style
 * @function MetaphorJs.dom.setStyle
 * @param {HTMLElement} el
 * @param {string} name
 * @param {*} value
 */


module.exports = MetaphorJs.dom.setStyle = function dom_setStyle(el, name, value) {
  if (!el || !el.style) {
    return;
  }

  var props,
      style = el.style,
      k;

  if (typeof name === "string") {
    props = {};
    props[name] = value;
  } else {
    props = name;
  }

  for (k in props) {
    style[k] = props[k];
  }
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/toFragment.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/func/dom/toFragment.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dom.toFragment = function dom_toFragment(nodes, doc) {
  const fragment = (doc || window.document).createDocumentFragment();
  let i, l;

  if (isString(nodes)) {
    const tmp = window.document.createElement('div');
    tmp.innerHTML = nodes;
    nodes = tmp.childNodes;
  }

  if (!nodes) {
    return fragment;
  }

  if (nodes.nodeType) {
    fragment.appendChild(nodes);
  } else {
    // due to a bug in jsdom, we turn NodeList into array first
    if (nodes.item) {
      const tmpNodes = nodes;
      nodes = [];

      for (i = -1, l = tmpNodes.length >>> 0; ++i !== l; nodes.push(tmpNodes[i])) {}
    }

    for (i = -1, l = nodes.length; ++i !== l; fragment.appendChild(nodes[i])) {}
  }

  return fragment;
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/transclude.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/func/dom/transclude.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./data.js */ "../metaphorjs/src/func/dom/data.js");

__webpack_require__(/*! ./toFragment.js */ "../metaphorjs/src/func/dom/toFragment.js");

__webpack_require__(/*! ./clone.js */ "../metaphorjs/src/func/dom/clone.js");

__webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js");

const toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dom.transclude = function () {
  var getTranscludeFrom = function (parent) {
    var contents;

    while (parent) {
      contents = MetaphorJs.dom.data(parent, 'mjs-transclude');

      if (contents !== undefined) {
        return contents;
      }

      parent = parent.parentNode;
    }

    return undefined;
  };

  return function dom_transclude(node, replace, parents) {
    parents = parents || [];
    parents.unshift(node.parentNode);
    var i, l, contents;

    for (i = 0, l = parents.length; i < l; i++) {
      contents = getTranscludeFrom(parents[i]);

      if (contents) {
        break;
      }
    }

    if (contents) {
      if (node.firstChild) {
        MetaphorJs.dom.data(node, "mjs-transclude", MetaphorJs.dom.toFragment(node.childNodes));
      }

      var parent = node.parentNode,
          //next        = node.nextSibling,
      cloned = MetaphorJs.dom.clone(contents),
          children = toArray(cloned.childNodes);

      if (replace) {
        parent.replaceChild(node, cloned); //parent.removeChild(node);
        //parent.insertBefore(cloned, next);
      } else {
        node.appendChild(cloned);
      }

      return children;
    }

    return null;
  };
}();

/***/ }),

/***/ "../metaphorjs/src/func/dom/triggerEvent.js":
/*!**************************************************!*\
  !*** ../metaphorjs/src/func/dom/triggerEvent.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Trigger DOM event on element
 * @function MetaphorJs.dom.triggerEvent
 * @param {HTMLElement} el
 * @param {string} event
 */


module.exports = MetaphorJs.dom.triggerEvent = function dom_triggerEvent(el, event) {
  var isStr = typeof event === "string",
      type = isStr ? event : event.type;

  if (el.fireEvent) {
    return el.fireEvent("on" + type);
  } else {
    if (isStr) {
      if (document.createEvent) {
        event = document.createEvent("Event");
        event.initEvent(type, true, true);
      } else {
        event = new Event(event);
      }
    }

    return el.dispatchEvent(event);
  }
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/undelegate.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/func/dom/undelegate.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./__init.js */ "../metaphorjs/src/func/dom/__init.js");

__webpack_require__(/*! ./removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

__webpack_require__(/*! metaphorjs-shared/src/lib/Cache.js */ "../metaphorjs-shared/src/lib/Cache.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = function undelegate(el, selector, event, fn) {
  var key = selector + "-" + event,
      i,
      l,
      ds,
      delegates = MetaphorJs.lib.Cache.global().get("dom/delegates", []);

  if (ds = delegates[key]) {
    for (i = -1, l = ds.length; ++i < l;) {
      if (ds[i].el === el && ds[i].fn === fn) {
        MetaphorJs.dom.removeListener(el, event, ds[i].ls);
      }
    }
  }
};

/***/ }),

/***/ "../metaphorjs/src/func/dom/whenAttached.js":
/*!**************************************************!*\
  !*** ../metaphorjs/src/func/dom/whenAttached.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./isAttached.js */ "../metaphorjs/src/func/dom/isAttached.js");

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dom.whenAttached = function () {
  var nodes = [],
      promises = [],
      observer,
      html;

  var check = function () {
    var i,
        l,
        inx,
        sub = 0,
        remove = [];

    for (i = 0, l = nodes.length; i < l; i++) {
      if (html.contains(nodes[i])) {
        promises[i].resolve();
        remove.push(i);
      }
    }

    for (i = 0, l = remove.length; i < l; i++) {
      inx = remove[i] - sub++;
      nodes.splice(inx, 1);
      promises.splice(inx, 1);
    }

    if (nodes.length === 0) {
      if (window.MutationObserver) {
        observer.disconnect();
        observer = null;
      } else {
        window.clearInterval(observer);
        observer = null;
      }
    }
  };

  var initObserver = window.MutationObserver ? function () {
    html = window.document.documentElement;
    observer = new window.MutationObserver(check);
    observer.observe(html, {
      childList: true,
      subtree: true
    });
  } : function () {
    html = window.document.documentElement;
    observer = window.setInterval(check, 1000);
  };
  return function when_attached(node) {
    if (MetaphorJs.dom.isAttached(node)) {
      return MetaphorJs.lib.Promise.resolve();
    }

    !observer && initObserver();
    var inx;

    if ((inx = nodes.indexOf(node)) === -1) {
      nodes.push(node);
      promises.push(new MetaphorJs.lib.Promise());
      inx = nodes.length - 1;
    }

    ;

    if (promises[inx].isCancelled()) {
      promises[inx] = new MetaphorJs.lib.Promise();
    }

    return promises[inx];
  };
}();

/***/ }),

/***/ "../metaphorjs/src/lib/Config.js":
/*!***************************************!*\
  !*** ../metaphorjs/src/lib/Config.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-observable/src/lib/Observable.js */ "../metaphorjs-observable/src/lib/Observable.js");

__webpack_require__(/*! ./Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ./MutationObserver.js */ "../metaphorjs/src/lib/MutationObserver.js");

__webpack_require__(/*! ../func/app/prebuilt.js */ "../metaphorjs/src/func/app/prebuilt.js");

const extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      toBool = __webpack_require__(/*! metaphorjs-shared/src/func/toBool.js */ "../metaphorjs-shared/src/func/toBool.js"),
      toArray = __webpack_require__(/*! metaphorjs-shared/src/func/toArray.js */ "../metaphorjs-shared/src/func/toArray.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      isPrimitive = __webpack_require__(/*! metaphorjs-shared/src/func/isPrimitive.js */ "../metaphorjs-shared/src/func/isPrimitive.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * @class MetaphorJs.lib.Config
 */


module.exports = MetaphorJs.lib.Config = function () {
  const $$observable = new MetaphorJs.lib.Observable();
  const MODE_STATIC = 1,
        MODE_DYNAMIC = 2,
        MODE_SINGLE = 3,
        MODE_GETTER = 4,
        MODE_SETTER = 5,
        MODE_FUNC = 6,
        MODE_FNSET = 7,
        MODE_LISTENER = 8;
  /**
   * @constructor
   * @method
   * @param {object} properties Attribute expressions/properties map
   * @param {object} cfg {
   *  @type {object} state Data object
   *  @type {object} setTo set all values to this object
   * }
   * @param {string} scalarAs {
   *  expression|defaultValue|value -- 
   *  if property comes as scalar value {name: value}, this
   *  option helps determine what to do with it, make an expression
   *  out of it, or use as default value.
   * }
   */

  var Config = function (properties, cfg, scalarAs) {
    var self = this;
    self.id = nextUid();
    self.values = {};
    self.properties = {};
    self.cfg = cfg || {};
    self.keys = [];

    if (properties) {
      self.addProperties(properties, scalarAs);
    }
  };

  extend(Config.prototype, {
    id: null,
    properties: null,
    values: null,
    keys: null,
    cfg: null,
    _initMo: function (name, pb) {
      var self = this,
          prop = self.properties[name];
      prop.mo = MetaphorJs.lib.MutationObserver.get(prop.state || self.cfg.state, pb || prop.expression);
      prop.mo.subscribe(self._onPropMutated, self, {
        append: [name]
      });
    },
    _unsetMo: function (name) {
      var self = this,
          prop = self.properties[name];

      if (prop.mo) {
        prop.mo.unsubscribe(self._onPropMutated, self);
        prop.mo.$destroy(true);
        prop.mo = null;
      }
    },
    storeAsCode: function (name) {
      var self = this,
          prop = self.getProperty(name),
          mode,
          expr,
          res,
          descr;

      if (!prop || !prop.expression) {
        return null;
      }

      mode = prop.mode || prop.defaultMode || MODE_DYNAMIC;
      expr = prop.expression;

      if (mode !== MODE_STATIC) {
        descr = MetaphorJs.lib.Expression.describeExpression(expr);
      }

      switch (mode) {
        case MODE_STATIC:
          {
            if (typeof expr === "string") {
              expr = expr.replace(/\\([\s\S])|(")/g, "\\$1$2");
            }

            res = {
              getterFn: new Function("", "return \"" + expr + "\""),
              mode: MODE_STATIC
            };
            break;
          }

        case MODE_SINGLE:
        case MODE_DYNAMIC:
        case MODE_FUNC:
        case MODE_GETTER:
        case MODE_SETTER:
        case MODE_FNSET:
          {
            res = MetaphorJs.lib.Expression.deconstruct(expr, {
              noReturn: mode === MODE_FUNC || mode === MODE_SETTER,
              setter: mode === MODE_SETTER || mode === MODE_FNSET
            });
            break;
          }

        case MODE_LISTENER:
          {
            var delegate = expr.indexOf('(') === -1 && expr.indexOf('=') === -1;
            res = MetaphorJs.lib.Expression.expression(expr, {
              noReturn: delegate === false
            });
            res.delegate = delegate;
            break;
          }
      }

      prop.inflate && (res.inflate = prop.inflate);
      res.descr = descr;
      return res;
    },
    _calcProperty: function (name) {
      var self = this,
          prop = self.getProperty(name),
          value,
          pb,
          setTo;

      if (!prop || prop.disabled) {
        return null;
      }

      if (prop.expression || prop.prebuilt) {
        pb = prop.prebuilt;

        if (!pb && MetaphorJs.app.prebuilt.isKey(prop.expression)) {
          prop.prebuilt = pb = MetaphorJs.app.prebuilt.get("config", prop.expression);
        }

        if (!prop.mode) {
          prop.mode = self.cfg.defaultMode || MODE_DYNAMIC;
        }

        if (prop.mode === MODE_STATIC) {
          if (pb) {
            value = pb.getterFn();
          } else {
            value = prop.expression;
          }
        } else if (prop.mode === MODE_SINGLE) {
          if (pb) {
            value = (pb.getterFn || pb.fn)(prop.state || self.cfg.state);
          } else {
            value = MetaphorJs.lib.Expression.get(prop.expression, prop.state || self.cfg.state);
          }
        } else if (prop.mode === MODE_DYNAMIC) {
          !prop.mo && self._initMo(name, pb);
          value = prop.mo.getValue();
        } else if (prop.mode === MODE_GETTER || prop.mode === MODE_SETTER) {
          if (pb) {
            value = MetaphorJs.lib.Expression.construct(pb, {
              setterOnly: prop.mode === MODE_SETTER,
              getterOnly: prop.mode === MODE_GETTER
            });
          } else {
            value = MetaphorJs.lib.Expression.parse(prop.expression, {
              setter: prop.mode === MODE_SETTER,
              setterOnly: prop.mode === MODE_SETTER,
              getterOnly: prop.mode === MODE_GETTER
            });
          }
        } else if (prop.mode === MODE_FNSET) {
          if (pb) {
            value = {
              getter: MetaphorJs.lib.Expression.construct(pb, {
                getterOnly: true
              }),
              setter: MetaphorJs.lib.Expression.construct(pb, {
                setterOnly: true
              })
            };
          } else {
            value = {
              getter: MetaphorJs.lib.Expression.getter(prop.expression),
              setter: MetaphorJs.lib.Expression.setter(prop.expression)
            };
          }
        } else if (prop.mode === MODE_FUNC) {
          if (pb) {
            value = pb.fn || pb.getterFn;
          } else {
            value = MetaphorJs.lib.Expression.func(prop.expression);
          }
        } else if (prop.mode === MODE_LISTENER) {
          if (pb) {
            if (pb.delegate) {
              value = pb.getterFn(prop.state || self.cfg.state);
            } else {
              value = self._wrapListener(pb.fn || pb.getterFn, prop.state || self.cfg.state, prop);
            }
          } else {
            if (prop.expression.indexOf('(') === -1 && prop.expression.indexOf('=') === -1) {
              value = MetaphorJs.lib.Expression.get(prop.expression, prop.state || self.cfg.state);
            } else {
              value = MetaphorJs.lib.Expression.func(prop.expression);

              if (value && typeof value === "function") {
                value = self._wrapListener(value, prop.state || self.cfg.state, prop);
              }
            }
          }
        }
      }

      if (value === undefined) {
        value = prop.defaultValue;
      }

      var retValue = self._prepareValue(value, prop);

      if (value !== undefined) {
        self.values[name] = retValue;
      }

      setTo = self.cfg.setTo || prop.setTo;

      if (setTo) {
        setTo[name] = retValue;
      }

      return retValue;
    },
    _wrapListener: function (ls, state, prop) {
      return function () {
        var args = toArray(arguments),
            i,
            l;

        for (i = 0, l = args.length; i < l; i++) {
          state["$" + (i + 1)] = args[i];
        }

        ls(state);

        for (i = 0, l = args.length; i < l; i++) {
          delete state["$" + (i + 1)];
        }
      };
    },
    _prepareValue: function (value, prop) {
      if (!prop.type) {
        return value;
      }

      if (value === true && prop.type !== "bool" && prop.type !== "boolean" && prop.defaultValue) {
        value = prop.defaultValue;
      }

      switch (prop.type) {
        case 'int':
          return parseInt(value);

        case 'float':
        case 'number':
          return parseFloat(value);

        case 'bool':
        case 'boolean':
          return toBool(value);

        case 'array':
        case 'list':
          return !isArray(value) ? [value] : value;

        case 'string':
        case 'str':
          return value === null || value === undefined ? "" : "" + value;
      }

      return value;
    },
    _onPropMutated: function (val, prev, name) {
      var self = this,
          prop = self.properties[name],
          setTo = prop.setTo || self.cfg.setTo,
          value;
      value = self._prepareValue(val, prop);
      self.values[name] = value;

      if (setTo) {
        setTo[name] = value;
      }

      $$observable.trigger(this.id, name, value, prev);
      $$observable.trigger(this.id + '-' + name, value, prev);
    },

    /**
     * Set Config's option
     * @method
     * @param {string} name 
     * @param {*} value 
     */
    setOption: function (name, value) {
      this.cfg[name] = value;
    },

    /**
     * Get config's option
     * @param {string} name 
     * @returns {*}
     */
    getOption: function (name) {
      return this.cfg[name];
    },

    /**
     * Add multiple properties to the config.
     * @param {object} properties {name: {cfg}}
     * @param {string} scalarAs {
     *  expression|defaultValue|value -- 
     *  if property comes as scalar value {name: value}, this
     *  option helps determine what to do with it, make an expression
     *  out of it, or use as default value.
     * }
     * @param {bool} override {
     *  Override existing settings
     *  @default true
     * }
     */
    addProperties: function (properties, scalarAs, override) {
      var prop, k, val, pb;

      for (k in properties) {
        val = properties[k];

        if (val === null || val === undefined) {
          continue;
        }

        if (MetaphorJs.app.prebuilt.isKey(val)) {
          pb = MetaphorJs.app.prebuilt.get("config", val);
          prop = {
            expression: val,
            prebuilt: pb
          };
        } // string can be a value or expression
        else if (typeof val === "string") {
          prop = {};
          prop[scalarAs || "expression"] = val;
        } // bool and int can only be a value
        else if (isPrimitive(val)) {
          prop = {
            defaultValue: val
          };
        } // objects can only describe properties
        else {
          prop = val;

          if (prop.expression && typeof prop.expression === "string" && !prop.mode && scalarAs === "defaultValue" && (!this.properties[k] || !this.properties[k].mode)) {
            prop.mode = MODE_DYNAMIC;
          }
        }

        this.setProperty(k, prop, undefined, override);
      }
    },

    /**
     * Set or update property
     * @method
     * @param {string} name 
     * @param {object} cfg {
     *  @type {string} type int|float|array|bool|string
     *  @type {object} setTo
     *  @type {object} state
     *  @type {boolean} disabled
     *  @type {*} defaultValue
     *  @type {*} value
     *  @type {int} defaultMode
     *  @type {int} mode MetaphorJs.lib.Config.MODE_***
     * }
     */

    /**
     * Set or update property
     * @method
     * @param {string} name 
     * @param {string} cfg 
     * @param {*} val 
     * @param {bool} override {
     *  @default true
     * }
     */
    setProperty: function (name, cfg, val, override) {
      var self = this,
          props = self.properties,
          prop,
          changed = false,
          newProp = false,
          changes = {},
          value;

      if (override === undefined) {
        override = true;
      }

      if (!props[name]) {
        props[name] = {};
        self.keys.push(name);
        changed = true;
        newProp = true;
      }

      if (!cfg) {
        cfg = {};
      }

      prop = props[name];

      if (prop.final === true) {
        return false;
      }

      if (val === undefined || val === null) {
        var k;

        for (k in cfg) {
          if (k === "value") {
            value = cfg[k];
            continue;
          } else if (prop[k] === undefined || cfg[k] !== prop[k] && override) {
            changes[k] = true;
            prop[k] = cfg[k];
          }
        }
      } else {
        if (cfg === "value") {
          value = val;
        } else if (prop[cfg] === undefined || prop[cfg] !== val && override) {
          changes[cfg] = true;
          prop[cfg] = val;
        }
      }

      if (!prop.mode) {
        if (prop.defaultMode) {
          prop.mode = prop.defaultMode;
          changed = true;
        } else if (prop.expression === true || prop.expression === false) {
          prop.mode = MODE_STATIC;
          changed = true;
        } else if (self.cfg.defaultMode) {
          prop.mode = self.cfg.defaultMode;
          changed = true;
        } else if (newProp && value !== undefined && value !== null) {
          prop.mode = MODE_STATIC;
        }
      }

      if (!prop.state) {
        prop.state = self.cfg.state;
      }

      if (prop.mode === MODE_DYNAMIC && prop.expression && !prop.mo && !prop.disabled) {
        self._initMo(name);
      }

      if (value !== undefined && value !== null) {
        self.values[name] = value;
      } else if (self.values[name] !== undefined) {
        if (changes.mode || changes.expression || !prop.mode && changes.defaultMode) {
          delete self.values[name];
        }
      }
    },

    /**
     * Get property config
     * @method
     * @param {string} name 
     * @returns {object}
     */
    getProperty: function (name) {
      return this.properties[name] || null;
    },

    /**
     * Create prop definition copy (without mutation observer)
     * @param {string} name 
     */
    copyProperty: function (name) {
      var prop = this.properties[name],
          cp;

      if (prop) {
        cp = extend({}, prop, false, false);
        cp.state = cp.state || this.cfg.state;
        delete cp['mo'];

        if (cp.mode === MODE_STATIC || !cp.mode && cp.defaultMode === cp.mode === MODE_STATIC || !cp.mode && !cp.defaultMode) {
          if (this.values[name] !== undefined) {
            cp.value = this.values[name];
          }
        }

        return cp;
      } else return null;
    },

    /**
     * Get property mode (or null, if not defined)
     * @method
     * @param {string} name 
     * @returns {int|null}
     */
    getMode: function (name) {
      var prop = this.getProperty(name);
      return prop ? prop.mode || null : null;
    },

    /**
     * Get property expression
     * @method
     * @param {string} name 
     */
    getExpression: function (name) {
      var prop = this.getProperty(name);
      return prop ? prop.expression || null : null;
    },

    /**
     * Get all config values
     * @method
     * @returns {object}
     */
    getAll: function () {
      var self = this,
          k,
          vs = {};

      for (k in self.properties) {
        if (!self._isValue(self.values[k])) {
          vs[k] = self._calcProperty(k);
        } else vs[k] = self.values[k];
      }

      return vs;
    },
    _isValue: function (v) {
      return v !== undefined && v !== null && !(typeof v === "number" && isNaN(v));
    },

    /**
     * Iterate over properties
     * @method
     * @param {function} fn {
     *  @param {string} key
     *  @param {object} property
     *  @param {MetaphorJs.lib.Config} self
     * } 
     * @param {object} context 
     */
    eachProperty: function (fn, context) {
      var k,
          self = this;

      for (k in self.properties) {
        fn.call(context, k, self.properties[k], self);
      }
    },

    /**
     * Does this config has a property
     * @method
     * @param {string} name 
     * @returns {bool}
     */
    hasProperty: function (name) {
      return !!this.properties[name];
    },

    /**
     * Does this config has a property with expression
     * @method
     * @param {string} name 
     * @returns {bool}
     */
    hasExpression: function (name) {
      return !!(this.properties[name] && (this.properties[name].expression || this.properties[name].prebuilt));
    },

    /**
     * Does this config has a value for given key
     * @param {string} name 
     * @returns {bool}
     */
    hasValue: function (name) {
      return this.values[name] !== undefined;
    },

    /**
     * Does this config has an expression to calc value or 
     * already calculated value or default value
     * @method
     * @param {string} name 
     * @returns {boolean}
     */
    has: function (name) {
      var self = this;
      return self._isValue(self.values[name]) || self.properties[name] && (self.properties[name].defaultValue !== undefined || self.properties[name].expression !== undefined || self.properties[name].prebuilt !== undefined);
    },
    _toggleProperty: function (name, val) {
      var self = this,
          prop = self.properties[name],
          prev = prop ? prop.disabled || false : false;

      if (!prop) {
        prop = self.setProperty(name, {
          disabled: val
        });
      } else if (prev !== val) {
        prop.mode === MODE_DYNAMIC && self[!val ? "_initMo" : "_unsetMo"](name);
        prop.disabled = val;
      }
    },

    /**
     * Disable MutationObserver on a property
     * @method
     * @param {string} name 
     */
    disableProperty: function (name) {
      this._toggleProperty(name, true);
    },

    /**
     * Enable MutationObserver on a property
     * @method
     * @param {string} name 
     */
    enableProperty: function (name) {
      this._toggleProperty(name, false);
    },

    /**
     * Remove config property and its value
     * @param {string} name 
     */
    removeProperty: function (name) {
      if (this.properties[name]) {
        this._toggleProperty(name, true);

        delete this.properties[name];
        delete this.values[name];
        var inx = this.keys.indexOf(name);

        if (inx !== -1) {
          this.keys.splice(inx, 1);
        }
      }
    },

    /**
     * Set property mode
     * @method
     * @param {string} name 
     * @param {int} mode 
     * @param {string|*} expression
     */
    setMode: function (name, mode, expression) {
      var prop = {
        mode: mode
      };

      if (expression !== undefined) {
        prop.expression = expression;
      }

      this.setProperty(name, prop);
    },

    /**
     * Set property type
     * @method
     * @param {string} name 
     * @param {string} type 
     * @param {int} defaultMode {
     *  @optional
     * }
     * @param {*} defaultValue {
     *  @optional
     * }
     * @param {bool} override {
     * @default true
     * }
     */
    setType: function (name, type, defaultMode, defaultValue, override) {
      if (type) {
        this.setProperty(name, "type", type, override);
      }

      if (defaultMode) {
        this.setProperty(name, "defaultMode", defaultMode, override);
      }

      if (defaultValue !== undefined) {
        this.setProperty(name, "defaultValue", defaultValue, override);
      }
    },

    /**
     * Set default mode
     * @method
     * @param {string} name 
     * @param {int} mode 
     * @param {bool} override {
     * @default true
     * }
     */
    setDefaultMode: function (name, mode, override) {
      this.setProperty(name, "defaultMode", mode, override);
    },

    /**
     * Set default value
     * @method
     * @param {string} name 
     * @param {*} val 
     * @param {bool} override {
     * @default true
     * }
     */
    setDefaultValue: function (name, val, override) {
      this.setProperty(name, "defaultValue", val, override);
    },

    /**
     * Transform property to dynamic mode if it is static
     * @param {string} name 
     * @param {string} expression 
     * @param {object|null} state {
     *  @optional
     * }
     */
    makeLocalDynamic: function (name, expression, state) {
      var self = this,
          prop,
          val;
      state = state || self.cfg.state;

      if (prop = self.properties[name]) {
        if (prop.final) {
          return;
        }

        if (!prop.mode || prop.mode === MODE_STATIC || prop.mode === MODE_SINGLE) {
          val = self.get(name);
          self.setProperty(name, {
            expression,
            mode: MODE_DYNAMIC,
            state
          });
          self.values[name] = val;
          self.set(name, val);
        }
      } else {
        self.setProperty(name, {
          expression,
          mode: MODE_DYNAMIC,
          state
        });
      }
    },

    /**
     * Force property to static mode with given value
     * @param {string} name 
     * @param {*} val 
     */
    setStatic: function (name, val) {
      var self = this;

      if (self.properties[name] && self.properties[name].final) {
        return;
      }

      var prev = self.values[val];
      self.setMode(name, MODE_STATIC);
      self.values[name] = val;

      if (prev != val) {
        $$observable.trigger(self.id, name, val, prev);
        $$observable.trigger(self.id + '-' + name, val, prev);
      }
    },

    /**
     * Lock the property
     * @param {string} name 
     */
    setFinal: function (name) {
      this.setProperty(name, "final", true);
    },

    /**
     * Try to set value based on property mode
     * @param {string} name 
     * @param {*} val 
     */
    set: function (name, val) {
      var self = this,
          prop;

      if (!self.properties[name]) {
        self.setProperty(name);
      }

      prop = self.properties[name];

      switch (prop.mode) {
        case MODE_DYNAMIC:
          {
            !prop.mo && self._initMo(name);
            prop.mo.setValue(val);
            break;
          }

        case MODE_GETTER:
        case MODE_FUNC:
        case MODE_SETTER:
        case MODE_FNSET:
          {
            throw new Error("Incompatible property mode");
          }

        case MODE_SINGLE:
        case MODE_STATIC:
          {
            self.setStatic(name, val);
            break;
          }

        default:
          {
            self.setStatic(name, val);
            break;
          }
      }
    },

    /**
     * Get property keys
     * @method
     * @returns {array}
     */
    getKeys: function () {
      return this.keys;
    },

    /**
     * Get all keys starting with "value"
     * @method
     */
    getAllValues: function () {
      var self = this,
          i,
          l,
          k,
          name,
          vs = {};

      for (i = 0, l = self.keys.length; i < l; i++) {
        k = self.keys[i];

        if (k === "value") {
          name = "";
        } else if (k.indexOf("value.") === 0) {
          name = k.replace("value.", "");
        } else continue;

        vs[name] = self.get(k);
      }

      return vs;
    },

    /**
     * Get property value
     * @method
     * @param {string} name 
     * @returns {*}
     */
    get: function (name) {
      if (!this._isValue(this.values[name])) {
        return this._calcProperty(name);
      }

      return this.values[name];
    },

    /**
     * @method on
     * @param {string} name 
     * @param {function} fn {
     *  @param {*} currentValue
     *  @param {*} prevValue
     * }
     * @param {object} context fn's context
     * @param {object} opt MetaphorJs.lib.Observable.on() options
     */

    /**
    * @method on
    * @param {function} fn {
    *  @param {string} name
    *  @param {*} currentValue
    *  @param {*} prevValue
    * }
    * @param {object} context fn's context
    * @param {object} opt MetaphorJs.lib.Observable.on() options
    */
    on: function (name, fn, context, opt) {
      if (typeof name === "string") {
        $$observable.on(this.id + '-' + name, fn, context, opt);
      } else {
        $$observable.on(this.id, name, fn, context);
      }
    },

    /**
     * @method un
     * @param {string} name 
     * @param {function} fn
     * @param {object} context 
     */

    /**
    * @method un
    * @param {function} fn 
    * @param {object} context 
    */
    un: function (name, fn, context) {
      if (typeof name === "string") {
        $$observable.on(this.id + '-' + name, fn, context);
      } else {
        $$observable.on(this.id, name, fn);
      }
    },

    /**
     * Set property values to this object
     * @method
     * @param {object} obj 
     */
    setTo: function (obj) {
      this.cfg.setTo = obj;
    },

    /**
     * Import properties and values from another config
     * @method
     * @param {MetaphorJs.lib.Config} config 
     */
    importConfig: function (config, overwrite) {
      var name,
          ps = this.properties,
          vs = this.values;

      for (name in config.properties) {
        if (config.properties.hasOwnProperty(name)) {
          if (ps[name] && !overwrite) {
            continue;
          }

          ps[name] = extend({}, config.properties[name]);
          vs[name] = config.values[name];
        }
      }
    },

    /**
     * Create a new config with given properties
     * @method
     * @param {array} props
     * @param {object} cfg override new config cfg with these values
     * @returns MetaphorJs.lib.Config
     */
    slice: function (props, overrideCfg) {
      var map = {},
          self = this,
          name,
          i,
          l,
          values = {},
          existing = self.properties;

      for (i = 0, l = props.length; i < l; i++) {
        name = props[i];

        if (existing[name]) {
          map[name] = extend({}, existing[name], false, false);
          values[name] = self.values[name];
          delete map[name].mo;
        }
      }

      var newCfg = new Config(map, extend({}, self.cfg, overrideCfg, true, false));
      newCfg.values = values;
      return newCfg;
    },

    /**
     * Check for changes of specific property
     * @method
     * @param {string} name 
     * @returns {bool}
     */

    /**
     * Check for changes
     * @method
     * @returns {int} number of changed properties
     */
    check: function (name) {
      var self = this,
          keys = name ? [name] : self.keys,
          i,
          l,
          key,
          prop,
          res = name ? 0 : false;

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        prop = self.properties[key];

        if (prop.mo) {
          if (name) {
            return prop.mo.check();
          }

          res += prop.mo.check() ? 1 : 0;
        }
      }

      return res;
    },

    /**
     * Check state based on property opts 
     * (does it require checking parent or root)
     * @method
     * @param {string} propName 
     */
    checkState: function (propName) {
      const prop = this.properties[propName];

      if (!prop) {
        return;
      }

      const state = prop.state || this.cfg.state,
            descr = prop.prebuilt ? prop.prebuilt.descr || "" : MetaphorJs.lib.Expression.describeExpression(this.getExpression(propName));

      if (descr.indexOf("r") !== -1) {
        return state.$root.$check();
      } else if (descr.indexOf("p") !== -1) {
        return state.$parent ? state.$parent.$check() : state.$root.$check();
      } else {
        return state.$check();
      }
    },

    /**
     * Stop all observers, clear data, remove listeners.
     * But keep values and properties
     * @method
     */
    clear: function () {
      var self = this,
          id = self.id,
          k;

      if (self.properties === null) {
        return;
      }

      for (k in self.properties) {
        self._unsetMo(k);

        $$observable.destroyEvent(id + '-' + k);
      }

      $$observable.destroyEvent(id);
      self.subscribe = emptyFn;
      self.unsubscribe = emptyFn;
    },

    /**
     * @method
     * @returns {bool}
     */
    $isDestroyed: function () {
      return this.properties === null;
    },

    /**
     * @method
     */
    $destroy: function () {
      var self = this;

      if (self.properties !== null) {
        self.clear();
      }

      self.properties = null;
      self.values = null;
      self.cfg = null;
    }
  });
  /**
   * @property MetaphorJs.lib.Config.MODE_STATIC
   * @static
   * Do not calculate value, use whatever provided or default value
   */

  Config.MODE_STATIC = MODE_STATIC;
  /**
   * @property MetaphorJs.lib.Config.MODE_DYNAMIC
   * @static
   * Calculate value and watch for changes
   */

  Config.MODE_DYNAMIC = MODE_DYNAMIC;
  /**
   * @property MetaphorJs.lib.Config.MODE_SINGLE
   * @static
   * Calculate value once 
   */

  Config.MODE_SINGLE = MODE_SINGLE;
  /**
   * @property MetaphorJs.lib.Config.MODE_GETTER
   * @static
   * Treat value as expression, return a function that executes expression
   * that returns value
   */

  Config.MODE_GETTER = MODE_GETTER;
  /**
   * @property MetaphorJs.lib.Config.MODE_SETTER
   * @static
   * Treat value as expression, return a setter function that executes expression
   * that sets value
   */

  Config.MODE_SETTER = MODE_SETTER;
  /**
   * @property MetaphorJs.lib.Config.MODE_FUNC
   * @static
   * Treat value as expression, return a function that executes expression
   */

  Config.MODE_FUNC = MODE_FUNC;
  /**
   * @property MetaphorJs.lib.Config.MODE_FNSET
   * @static
   * Treat value as expression, return an object with
   * both setter and getter functions
   */

  Config.MODE_FNSET = MODE_FNSET;
  /**
   * @property MetaphorJs.lib.Config.MODE_LISTENER
   * @static
   * Treat value as expression. If expression is a reference to a function, 
   * return this function. Else, return a wrapper function that is executed
   * in current state (config's or property's) and has all passed arguments
   * as this.$1, this.$2, etc.
   */

  Config.MODE_LISTENER = MODE_LISTENER;

  Config.create = function (properties, cfg, scalarAs) {
    if (properties instanceof Config) {
      return properties;
    }

    return new Config(properties, cfg, scalarAs);
  };

  return Config;
}();

/***/ }),

/***/ "../metaphorjs/src/lib/DomEvent.js":
/*!*****************************************!*\
  !*** ../metaphorjs/src/lib/DomEvent.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const returnFalse = __webpack_require__(/*! metaphorjs-shared/src/func/returnFalse.js */ "../metaphorjs-shared/src/func/returnFalse.js"),
      returnTrue = __webpack_require__(/*! metaphorjs-shared/src/func/returnTrue.js */ "../metaphorjs-shared/src/func/returnTrue.js"),
      isNull = __webpack_require__(/*! metaphorjs-shared/src/func/isNull.js */ "../metaphorjs-shared/src/func/isNull.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"); // from jQuery

/**
 * Dom event wrapper.
 * @class MetaphorJs.lib.DomEvent
 */

/**
 * @method DomEvent
 * @constructor
 * @param {Event} src Native event
 */


module.exports = MetaphorJs.lib.DomEvent = function () {
  var DomEvent = function DomEvent(src) {
    if (src instanceof DomEvent) {
      return src;
    } // Allow instantiation without the 'new' keyword


    if (!(this instanceof DomEvent)) {
      return new DomEvent(src);
    }

    var self = this;

    for (var i in src) {
      if (!self[i]) {
        try {
          self[i] = src[i];
        } catch (thrownError) {}
      }
    } // Event object


    self.originalEvent = src;
    self.type = src.type;

    if (!self.target && src.srcElement) {
      self.target = src.srcElement;
    }

    var eventDoc,
        doc,
        body,
        button = src.button; // Calculate pageX/Y if missing and clientX/Y available

    if (self.pageX === undefined && !isNull(src.clientX)) {
      eventDoc = self.target ? self.target.ownerDocument || window.document : window.document;
      doc = eventDoc.documentElement;
      body = eventDoc.body;
      self.pageX = src.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      self.pageY = src.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    } // Add which for click: 1 === left; 2 === middle; 3 === right
    // Note: button is not normalized, so don't use it


    if (!self.which && button !== undefined) {
      self.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
    } // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.


    self.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android<4.0
    src.returnValue === false ? returnTrue : returnFalse; // Create a timestamp if incoming event doesn't have one

    self.timeStamp = src && src.timeStamp || new Date().getTime();
  }; // Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


  extend(DomEvent.prototype, {
    /**
     * @method isDefaultPrevented
     * @returns {boolean}
     */
    isDefaultPrevented: returnFalse,

    /**
     * @method isPropagationStopped
     * @returns {boolean}
     */
    isPropagationStopped: returnFalse,

    /**
     * @method isImmediatePropagationStopped
     * @returns {boolean}
     */
    isImmediatePropagationStopped: returnFalse,

    /**
     * @method
     */
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      e.returnValue = false;

      if (e && e.preventDefault) {
        e.preventDefault();
      }
    },

    /**
     * @method
     */
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      e.cancelBubble = true;

      if (e && e.stopPropagation) {
        e.stopPropagation();
      }
    },

    /**
     * @method
     */
    stopImmediatePropagation: function () {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;

      if (e && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }

      this.stopPropagation();
    }
  }, true, false);
  return DomEvent;
}();

/***/ }),

/***/ "../metaphorjs/src/lib/EventBuffer.js":
/*!********************************************!*\
  !*** ../metaphorjs/src/lib/EventBuffer.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-observable/src/lib/Observable.js */ "../metaphorjs-observable/src/lib/Observable.js");

__webpack_require__(/*! ../func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! ../func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

__webpack_require__(/*! ../func/dom/getWidth.js */ "../metaphorjs/src/func/dom/getWidth.js");

__webpack_require__(/*! ../func/dom/getHeight.js */ "../metaphorjs/src/func/dom/getHeight.js");

__webpack_require__(/*! ../func/dom/getScrollTop.js */ "../metaphorjs/src/func/dom/getScrollTop.js");

__webpack_require__(/*! ../func/dom/getScrollLeft.js */ "../metaphorjs/src/func/dom/getScrollLeft.js");

const bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      raf = __webpack_require__(/*! metaphorjs-animate/src/func/raf.js */ "../metaphorjs-animate/src/func/raf.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Allows you to subscribe to a dom event and call handler
 * no sooner than given interval;<br>
 * Also you can subscribe to a specific change: like media query in css.
 * @class MetaphorJs.lib.EventBuffer
 */


module.exports = MetaphorJs.lib.EventBuffer = function () {
  var bufferKey = function (event, interval) {
    return '$$' + event + "_" + interval;
  };
  /**
   * @method EventBuffer
   * @constructor
   * @param {HTMLElement} node 
   * @param {string} event Dom event name
   * @param {int} interval 
   * @param {object} eventOptions
   */


  var EventBuffer = function (node, event, interval, eventOpts) {
    var self = this,
        key = bufferKey(event, interval);

    if (node[key]) {
      return node[key];
    }

    node[key] = self;
    self.eventOptions = eventOpts || {};
    self.id = key;
    self.breaks = {};
    self.watchers = {};
    self.node = node;
    self.event = event;
    self.observable = new MetaphorJs.lib.Observable();
    self.interval = interval || 0;
    self.handlerDelegate = bind(self.handler, self);
    self.triggerDelegate = bind(self.trigger, self);
    self.up();
  };

  extend(EventBuffer.prototype, {
    observable: null,
    handlerDelegate: null,
    triggerDelegate: null,
    watchers: null,
    breaks: null,
    running: false,
    lastEvent: null,
    currentEvent: null,
    interval: null,
    id: null,
    handler: function (e) {
      var self = this;

      if (self.running) {
        if (e) {
          self.lastEvent = e;
        }
      } else {
        self.next(e);
      }
    },
    next: function (e) {
      var self = this,
          itv = self.interval;
      e = e || self.lastEvent;

      if (!e) {
        return;
      }

      self.lastEvent = null;
      self.running = true;
      self.currentEvent = e;

      if (itv === "raf") {
        raf(self.triggerDelegate);
      } else {
        setTimeout(self.triggerDelegate, itv);
      }
    },

    /**
     * Shorthand for adding width watcher
     * @method
     */
    watchWidth: function () {
      this.addWatcher("width", MetaphorJs.dom.getWidth);
    },

    /**
     * Shorthand for adding height watcher
     * @method
     */
    watchHeight: function () {
      this.addWatcher("height", MetaphorJs.dom.getHeight);
    },

    /**
     * Shorthand for adding scrolltop watcher
     * @method
     */
    watchScrollTop: function () {
      this.addWatcher("scrollTop", MetaphorJs.dom.getScrollTop);
    },

    /**
     * Shorthand for adding scrollleft watcher
     * @method
     */
    watchScrollLeft: function () {
      this.addWatcher("scrollLeft", MetaphorJs.dom.getScrollLeft);
    },

    /**
     * Add your own watcher
     * @method
     * @param {string} name Watcher name
     * @param {function} fn {
     *  @param {HTMLElement} node
     * }
     * @param {object} context fn's context
     */
    addWatcher: function (name, fn, context) {
      if (!this.watchers[name]) {
        this.watchers[name] = {
          fn: fn,
          context: context,
          prev: null,
          current: parseInt(fn.call(context, this.node), 10)
        };
      }
    },

    /**
     * Remove watcher
     * @method
     * @param {string} name
     */
    removeWatcher: function (name) {
      delete this.watchers[name];
    },
    breakFilter: function (l, args, event) {
      if (!this.watchers[event.watcher]) {
        return false;
      }

      var self = this,
          breakValue = l.breakValue,
          luft = l.breakLuft || 0,
          lowLuft = l.breakLowLuft || luft,
          highLuft = l.breakHighLuft || luft,
          lowBreak = breakValue - lowLuft,
          highBreak = breakValue + highLuft,
          w = self.watchers[event.watcher],
          current = w.current,
          prev = w.prev,
          min = Math.min(prev, current),
          max = Math.max(prev, current);

      if (breakValue === "!=") {
        return prev != current;
      }

      args[0].breakPosition = current < lowBreak ? -1 : current >= highBreak ? 1 : 0;
      return min <= lowBreak && lowBreak <= max || min <= highBreak && highBreak <= max;
    },

    /**
     * Add break listener (media query stop)
     * @method
     * @param {string} watcher Watcher name
     * @param {int} breakValue 
     * @param {function} fn {
     *  Listener function
     *  @param {Event} event Native dom event
     * }
     * @param {object} context fn's context
     * @param {object} options Options are passed to 
     * MetaphorJs.lib.Observable.on()
     */
    onBreak: function (watcher, breakValue, fn, context, options) {
      var self = this,
          name = watcher + "_" + breakValue;
      options = options || {};
      options.breakValue = breakValue;

      if (!self.breaks[name]) {
        self.breaks[name] = self.observable.createEvent(name, {
          watcher: watcher,
          triggerFilter: self.breakFilter,
          filterContext: self
        });
      }

      self.breaks[name].on(fn, context, options);
    },

    /**
     * Unsubscribe from a break
     * @method
     * @param {string} watcher Watcher name
     * @param {int} breakValue 
     * @param {function} fn
     * @param {object} context fn's context
     * @param {boolean} destroy Destroy if there are no more listeners
     */
    unBreak: function (watcher, breakValue, fn, context, destroy) {
      var self = this,
          name = watcher + "_" + breakValue;

      if (self.breaks[name]) {
        self.breaks[name].un(fn, context);

        if (!self.breaks[name].hasListener()) {
          self.observable.destroyEvent(name);
          self.breaks[name] = null;
          delete self.breaks[name];
        }
      }

      if (destroy) {
        self.destroyIfIdle();
      }
    },

    /**
     * Subscribe to dom event
     * @method
     * @param {function} fn {
     *  @param {Event} event 
     * }
     * @param {object} context fn's context
     * @param {object} options Observable's options
     */
    on: function (fn, context, options) {
      this.observable.on(this.event, fn, context, options);
    },

    /**
     * Ubsubscribe from dom event
     * @method
     * @param {function} fn 
     * @param {object} context fn's context
     * @param {boolean} destroy Destroy if there are no more listeners
     */
    un: function (fn, context, destroy) {
      var self = this;
      self.observable.un(self.event, fn, context);

      if (destroy) {
        self.destroyIfIdle();
      }
    },
    trigger: function () {
      var self = this,
          e = self.currentEvent,
          ws = self.watchers,
          bs = self.breaks,
          node = self.node,
          w,
          b;
      self.observable.trigger(self.event, e);

      for (w in ws) {
        ws[w].prev = ws[w].current;
        ws[w].current = parseInt(ws[w].fn.call(ws[w].context, node, e), 10);
      }

      for (b in bs) {
        bs[b].trigger(e);
      }

      self.running = false;
      self.currentEvent = null;
      self.next();
    },

    /**
     * Start listening to DOM event. (Called automatically from constructor)
     * @method
     */
    up: function () {
      var self = this;
      MetaphorJs.dom.addListener(self.node, self.event, self.handlerDelegate, self.eventOptions);
    },

    /**
     * Stop listening to DOM event
     * @method
     */
    down: function () {
      var self = this;
      MetaphorJs.dom.removeListener(self.node, self.event, self.handlerDelegate);
    },

    /**
     * Destroy if there are no listeners
     * @method
     */
    destroyIfIdle: function () {
      if (this.observable && !this.observable.hasListener()) {
        this.$destroy();
        return true;
      }
    },

    /**
     * @method
     */
    $destroy: function () {
      var self = this;
      delete self.node[self.id];
      self.down();
      self.observable.$destroy();
    }
  });
  /**
   * Get existing event buffer
   * @method get
   * @static
   * @param {HTMLElement} node 
   * @param {string} event 
   * @param {int} interval 
   * @param {object} eventOptions
   * @returns {MetaphorJs.lib.EventBuffer}
   */

  EventBuffer.get = function (node, event, interval, eventOpts) {
    var key = bufferKey(event, interval);

    if (node[key]) {
      return node[key];
    }

    return node[key] = new EventBuffer(node, event, interval, eventOpts);
  };

  return EventBuffer;
}();

/***/ }),

/***/ "../metaphorjs/src/lib/EventHandler.js":
/*!*********************************************!*\
  !*** ../metaphorjs/src/lib/EventHandler.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! ../func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

__webpack_require__(/*! ../func/dom/normalizeEvent.js */ "../metaphorjs/src/func/dom/normalizeEvent.js");

__webpack_require__(/*! ../func/dom/is.js */ "../metaphorjs/src/func/dom/is.js");

__webpack_require__(/*! ./EventBuffer.js */ "../metaphorjs/src/lib/EventBuffer.js");

__webpack_require__(/*! ./Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ./MutationObserver.js */ "../metaphorjs/src/lib/MutationObserver.js");

const extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      async = __webpack_require__(/*! metaphorjs-shared/src/func/async.js */ "../metaphorjs-shared/src/func/async.js"),
      isPlainObject = __webpack_require__(/*! metaphorjs-shared/src/func/isPlainObject.js */ "../metaphorjs-shared/src/func/isPlainObject.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * Handles events as they come defined in html templates
 * @class MetaphorJs.lib.EventHandler
 */

/**
 * @method EventHandler
 * @constructor
 * @param {string} event Dom event name
 * @param {MetaphorJs.lib.State} state 
 * @param {HTMLElement} node 
 * @param {MetaphorJs.lib.Config} cfg MetaphorJs.lib.Config
 */


MetaphorJs.lib.EventHandler = function (event, state, node, cfg) {
  var self = this;
  self.config = cfg;
  self.event = event;
  self.prevEvent = {};
  self.state = state;
  self.node = node;
  self.handler = null;
  self.buffer = null;

  if (cfg.hasExpression("if")) {
    cfg.on("if", self.onIfChange, self);
  }

  self.up();
};

extend(MetaphorJs.lib.EventHandler.prototype, {
  $destroyed: false,
  $destroying: false,
  onIfChange: function (val) {
    this[val ? "up" : "down"]();
  },
  createHandler: function () {
    var self = this,
        state = self.state,
        config = self.config,
        asnc;

    var handler = function (e) {
      if (self.$destroyed || self.$destroying) {
        return;
      }

      var keyCode,
          preventDefault = false,
          returnValue = undefined,
          stopPropagation = false,
          stopImmediate = false,
          res,
          cfg = config.getAll(),
          not = cfg.not,
          handlers = [],
          names = [],
          skipHandler = false,
          handler,
          i,
          l;
      config.eachProperty(function (name) {
        if (name.indexOf("value") === 0) {
          handlers.push(config.get(name));
          names.push(name);
        }
      });
      cfg.preventDefault !== undefined && (preventDefault = cfg.preventDefault);
      cfg.stopPropagation !== undefined && (stopPropagation = cfg.stopPropagation);
      cfg.stopImmediatePropagation !== undefined && (stopImmediate = cfg.stopImmediatePropagation);
      cfg.returnValue !== undefined && (returnValue = cfg.returnValue);
      cfg.keyCode !== undefined && (keyCode = cfg.keyCode);
      e = MetaphorJs.dom.normalizeEvent(e || window.event);

      if (not) {
        if (!isArray(not)) {
          not = [not];
        }

        var prnt;

        nt: for (i = 0, l = not.length; i < l; i++) {
          prnt = e.target;

          while (prnt && prnt !== self.node) {
            if (MetaphorJs.dom.is(prnt, not[i])) {
              skipHandler = true;
              break nt;
            }

            prnt = prnt.parentNode;
          }
        }
      }

      if (keyCode) {
        if (typeof keyCode === "number" && keyCode !== e.keyCode) {
          return null;
        } else if (keyCode.indexOf(e.keyCode) === -1) {
          return null;
        }
      }

      state.$event = e;
      state.$eventNode = self.node;
      state.$prevEvent = self.prevEvent[e.type];
      state.$eventCmp = config.get("targetComponent");

      if (!skipHandler && handlers.length > 0) {
        for (i = 0, l = handlers.length; i < l; i++) {
          handler = handlers[i];
          res = handler.call(cfg.context || null, state);

          if (res && isPlainObject(res)) {
            res.preventDefault !== undefined && (preventDefault = res.preventDefault);
            res.stopPropagation !== undefined && (stopPropagation = res.stopPropagation);
            res.returnValue !== undefined && (returnValue = res.returnValue);
          }
        }
      }

      stopPropagation && e.stopPropagation();
      stopImmediate && e.stopImmediatePropagation && e.stopImmediatePropagation();
      preventDefault && e.preventDefault();

      if (self.$destroyed || self.$destroying) {
        return returnValue !== undefined ? returnValue : undefined;
      }

      state.$event = null;
      state.$eventNode = null;
      state.$eventCmp = null;
      self.prevEvent[e.type] = e;

      for (i = 0, l = names.length; i < l; i++) {
        config.checkState(names[i]);
      }

      if (returnValue !== undefined) {
        return returnValue;
      }
    };

    if (asnc = self.config.get("async")) {
      return function (e) {
        async(handler, null, [e], typeof asnc == "number" ? asnc : null);
      };
    } else {
      return handler;
    }
  },

  /**
   * Start listening to event
   * @method
   */
  up: function () {
    var self = this,
        cfg = self.config,
        buffer = cfg.get("buffer");

    if (!cfg.hasExpression("if") || cfg.get('if')) {
      self.handler = self.createHandler();

      if (buffer) {
        self.buffer = MetaphorJs.lib.EventBuffer.get(self.node, self.event, buffer, self._getEventConfig());
        self.buffer.on(self.handler);
      } else {
        MetaphorJs.dom.addListener(self.node, self.event, self.handler, self._getEventConfig());
      }
    }
  },

  /**
   * Stop listening to event
   * @method
   */
  down: function () {
    var self = this;

    if (self.buffer) {
      self.buffer.un(self.handler);
      self.buffer.destroyIfIdle();
      self.buffer = null;
    } else {
      MetaphorJs.dom.removeListener(self.node, self.event, self.handler);
    }
  },
  _getEventConfig: function () {
    var opts = {};

    if (this.config.hasExpression("passive")) {
      opts.passive = this.config.get("passive");
    }

    return opts;
  },

  /**
   * @method
   */
  $destroy: function () {
    var self = this;

    if (self.$destroyed || self.$destroying) {
      return;
    }

    self.$destroying = true;
    self.down();
    self.config.clear();
    self.$destroying = false;
    self.$destroyed = true;
  }
});
module.exports = MetaphorJs.lib.EventHandler;

/***/ }),

/***/ "../metaphorjs/src/lib/Expression.js":
/*!*******************************************!*\
  !*** ../metaphorjs/src/lib/Expression.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      error = __webpack_require__(/*! metaphorjs-shared/src/func/error.js */ "../metaphorjs-shared/src/func/error.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js"),
      split = __webpack_require__(/*! metaphorjs-shared/src/func/split.js */ "../metaphorjs-shared/src/func/split.js");

__webpack_require__(/*! ../filter/__init.js */ "../metaphorjs/src/filter/__init.js");

module.exports = MetaphorJs.lib.Expression = function () {
  var REG_REPLACE_EXPR = /((^|[^a-z0-9_$\]\)'"])|(this))(\.)([^0-9])/ig,
      REG_REPLACER = "$2____.$5",
      fnBodyStart = '',
      fnBodyEnd = '',
      //fnBodyStart = 'try {',
  //fnBodyEnd = ';} catch (thrownError) { ' +
  //'/*DEBUG-START*/console.log("expr");console.log(thrownError);/*DEBUG-END*/' +
  //'return undefined; }',
  cache = {},
      cacheEnabled = true,
      descrCache = {},
      filterSources = [],
      isPrebuiltKey = function (expr) {
    return typeof expr === "string" && expr.substring(0, 2) === '--';
  },
      isAtom = function (expr) {
    return !expr.trim().match(/[^a-zA-Z0-9_$'"\(\)\[\]\.;]/);
  },
      isProperty = function (expr) {
    var match = expr.match(/^this\.([a-zA-Z0-9_$]+)$/);
    return match ? match[1] : false;
  },
      isStatic = function (val) {
    if (!isString(val)) {
      return {
        value: val
      };
    }

    var first = val.substr(0, 1),
        last = val.length - 1,
        num;

    if (first === '"' || first === "'") {
      if (val.indexOf(first, 1) === last) {
        return {
          value: val.substring(1, last)
        };
      }
    } else if (val === 'true' || val === 'false') {
      return {
        value: val === 'true'
      };
    } else if ((num = parseFloat(val)) == val) {
      return {
        value: num
      };
    }

    return false;
  },
      getFilter = function (name, filters) {
    if (filters) {
      if (isArray(filters)) {
        filters = filters.concat(filterSources);
      } else if (filters.hasOwnProperty(name) && typeof filters[name] === "function") {
        return filters[name];
      } else {
        filters = filterSources;
      }
    } else {
      filters = filterSources;
    }

    var i,
        l = filters.length;

    for (i = 0; i < l; i++) {
      if (filters[i] && filters[i].hasOwnProperty(name)) {
        return filters[i][name];
      }
    }

    return null;
  },
      expression = function (expr, opt) {
    opt = opt || {};

    if (typeof opt === "string" && opt === "setter") {
      opt = {
        setter: true
      };
    }

    if (!cacheEnabled) {
      cache = {};
    }

    var asCode = opt.asCode === true,
        isSetter = opt.setter === true,
        noReturn = opt.noReturn === true,
        cacheKey;

    if (isStatic(expr)) {
      cacheKey = expr + "_static";
      noReturn && (cacheKey += "_noret");

      if (cache[cacheKey] && !asCode) {
        return cache[cacheKey];
      }

      if (isSetter) {
        throw new Error("Static value cannot work as setter");
      }

      if (asCode) {
        return "".concat("function() {", "return ", expr, "}");
      } //expr = expr.replace(/\\([\s\S])|(")/g,"\\$1$2")


      return cache[cacheKey] = new Function("", "return " + expr);
    }

    try {
      var atom = isAtom(expr);
      cacheKey = expr + "_" + (isSetter ? "setter" : noReturn ? "func" : "getter");
      noReturn && (cacheKey += "_noret");

      if (!atom && isSetter) {
        throw new Error("Complex expression cannot work as setter");
      }

      if (!cache[cacheKey] || asCode) {
        var code = expr.replace(REG_REPLACE_EXPR, REG_REPLACER),
            body = !atom || !isSetter ? "".concat(fnBodyStart, noReturn ? '' : 'return ', code, fnBodyEnd) : "".concat(fnBodyStart, //noReturn ? '' : 'return ', 
        code, ' = $$$$', fnBodyEnd);
        /*DEBUG-START*/

        var esc = expr.replace(/\n/g, '\\n');
        esc = esc.replace(/\r/g, '\\r');
        esc = esc.replace(/'/g, "\\'");
        esc = esc.replace(/"/g, '\\"');
        body = body.replace('"expr"', '"' + esc + '"');
        /*DEBUG-END*/

        if (asCode) {
          return "function(____, $$$$) {" + body + "}";
        } else {
          cache[cacheKey] = new Function('____', '$$$$', body);
        }
      }

      return cache[cacheKey];
    } catch (thrownError) {
      error(new Error("Error parsing expression: " + expr + "; \n\n\n" + body));
      error(thrownError);
      return emptyFn;
    }
  },
      preparePipe = function (pipe, filters) {
    var name = pipe.shift(),
        fn = isFunction(name) ? name : null,
        params = [],
        exprs = [],
        fchar = fn ? null : name.substr(0, 1),
        opt = {
      neg: false,
      dblneg: false,
      undeterm: false,
      name: name
    },
        i,
        l;

    if (!fn) {
      if (name.substr(0, 2) === "!!") {
        name = name.substr(2);
        opt.dblneg = true;
      } else {
        if (fchar === "!") {
          name = name.substr(1);
          opt.neg = true;
        } else if (fchar === "?") {
          name = name.substr(1);
          opt.undeterm = true;
        }
      }

      opt.name = name;
    } else {
      opt.name = fn.name;
    }

    !fn && (fn = getFilter(name, filters));

    if (isFunction(fn)) {
      for (i = -1, l = pipe.length; ++i < l; params.push(expressionFn(pipe[i]))) {
        if (!isStatic(pipe[i])) {
          exprs.push(pipe[i]);
        }
      }

      if (fn.$undeterministic) {
        opt.undeterm = true;
      }

      return {
        fn: fn,
        origArgs: pipe,
        params: params,
        expressions: exprs,
        opt: opt
      };
    }

    return null;
  },
      parsePipes = function (expr, isInput, filters) {
    var separator = isInput ? ">>" : "|";

    if (expr.indexOf(separator) === -1) {
      return expr;
    }

    var parts = split(expr, separator),
        ret = isInput ? parts.pop() : parts.shift(),
        pipes = [],
        pipe,
        i,
        l;

    for (i = 0, l = parts.length; i < l; i++) {
      pipe = split(parts[i].trim(), ':');
      pipe = preparePipe(pipe, filters);
      pipe && pipes.push(pipe);
    }

    return {
      expr: ret.trim(),
      pipes: pipes
    };
  },
      _initSetter = function (struct) {
    struct.setterFn = expressionFn(struct.expr, {
      setter: true
    });
  },
      deconstructor = function (expr, opt) {
    opt = opt || {};
    var isNormalPipe = expr.indexOf("|") !== -1,
        isInputPipe = expr.indexOf(">>") !== -1,
        res,
        struct = {
      fn: null,
      getterFn: null,
      setterFn: null,
      expr: expr,
      pipes: [],
      inputPipes: []
    };

    if (!isNormalPipe && !isInputPipe && opt.setter !== true) {
      struct[opt.noReturn ? "fn" : "getterFn"] = expressionFn(expr, opt);
      return struct;
    }

    if (isNormalPipe) {
      res = parsePipes(expr, false, opt.filters);
      expr = res.expr;
      struct.pipes = res.pipes;
    }

    if (isInputPipe) {
      res = parsePipes(expr, true, opt.filters);
      expr = res.expr;
      struct.inputPipes = res.pipes;
      opt.setter = true;
    }

    if (opt.setter === true) {
      struct.setterFn = expressionFn(expr, opt);
      opt.setter = false;
    }

    struct[opt.noReturn ? "fn" : "getterFn"] = expressionFn(expr, opt);
    return struct;
  },
      runThroughPipes = function (val, pipes, dataObj) {
    var j,
        args,
        pipe,
        jlen = pipes.length,
        z,
        zl;

    for (j = 0; j < jlen; j++) {
      pipe = pipes[j];
      !pipe.fn && pipe.opt.name && (pipe.fn = getFilter(pipe.opt.name));
      args = [];

      for (z = -1, zl = pipe.params.length; ++z < zl; args.push(pipe.params[z](dataObj))) {}

      args.unshift(dataObj);
      args.unshift(val);
      val = pipe.fn.apply(dataObj, args);

      if (pipe.opt.neg) {
        val = !val;
      } else if (pipe.opt.dblneg) {
        val = !!val;
      }
    }

    return val;
  },
      constructor = function (struct, opt) {
    opt = opt || {};

    if (struct.pipes.length === 0 && struct.inputPipes.length === 0) {
      if (opt.setterOnly) {
        !struct.setterFn && _initSetter(struct);
        return struct.setterFn;
      }

      return struct.getterFn || struct.fn;
    }

    return function (dataObj, inputVal) {
      var val;

      if (struct.inputPipes.length && !opt.getterOnly) {
        val = inputVal;
        val = runThroughPipes(val, struct.inputPipes, dataObj);
        !struct.setterFn && _initSetter(struct);
        struct.setterFn(dataObj, val);
      }

      if (struct.pipes && !opt.setterOnly) {
        val = struct.getterFn(dataObj);
        val = runThroughPipes(val, struct.pipes, dataObj);
      }

      return val;
    };
  },
      expressionFn,
      parserFn,
      deconstructorFn,
      constructorFn,
      parser = function (expr, opt) {
    return constructorFn(typeof expr === "string" ? deconstructorFn(expr, opt) : expr, opt);
  },
      reset = function () {
    parserFn = parser;
    deconstructorFn = deconstructor;
    constructorFn = constructor;
    expressionFn = expression;
  };

  if (MetaphorJs.filter) {
    filterSources.push(MetaphorJs.filter);
  }

  if (typeof window !== "undefined") {
    filterSources.push(window);
  }

  reset();
  /**
   * @object MetaphorJs.expression
   */

  return {
    /**
     * Set your code parser
     * @property {function} setExpressionFn {
     *  @param {function} expression {
     *      @param {string} expression A single piece of code that 
     *              gets or sets data and doesn't contain pipes
     *      @param {object} options {
     *          @type {boolean} asCode return code as string
     *      }
     *      @returns {function} {
     *          @param {object} dataObj Data object to execute expression against
     *          @param {*} value Optional value which makes function a setter
     *          @returns {*} value of expression on data object
     *      }
     *  }
     * }
     */
    setExpressionFn: function (expression) {
      expressionFn = expression;
    },

    /**
     * Get expression parser
     * @property {function} getExpressionFn {
     *  @returns {function} See setExpressionFn
     * }
     */
    getExpressionFn: function () {
      return expressionFn;
    },

    /**
     * Set deconstructor function that returns set of prepared pipes
     * @property {function} setDeconstructorFn {
     *  @param {function} deconstructor {
     *      @param {string} expression
     *      @param {object} filters {
     *          Optional set of filters (pipes)
     *      }
     *      @returns {object} {
     *          @type {function} expr {
     *              @param {object} dataObj Data object to execute expression against
     *              @param {*} value Optional value which makes function a setter
     *              @returns {*} value of expression on data object
     *          }
     *          @type {array} pipes {
     *              @type {function} fn {
     *                  Filter function
     *                  @param {*} inputValue
     *                  @param {object} dataObj 
     *                  @param {...} argN pipe arguments
     *                  @returns {*} processed input value
     *              }
     *              @type {array} origArgs List of strings describing the pipe
     *              @type {array} params {
     *                  @param {object} dataObj
     *                  @returns {*} pipe argument value
     *              }
     *              @type {object} opt {
     *                  Pipe options
     *                  @type {boolean} neg Return !value
     *                  @type {boolean} dblneg Return !!value
     *                  @type {boolean} undeterm This pipe's result is undetermined
     *                  @type {string} name Filter name
     *              }
     *          }
     *          @type {array} inputPipes same as pipes
     *      }
     *  }
     * }
     */
    setDeconstructorFn: function (deconstructor) {
      deconstructorFn = deconstructor;
    },

    /**
     * @property {function} getDeconstructorFn {
     *  @returns {function} See setDeconstructorFn
     * }
     */
    getDeconstructorFn: function () {
      return deconstructorFn;
    },

    /**
     * @property {function} setConstructorFn {
     *  Takes result of <code>deconstructor</code> and 
     *  returns function with the same api as <code>expression</code>
     *  @param {function} constructor {
     *      @param {object} struct As returned from deconstructorFn
     *      @param {object} opt {
     *          @type {boolean} getterOnly
     *          @type {boolean} setterOnly
     *      }
     *      @returns {function} Same that expressionFn and parserFn returns
     *  }
     * }
     */
    setConstructorFn: function (constructor) {
      constructorFn = constructor;
    },

    /**
     * @property {function} getConstructorFn {
     *  @returns {function}
     * }
     */
    getConstructorFn: function () {
      return constructorFn;
    },

    /**
     * @property {function} setParserFn {
     *  @param {function} parser {
     *      @param {string} expression Code expression with or without pipes
     *      @returns {function} {
     *          @param {object} dataObj Data object to execute expression against
     *          @param {*} value Optional value which makes function a setter
     *          @returns {*} value of expression on data object
     *      }
     *  }
     * }
     */
    setParserFn: function (parser) {
      parserFn = parser;
    },

    /**
     * @property {function} getParserFn {
     *  @returns {function} See setParserFn
     * }
     */
    getParserFn: function () {
      return parserFn;
    },

    /**
     * Add filters collection
     * @param {object} filters {
     *  name:function collection of filters (pipes)
     * }
     */
    addFilterSource: function (filters) {
      filterSources.push(filters);
    },

    /**
     * Reset to default parser
     * @property {function} reset
     */
    reset: reset,

    /**
     * Get executable function out of code string (no pipes)
     * @property {function} expression
     * @param {string} expr 
     * @param {object|string} opt See <code>parse</code>
     * @returns {function} {
     *  @param {object} dataObj Data object to execute expression against
     *  @param {*} value Optional value which makes function a setter
     *  @returns {*} value of expression on data object
     * }
     */
    expression: function (expr, opt) {
      return expressionFn(expr, opt);
    },

    /**
     * @property {function} deconstruct {
     *  See setDeconstructorFn
     *  @param {string} expr 
     *  @param {object|string} opt See <code>parse</code>
     *  @returns {function} 
     * }
     */
    deconstruct: function (expr, opt) {
      return deconstructorFn(expr, opt);
    },

    /**
     * Get a expression function out of deconstructed parts
     * @property {function} construct {
     *  @param {object} struct Result of <code>deconstruct(expr)</code>
     *  @param {object} opt {
     *      @type {boolean} setterOnly
     *      @type {boolean} getterOnly
     *  }
     *  @returns {function} {
     *      @param {object} dataObj Data object to execute expression against
     *      @param {*} value Optional value which makes function a setter
     *      @returns {*} value of expression on data object
     * }
     * }
     */
    construct: function (struct, opt) {
      return constructorFn(struct, opt);
    },

    /**
     * @property {function} parse {
     *  See setParserFn
     *  @param {string} expr 
     *  @param {object|string} opt {
     *      @type {object} filters
     *      @type {boolean} setter {    
     *          @default false
     *      }
     *  }
     *  @returns {function}
     * }
     */
    parse: function (expr, opt) {
      return parserFn(expr, opt);
    },

    /**
     * @property {function} func {
     *  @param {string} expr 
     *  @param {object} opt {
     *      @type {boolean} noReturn {    
     *          @default true
     *      }
     *  }
     *  @returns {function}
     * }
     */
    func: function (expr, opt) {
      opt = opt || {};
      opt.noReturn = true;
      opt.getterOnly = true;
      return parserFn(expr, opt);
    },

    /**
     * @property {function} setter {
     *  @param {string} expr 
     *  @param {object} opt {
     *      @type {boolean} setter {    
     *          @default true
     *      }
     *  }
     *  @returns {function}
     * }
     */
    setter: function (expr, opt) {
      opt = opt || {};
      opt.setter = true;
      opt.setterOnly = true;
      return parserFn(expr, opt);
    },

    /**
     * @property {function} getter {
     *  @param {string} expr 
     *  @param {object} opt {
     *      @type {boolean} setter {    
     *          @default false
     *      }
     *      @type {boolean} getterOnly {
     *          @default true
     *      }
     *  }
     *  @returns {function}
     * }
     */
    getter: function (expr, opt) {
      opt = opt || {};
      opt.setter = false;
      opt.getterOnly = true;
      return parserFn(expr, opt);
    },

    /**
     * Execute code on given data object
     * @property {function} run
     * @param {string} expr 
     * @param {object} dataObj 
     * @param {*} inputValue
     * @param {object} opt See <code>parse</code>
     */
    run: function (expr, dataObj, inputValue, opt) {
      opt = opt || {};
      opt.noReturn = true;
      parserFn(expr, opt)(dataObj, inputValue);
    },

    /**
     * Execute code on given data object
     * @property {function} run
     * @param {string} expr 
     * @param {object} dataObj 
     * @param {*} inputValue
     * @param {object} opt See <code>parse</code>
     */
    get: function (expr, dataObj, inputValue, opt) {
      opt = opt || {};
      opt.getterOnly = true;
      return parserFn(expr, opt)(dataObj, inputValue);
    },

    /**
     * Execute code on given data object as a setter
     * @property {function} run
     * @param {string} expr 
     * @param {object} dataObj 
     * @param {*} inputValue
     * @param {object} opt See <code>parse</code>
     */
    set: function (expr, dataObj, inputValue, opt) {
      opt = opt || {};
      opt.setter = true;
      opt.setterOnly = true;
      return parserFn(expr, opt)(dataObj, inputValue);
    },

    /**
     * Check if given expression is a static string or number
     * @property {function} isStatic
     * @param {string} expr
     * @returns {boolean|object} {  
     *  Static value can be 0 or false, so it must be returned contained.<br>
     *  So it is either false or ret.value
     *  @type {*} value 
     * }
     */
    isStatic: isStatic,

    /**
     * Checks if given expression is simple getter (no function or operations)
     * @property {function} isAtom {
     *  @param {string} expr
     *  @returns {boolean}
     * }
     */
    isAtom: isAtom,

    /**
     * Checks if given expression is a property getter
     * @property {function} isProperty {
     *  @param {string} expr 
     *  @returns {string|boolean} property name or false
     * }
     */
    isProperty: isProperty,

    /**
     * Is this a key in prebuilt cache
     * @property {function} isPrebuiltKey {
     *  @param {string} key
     *  @returns {boolean}
     * }
     */
    isPrebuiltKey: isPrebuiltKey,

    /**
     * Does the expression has pipes
     * @property {function} expressionHasPipes {
     *  @param {string} expr
     *  @returns {boolean}
     * }
     */
    expressionHasPipes: function (expr) {
      return split(expr, '|').length > 1 || split(expr, '>>').length > 1;
    },

    /**
     * Get a small string containing expression features:
     * p: updates parent, r: updates root, i: has input pipes,
     * o: has output pipes
     * @property {function} describeExpression {
     *  @param {string} expr 
     *  @returns {string}
     * }
     */
    describeExpression: function (expr) {
      if (!expr || typeof expr !== "string") return "";

      if (!cacheEnabled) {
        descrCache = {};
      }

      if (descrCache[expr]) {
        return descrCache[expr];
      }

      var descr = "" + (expr.indexOf("$parent") !== -1 ? "p" : "") + (expr.indexOf("$root") !== -1 ? "r" : "") + (split(expr, '|').length > 1 ? "o" : "") + (split(expr, '>>').length > 1 ? "i" : "");
      descrCache[expr] = descr;
      return descr;
    },

    /**
     * Clear expressions cache
     * @property {function} clearCache
     */
    clearCache: function () {
      cache = {};
    },
    disableCache: function () {},
    enableCache: function () {}
  };
}();

/***/ }),

/***/ "../metaphorjs/src/lib/History.js":
/*!****************************************!*\
  !*** ../metaphorjs/src/lib/History.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-observable/src/lib/Observable.js */ "../metaphorjs-observable/src/lib/Observable.js");

__webpack_require__(/*! ../func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ../func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! ../func/dom/normalizeEvent.js */ "../metaphorjs/src/func/dom/normalizeEvent.js");

__webpack_require__(/*! metaphorjs-shared/src/func/browser/parseLocation.js */ "../metaphorjs-shared/src/func/browser/parseLocation.js");

__webpack_require__(/*! metaphorjs-shared/src/func/browser/joinLocation.js */ "../metaphorjs-shared/src/func/browser/joinLocation.js");

const extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      emptyFn = __webpack_require__(/*! metaphorjs-shared/src/func/emptyFn.js */ "../metaphorjs-shared/src/func/emptyFn.js"),
      async = __webpack_require__(/*! metaphorjs-shared/src/func/async.js */ "../metaphorjs-shared/src/func/async.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.lib.History = function () {
  var win,
      history,
      location,
      observable = new MetaphorJs.lib.Observable(),
      api = {},
      programId = nextUid(),
      stateKeyId = "$$" + programId,
      currentId = nextUid(),
      hashIdReg = new RegExp("#" + programId + "=([A-Z0-9]+)"),
      pushState,
      replaceState,
      windowLoaded = typeof window == "undefined",
      prevLocation = null,
      pushStateSupported,
      hashChangeSupported,
      useHash;
  observable.createEvent("before-location-change", false);
  observable.createEvent("void-click", false);

  var initWindow = function () {
    win = window;
    history = win.history;
    location = win.location;
    pushStateSupported = !!history.pushState;
    hashChangeSupported = "onhashchange" in win;
    useHash = false; //pushStateSupported && (navigator.vendor || "").match(/Opera/);

    prevLocation = extend({}, location, true, false);
  };

  var preparePushState = function (state) {
    state = state || {};

    if (!state[stateKeyId]) {
      state[stateKeyId] = nextUid();
    }

    currentId = state[stateKeyId];
    return state;
  };

  var prepareReplaceState = function (state) {
    state = state || {};

    if (!state[stateKeyId]) {
      state[stateKeyId] = currentId;
    }

    return state;
  };

  var hostsDiffer = function (prev, next) {
    if (typeof prev == "string") {
      prev = MetaphorJs.browser.parseLocation(prev);
    }

    if (typeof next == "string") {
      next = MetaphorJs.browser.parseLocation(next);
    }

    var canBeEmpty = ["protocol", "host", "port"],
        i,
        l,
        k;

    for (i = 0, l = canBeEmpty.length; i < l; i++) {
      k = canBeEmpty[i];

      if (prev[k] && next[k] && prev[k] != next[k]) {
        return true;
      }
    }

    return false;
  };

  var pathsDiffer = function (prev, next) {
    if (typeof prev == "string") {
      prev = MetaphorJs.browser.parseLocation(prev);
    }

    if (typeof next == "string") {
      next = MetaphorJs.browser.parseLocation(next);
    }

    return hostsDiffer(prev, next) || prev.pathname != next.pathname || prev.search != next.search || prev.hash != next.hash;
  };

  var preparePath = function (url) {
    var loc = MetaphorJs.browser.parseLocation(url);

    if (!pushStateSupported || useHash) {
      return loc.path;
    }

    return MetaphorJs.browser.joinLocation(loc, {
      onlyPath: true
    });
  };

  var getCurrentStateId = function () {
    if (pushStateSupported) {
      return history.state ? history.state[stateKeyId] : null;
    } else {
      return parseOutHashStateId(location.hash).id;
    }
  };

  var parseOutHashStateId = function (hash) {
    var id = null;
    hash = hash.replace(hashIdReg, function (match, idMatch) {
      id = idMatch;
      return "";
    });
    return {
      hash: hash,
      id: id
    };
  };

  var setHash = function (hash, state) {
    if (hash) {
      if (hash.substr(0, 1) != '#') {
        hash = parseOutHashStateId(hash).hash;
        hash = "!" + hash + "#" + programId + "=" + currentId;
      }

      location.hash = hash;
    } else {
      location.hash = "";
    }
  };

  var getCurrentUrl = function () {
    var loc, tmp;

    if (pushStateSupported) {
      //loc = location.pathname + location.search + location.hash;
      loc = MetaphorJs.browser.joinLocation(location);
    } else {
      loc = location.hash.substr(1);
      tmp = extend({}, location, true, false);

      if (loc) {
        loc = parseOutHashStateId(loc).hash;

        if (loc.substr(0, 1) == "!") {
          loc = loc.substr(1);
        }

        var p = decodeURIComponent(loc).split("?");
        tmp.pathname = p[0];
        tmp.search = p[1] ? "?" + p[1] : "";
      }

      loc = MetaphorJs.browser.joinLocation(tmp);
    }

    return loc;
  };

  var onLocationPush = function (url) {
    prevLocation = extend({}, location, true, false);
    triggerEvent("location-change", url);
  };

  var onLocationPop = function () {
    if (pathsDiffer(prevLocation, location)) {
      var url = getCurrentUrl(),
          state = history.state || {};
      triggerEvent("before-location-pop", url);
      currentId = getCurrentStateId();
      prevLocation = extend({}, location, true, false);
      triggerEvent("location-change", url);
    }
  };

  var triggerEvent = function triggerEvent(event, data, anchor) {
    var url = data || getCurrentUrl(),
        loc = MetaphorJs.browser.parseLocation(url),
        path = loc.pathname + loc.search + loc.hash;
    return observable.trigger(event, path, anchor, url);
  };

  var init = function () {
    initWindow(); // normal pushState

    if (pushStateSupported) {
      //history.origPushState       = history.pushState;
      //history.origReplaceState    = history.replaceState;
      MetaphorJs.dom.addListener(win, "popstate", onLocationPop);

      pushState = function (url, anchor, state) {
        if (triggerEvent("before-location-change", url, anchor) === false) {
          return false;
        }

        history.pushState(preparePushState(state), null, preparePath(url));
        onLocationPush(url);
      };

      replaceState = function (url, anchor, state) {
        history.replaceState(prepareReplaceState(state), null, preparePath(url));
        onLocationPush(url);
      };

      async(function () {
        replaceState(getCurrentUrl());
      });
    } else {
      // onhashchange
      if (hashChangeSupported) {
        pushState = function (url, anchor, state) {
          if (triggerEvent("before-location-change", url, anchor) === false) {
            return false;
          }

          async(setHash, null, [preparePath(url), preparePushState(state)]);
        };

        replaceState = function (url, anchor, state) {
          async(setHash, null, [preparePath(url), prepareReplaceState(state)]);
        };

        MetaphorJs.dom.addListener(win, "hashchange", onLocationPop);
      } // iframe
      else {
        /*
        var frame   = null,
            initialUpdate = false;
         var createFrame = function() {
            frame   = window.document.createElement("iframe");
            frame.src = 'about:blank';
            frame.style.display = 'none';
            window.document.body.appendChild(frame);
        };
         win.onIframeHistoryChange = function(val) {
            if (!initialUpdate) {
                async(function(){
                    setHash(val);
                    onLocationPop();
                });
            }
        };
         var pushFrame = function(value) {
            var frameDoc;
            if (frame.contentDocument) {
                frameDoc = frame.contentDocument;
            }
            else {
                frameDoc = frame.contentWindow.document;
            }
            frameDoc.open();
            //update iframe content to force new history record.
            frameDoc.write('<html><head><title>' + document.title +
                           '</title><script type="text/javascript">' +
                           'var hashValue = "'+value+'";'+
                           'window.top.onIframeHistoryChange(hashValue);' +
                           '</script>' +
                           '</head><body>&nbsp;</body></html>'
            );
            frameDoc.close();
        };
         var replaceFrame = function(value) {
            frame.contentWindow.hashValue = value;
        };
          pushState = function(url, anchor, state) {
            if (triggerEvent("before-location-change", url, anchor) === false) {
                return false;
            }
            pushFrame(preparePath(url));
        };
         replaceState = function(url, anchor, state) {
            if (triggerEvent("before-location-change", url, anchor) === false) {
                return false;
            }
            replaceFrame(preparePath(url));
        };
         var initFrame = function(){
            createFrame();
            initialUpdate = true;
            pushFrame(preparePath(location.hash.substr(1)));
            initialUpdate = false;
        };
         if (windowLoaded) {
            initFrame();
        }
        else {
            MetaphorJs.dom.addListener(win, "load", initFrame);
        }
        */
      }
    }

    MetaphorJs.dom.addListener(window.document.documentElement, "click", function (e) {
      e = MetaphorJs.dom.normalizeEvent(e || win.event);
      var a = e.target,
          href;

      while (a && a.nodeName.toLowerCase() != "a") {
        a = a.parentNode;
      }

      if (a && !e.isDefaultPrevented()) {
        href = MetaphorJs.dom.getAttr(a, "href");

        if (href == "#") {
          var res = observable.trigger("void-click", a);

          if (!res) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        }

        if (href && href.substr(0, 1) != "#" && !MetaphorJs.dom.getAttr(a, "target")) {
          var prev = extend({}, location, true, false),
              next = MetaphorJs.browser.parseLocation(href);

          if (hostsDiffer(prev, next)) {
            return null;
          }

          if (pathsDiffer(prev, next)) {
            pushState(href, a);
          } else {
            triggerEvent("same-location", null, a);
          }

          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      }

      return null;
    });
    init = emptyFn;
  };

  MetaphorJs.dom.addListener(window, "load", function () {
    windowLoaded = true;
  });
  /**
   * Browser pushState wrapper and polyfill. 
   * @object MetaphorJs.lib.History
   */

  return extend(api, {
    /**
     * @property {function} on {
     * @param {string} event
     * @param {function} listener 
     * @param {object} callback context
     * @param {object} options
     * }
     */
    on: function () {
      return observable.on.apply(observable, arguments);
    },

    /**
     * @property {function} un {
     * @param {string} event
     * @param {function} listener 
     * @param {object} callback context
     * }
     */
    un: function () {
      return observable.un.apply(observable, arguments);
    },

    /**
     * @property {function} once {
     * @param {string} event
     * @param {function} listener 
     * @param {object} callback context
     * }
     */
    once: function () {
      return observable.once.apply(observable, arguments);
    },

    /**
     * @property {function} push {
     *  Push new url
     *  @param {string} url
     *  @param {object} state
     * }
     */
    push: function (url, state) {
      init();
      var prev = extend({}, location, true, false),
          next = MetaphorJs.browser.parseLocation(url);

      if (hostsDiffer(prev, next)) {
        return null;
      }

      if (pathsDiffer(prev, next)) {
        pushState(url, null, state);
      }
    },

    /**
     * @property {function} replace {
     *  Replace current url with another url
     *  @param {string} url
     *  @param {object} state
     * }
     */
    replace: function (url, state) {
      init();
      var prev = extend({}, location, true, false),
          next = MetaphorJs.browser.parseLocation(url);

      if (hostsDiffer(prev, next)) {
        return null;
      }

      if (pathsDiffer(prev, next)) {
        replaceState(url, null, state);
      }
    },

    /**
     * Update state of current url
     * @property {function} saveState {
     *  @param {object} state
     * }
     */
    saveState: function (state) {
      init();
      replaceState(getCurrentUrl(), null, state);
    },

    /**
     * Merge new state into current state 
     * @property {function} mergeState {
     *  @param {object} state
     * }
     */
    mergeState: function (state) {
      this.saveState(extend({}, history.state, state, true, false));
    },

    /**
     * Get current state
     * @property {function} getState {
     *  @returns {object}
     * }
     */
    getState: function () {
      return history.state;
    },

    /**
     * Get current instance id
     * @property {functrion} getCurrentStateId {
     *  @returns {string}
     * }
     */
    getCurrentStateId: function () {
      return currentId;
    },

    /**
     * Get current url
     * @property {function} current {
     *  @returns {string} url
     * }
     */
    current: function () {
      init();
      return getCurrentUrl();
    },

    /**
     * Initialize instance 
     * @property {function} init
     */
    init: function () {
      return init();
    },

    /**
     * Polyfill window.pushState and replaceState
     * @property {function} polyfill
     */
    polyfill: function () {
      init();

      window.history.pushState = function (state, title, url) {
        pushState(url, null, state);
      };

      window.history.replaceState = function (state, title, url) {
        replaceState(url, null, state);
      };
    }
  });
}();

/***/ }),

/***/ "../metaphorjs/src/lib/Input.js":
/*!**************************************!*\
  !*** ../metaphorjs/src/lib/Input.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-observable/src/lib/Observable.js */ "../metaphorjs-observable/src/lib/Observable.js");

__webpack_require__(/*! ../func/dom/getInputValue.js */ "../metaphorjs/src/func/dom/getInputValue.js");

__webpack_require__(/*! ../func/dom/setInputValue.js */ "../metaphorjs/src/func/dom/setInputValue.js");

__webpack_require__(/*! ../func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! ../func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

__webpack_require__(/*! ../func/dom/isAttached.js */ "../metaphorjs/src/func/dom/isAttached.js");

__webpack_require__(/*! ../func/browser/isAndroid.js */ "../metaphorjs/src/func/browser/isAndroid.js");

__webpack_require__(/*! ../func/browser/hasEvent.js */ "../metaphorjs/src/func/browser/hasEvent.js");

__webpack_require__(/*! ../func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ../func/dom/normalizeEvent.js */ "../metaphorjs/src/func/dom/normalizeEvent.js");

__webpack_require__(/*! ../func/dom/select.js */ "../metaphorjs/src/func/dom/select.js");

const bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.lib.Input = function () {
  var observable = new MetaphorJs.lib.Observable(),
      id = 0;
  /**
   * @class MetaphorJs.lib.Input
   * 
   * @constructor
   * @param {Node} el 
   * @param {function} changeFn 
   * @param {object} changeFnContext 
   * @param {object} cfg 
   */

  var Input = function (el, changeFn, changeFnContext, cfg) {
    if (el.$$input) {
      if (changeFn) {
        el.$$input.on("change", changeFn, changeFnContext);
      }

      return el.$$input;
    }

    var self = this;
    cfg = cfg || {}; //self.observable     = new MetaphorJs.lib.Observable;

    self.el = el;
    self.id = ++id;
    self.inputType = el.type ? el.type.toLowerCase() : "none";
    self.dataType = cfg.type || MetaphorJs.dom.getAttr(el, "data-type") || self.inputType;
    self.listeners = [];

    if (changeFn) {
      self.on("change", changeFn, changeFnContext);
    }
  };

  extend(Input.prototype, {
    el: null,
    inputType: null,
    dataType: null,
    listeners: null,
    radio: null,
    keydownDelegate: null,
    changeInitialized: false,

    /**
     * @method
     */
    $destroy: function () {
      var self = this,
          i; //self.observable.$destroy();

      observable.destroyEvent("change-" + self.id);
      observable.destroyEvent("key-" + self.id);

      self._addOrRemoveListeners(MetaphorJs.dom.removeListener, true);

      self.el.$$input = null;

      for (i in self) {
        if (self.hasOwnProperty(i)) {
          self[i] = null;
        }
      }
    },
    _addOrRemoveListeners: function (fn, onlyUsed) {
      var self = this,
          type = self.inputType,
          listeners = self.listeners,
          radio = self.radio,
          el = self.el,
          used,
          i,
          ilen,
          j,
          jlen;

      for (i = 0, ilen = listeners.length; i < ilen; i++) {
        used = !!listeners[i][2];

        if (used === onlyUsed) {
          if (type === "radio") {
            for (j = 0, jlen = radio.length; j < jlen; j++) {
              fn(radio[j], listeners[i][0], listeners[i][1]);
            }
          } else {
            fn(el, listeners[i][0], listeners[i][1]);
          }

          listeners[i][2] = !onlyUsed;
        }
      }
    },
    initInputChange: function () {
      var self = this,
          type = self.inputType;

      if (type === "radio") {
        self.initRadioInput();
      } else if (type === "checkbox") {
        self.initCheckboxInput();
      } else {
        self.initTextInput();
      }

      self._addOrRemoveListeners(MetaphorJs.dom.addListener, false);

      self.changeInitialized = true;
    },
    initRadioInput: function () {
      var self = this,
          el = self.el,
          name = el.name,
          parent;

      if (MetaphorJs.dom.isAttached(el)) {
        parent = el.ownerDocument;
      } else {
        parent = el;

        while (parent.parentNode) {
          parent = parent.parentNode;
        }
      }

      self.radio = MetaphorJs.dom.select("input[name=" + name + "]", parent);
      self.onRadioInputChangeDelegate = bind(self.onRadioInputChange, self);
      self.listeners.push(["click", self.onRadioInputChangeDelegate, false]);
    },
    initCheckboxInput: function () {
      var self = this;
      self.clicked = false;
      self.onCheckboxInputChangeDelegate = bind(self.onCheckboxInputChange, self);
      self.onCheckboxInputClickDelegate = bind(self.onCheckboxInputClick, self);
      self.listeners.push(["click", self.onCheckboxInputClickDelegate, false]);
      self.listeners.push(["change", self.onCheckboxInputChangeDelegate, false]);
    },
    initTextInput: function () {
      var composing = false,
          self = this,
          listeners = self.listeners,
          timeout; // In composition mode, users are still inputing intermediate text buffer,
      // hold the listener until composition is done.
      // More about composition events:
      // https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent

      if (!MetaphorJs.browser.isAndroid() && self.inputType !== "none") {
        var compositionStart = function () {
          composing = true;
        };

        var compositionEnd = function () {
          composing = false;
          listener();
        };

        listeners.push(["compositionstart", compositionStart, false]);
        listeners.push(["compositionend", compositionEnd, false]);
      }

      var listener = self.onTextInputChangeDelegate = function (ev) {
        if (composing) {
          return;
        }

        self.onTextInputChange(ev);
      };

      var deferListener = function (ev) {
        if (!timeout) {
          timeout = setTimeout(function () {
            listener(ev);
            timeout = null;
          }, 0);
        }
      };

      var keydown = function (event) {
        event = event || window.event;
        var key = event.keyCode; // ignore
        //    command            modifiers                   arrows

        if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40) {
          return;
        }

        deferListener(event);
      }; // if the browser does support "input" event, we are fine - except on
      // IE9 which doesn't fire the
      // input event on backspace, delete or cut


      if (MetaphorJs.browser.hasEvent('input') && self.inputType !== "none") {
        listeners.push(["input", listener, false]);
      } else {
        listeners.push(["keydown", keydown, false]); // if user modifies input value using context menu in IE,
        // we need "paste" and "cut" events to catch it

        if (MetaphorJs.browser.hasEvent('paste') && self.inputType !== "none") {
          listeners.push(["paste", deferListener, false]);
          listeners.push(["cut", deferListener, false]);
        }
      } // if user paste into input using mouse on older browser
      // or form autocomplete on newer browser, we need "change" event to catch it


      if (self.inputType !== "none") {
        listeners.push(["change", listener, false]);
      }
    },
    processValue: function (val) {
      switch (this.dataType) {
        case "number":
        case "float":
        case "double":
          if (val === "" || isNaN(val = parseFloat(val))) {
            val = undefined;
          }

          break;

        case "int":
        case "integer":
          if (val === "" || isNaN(val = parseInt(val, 10))) {
            val = undefined;
          }

          break;

        case "bool":
        case "boolean":
          return !(val === "false" || val === "0" || val === 0 || val === "off" || val === false || val === "");
      }

      return val;
    },
    onTextInputChange: function (ev) {
      var self = this,
          val = self.getValue();
      observable.trigger("change-" + self.id, self.processValue(val));
    },
    _checkboxChange: function () {
      var self = this,
          node = self.el;
      observable.trigger("change-" + self.id, self.processValue(node.checked ? MetaphorJs.dom.getAttr(node, "value") || true : false));
    },
    onCheckboxInputChange: function () {
      if (!this.clicked) {
        this._checkboxChange();
      }

      this.clicked = false;
    },
    onCheckboxInputClick: function () {
      this._checkboxChange();

      this.clicked = true;
    },
    onRadioInputChange: function (e) {
      e = e || window.event;
      var self = this,
          trg = e.target || e.srcElement;
      observable.trigger("change-" + self.id, self.processValue(trg.value));
    },

    /**
     * @method
     * @param {*} val 
     */
    setValue: function (val) {
      var self = this,
          type = self.inputType,
          radio,
          i,
          len;
      val = self.processValue(val);

      if (type === "radio") {
        radio = self.radio;

        for (i = 0, len = radio.length; i < len; i++) {
          radio[i].checked = self.processValue(radio[i].value) == val;
        }
      } else if (type === "checkbox") {
        var node = self.el;
        node.checked = val === true || val == self.processValue(node.value);
      } else {
        if (val === undefined) {
          val = "";
        }

        MetaphorJs.dom.setInputValue(self.el, val);
      }

      self.triggerChange();
    },

    /**
     * @method
     * @returns {*}
     */
    getValue: function () {
      var self = this,
          type = self.inputType,
          radio,
          i,
          l;

      if (type === "radio") {
        radio = self.radio;

        for (i = 0, l = radio.length; i < l; i++) {
          if (radio[i].checked) {
            return self.processValue(radio[i].value);
          }
        }

        return null;
      } else if (type === "checkbox") {
        return self.processValue(self.el.checked ? MetaphorJs.dom.getAttr(self.el, "value") || true : false);
      } else {
        return self.processValue(MetaphorJs.dom.getInputValue(self.el));
      }
    },

    /**
     * @method
     * @param {string} event change|key
     * @param {function} fn event listener
     * @param {object} ctx event listener context
     * @param {object} opt MetaphorJs.lib.Observable's on() options
     */
    on: function (event, fn, ctx, opt) {
      var self = this;

      if (event === "change" && !self.changeInitialized) {
        self.initInputChange();
      } else if (event === "key" && !self.keydownDelegate) {
        self.keydownDelegate = bind(self.keyHandler, self);
        self.listeners.push(["keydown", self.keydownDelegate, false]);
        MetaphorJs.dom.addListener(self.el, "keydown", self.keydownDelegate);
        observable.createEvent("key-" + self.id, {
          returnResult: false,
          triggerFilter: self.keyEventFilter
        });
      }

      return observable.on(event + "-" + self.id, fn, ctx, opt);
    },

    /**
     * @method
     * @param {string} event 
     * @param {function} fn 
     * @param {object} ctx 
     */
    un: function (event, fn, ctx) {
      return observable.un(event + "-" + this.id, fn, ctx);
    },

    /**
     * @method
     * @param {function} fn 
     * @param {object} context 
     */
    onChange: function (fn, context) {
      return this.on("change", fn, context);
    },

    /**
     * @method
     * @param {function} fn 
     * @param {object} context 
     */
    unChange: function (fn, context) {
      return this.un("change", fn, context);
    },

    /**
     * @method
     * @param {int} key 
     * @param {function} fn 
     * @param {object} context 
     * @param {object} opt
     */
    onKey: function (key, fn, context, opt) {
      return this.on("key", fn, context, extend({}, opt, {
        key: key
      }));
    },

    /**
     * @method
     * @param {int} key 
     * @param {function} fn 
     * @param {object} context 
     */
    unKey: function (key, fn, context) {
      this.un("key", fn, context);
    },
    keyEventFilter: function (l, args) {
      var key = l.key,
          e = args[0];

      if (typeof key !== "object") {
        return key === e.keyCode;
      } else {
        if (key.ctrlKey !== undefined && key.ctrlKey !== e.ctrlKey) {
          return false;
        }

        if (key.shiftKey !== undefined && key.shiftKey !== e.shiftKey) {
          return false;
        }

        return !(key.keyCode !== undefined && key.keyCode !== e.keyCode);
      }
    },
    keyHandler: function (event) {
      observable.trigger("key-" + this.id, MetaphorJs.dom.normalizeEvent(event || window.event));
    },
    triggerChange: function () {
      if ("createEvent" in document) {
        var evt = document.createEvent("HTMLEvents");
        evt.initEvent("change", false, true);
        this.el.dispatchEvent(evt);
      } else {
        this.el.fireEvent("onchange");
      }
    }
  }, true, false);
  /**
   * @method
   * @static
   * @param {Node} node
   * @param {MetaphorJs.lib.State} state
   * @returns {MetaphorJs.lib.Input}
   */

  Input.get = function (node, state) {
    if (node.$$input) {
      return node.$$input;
    }

    if (state && state.$app && !node.type) {
      var cmp = state.$app.getParentCmp(node, true);

      if (cmp && cmp.getInputApi) {
        return cmp.getInputApi();
      }
    }

    return new Input(node);
  };
  /**
   * @method
   * @static
   * @param {Node} node
   * @returns {string}
   */


  Input.getValue = MetaphorJs.dom.getInputValue;
  /**
   * @method
   * @static
   * @param {Node} node
   * @param {string} value
   */

  Input.setValue = MetaphorJs.dom.setInputValue;
  return Input;
}();

/***/ }),

/***/ "../metaphorjs/src/lib/MutationObserver.js":
/*!*************************************************!*\
  !*** ../metaphorjs/src/lib/MutationObserver.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      isFunction = __webpack_require__(/*! metaphorjs-shared/src/func/isFunction.js */ "../metaphorjs-shared/src/func/isFunction.js"),
      isArray = __webpack_require__(/*! metaphorjs-shared/src/func/isArray.js */ "../metaphorjs-shared/src/func/isArray.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      equals = __webpack_require__(/*! metaphorjs-shared/src/func/equals.js */ "../metaphorjs-shared/src/func/equals.js"),
      copy = __webpack_require__(/*! metaphorjs-shared/src/func/copy.js */ "../metaphorjs-shared/src/func/copy.js");

__webpack_require__(/*! metaphorjs-observable/src/lib/Observable.js */ "../metaphorjs-observable/src/lib/Observable.js");

__webpack_require__(/*! ./Expression.js */ "../metaphorjs/src/lib/Expression.js");
/**
 * @class MetaphorJs.lib.MutationObserver
 */


module.exports = MetaphorJs.lib.MutationObserver = function () {
  var observable = new MetaphorJs.lib.Observable();

  var checkAll = function () {
    var k,
        changes = 0;

    for (k in this) {
      if (this.hasOwnProperty(k) && k !== "$checkAll") {
        if (this[k].check()) {
          changes++;
        }
      }
    }

    return changes;
  };
  /**
   * @constructor
   * @method
   * @param {object} dataObj Data object to run expression against
   * @param {string|function} expr Code expression or property name or getter function
   * @param {function} listener {
   *  @param {*} currentValue
   *  @param {*} prevValue
   * }
   * @param {object} context Listener's context
   * @param {object} opt {
   *  @type {array|object} filters {
   *      Either one filter source or array of filter sources
   *  }
   * }
   */


  const MutationObserver = function (dataObj, expr, listener, context, opt) {
    var self = this,
        id = nextUid(),
        type = "expr",
        propertyName,
        statc,
        pb,
        tp = typeof expr;

    if (MetaphorJs.app.prebuilt.isKey(expr)) {
      pb = MetaphorJs.app.prebuilt.get("config", expr);
    } else if (tp !== "string" && tp !== "function") {
      pb = expr;
      expr = pb.id || nextUid();
    }

    opt = opt || {};

    if (listener) {
      observable.on(id, listener, context, {
        allowDupes: true
      });
    }

    self.id = id;
    self.origExpr = expr;
    self.propertyName = null;
    self.staticValue = null;
    self.dataObj = dataObj;
    self.currentValue = null;
    self.prevValue = null;
    self.rawInput = null;
    self.setterFn = null;
    self.getterFn = null;
    self.exprStruct = null;
    self.sub = [];
    self.localFilter = opt.localFilter || null;

    if (pb) {
      type = "prebuilt";
      self.exprStruct = pb;
      self.getterFn = MetaphorJs.lib.Expression.construct(pb, {
        getterOnly: true
      });

      if (pb.setterFn) {
        self.setterFn = MetaphorJs.lib.Expression.construct(pb, {
          setterOnly: true
        });

        self._initSetter();
      }
    } else {
      if (isFunction(expr)) {
        self.getterFn = expr;
      } else if (statc = MetaphorJs.lib.Expression.isStatic(expr)) {
        type = "static";
        self.staticValue = statc.value;
        self.getterFn = bind(self._staticGetter, self);
      } else if (dataObj) {
        propertyName = expr;

        if (dataObj.hasOwnProperty(propertyName) || (propertyName = MetaphorJs.lib.Expression.isProperty(expr)) && dataObj.hasOwnProperty(propertyName)) {
          type = "attr";
          self.propertyName = propertyName;
          self.getterFn = bind(self._propertyGetter, self);
        }
      }
    }

    if (!self.getterFn && type === "expr") {
      if (!opt.filters) {
        opt.filters = dataObj;
      } else {
        if (!isArray(opt.filters)) {
          opt.filters = [opt.filters];
        } else {
          opt.filters.push(dataObj);
        }
      }

      var struct = MetaphorJs.lib.Expression.deconstruct(expr, {
        filters: opt.filters
      });
      self.exprStruct = struct;
      self.getterFn = MetaphorJs.lib.Expression.construct(struct, {
        getterOnly: true
      });

      if (struct.inputPipes.length || opt.setter) {
        self._initSetter();
      }
    }

    if (dataObj) {
      if (!dataObj["$$mo"]) {
        dataObj.$$mo = {
          $checkAll: checkAll
        };
      }

      if (!dataObj.$$mo[expr]) {
        dataObj.$$mo[expr] = self;
      }
    }

    self.currentValue = self._getValue();
    self.currentValueCopy = copy(self.currentValue);
    self.type = type;
  };

  extend(MutationObserver.prototype, {
    _propertyGetter: function () {
      return this.dataObj[this.propertyName];
    },
    _propertySetter: function (dataObj, newValue) {
      this.dataObj[this.propertyName] = newValue;
    },
    _staticGetter: function () {
      return this.staticValue;
    },

    /**
     * Check for changes
     * @method
     * @returns {boolean} true for changes
     */
    check: function () {
      var self = this,
          curr = self.currentValueCopy,
          val = self._getValue();

      if (!equals(val, curr)) {
        self.prevValue = curr;
        self.currentValue = val;
        self.currentValueCopy = copy(val);
        observable.trigger(self.id, self.currentValue, self.prevValue);
        return true;
      }

      return false;
    },
    _initSetter: function () {
      var self = this,
          struct = self.exprStruct;

      if (self.type === "attr") {
        self.setterFn = bind(self._propertySetter, self);
      } else {
        if (!struct) {
          throw new Error("Unable to make setter out of " + this.expr);
        }

        if (!self.setterFn) {
          self.setterFn = MetaphorJs.lib.Expression.construct(struct, {
            setterOnly: true
          });
        }

        self._initInputPipes();
      }
    },
    _initInputPipes: function () {
      var self = this,
          struct = self.exprStruct;
      var i, l, p, j, jl;

      if (struct.inputPipes) {
        for (i = 0, l = struct.inputPipes.length; i < l; i++) {
          p = struct.inputPipes[i];

          for (j = 0, jl = p.expressions.length; j < jl; j++) {
            self.sub.push(MetaphorJs.lib.MutationObserver.get(self.dataObj, p.expressions[j], self._onSubChange, self));
          }
        }
      }
    },
    _getValue: function () {
      const self = this;
      const val = self.getterFn(self.dataObj || {});
      return self.localFilter ? self.localFilter(val, self) : val;
    },
    _onSubChange: function () {
      this.setValue(this.rawInput);
    },

    /**
     * Get current value of expression
     * @method
     * @returns {*}
     */
    getValue: function () {
      return this.currentValue;
    },

    /**
     * Get copy of current value of expression
     * @method
     * @returns {*}
     */
    getCopy: function () {
      return this.currentValueCopy;
    },

    /**
     * If the expression uses input pipes, use this method to trigger them
     * @method
     * @param {*} newValue 
     * @returns {*} resulting value
     */
    setValue: function (newValue) {
      var self = this;
      self.rawInput = newValue;

      if (!self.setterFn) {
        self._initSetter();
      }

      self.setterFn(self.dataObj, newValue);
    },

    /**
     * Get previous value
     * @method
     * @returns {*}
     */
    getPrevValue: function () {
      return this.prevValue;
    },

    /**
     * 
     * @param {function} fn {
     *  @param {*} currentValue
     *  @param {*} prevValue
     * }
     * @param {object} context fn's context
     * @param {object} opt See MetaphorJs.lib.Observable.on()
     * @returns {MetaphorJs.lib.MutationObserver} self
     */
    subscribe: function (fn, context, opt) {
      opt = opt || {};
      opt.allowDupes = true;
      observable.on(this.id, fn, context, opt);
      return this;
    },

    /**
     * Unsubscribe from changes event
     * @param {function} fn 
     * @param {object} context 
     * @returns {MetaphorJs.lib.MutationObserver} self
     */
    unsubscribe: function (fn, context) {
      observable.un(this.id, fn, context);
      return this;
    },

    /**
     * Does the expression have input pipes
     * @method
     * @returns {boolean}
     */
    hasInputPipes: function () {
      return this.exprStruct && this.exprStruct.inputPipes.length > 0;
    },

    /**
     * Does the expression have output pipes
     * @method
     * @returns {boolean}
     */
    hasOutputPipes: function () {
      return this.exprStruct && this.exprStruct.pipes.length > 0;
    },

    /**
     * Destroy observer
     * @param {boolean} ifUnobserved 
     * @returns {boolean} true for destroyed
     */
    $destroy: function (ifUnobserved) {
      var self = this,
          i,
          l,
          s;

      if (ifUnobserved && observable.hasListener(self.id)) {
        return false;
      }

      for (i = 0, l = self.sub.length; i < l; i++) {
        s = self.sub[i];
        s.unsubscribe(self._onSubChange, self);
        s.$destroy(true);
      }

      observable.destroyEvent(self.id);

      if (self.dataObj && self.dataObj['$$mo']) {
        if (self.dataObj['$$mo'][self.origExpr] === self) {
          delete self.dataObj['$$mo'][self.origExpr];
        }
      }

      for (var key in self) {
        if (self.hasOwnProperty(key)) {
          self[key] = null;
        }
      }

      return true;
    }
  });
  /**
   * Check data object for changes
   * @static
   * @method
   * @param {object} dataObj
   * @param {string} expr {
   *  Optional expression 
   *  @optional
   * }
   * @returns {bool|int} Either true|false for specific expression or number of changes
   */

  MutationObserver.check = function (dataObj, expr) {
    var mo;

    if (expr) {
      mo = MutationObserver.exists(dataObj, expr);

      if (!mo) {
        throw new Error("MutationObserver not found for expression: " + expr);
      }

      return mo.check();
    }

    if (!dataObj.$$mo) {
      return false;
    }

    return dataObj.$$mo.$checkAll();
  };
  /**
   * See the constructor parameters
   * @static
   * @method
   */


  MutationObserver.get = function (dataObj, expr, listener, context, opt) {
    var pbOrExpr = expr;

    if (typeof expr !== "string") {
      expr = pbOrExpr.expr;
    }

    if (expr) {
      expr = expr.trim();
      var mo = MutationObserver.exists(dataObj, expr);

      if (mo) {
        if (listener) {
          mo.subscribe(listener, context);
        }

        return mo;
      }
    }

    return new MutationObserver(dataObj, pbOrExpr, listener, context, opt);
  };
  /**
   * Check if mutation observer exists on the object and return it or false
   * @static
   * @method
   * @param {object} dataObj
   * @param {string} expr
   * @returns {MetaphorJs.lib.MutationObserver|boolean}
   */


  MutationObserver.exists = function (dataObj, expr) {
    expr = expr.trim();

    if (dataObj && dataObj.$$mo && dataObj.$$mo[expr]) {
      return dataObj.$$mo[expr];
    }

    return false;
  };
  /**
   * Destroy an observer
   * @static
   * @method
   * @param {object} dataObj
   * @param {string|null} expr If null, destroy all observers on this object
   * @param {boolean} ifUnobserved Destroy only if unobserved
   */


  MutationObserver.$destroy = function (dataObj, expr, ifUnobserved) {
    var key,
        all = true;

    if (dataObj && dataObj.$$mo) {
      for (key in dataObj.$$mo) {
        if (dataObj.$$mo.hasOwnProperty(key) && (!expr || key === expr) && key[0] !== '$') {
          if (dataObj.$$mo[key].$destroy(ifUnobserved)) {
            delete dataObj.$$mo[key];
          } else all = false;
        }
      }

      if (all) {
        delete dataObj.$$mo;
      }
    }
  };

  return MutationObserver;
}();

/***/ }),

/***/ "../metaphorjs/src/lib/State.js":
/*!**************************************!*\
  !*** ../metaphorjs/src/lib/State.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-observable/src/lib/Observable.js */ "../metaphorjs-observable/src/lib/Observable.js");

__webpack_require__(/*! ./MutationObserver.js */ "../metaphorjs/src/lib/MutationObserver.js");

const extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      async = __webpack_require__(/*! metaphorjs-shared/src/func/async.js */ "../metaphorjs-shared/src/func/async.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");
/**
 * The state object is what templates see as "this" when executing expressions.
 * (Actually, this is more like a Context)
 * @class MetaphorJs.lib.State
 */


module.exports = MetaphorJs.lib.State = function () {
  const publicStates = {};
  /**
   * @method State
   * @constructor
   * @param {object} cfg Whatever data should be visible in template
   */

  const State = function (cfg) {
    this.$$observable = new MetaphorJs.lib.Observable();
    this.$$historyWatchers = {};
    extend(this, cfg, true, false);

    if (this.$parent) {
      /**
       * @event check
       * @param {array} changes 
       */
      this.$parent.$on("check", this.$$onParentCheck, this);
      /**
       * @event changed
       */

      /**
       * @event destroy
       */

      this.$parent.$on("destroy", this.$$onParentDestroy, this);
      /**
       * @event freeze
       * @param {MetaphorJs.lib.State}
       */

      this.$parent.$on("freeze", this.$freeze, this);
      /**
       * @event unfreeze
       * @param {MetaphorJs.lib.State}
       */

      this.$parent.$on("unfreeze", this.$unfreeze, this);
    } else {
      this.$root = this;
      this.$isRoot = true;
    }

    if (this.$$publicName) {
      if (publicStates[this.$$publicName]) {
        this.$$publicName = null;
      }

      publicStates[this.$$publicName] = this;
    }
  };

  extend(State.prototype, {
    /**
     * @property {MetaphorJs.app.App}
     */
    $app: null,

    /**
     * @property {MetaphorJs.lib.State}
     */
    $parent: null,

    /**
     * @property {MetaphorJs.lib.State}
     */
    $root: null,

    /**
     * @property {boolean}
     */
    $isRoot: false,

    /**
     * @property {int}
     */
    $level: 0,
    $static: false,
    $$frozen: false,
    $$observable: null,
    $$watchers: null,
    $$historyWatchers: null,
    $$checking: false,
    $$destroyed: false,
    $$changing: false,
    $$publicName: null,
    $$tmt: null,

    /**
     * Create child state
     * @method
     * @param {object} data Child state data
     * @returns {MetaphorJs.lib.State}
     */
    $new: function (data) {
      return new State(extend({}, data, {
        $parent: this,
        $root: this.$root,
        $app: this.$app,
        $level: this.$level + 1,
        $static: this.$static
      }, true, false));
    },

    /**
     * Create child state with no relation to this state (no $parent)
     * but with $app propery set.
     * @method
     * @param {object} data Child state data
     * @returns {MetaphorJs.lib.State}
     */
    $newIsolated: function (data) {
      return new State(extend({}, data, {
        $app: this.$app,
        $level: this.$level + 1,
        $static: this.$static
      }, true, false));
    },

    /**
     * Freeze the state. It will not perfom checks and trigger change events
     * @method
     */
    $freeze: function () {
      if (!this.$$frozen) {
        this.$$frozen = true;
        this.$$observable.trigger("freeze", this);
      }
    },

    /**
     * Unfreeze state. Resume checking for changes
     * @method
     */
    $unfreeze: function () {
      if (this.$$frozen) {
        this.$$frozen = false;
        this.$$observable.trigger("unfreeze", this);
      }
    },

    /**
     * Subsrcibe to state events
     * @method 
     * @param {string} event
     * @param {function} fn
     * @param {object} context 
     */
    $on: function (event, fn, context) {
      return this.$$observable.on(event, fn, context);
    },

    /**
     * Unsubsrcibe from state events
     * @method 
     * @param {string} event
     * @param {function} fn
     * @param {object} context 
     */
    $un: function (event, fn, context) {
      return this.$$observable.un(event, fn, context);
    },

    /**
     * Create a watcher on js expression
     * @method
     * @param {string} expr js expression
     * @param {function} fn {
     *  @param {*} value
     * }
     * @param {object} context
     * @returns {MetaphorJs.lib.MutationObserver}
     */
    $watch: function (expr, fn, context) {
      return MetaphorJs.lib.MutationObserver.get(this, expr, fn, context);
    },

    /**
     * Stop watching js expression
     * @method
     * @param {string} expr js expression
     * @param {function} fn 
     * @param {object} context
     */
    $unwatch: function (expr, fn, context) {
      var mo = MetaphorJs.lib.MutationObserver.exists(this, expr);

      if (mo) {
        mo.unsubscribe(fn, context);
        mo.$destroy(true);
      }
    },

    /**
     * Watch changes in page url. Triggers regular change event
     * @method
     * @param {string} prop State property name
     * @param {string} param Url param name
     */
    $watchHistory: function (prop, param) {
      if (!this.$$historyWatchers[param]) {
        this.$$historyWatchers[param] = prop;
        MetaphorJs.lib.History.on("change-" + param, this.$$onHistoryChange, this);
      }
    },

    /**
     * Stop watching changes in page url.
     * @method
     * @param {string} param Url param name
     */
    $unwatchHistory: function (param) {
      if (!this.$$historyWatchers[param]) {
        delete this.$$historyWatchers[param];
        MetaphorJs.lib.History.un("change-" + param, this.$$onHistoryChange, this);
      }
    },

    /**
     * Set state value and check for changes.
     * @method
     * @param {string} key
     * @param {*} value
     */

    /**
    * Set state value and check for changes.
    * @method
    * @param {object} obj Key:value pairs
    */

    /**
     * Batch value update and check for changes.
     * @method
     * @param {function} fn fn(state)
     */
    $set: function (key, value) {
      if (typeof key === "string") {
        this[key] = value;
      } else if (typeof key === "function") {
        key(this);
      } else {
        for (let k in key) {
          this[k] = key[k];
        }
      }

      this.$check();
    },

    /**
     * Update state with object and check for changes
     * @param {object} data 
     */

    /**
     * Update state with object and check for changes
     * @param {string} key
     * @param {object} data 
     */
    $extend: function (key, data) {
      if (arguments.length === 2) {
        this[key] = extend(this[key], data, true, true);
      } else {
        extend(this, key, true, true);
      }

      this.$check();
    },
    $$onParentDestroy: function () {
      this.$destroy();
    },
    $$onParentCheck: function () {
      this.$check();
    },
    $$onHistoryChange: function (val, prev, name) {
      let prop;

      if (this.$$historyWatchers[name]) {
        prop = this.$$historyWatchers[name];
        this[prop] = val;
        this.$check();
      }
    },

    /**
     * Schedule a delayed check
     * @method
     * @param {int} timeout
     */
    $scheduleCheck: function (timeout) {
      if (!this.$$tmt) {
        this.$tmt = async(this.$check, this, null, timeout);
      }
    },

    /**
     * Check for changes and trigger change events.<br>
     * If changes are found, the check will run again
     * until no changes is found.
     * @method
     */
    $check: function () {
      let changes;

      if (this.$$checking || this.$static || this.$$frozen) {
        return;
      }

      this.$$checking = true;

      if (this.$$tmt) {
        clearTimeout(this.$$tmt);
        this.$$tmt = null;
      }

      if (this.$$mo) {
        changes = this.$$mo.$checkAll();
      }

      this.$$checking = false;

      if (!this.$$destroyed) {
        this.$$observable.trigger("check", changes);
      }

      if (changes > 0) {
        this.$$changing = true;
        this.$check();
      } else {
        // finished changing after all iterations
        if (this.$$changing) {
          this.$$changing = false;
          this.$$observable.trigger("changed");
        }
      }
    },

    /**
     * Register this state as public
     * @method
     * @param {string} name 
     */
    $registerPublic: function (name) {
      if (this.$$publicName || publicStates[name]) {
        return;
      }

      this.$$publicName = name;
      publicStates[name] = this;
    },

    /**
     * Register this state as default public
     * @method
     * @param {string} name 
     */
    $makePublicDefault: function () {
      this.$registerPublic("__default");
    },

    /**
     * Unregister public state
     * @method
     */
    $unregisterPublic: function () {
      const name = this.$$publicName;

      if (!name || !publicStates[name]) {
        return;
      }

      delete publicStates[name];
      this.$$publicName = null;
    },

    /**
     * Destroy state
     * @method
     */
    $destroy: function () {
      let param, i;

      if (this.$$destroyed) {
        return;
      }

      this.$$destroyed = true;
      this.$$observable.trigger("destroy");
      this.$$observable.$destroy();

      if (this.$parent && this.$parent.$un) {
        this.$parent.$un("check", this.$$onParentCheck, this);
        this.$parent.$un("destroy", this.$$onParentDestroy, this);
        this.$parent.$un("freeze", this.$freeze, this);
        this.$parent.$un("unfreeze", this.$unfreeze, this);
      }

      if (this.$$mo) {
        MetaphorJs.lib.MutationObserver.$destroy(this);
      }

      for (param in this.$$historyWatchers) {
        this.$unwatchHistory(param);
      }

      this.$unregisterPublic();

      for (i in this) {
        if (this.hasOwnProperty(i)) {
          this[i] = null;
        }
      }

      this.$$destroyed = true;
    }
  }, true, false);
  /**
   * Check if public state exists
   * @static
   * @method $exists
   * @param {string} name
   * @returns MetaphorJs.lib.State
   */

  State.$exists = function (name) {
    return !!publicStates[name];
  };
  /**
   * Get public state
   * @static
   * @method $get
   * @param {string} name - skip to get public default
   * @returns MetaphorJs.lib.State
   */


  State.$get = function (name) {
    return publicStates[name || "__default"];
  };
  /**
   * Produce a state either by getting a public state,
   * or creating a child of public state or
   * creating a new state
   * @static
   * @method
   * @param {string|MetaphorJs.lib.State} name {
   *  @optional
   * }
   * @param {MetaphorJs.lib.State} parent {
   *  @optional
   * }
   * @returns MetaphorJs.lib.State
   */


  State.$produce = function (name, parent) {
    if (name instanceof State) {
      return name;
    }

    if (!name) {
      if (parent) {
        return parent;
      }

      const def = publicStates['__default'];
      return def ? def.$new() : new State();
    } else {
      let action = "self";

      if (name.indexOf(":") !== -1) {
        let parts = name.split(":");
        name = parts[0];
        action = parts[1] || "self";
      }

      if (name) {
        parent = this.$get(name);

        if (!parent) {
          throw new Error("State with name " + name + " not found");
        }
      }

      switch (action) {
        case "self":
          return parent;

        case "new":
          return parent.$new();

        case "parent":
          return parent.$parent || parent.$root;

        case "root":
          return parent.$root;

        case "app":
          if (!parent.$app) {
            throw new Error("App not found in state");
          }

          return parent.$app.state;

        default:
          throw new Error("Unknown state action: " + action);
      }
    }
  };

  return State;
}();

/***/ }),

/***/ "../metaphorjs/src/lib/Stylesheet.js":
/*!*******************************************!*\
  !*** ../metaphorjs/src/lib/Stylesheet.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.lib.Stylesheet = function () {
  var Stylesheet = function (cfg) {
    var self = this;
    extend(self, cfg);
    !self.id && (self.id = nextUid());
    self.appended = false;

    if (self.content) {
      var content = self.content;
      self.content = null;
      self.setContent(content);
    }
  };

  extend(Stylesheet.prototype, {
    _initStylesheet: function () {
      var self = this;
      self.stylesheet = window.document.createElement("style");
      self.stylesheet.type = "text/css";
      self.stylesheet.id = "for_" + self.id;
      self.head = window.document.head || window.document.getElementsByTagName('head')[0] || window.document.body;
    },
    setContent: function (cssContent) {
      var self = this;

      if (cssContent != self.content) {
        self.content = cssContent;

        if (!self.stylesheet) {
          self._initStylesheet();
        }

        var style = self.stylesheet;

        if (style.styleSheet) {
          // This is required for IE8 and below.
          style.styleSheet.cssText = self.content;
        } else {
          while (style.firstChild) {
            style.removeChild(style.firstChild);
          }

          style.appendChild(window.document.createTextNode(self.content));
        }

        if (!self.appended) {
          self.append();
        }
      }
    },
    append: function () {
      var self = this;

      if (!self.stylesheet) {
        self._initStylesheet();
      }

      if (!self.appended) {
        self.head.appendChild(self.stylesheet);
        self.appended = true;
      }
    },
    remove: function () {
      var self = this;

      if (self.appended) {
        self.head.removeChild(self.stylesheet);
        self.appended = false;
      }
    },
    $destroy: function () {
      if (this.appended) {
        this.remove();
      }
    }
  });
  return Stylesheet;
}();

/***/ }),

/***/ "../metaphorjs/src/lib/Text.js":
/*!*************************************!*\
  !*** ../metaphorjs/src/lib/Text.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-observable/src/lib/Observable.js */ "../metaphorjs-observable/src/lib/Observable.js");

__webpack_require__(/*! ../lib/MutationObserver.js */ "../metaphorjs/src/lib/MutationObserver.js");

__webpack_require__(/*! ../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ../func/app/prebuilt.js */ "../metaphorjs/src/func/app/prebuilt.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      nextUid = __webpack_require__(/*! metaphorjs-shared/src/func/nextUid.js */ "../metaphorjs-shared/src/func/nextUid.js"),
      async = __webpack_require__(/*! metaphorjs-shared/src/func/async.js */ "../metaphorjs-shared/src/func/async.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js");
/**
 * Text renderer
 * @class MetaphorJs.lib.Text
 */


module.exports = MetaphorJs.lib.Text = function () {
  var startSymbol = '{{',
      endSymbol = '}}',
      startSymbolLength = 2,
      endSymbolLength = 2,
      events = new MetaphorJs.lib.Observable(),
      _procExpr = function (expr, state, observers) {
    if (observers) {
      var w = MetaphorJs.lib.MutationObserver.get(state, expr);
      observers.push(w);
      return w.getValue();
    } else {
      if (MetaphorJs.app.prebuilt.isKey(expr)) {
        expr = MetaphorJs.app.prebuilt.get("config", expr);
      }

      return MetaphorJs.lib.Expression.get(expr, state);
    }
  },
      eachText = function (text, fn) {
    var index = 0,
        textLength = text.length,
        startIndex,
        endIndex,
        expr,
        result = "";

    while (index < textLength) {
      if ((startIndex = text.indexOf(startSymbol, index)) !== -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) !== -1 && text.substr(startIndex - 1, 1) !== '\\') {
        result += text.substring(index, startIndex);

        if (endIndex !== startIndex + startSymbolLength) {
          expr = text.substring(startIndex + startSymbolLength, endIndex);
          expr = expr.trim();
          result += fn(expr);
        }

        index = endIndex + endSymbolLength;
      } else {
        // we did not find an interpolation
        if (index !== textLength) {
          result += text.substring(index);
        }

        break;
      }
    }

    return result;
  },
      render = function (text, state, observers, recursive, fullExpr) {
    var result,
        prev = text,
        iter = 0;

    if (text === false) {
      return false;
    }

    while (true) {
      if (iter > 100) {
        throw new Error("Got more than 100 iterations on template: " + self.origin);
      }

      if (fullExpr) {
        result = _procExpr(text, state, observers);
        fullExpr = false;
      } else {
        result = eachText(prev, function (expr) {
          return _procExpr(expr, state, observers);
        });
      }

      if (!recursive || result === prev) {
        return result;
      }

      prev = result;
      iter++;
    }
  };
  /**
   * @constructor
   * @method
   * @param {object} dataObj
   * @param {string} text 
   * @param {object} opt {
   *  @type {bool} recursive
   * }
   */


  var Text = function (state, text, opt) {
    opt = opt || {};
    var self = this;
    self.id = nextUid();
    self.origin = text;
    self.text = "";
    self.state = state;
    self.$destroyed = false;
    self.fullExpr = false;
    self.recursive = false;
    self.once = false;

    if (opt.recursive === true || opt.recursive === false) {
      self.recursive = opt.recursive;
    }

    if (opt.fullExpr === true || opt.fullExpr === false) {
      self.fullExpr = opt.fullExpr;
    }

    if (opt.once === true || opt.once === false) {
      self.once = opt.once;
    }

    self._processDelegate = bind(self._process, self);
    self.observers = [];

    self._process(true);
  };

  extend(Text.prototype, {
    _process: function (initial) {
      if (this.$destroyed) {
        return;
      }

      var self = this,
          obs = self.observers.slice();

      self._observeData(obs, "unsubscribe");

      self.observers = [];
      self.text = render(self.origin, self.state, self.observers, self.recursive, self.fullExpr);

      self._observeData(self.observers, "subscribe");

      self._destroyObservers(obs);

      if (!initial) {
        events.trigger(self.id, self);
      }
    },
    _onDataChange: function () {
      async(this._processDelegate);
    },
    _observeData: function (obs, mode) {
      var i,
          l,
          self = this;

      for (i = 0, l = obs.length; i < l; i++) {
        // subscribe/unsubscribe
        obs[i][mode](self._onDataChange, self);
      }
    },
    _destroyObservers: function (obs) {
      var i, l;

      for (i = 0, l = obs.length; i < l; i++) {
        obs[i].$destroy(true);
      }
    },

    /**
     * Get processed text
     * @method
     * @returns {string}
     */
    getString: function () {
      return this.text;
    },

    /**
     * Subscribe to changes in text
     * @param {function} fn 
     * @param {object} context 
     * @param {object} opt {
     *  MetaphorJs.lib.Observable.on() options
     * }
     */
    subscribe: function (fn, context, opt) {
      return events.on(this.id, fn, context, opt);
    },

    /**
     * Unsubscribe from changes in text
     * @param {function} fn 
     * @param {object} context 
     */
    unsubscribe: function (fn, context) {
      return events.un(this.id, fn, context);
    },

    /**
     * Used only in standalone mode. When part of an app, 
     * use state.$check()
     * @method
     * @returns {int}
     */
    check: function () {
      return MetaphorJs.lib.MutationObserver.check(this.state);
    },

    /**
     * Destroy text container
     * @method
     */
    $destroy: function () {
      var self = this;
      self.$destroyed = true;
      events.destroyEvent(self.id);

      self._observeData(self.observers, "unsubscribe");

      self._destroyObservers(self.observers);
    }
  });
  /**
   * Statically process text without subscribing to changes
   * @static
   * @method
   * @param {string} text Text template
   * @param {object} dataObj Data object (app.State) to read variables from
   * @param {array|null} observers {
   *  Pass empty array 
   *  @type {MetaphorJs.lib.MutationObserver} observer
   * }
   * @param {bool} recursive Recursively process text template
   * @returns {string}
   */

  Text.render = render;
  /**
   * @static
   * @method
   * @param {string} text Text template
   * @param {function} fn {
   *  @param {string} expression
   *  @returns {string} replacement
   * }
   * @returns {string} processed template
   */

  Text.eachText = eachText;
  /**
   * Does the text have expressions
   * @static
   * @method
   * @param {string} text
   * @returns {boolean}
   */

  Text.applicable = function (text) {
    return MetaphorJs.app.prebuilt.isKey(text) || !text || !text.indexOf || text.indexOf(startSymbol) === -1 ? false : true;
  };

  return Text;
}();

/***/ }),

/***/ "../metaphorjs/src/lib/UrlParam.js":
/*!*****************************************!*\
  !*** ../metaphorjs/src/lib/UrlParam.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./History.js */ "../metaphorjs/src/lib/History.js");

__webpack_require__(/*! metaphorjs-shared/src/func/browser/parseLocation.js */ "../metaphorjs-shared/src/func/browser/parseLocation.js");

__webpack_require__(/*! metaphorjs-observable/src/mixin/Observable.js */ "../metaphorjs-observable/src/mixin/Observable.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js"),
      isString = __webpack_require__(/*! metaphorjs-shared/src/func/isString.js */ "../metaphorjs-shared/src/func/isString.js"),
      extend = __webpack_require__(/*! metaphorjs-shared/src/func/extend.js */ "../metaphorjs-shared/src/func/extend.js"),
      getRegExp = __webpack_require__(/*! metaphorjs-shared/src/func/getRegExp.js */ "../metaphorjs-shared/src/func/getRegExp.js");

module.exports = MetaphorJs.lib.UrlParam = function () {
  var cache = {};
  /**
   * Url param watcher
   * @class MetaphorJs.lib.UrlParam
   */

  var UrlParam = cls({
    $mixins: [MetaphorJs.mixin.Observable],
    id: null,
    name: null,
    extractor: null,
    context: null,
    regexp: null,
    valueIndex: 1,
    prev: null,
    value: null,
    enabled: true,

    /**
     * @method
     * @constructor
     * @param {object} cfg {
     *  @type {string} id unique param id
     *  @type {string|RegExp} regexp
     *  @type {string} name
     *  @type {function} extractor {
     *      @param {string} url     
     *      @returns {*} value
     *  }
     *  @type {object} context extractor's context
     *  @type {int} valueIndex {
     *      Index in regexp match array
     *      @default 1
     *  }
     * }
     */
    $init: function (cfg) {
      var self = this;
      extend(self, cfg, true, false);

      if (self.regexp && isString(self.regexp)) {
        self.regexp = getRegExp(self.regexp);
      }

      if (self.name && !self.regexp && !self.extractor) {
        self.regexp = getRegExp(self.name + "=([^&]+)");
      }

      if (!self.regexp && !self.extractor) {
        throw new Error("Invalid UrlParam config, missing regexp or extractor");
      }

      if (self.enabled) {
        self.enabled = false;
        self.enable();
      }
    },

    /**
     * Enable watcher (enabled by default)
     * @method 
     */
    enable: function () {
      var self = this;

      if (!self.enabled) {
        self.enabled = true;
        MetaphorJs.lib.History.on("location-change", self.onLocationChange, self);
        var url = MetaphorJs.lib.History.current(),
            loc = MetaphorJs.browser.parseLocation(url);
        self.onLocationChange(loc.pathname + loc.search + loc.hash);
      }
    },

    /**
     * Disable watcher
     * @method
     */
    disable: function () {
      var self = this;

      if (self.enabled) {
        self.enabled = false;
        MetaphorJs.lib.History.un("location-change", self.onLocationChange, self);
      }
    },
    onLocationChange: function (url) {
      var self = this,
          value = self.extractValue(url);

      if (self.value != value) {
        self.prev = self.value;
        self.value = value;
        self.trigger("change", value, self.prev);
      }
    },

    /**
     * Extract param value from url
     * @method
     * @param {string} url
     * @returns {string}
     */
    extractValue: function (url) {
      var self = this;

      if (self.regexp) {
        var match = url.match(self.regexp);
        return match ? match[self.valueIndex] : null;
      } else if (self.extractor) {
        return self.extractor.call(self.context, url);
      }
    },

    /**
     * Get current param value
     * @method
     * @returns {string|null}
     */
    getValue: function () {
      return this.value;
    },

    /**
     * Get previous value
     * @method
     * @returns {string|null}
     */
    getPrev: function () {
      return this.prev;
    },

    /**
     * Destroy param watcher if there are no listeners
     * @method
     */
    destroyIfIdle: function () {
      var self = this;

      if (!self.$$observable.hasListener()) {
        self.$destroy();
      }
    },
    onDestroy: function () {
      var self = this;
      self.disable();
    }
  }, {
    /**
     * Get already initialized instance based on cfg.id
     * @static
     * @method
     * @param {object} cfg See constructor
     * @returns {MetaphorJs.lib.UrlParam}
     */
    get: function (cfg) {
      if (cfg.id && cache[cfg.id]) {
        return cache[cfg.id];
      } else {
        return new UrlParam(cfg);
      }
    }
  });
  return UrlParam;
}();

/***/ }),

/***/ "../metaphorjs/src/plugin/ListAnimated.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/plugin/ListAnimated.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/animate.js */ "../metaphorjs-animate/src/animate/animate.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/stop.js */ "../metaphorjs-animate/src/animate/stop.js");

__webpack_require__(/*! metaphorjs-animate/src/animate/getPrefixes.js */ "../metaphorjs-animate/src/animate/getPrefixes.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      raf = __webpack_require__(/*! metaphorjs-animate/src/func/raf.js */ "../metaphorjs-animate/src/func/raf.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = function () {
  var methods = {
    getNodePositions: function (tmp, items, oldItems) {
      var nodes = [],
          i,
          l,
          el,
          r,
          tmpNode,
          positions = {};

      while (tmp.firstChild) {
        tmp.removeChild(tmp.firstChild);
      }

      for (i = 0, l = items.length; i < l; i++) {
        if (oldItems && oldItems[i]) {
          tmpNode = oldItems[i].el.cloneNode(true);
          tmp.appendChild(tmpNode);
        }

        tmpNode = items[i].el.cloneNode(true);
        tmp.appendChild(tmpNode);
        nodes.push(tmpNode);
      }

      for (i = 0, l = nodes.length; i < l; i++) {
        el = nodes[i];
        r = items[i].renderer;

        if (r) {
          positions[r.id] = {
            left: el.offsetLeft,
            top: el.offsetTop
          };
        }
      }

      return positions;
    },
    calculateTranslates: function (newRenderers, origRenderers, withDeletes) {
      var self = this,
          parent = self._nextEl.parentNode,
          pp = parent.parentNode,
          tmp = parent.cloneNode(true),
          ofsW = parent.offsetWidth,
          translates = [],
          fl = 0,
          ft = 0,
          oldPositions,
          insertPositions,
          newPositions,
          r,
          i,
          len,
          id,
          style,
          el;
      style = tmp.style;
      style.position = "absolute";
      style.left = "-10000px";
      style.visibility = "hidden";
      style.width = ofsW + 'px';
      pp.insertBefore(tmp, parent); // correct width to compensate for padding and stuff

      style.width = ofsW - (tmp.offsetWidth - ofsW) + "px"; // positions before change

      oldPositions = self.getNodePositions(tmp, origRenderers); // positions when items reordered but deleted items are still in place

      insertPositions = self.getNodePositions(tmp, newRenderers, withDeletes); // positions after old items removed from dom

      newPositions = self.getNodePositions(tmp, newRenderers);
      pp.removeChild(tmp);
      tmp = null;

      for (i = 0, len = newRenderers.length; i < len; i++) {
        el = newRenderers[i].el;
        r = newRenderers[i].renderer;
        id = r.id;

        if (i === 0) {
          fl = el.offsetLeft;
          ft = el.offsetTop;
        }

        translates.push([// to
        {
          left: newPositions[id].left - fl - (insertPositions[id].left - fl),
          top: newPositions[id].top - ft - (insertPositions[id].top - ft)
        }, // from
        oldPositions[id] ? //insertPositions[id] &&
        {
          left: oldPositions[id].left - fl - (insertPositions[id].left - fl),
          top: oldPositions[id].top - ft - (insertPositions[id].top - ft)
        } : null]);
      }

      return translates;
    },
    moveAnimation: function (el, to, from, startCallback, applyFrom) {
      var style = el.style;
      applyFrom.done(function () {
        if (from) {
          var prefixes = MetaphorJs.animate.getPrefixes();
          style[prefixes.transform] = "translateX(" + from.left + "px) translateY(" + from.top + "px)";
        }
      });
      return MetaphorJs.animate.animate(el, "move", startCallback, function (el, position, stage) {
        if (position === 0 && stage !== "start" && to) {
          var prefixes = MetaphorJs.animate.getPrefixes();
          style[prefixes.transform] = "translateX(" + to.left + "px) translateY(" + to.top + "px)";
        }
      });
    },
    reflectChanges: function (vars) {
      var self = this,
          oldRenderers = vars.oldItems,
          newRenderers = vars.newItems,
          translates,
          i,
          len,
          r;
      self.renderOrUpdate(); //self.renderOrUpdate(vars.updateStart, null, "enter");

      if (vars.doesMove) {
        translates = self.calculateTranslates(vars.newItems, vars.origItems, vars.oldItems);
      }

      var animPromises = [],
          startAnimation = new MetaphorJs.lib.Promise(),
          applyFrom = new MetaphorJs.lib.Promise(),
          donePromise = new MetaphorJs.lib.Promise(),
          animReady = MetaphorJs.lib.Promise.counter(newRenderers.length),
          startCallback = function () {
        animReady.countdown();
        return startAnimation;
      }; // destroy old renderers and remove old elements


      for (i = 0, len = oldRenderers.length; i < len; i++) {
        r = oldRenderers[i];

        if (r) {
          r.state.$destroy();
          MetaphorJs.animate.stop(r.el);
          animPromises.push(MetaphorJs.animate.animate(r.el, "leave").done(function (el) {
            el.style.visibility = "hidden";
          }));
        }
      }

      for (i = 0, len = newRenderers.length; i < len; i++) {
        r = newRenderers[i];
        MetaphorJs.animate.stop(r.el);
        r.action === "enter" ? animPromises.push(MetaphorJs.animate.animate(r.el, "enter", startCallback)) : animPromises.push(self.moveAnimation(r.el, vars.doesMove ? translates[i][0] : null, vars.doesMove ? translates[i][1] : null, startCallback, applyFrom));
      }

      animReady.done(function () {
        raf(function () {
          applyFrom.resolve();
          self.applyDomPositions(oldRenderers);

          if (!vars.doesMove) {
            self.renderOrUpdate(vars.updateStart, null, "move");
          }

          raf(function () {
            startAnimation.resolve();
          });
          self.trigger("change", self);
        });
      });
      MetaphorJs.lib.Promise.all(animPromises).always(function () {
        raf(function () {
          var prefixes = MetaphorJs.animate.getPrefixes();
          self.renderOrUpdate(vars.updateStart || 0);
          self.removeOldElements(oldRenderers);

          if (vars.doesMove) {
            self.renderOrUpdate(vars.updateStart, null, "move");

            for (i = 0, len = newRenderers.length; i < len; i++) {
              r = newRenderers[i];

              if (r && r.el) {
                r.el.style[prefixes.transform] = null;
                r.el.style[prefixes.transform] = "";
              }
            }
          }

          donePromise.resolve();
        });
      });
      return donePromise;
    }
  };
  return cls({
    $class: "MetaphorJs.plugin.ListAnimated",
    $init: function (list) {
      list.$implement(methods);
    }
  });
}();

/***/ }),

/***/ "../metaphorjs/src/plugin/ListBuffered.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/plugin/ListBuffered.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-promise/src/lib/Promise.js */ "../metaphorjs-promise/src/lib/Promise.js");

__webpack_require__(/*! ../func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! ../func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

__webpack_require__(/*! ../func/dom/getScrollParent.js */ "../metaphorjs/src/func/dom/getScrollParent.js");

__webpack_require__(/*! ../func/dom/addClass.js */ "../metaphorjs/src/func/dom/addClass.js");

__webpack_require__(/*! ../func/dom/getPosition.js */ "../metaphorjs/src/func/dom/getPosition.js");

__webpack_require__(/*! ../func/dom/getScrollLeft.js */ "../metaphorjs/src/func/dom/getScrollLeft.js");

__webpack_require__(/*! ../func/dom/getScrollTop.js */ "../metaphorjs/src/func/dom/getScrollTop.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      raf = __webpack_require__(/*! metaphorjs-animate/src/func/raf.js */ "../metaphorjs-animate/src/func/raf.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = cls({
  $class: "MetaphorJs.plugin.ListBuffered",
  list: null,
  enabled: true,
  itemSize: null,
  itemsOffsite: 5,
  bufferState: null,
  scrollOffset: 0,
  horizontal: false,
  dynamicOffset: false,
  bufferEventDelegate: null,
  topStub: null,
  botStub: null,
  $init: function (list) {
    var self = this;
    self.list = list;
    list.$intercept("afterInit", this.afterInit, this, "before");
    list.$intercept("doRender", this.doRender, this, "instead");
    list.$implement({
      scrollTo: self.$bind(self.scrollTo),
      reflectChanges: function (vars) {
        if (!self.enabled) {
          self.$super(vars);
        } else {
          self.getScrollOffset();
          list.removeOldElements(vars.oldRenderers);
          list.queue.append(self.updateScrollBuffer, self, [true]);
          list.trigger("change", list);
        }
      }
    });
  },
  afterInit: function () {
    var self = this,
        attr = self.list.attr,
        cfg = attr ? attr.config : {};
    self.itemSize = cfg.itemSize;
    self.itemsOffsite = parseInt(cfg.itemsOffsite || 5, 10);
    self.horizontal = cfg.horizontal || false;
    self.dynamicOffset = cfg.dynamicOffset || false;
    self.initScrollParent(cfg);
    self.initScrollStubs(cfg);
    self.bufferEventDelegate = bind(self.bufferUpdateEvent, self);
    self.up();
    self.list.state.$on("freeze", self.down, self);
    self.list.state.$on("unfreeze", self.up, self);
  },
  doRender: function () {
    this.getScrollOffset();
    this.updateScrollBuffer();
  },
  up: function () {
    var self = this;
    MetaphorJs.dom.addListener(self.scrollEl, "scroll", self.bufferEventDelegate);
    MetaphorJs.dom.addListener(window, "resize", self.bufferEventDelegate);
  },
  down: function () {
    var self = this;
    MetaphorJs.dom.removeListener(self.scrollEl, "scroll", self.bufferEventDelegate);
    MetaphorJs.dom.removeListener(window, "resize", self.bufferEventDelegate);
  },
  initScrollParent: function (cfg) {
    var self = this;
    self.scrollEl = MetaphorJs.dom.getScrollParent(self.list.parentEl);
  },
  initScrollStubs: function (cfg) {
    var self = this,
        list = self.list,
        parent = list.parentEl,
        prev = list.prevEl,
        ofsTop,
        ofsBot,
        i,
        style = {
      fontSize: 0,
      lineHeight: 0,
      padding: 0,
      paddingTop: 0,
      paddingLeft: 0,
      paddingBottom: 0,
      paddingRight: 0,
      margin: 0,
      marginLeft: 0,
      marginTop: 0,
      marginRight: 0,
      marginBottom: 0
    };
    self.topStub = ofsTop = window.document.createElement(cfg.stub || "div");
    self.botStub = ofsBot = window.document.createElement(cfg.stub || "div");
    MetaphorJs.dom.addClass(ofsTop, "mjs-buffer-top");
    MetaphorJs.dom.addClass(ofsBot, "mjs-buffer-bottom");

    for (i in style) {
      ofsTop.style[i] = style[i];
      ofsBot.style[i] = style[i];
    }

    parent.insertBefore(ofsTop, prev ? prev.nextSibling : parent.firstChild);
    parent.insertBefore(ofsBot, list.nextEl);
    list.prevEl = ofsTop;
    list.nextEl = ofsBot;
  },
  getItemsPerRow: function () {
    return 1;
  },
  getRowHeight: function () {
    return this.itemSize;
  },
  getScrollOffset: function () {
    var self = this,
        position = MetaphorJs.dom.getPosition(self.topStub, self.scrollEl),
        ofs = self.horizontal ? position.left : position.top;
    return self.scrollOffset = ofs;
  },
  getBufferState: function (updateScrollOffset) {
    var self = this,
        scrollEl = self.scrollEl,
        hor = self.horizontal,
        html = window.document.documentElement,
        size = scrollEl === window ? window[hor ? "innerWidth" : "innerHeight"] || html[hor ? "clientWidth" : "clientHeight"] : scrollEl[hor ? "offsetWidth" : "offsetHeight"],
        scroll = hor ? MetaphorJs.dom.getScrollLeft(scrollEl) : MetaphorJs.dom.getScrollTop(scrollEl),
        sh = scrollEl.scrollHeight,
        perRow = self.getItemsPerRow(),
        isize = self.getRowHeight(),
        off = self.itemsOffsite,
        offset = updateScrollOffset ? self.getScrollOffset() : self.scrollOffset,
        cnt = Math.ceil(self.list.renderers.length / perRow),
        viewFirst,
        viewLast,
        first,
        last; //scroll  = Math.max(0, scroll - offset);

    first = Math.ceil((scroll - offset) / isize);

    if (first < 0) {
      first = 0;
    }

    viewFirst = first;
    last = viewLast = first + Math.ceil(size / isize);
    first = first > off ? first - off : 0;
    last += off;

    if (last > cnt - 1) {
      last = cnt - 1;
    }

    if (sh && scroll + size >= sh && self.bufferState) {
      if (self.bufferState.last == last * perRow) {
        last += off;
      }
    }

    if (first > last) {
      return self.bufferState;
    }

    return self.bufferState = {
      first: first * perRow,
      viewFirst: viewFirst * perRow,
      last: last * perRow,
      viewLast: viewLast * perRow,
      ot: first * isize,
      ob: (cnt - last - 1) * isize
    };
  },
  updateStubs: function (bs) {
    var self = this,
        hor = self.horizontal;
    self.topStub.style[hor ? "width" : "height"] = bs.ot + "px";
    self.botStub.style[hor ? "width" : "height"] = bs.ob + "px";
  },
  bufferUpdateEvent: function () {
    var self = this;
    self.list.queue.add(self.updateScrollBuffer, self);
  },
  updateScrollBuffer: function (reset) {
    var self = this,
        list = self.list,
        prev = self.bufferState,
        parent = list.parentEl,
        rs = list.renderers,
        bot = self.botStub,
        bs = self.getBufferState(self.dynamicOffset),
        promise = new MetaphorJs.lib.Promise(),
        doc = window.document,
        fragment,
        i,
        x,
        r;

    if (!bs) {
      return null;
    }

    if (!prev || bs.first != prev.first || bs.last != prev.last) {
      list.trigger("buffer-change", self, bs, prev);
    }

    raf(function () {
      if (self.$isDestroyed()) {
        return;
      } //TODO: account for tag mode


      if (reset || !prev || bs.last < prev.first || bs.first > prev.last) {
        //remove old and append new
        if (prev) {
          for (i = prev.first, x = prev.last; i <= x; i++) {
            r = rs[i];

            if (r && r.attached) {
              parent.removeChild(r.el);
              r.attached = false;
            }
          }
        }

        fragment = doc.createDocumentFragment();

        for (i = bs.first, x = bs.last; i <= x; i++) {
          r = rs[i];

          if (r) {
            if (!r.rendered) {
              list.renderItem(i);
            }

            fragment.appendChild(r.el);
            r.attached = true;
          }
        }

        parent.insertBefore(fragment, bot);
      } else {
        if (prev.first < bs.first) {
          for (i = prev.first, x = bs.first; i < x; i++) {
            r = rs[i];

            if (r && r.attached) {
              parent.removeChild(r.el);
              r.attached = false;
            }
          }
        } else if (prev.first > bs.first) {
          fragment = doc.createDocumentFragment();

          for (i = bs.first, x = prev.first; i < x; i++) {
            r = rs[i];

            if (r) {
              if (!r.rendered) {
                list.renderItem(i);
              }

              fragment.appendChild(r.el);
              r.attached = true;
            }
          }

          parent.insertBefore(fragment, rs[prev.first].el);
        }

        if (prev.last < bs.last) {
          fragment = doc.createDocumentFragment();

          for (i = prev.last + 1, x = bs.last; i <= x; i++) {
            r = rs[i];

            if (r) {
              if (!r.rendered) {
                list.renderItem(i);
              }

              fragment.appendChild(r.el);
              r.attached = true;
            }
          }

          parent.insertBefore(fragment, bot);
        } else if (prev.last > bs.last) {
          for (i = bs.last + 1, x = prev.last; i <= x; i++) {
            r = rs[i];

            if (r && r.attached) {
              parent.removeChild(r.el);
              r.attached = false;
            }
          }
        }
      }

      self.updateStubs(bs);
      list.trigger("buffer-update", self);
      self.onBufferStateChange(bs, prev);
      promise.resolve();
    });
    return promise;
  },
  // not finished: todo unbuffered and animation
  scrollTo: function (index) {
    var self = this,
        list = self.list,
        isize = self.itemSize,
        sp = self.scrollEl || MetaphorJs.dom.getScrollParent(list.parentEl),
        hor = self.horizontal,
        prop = hor ? "scrollLeft" : "scrollTop",
        promise = new MetaphorJs.lib.Promise(),
        pos;
    list.queue.append(function () {
      raf(function () {
        pos = isize * index;

        if (sp === window) {
          window.scrollTo(hor ? pos : MetaphorJs.dom.getScrollLeft(), !hor ? pos : MetaphorJs.dom.getScrollTop());
        } else {
          sp[prop] = pos;
        }

        promise.resolve();
      });
      return promise;
    });
    return promise;
  },
  onBufferStateChange: function (bs, prev) {},
  $beforeHostDestroy: function () {
    var self = this,
        parent = self.list.parentEl;
    parent.removeChild(self.topStub);
    parent.removeChild(self.botStub);
    self.down();
  }
});

/***/ }),

/***/ "../metaphorjs/src/plugin/ListPullNext.js":
/*!************************************************!*\
  !*** ../metaphorjs/src/plugin/ListPullNext.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./ListBuffered.js */ "../metaphorjs/src/plugin/ListBuffered.js");

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.plugin.ListBuffered.$extend({
  $class: "MetaphorJs.plugin.ListPullNext",
  buffered: false,
  $init: function (list, args) {
    var attr = list.attr,
        cfg = attr ? attr.config : {};

    if (cfg.bufferedPullNext) {
      this.buffered = cfg.bufferedPullNext;
      list.buffered = true;
    }

    this.$super(list, args);
  },
  afterInit: function () {
    this.$super();
    this.getScrollOffset();
  },
  updateScrollBuffer: function (reset) {
    var self = this;

    if (self.buffered) {
      return self.$super(reset);
    } else {
      var prev = self.bufferState,
          bs = self.getBufferState(self.dynamicOffset);

      if (!prev || bs.first != prev.first || bs.last != prev.last) {
        self.list.trigger("buffer-change", self, bs, prev);
        self.onBufferStateChange(bs, prev);
      }
    }
  },
  onBufferStateChange: function (bs, prev) {
    var self = this,
        list = self.list,
        cnt = list.store.getLength();
    self.$super(bs, prev);

    if (cnt - bs.last < (bs.last - bs.first) / 3 && !list.store.loading && !list.store.$destroyed) {
      list.store.addNextPage();
      list.trigger("pull", self);
    }
  }
});

/***/ }),

/***/ "../metaphorjs/src/plugin/SrcDeferred.js":
/*!***********************************************!*\
  !*** ../metaphorjs/src/plugin/SrcDeferred.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! metaphorjs-shared/src/lib/Queue.js */ "../metaphorjs-shared/src/lib/Queue.js");

__webpack_require__(/*! ../func/dom/getScrollParent.js */ "../metaphorjs/src/func/dom/getScrollParent.js");

__webpack_require__(/*! ../func/dom/getPosition.js */ "../metaphorjs/src/func/dom/getPosition.js");

__webpack_require__(/*! ../func/dom/getScrollTop.js */ "../metaphorjs/src/func/dom/getScrollTop.js");

__webpack_require__(/*! ../func/dom/getScrollLeft.js */ "../metaphorjs/src/func/dom/getScrollLeft.js");

__webpack_require__(/*! ../func/dom/getWidth.js */ "../metaphorjs/src/func/dom/getWidth.js");

__webpack_require__(/*! ../func/dom/getHeight.js */ "../metaphorjs/src/func/dom/getHeight.js");

__webpack_require__(/*! ../func/dom/addListener.js */ "../metaphorjs/src/func/dom/addListener.js");

__webpack_require__(/*! ../func/dom/removeListener.js */ "../metaphorjs/src/func/dom/removeListener.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      bind = __webpack_require__(/*! metaphorjs-shared/src/func/bind.js */ "../metaphorjs-shared/src/func/bind.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = cls({
  $class: "MetaphorJs.plugin.SrcDeferred",
  directive: null,
  queue: null,
  scrollEl: null,
  scrollDelegate: null,
  resizeDelegate: null,
  position: null,
  sw: null,
  sh: null,
  checkVisibility: true,
  $init: function (directive) {
    var self = this;
    self.directive = directive;
    directive.$intercept("onStateChange", self.onStateChange, self, "instead");
    directive.$intercept("initDirective", self.$initDirective, self, "before");
    self.queue = directive.queue || new MetaphorJs.lib.Queue({
      auto: true,
      async: true,
      mode: MetaphorJs.lib.Queue.REPLACE,
      thenable: true
    });
  },
  $initDirective: function () {
    var self = this;
    self.scrollEl = MetaphorJs.dom.getScrollParent(self.directive.node);
    self.scrollDelegate = bind(self.onScroll, self);
    self.resizeDelegate = bind(self.onResize, self);
    MetaphorJs.dom.addListener(self.scrollEl, "scroll", self.scrollDelegate);
    MetaphorJs.dom.addListener(window, "resize", self.resizeDelegate);
  },
  isVisible: function () {
    if (!this.checkVisibility) {
      return true;
    }

    var self = this,
        sEl = self.scrollEl,
        st = MetaphorJs.dom.getScrollTop(sEl),
        sl = MetaphorJs.dom.getScrollLeft(sEl),
        w = self.sw,
        h = self.sh,
        t,
        l;

    if (!self.position) {
      self.position = MetaphorJs.dom.getPosition(self.directive.node, sEl);
    }

    if (!w) {
      w = self.sw = MetaphorJs.dom.getWidth(sEl);
      h = self.sh = MetaphorJs.dom.getHeight(sEl);
    }

    t = self.position.top;
    l = self.position.left;
    return t > st && t < st + h && l > sl && l < sl + w;
  },
  onScroll: function () {
    var self = this;
    self.queue.add(self.changeIfVisible, self);
  },
  onResize: function () {
    var self = this;
    self.position = null;
    self.sw = null;
    self.queue.add(self.changeIfVisible, self);
  },
  onStateChange: function () {
    var self = this;
    self.queue.add(self.changeIfVisible, self);
  },
  changeIfVisible: function () {
    var self = this;

    if (self.isVisible()) {
      self.stopWatching();
      return self.directive.doChange();
    }
  },
  stopWatching: function () {
    var self = this;

    if (self.scrollEl) {
      MetaphorJs.dom.removeListener(self.scrollEl, "scroll", self.scrollDelegate);
      MetaphorJs.dom.removeListener(window, "resize", self.resizeDelegate);
      self.scrollEl = null;
      self.checkVisibility = false;
    }
  },
  $beforeHostDestroy: function () {
    this.stopWatching();
    this.queue.$destroy();
  }
});

/***/ }),

/***/ "../metaphorjs/src/plugin/SrcSize.js":
/*!*******************************************!*\
  !*** ../metaphorjs/src/plugin/SrcSize.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/Expression.js */ "../metaphorjs/src/lib/Expression.js");

__webpack_require__(/*! ../func/dom/getAttr.js */ "../metaphorjs/src/func/dom/getAttr.js");

__webpack_require__(/*! ../func/dom/removeStyle.js */ "../metaphorjs/src/func/dom/removeStyle.js");

const cls = __webpack_require__(/*! metaphorjs-class/src/cls.js */ "../metaphorjs-class/src/cls.js"),
      MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = cls({
  $class: "MetaphorJs.plugin.SrcSize",
  directive: null,
  width: null,
  height: null,
  origOnChange: null,
  $init: function (directive) {
    var self = this;
    self.directive = directive;
    directive.$intercept("initDirective", self.$initDirective, self, "after");
    self.origOnChange = directive.$intercept("onSrcChanged", self.onSrcChanged, self, "after");
  },
  $initDirective: function () {
    var attr = self.directive.attr,
        node = self.directive.node,
        state = self.directive.state,
        cfg = attr ? attr.config : {},
        size = cfg.preloadSize,
        style = node.style;

    if (size !== "attr") {
      size = MetaphorJs.lib.Expression.parse(size)(state);
    }

    var width = size === "attr" ? parseInt(MetaphorJs.dom.getAttr(node, "width"), 10) : size.width,
        height = size === "attr" ? parseInt(MetaphorJs.dom.getAttr(node, "height"), 10) : size.height;

    if (width || height) {
      style.display = "block";
    }

    if (width) {
      style.width = width + "px";
    }

    if (height) {
      style.height = height + "px";
    }
  },
  onSrcChanged: function () {
    var self = this,
        directive = self.directive,
        node = directive.node;
    directive.onSrcChanged = self.origOnChange;
    MetaphorJs.dom.removeStyle(node, "width");
    MetaphorJs.dom.removeStyle(node, "height");
    MetaphorJs.dom.removeStyle(node, "display");
    self.$destroy();
  }
});

/***/ }),

/***/ "../metaphorjs/src/var/dom/htmlTags.js":
/*!*********************************************!*\
  !*** ../metaphorjs/src/var/dom/htmlTags.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

module.exports = MetaphorJs.dom.htmlTags = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "math", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr"];

/***/ }),

/***/ "../../../../../private/tmp/wp-prebuilt-1655993698248.js":
/*!***************************************************************!*\
  !*** ../../../../../private/tmp/wp-prebuilt-1655993698248.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

const MetaphorJs = __webpack_require__(/*! ../metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

MetaphorJs.prebuilt = {
  "templates": {
    "ui/button/button-container.html": "<div ##main><!--##before--> <span {bind}=\"this.$cfg.text\"></span><!--##after--></div>",
    "ui/button/button-plain.html": "<a ##main><!--##before--> <span {bind}=\"this.$cfg.text\"></span><!--##after--></a>",
    "ui/button/button.html": "<!--<main ##button\n    ##body\n    class=\"ui button\" \n    {class.active}=\"this.$cfg.active\"\n    {class.loading}=\"this.$cfg.loading\"\n    {class.disabled}=\"this.$cfg.disabled\"\n    {class.dropdown}=\"this.button.hasDropdown()\"\n    (click)=\"this.button.onClick(this.$event)\"\n    (click.$if)=\"!this.$cfg.disabled && !this.$cfg.loading\">--><mjs-include $name*=\"this.button.hasDropdown() ? \n                    'ui/button/button-container.html' : \n                    'ui/button/button-plain.html'\"></mjs-include>",
    "ui/button/group.html": "<div class=\"ui buttons\" ##body></div>",
    "ui/dialog/color-picker.html": "<div class=\"section\"></div>",
    "ui/field/checkbox.html": "<div ##main class=\"ui checkbox\" {class.active}=\"this.$cfg.active\"><input type=\"checkbox\" [name]=\"this.$cfg.name\" {model}=\"this.checked\"> <label {bind}=\"this.$cfg.label\"></label></div>",
    "ui/field/input.html": "<div class=\"ui input\" ##main ##body><!--##before--> <input ##input [type]=\"this.$cfg.type\" [placeholder]=\"this.$cfg.placeholder\"><!--##after--></div>",
    "ui/field/select.html": "<div ##main class=\"ui dropdown selection\" (click)=\"this.$view.onSelfClick(this.$event)\" {init}=\"this.emptyShown = false; this.selectedShown = false;\" {class.loading}=\"this.loading\" {class.active}=\"this.opened\" {class.disabled}=\"this.$cfg.disabled\" {class.search}=\"this.$cfg.searchable\" {class.multiple}=\"this.field.isMultiSelection()\"><!--##before--> <input type=\"hidden\" ##hidden_field [name]=\"this.$cfg.name\" [value]=\"this.field.$$selection | join:','\"> <i ##icon_down class=\"dropdown icon\" (click)=\"this.$view.onDropdownIconClick(this.$event)\"></i> <a class=\"ui label transition\" {each}=\"item in this.field.getMultiSelection()\">{{ this.$parent.field.getItemName(this.item) }} <i class=\"delete icon\" (click)=\"this.$parent.$view.onItemDeleteClick(this.item, this.$event)\"></i> </a><input type=\"text\" ##search class=\"search\" [placeholder]=\"this.$cfg.placeholder\" {readonly}=\"this.$cfg.readonly\" {disabled}=\"this.$cfg.disabled\" {show}=\"this.$cfg.searchable\" {show.$display}=\"inline-block\" (focus)=\"this.$view.onSearchFocus(this.$event)\" (blur)=\"this.$view.onSearchBlur(this.$event)\" (key.backspace)=\"this.$view.onSearchBackspace(this.$event)\" {model}=\"this.searchQuery\"> <span class=\"sizer\" ##sizer {if}=\"this.field.isMultiSelection() && this.$cfg.searchable\" {bind}=\"this.searchQuery\"></span><div class=\"default text\" ##default_text (click)=\"this.$view.onValueTextClick(this.$event)\" {show}=\"!this.searchQuery && !this.field.hasSelection() &&\n                    !!this.$cfg.emptyText\" {show.$display}=\"inline-block\" {show.$on--change}=\"this.emptyShown = this.$1\" {bind}=\"this.$cfg.emptyText\"></div><div class=\"text\" ##text (click)=\"this.$view.onValueTextClick(this.$event)\" {class.default}=\"this.focused && this.searchQuery == ''\" {show}=\"!this.searchQuery && !this.field.isMultiSelection() && \n                    this.field.hasSelection()\" {show.$on--change}=\"this.selectedShown = this.$1\" {show.$display}=\"inline-block\" {bind-html}=\"this.field.getSelectedName() || '&nbsp;'\"></div><i class=\"delete icon\" ##icon_delete {if}=\"this.$cfg.showSingleClear && !this.field.isMultiSelection() && this.field.hasSelection()\" (click)=\"this.$view.onItemDeleteClick(this.field.getSelection(0), this.$event)\"></i><!-- replaces two previous text blocks with invisible placeholder --><div style=\"display: none\" class=\"default text\" {show}=\"!this.emptyShown && !this.selectedShown && !this.$cfg.searchable\" {show.$display}=\"inline-block\">&nbsp;</div><select ##hidden_select (click)=\"this.$view.onHiddenSelectClick(this.$event)\" (change)=\"this.$view.onHiddenSelectChange(this.$event)\" {if}=\"this.$cfg.useHiddenSelect\" {options}=\"this.field._getSelectOptions()\"></select><div class=\"menu transition\" ##menu_items><div class=\"disabled item\" ##menu_disabled {if}=\"this.$cfg.showNotFound && this.field.store.isEmpty()\" (click.$stop-propagation) {bind-html}=\"this.$cfg.notFoundText\"></div><a class=\"empty item\" href=\"#\" ##menu_empty {if}=\"this.$cfg.showEmptyItem && !this.field.store.isEmpty()\" (click)=\"this.$view.onItemClick(null, this.$event)\" {bind-html}=\"this.$cfg.emptyItemText\"></a> <a class=\"item\" href=\"#\" {each}=\"item in this.field.store\" (click)=\"this.$parent.$view.onItemClick(this.item, this.$event)\" {bind}=\"this.$parent.field.getItemName(this.item)\"></a><!--##pagination--></div><!--##after--></div>",
    "ui/menu/container.html": "<div ##main class=\"ui item\" {class.active}=\"this.$cfg.active\" {class.dropdown}=\"this.item.hasDropdown()\"><!--##before--><!--##body--><!--##after--></div>",
    "ui/menu/divider.html": "<div class=\"divider\" ##main></div>",
    "ui/menu/item-with-sub.html": "<div ##main class=\"ui item\" {class.active}=\"this.$cfg.active\" {class.dropdown}=\"this.item.hasDropdown()\" (click)=\"this.item.onClick(this.$event)\"><!--##before--> <span {bind}=\"this.$cfg.text\"></span><!--##body--><!--##after--></div>",
    "ui/menu/item.html": "<a ##main class=\"item\" {class.active}=\"this.$cfg.active\" (click)=\"this.item.onClick(this.$event)\"><!--##before--> <span {bind}=\"this.$cfg.text\"></span><!--##body--><!--##after--></a>",
    "ui/menu/menu.html": "<div ##main class=\"ui menu\"><!--##before--><!--##body--><!--##after--></div>",
    "ui/panel/panel.html": "<div class=\"ui segment\"><!--##tbar--><!--##bbar--></div>",
    "ui/toolbar/container.html": "<!--{includes: true}--><!-- include ui/menu/container.html -->",
    "ui/toolbar/divider.html": "<!--{includes: true}--><!-- include ui/menu/divider.html -->",
    "ui/toolbar/item-with-sub.html": "<!--{includes: true}--><!-- include ui/menu/item-with-sub.html -->",
    "ui/toolbar/item.html": "<!--{includes: true}--><!-- include ui/menu/item.html -->",
    "ui/toolbar/toolbar.html": "<!--{includes: true}--><!-- include ui/menu/menu.html -->",
    "ui/util/canvas.html": "<canvas ##main ##canvas {style.width}=\"this.$cfg.width + 'px'\" {style.height}=\"this.$cfg.height + 'px'\"></canvas>",
    "ui/util/color-picker.html": "<div ##main><div style=\"width:50px; height: 30px;\" {style.background-color}=\"'#'+this.sv\"></div><ui-color-sv $ref=\"sv\" $width=\"150\" $height=\"150\" $cursor=\"crosshair\" $color!=\"this.color\" {model}=\"this.sv\" {model.$binding}=\"input\" {bind}=\"this.hue\"></ui-color-sv><ui-color-hue $ref=\"hue\" $width=\"30\" $height=\"150\" $cursor=\"crosshair\" $color!=\"this.color\" {model}=\"this.hue\" {model.$binding}=\"input\"></ui-color-hue><div style=\"clear:both\">HEX: <input type=\"text\" {bind}=\"this.color.getHEX()\" {bind.$preserve-input} {model}=\"this.input.hex\" {model.$binding}=\"input\" {model.$focus-only}><br>R: <input type=\"number\" {model}=\"this.input.r\" {model.$binding}=\"input\" {model.$focus-only} {bind}=\"this.color.getRGBA()[0]\" {bind.$preserve-input} min=\"0\" max=\"255\"> G: <input type=\"number\" {model}=\"this.input.g\" {model.$binding}=\"input\" {model.$focus-only} {bind}=\"this.color.getRGBA()[1]\" {bind.$preserve-input} min=\"0\" max=\"255\"> B: <input type=\"number\" {model}=\"this.input.b\" {model.$binding}=\"input\" {model.$focus-only} {bind}=\"this.color.getRGBA()[2]\" {bind.$preserve-input} min=\"0\" max=\"255\"><br>H: <input type=\"number\" {model}=\"this.input.h\" {model.$binding}=\"input\" {model.$focus-only} {bind}=\"this.color.getHSVA()[0]\" {bind.$preserve-input} min=\"0\" max=\"360\"> S: <input type=\"number\" {model}=\"this.input.s\" {model.$binding}=\"input\" {model.$focus-only} {bind}=\"this.color.getHSVA()[1]\" {bind.$preserve-input} min=\"0\" max=\"100\"> V: <input type=\"number\" {model}=\"this.input.v\" {model.$binding}=\"input\" {model.$focus-only} {bind}=\"this.color.getHSVA()[2]\" {bind.$preserve-input} min=\"0\" max=\"100\"><br></div></div>",
    "ui/util/color.html": "<div ##main style=\"position:relative\" {style.width}=\"this.$cfg.width + 'px'\" {style.height}=\"this.$cfg.height + 'px'\"><i ##pointer {style.left}=\"this.pointerLeft\" {style.top}=\"this.pointerTop\"></i><canvas ##canvas {style.width}=\"this.$cfg.width + 'px'\" {style.height}=\"this.$cfg.height + 'px'\" {style.cursor}=\"this.$cfg.cursor\"></canvas></div>",
    "ui/util/pagination.html": "<div class=\"pagination\" ##main><!--##before--><div class=\"item\" {if}=\"!this.$cfg.simple\">{{ this.page }} of {{ this.pages }}</div><div class=\"item\" {if}=\"!!this.$cfg.simple\">{{ this.start + 1 }} &nbsp;&mdash;&nbsp;{{ this.end }}</div><a href=\"#\" class=\"arrow item\" ##arrow_left {class.disabled}=\"!this.hasPrev || this.loading\" [disabled]=\"!this.hasPrev || this.loading\" (click)=\"this.pgn.onPrevClick()\"></a><div class=\"item\" {if}=\"!this.$cfg.simple\">Page&nbsp; <input type=\"text\" ##input {model}=\"this.changePage\" (key.enter)=\"this.pgn.onPageKeyDown()\"></div><a href=\"#\" class=\"arrow item\" ##arrow_right {class.disabled}=\"!this.hasNext || this.loading\" [disabled]=\"!this.hasNext || this.loading\" (click)=\"this.pgn.onNextClick()\"></a><!--##after--></div>",
    "ui/window/window.html": "<div class=\"ui modal\" ##body></div>",
    "container1.html": "<div class=\"toolbar\" ##toolbar>Toolbar here</div><div class=\"body\">This is a body wrapper<div class=\"items\" ##body>This is the body</div></div><div class=\"fbar\" ##footer>Footer here</div>",
    "container2.html": "<div ##main>This is parent 3 (container2.html)<div ##body></div></div>"
  }
};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!******************************************************!*\
  !*** ../../../../../private/tmp/wp-1655993698248.js ***!
  \******************************************************/
const MetaphorJs = __webpack_require__(/*! ../metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

__webpack_require__(/*! ../../../../../tmp/wp-prebuilt-1655993698248.js */ "../../../../../private/tmp/wp-prebuilt-1655993698248.js");

__webpack_require__(/*! ../metaphorjs-shared/src/MetaphorJs.js */ "../metaphorjs-shared/src/MetaphorJs.js");

__webpack_require__(/*! ../metaphorjs/src/app/__init.js */ "../metaphorjs/src/app/__init.js");

__webpack_require__(/*! ../metaphorjs/src/app/App.js */ "../metaphorjs/src/app/App.js");

__webpack_require__(/*! ../metaphorjs/src/app/Component.js */ "../metaphorjs/src/app/Component.js");

__webpack_require__(/*! ../metaphorjs/src/app/component/View.js */ "../metaphorjs/src/app/component/View.js");

__webpack_require__(/*! ../metaphorjs/src/app/Container.js */ "../metaphorjs/src/app/Container.js");

__webpack_require__(/*! ../metaphorjs/src/app/Controller.js */ "../metaphorjs/src/app/Controller.js");

__webpack_require__(/*! ../metaphorjs/src/app/Directive.js */ "../metaphorjs/src/app/Directive.js");

__webpack_require__(/*! ../metaphorjs/src/app/ListRenderer.js */ "../metaphorjs/src/app/ListRenderer.js");

__webpack_require__(/*! ../metaphorjs/src/app/Renderer.js */ "../metaphorjs/src/app/Renderer.js");

__webpack_require__(/*! ../metaphorjs/src/app/StoreRenderer.js */ "../metaphorjs/src/app/StoreRenderer.js");

__webpack_require__(/*! ../metaphorjs/src/app/Template.js */ "../metaphorjs/src/app/Template.js");

__webpack_require__(/*! ../metaphorjs/src/app/view/Base.js */ "../metaphorjs/src/app/view/Base.js");

__webpack_require__(/*! ../metaphorjs/src/app/view/Component.js */ "../metaphorjs/src/app/view/Component.js");

__webpack_require__(/*! ../metaphorjs/src/app/view/Router.js */ "../metaphorjs/src/app/view/Router.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/app.js */ "../metaphorjs/src/directive/attr/app.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/autofocus.js */ "../metaphorjs/src/directive/attr/autofocus.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/bind-html.js */ "../metaphorjs/src/directive/attr/bind-html.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/bind.js */ "../metaphorjs/src/directive/attr/bind.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/class.js */ "../metaphorjs/src/directive/attr/class.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/cmp.js */ "../metaphorjs/src/directive/attr/cmp.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/controller.js */ "../metaphorjs/src/directive/attr/controller.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/each.js */ "../metaphorjs/src/directive/attr/each.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/events.js */ "../metaphorjs/src/directive/attr/events.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/focused.js */ "../metaphorjs/src/directive/attr/focused.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/hide.js */ "../metaphorjs/src/directive/attr/hide.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/if.js */ "../metaphorjs/src/directive/attr/if.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/include.js */ "../metaphorjs/src/directive/attr/include.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/init.js */ "../metaphorjs/src/directive/attr/init.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/input.js */ "../metaphorjs/src/directive/attr/input.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/key.js */ "../metaphorjs/src/directive/attr/key.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/model.js */ "../metaphorjs/src/directive/attr/model.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/options.js */ "../metaphorjs/src/directive/attr/options.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/properties.js */ "../metaphorjs/src/directive/attr/properties.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/router.js */ "../metaphorjs/src/directive/attr/router.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/show.js */ "../metaphorjs/src/directive/attr/show.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/source-src.js */ "../metaphorjs/src/directive/attr/source-src.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/src.js */ "../metaphorjs/src/directive/attr/src.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/state.js */ "../metaphorjs/src/directive/attr/state.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/style.js */ "../metaphorjs/src/directive/attr/style.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/transclude.js */ "../metaphorjs/src/directive/attr/transclude.js");

__webpack_require__(/*! ../metaphorjs/src/directive/attr/view.js */ "../metaphorjs/src/directive/attr/view.js");

__webpack_require__(/*! ../metaphorjs/src/directive/tag/transclude.js */ "../metaphorjs/src/directive/tag/transclude.js");

__webpack_require__(/*! ../metaphorjs/src/filter/__init.js */ "../metaphorjs/src/filter/__init.js");

__webpack_require__(/*! ../metaphorjs/src/filter/collect.js */ "../metaphorjs/src/filter/collect.js");

__webpack_require__(/*! ../metaphorjs/src/filter/filter.js */ "../metaphorjs/src/filter/filter.js");

__webpack_require__(/*! ../metaphorjs/src/filter/get.js */ "../metaphorjs/src/filter/get.js");

__webpack_require__(/*! ../metaphorjs/src/filter/join.js */ "../metaphorjs/src/filter/join.js");

__webpack_require__(/*! ../metaphorjs/src/filter/l.js */ "../metaphorjs/src/filter/l.js");

__webpack_require__(/*! ../metaphorjs/src/filter/limitTo.js */ "../metaphorjs/src/filter/limitTo.js");

__webpack_require__(/*! ../metaphorjs/src/filter/linkify.js */ "../metaphorjs/src/filter/linkify.js");

__webpack_require__(/*! ../metaphorjs/src/filter/lowercase.js */ "../metaphorjs/src/filter/lowercase.js");

__webpack_require__(/*! ../metaphorjs/src/filter/map.js */ "../metaphorjs/src/filter/map.js");

__webpack_require__(/*! ../metaphorjs/src/filter/moment.js */ "../metaphorjs/src/filter/moment.js");

__webpack_require__(/*! ../metaphorjs/src/filter/numeral.js */ "../metaphorjs/src/filter/numeral.js");

__webpack_require__(/*! ../metaphorjs/src/filter/offset.js */ "../metaphorjs/src/filter/offset.js");

__webpack_require__(/*! ../metaphorjs/src/filter/p.js */ "../metaphorjs/src/filter/p.js");

__webpack_require__(/*! ../metaphorjs/src/filter/pl.js */ "../metaphorjs/src/filter/pl.js");

__webpack_require__(/*! ../metaphorjs/src/filter/preloaded.js */ "../metaphorjs/src/filter/preloaded.js");

__webpack_require__(/*! ../metaphorjs/src/filter/r.js */ "../metaphorjs/src/filter/r.js");

__webpack_require__(/*! ../metaphorjs/src/filter/sortBy.js */ "../metaphorjs/src/filter/sortBy.js");

__webpack_require__(/*! ../metaphorjs/src/filter/split.js */ "../metaphorjs/src/filter/split.js");

__webpack_require__(/*! ../metaphorjs/src/filter/toArray.js */ "../metaphorjs/src/filter/toArray.js");

__webpack_require__(/*! ../metaphorjs/src/filter/ucfirst.js */ "../metaphorjs/src/filter/ucfirst.js");

__webpack_require__(/*! ../metaphorjs/src/filter/uppercase.js */ "../metaphorjs/src/filter/uppercase.js");

__webpack_require__(/*! ../metaphorjs/src/bootstrap/apps.js */ "../metaphorjs/src/bootstrap/apps.js");

__webpack_require__(/*! ../metaphorjs-model/src/__init.js */ "../metaphorjs-model/src/__init.js");

__webpack_require__(/*! ../metaphorjs-model/src/directive/attr/each.js */ "../metaphorjs-model/src/directive/attr/each.js");

__webpack_require__(/*! ../metaphorjs-model/src/model/Model.js */ "../metaphorjs-model/src/model/Model.js");

__webpack_require__(/*! ../metaphorjs-model/src/model/Record.js */ "../metaphorjs-model/src/model/Record.js");

__webpack_require__(/*! ../metaphorjs-model/src/model/Store.js */ "../metaphorjs-model/src/model/Store.js");

__webpack_require__(/*! ../metaphorjs-validator/src/directive/form.js */ "../metaphorjs-validator/src/directive/form.js");

__webpack_require__(/*! ../metaphorjs-validator/src/directive/validate.js */ "../metaphorjs-validator/src/directive/validate.js");

__webpack_require__(/*! ../metaphorjs/src/plugin/ListAnimated.js */ "../metaphorjs/src/plugin/ListAnimated.js");

__webpack_require__(/*! ../metaphorjs/src/plugin/ListBuffered.js */ "../metaphorjs/src/plugin/ListBuffered.js");

__webpack_require__(/*! ../metaphorjs/src/plugin/ListPullNext.js */ "../metaphorjs/src/plugin/ListPullNext.js");

__webpack_require__(/*! ../metaphorjs/src/plugin/SrcDeferred.js */ "../metaphorjs/src/plugin/SrcDeferred.js");

__webpack_require__(/*! ../metaphorjs/src/plugin/SrcSize.js */ "../metaphorjs/src/plugin/SrcSize.js");

__webpack_require__(/*! ../metaphorjs/src/extra-directives/attr/break-if.js */ "../metaphorjs/src/extra-directives/attr/break-if.js");

__webpack_require__(/*! ../metaphorjs/src/extra-directives/attr/ignore.js */ "../metaphorjs/src/extra-directives/attr/ignore.js");

__webpack_require__(/*! ../metaphorjs/src/extra-directives/attr/stylesheet.js */ "../metaphorjs/src/extra-directives/attr/stylesheet.js");

__webpack_require__(/*! ../metaphorjs/src/extra-directives/attr/update-on.js */ "../metaphorjs/src/extra-directives/attr/update-on.js");

__webpack_require__(/*! ../metaphorjs/src/extra-directives/tag/bind-html.js */ "../metaphorjs/src/extra-directives/tag/bind-html.js");

__webpack_require__(/*! ../metaphorjs/src/extra-directives/tag/bind.js */ "../metaphorjs/src/extra-directives/tag/bind.js");

__webpack_require__(/*! ../metaphorjs/src/extra-directives/tag/if.js */ "../metaphorjs/src/extra-directives/tag/if.js");

__webpack_require__(/*! ../metaphorjs/src/extra-directives/tag/include.js */ "../metaphorjs/src/extra-directives/tag/include.js");

__webpack_require__(/*! ../metaphorjs/src/extra-directives/tag/tag.js */ "../metaphorjs/src/extra-directives/tag/tag.js");

__webpack_require__(/*! ./src/ui/button/Button.js */ "./src/ui/button/Button.js");

__webpack_require__(/*! ./src/ui/button/Group.js */ "./src/ui/button/Group.js");

__webpack_require__(/*! ./src/ui/button/Split.js */ "./src/ui/button/Split.js");

__webpack_require__(/*! ./src/ui/dialog/Alert.js */ "./src/ui/dialog/Alert.js");

__webpack_require__(/*! ./src/ui/dialog/ColorPicker.js */ "./src/ui/dialog/ColorPicker.js");

__webpack_require__(/*! ./src/ui/dialog/Confirm.js */ "./src/ui/dialog/Confirm.js");

__webpack_require__(/*! ./src/ui/dialog/Popup.js */ "./src/ui/dialog/Popup.js");

__webpack_require__(/*! ./src/ui/dialog/Window.js */ "./src/ui/dialog/Window.js");

__webpack_require__(/*! ./src/ui/field/Checkbox.js */ "./src/ui/field/Checkbox.js");

__webpack_require__(/*! ./src/ui/field/Field.js */ "./src/ui/field/Field.js");

__webpack_require__(/*! ./src/ui/field/Input.js */ "./src/ui/field/Input.js");

__webpack_require__(/*! ./src/ui/field/Radio.js */ "./src/ui/field/Radio.js");

__webpack_require__(/*! ./src/ui/field/Select.js */ "./src/ui/field/Select.js");

__webpack_require__(/*! ./src/ui/field/view/Select.js */ "./src/ui/field/view/Select.js");

__webpack_require__(/*! ./src/ui/menu/Divider.js */ "./src/ui/menu/Divider.js");

__webpack_require__(/*! ./src/ui/menu/Item.js */ "./src/ui/menu/Item.js");

__webpack_require__(/*! ./src/ui/menu/Menu.js */ "./src/ui/menu/Menu.js");

__webpack_require__(/*! ./src/ui/mixin/Selectable.js */ "./src/ui/mixin/Selectable.js");

__webpack_require__(/*! ./src/ui/mixin/WithActiveState.js */ "./src/ui/mixin/WithActiveState.js");

__webpack_require__(/*! ./src/ui/mixin/WithDisabledState.js */ "./src/ui/mixin/WithDisabledState.js");

__webpack_require__(/*! ./src/ui/mixin/WithDropdown.js */ "./src/ui/mixin/WithDropdown.js");

__webpack_require__(/*! ./src/ui/mixin/WithLoadingState.js */ "./src/ui/mixin/WithLoadingState.js");

__webpack_require__(/*! ./src/ui/mixin/WithText.js */ "./src/ui/mixin/WithText.js");

__webpack_require__(/*! ./src/ui/panel/Panel.js */ "./src/ui/panel/Panel.js");

__webpack_require__(/*! ./src/ui/toolbar/Divider.js */ "./src/ui/toolbar/Divider.js");

__webpack_require__(/*! ./src/ui/toolbar/Item.js */ "./src/ui/toolbar/Item.js");

__webpack_require__(/*! ./src/ui/toolbar/Toolbar.js */ "./src/ui/toolbar/Toolbar.js");

__webpack_require__(/*! ./src/ui/util/Canvas.js */ "./src/ui/util/Canvas.js");

__webpack_require__(/*! ./src/ui/util/Color.js */ "./src/ui/util/Color.js");

__webpack_require__(/*! ./src/ui/util/ColorAlpha.js */ "./src/ui/util/ColorAlpha.js");

__webpack_require__(/*! ./src/ui/util/ColorHue.js */ "./src/ui/util/ColorHue.js");

__webpack_require__(/*! ./src/ui/util/ColorPicker.js */ "./src/ui/util/ColorPicker.js");

__webpack_require__(/*! ./src/ui/util/ColorSV.js */ "./src/ui/util/ColorSV.js");

__webpack_require__(/*! ./src/ui/util/Pagination.js */ "./src/ui/util/Pagination.js");

__webpack_require__(/*! ./src/ui/window/Window.js */ "./src/ui/window/Window.js");

__webpack_require__(/*! ../metaphorjs-dialog/src/directive/dropdown.js */ "../metaphorjs-dialog/src/directive/dropdown.js");

__webpack_require__(/*! ./dev-test/container.js */ "./dev-test/container.js");
})();

/******/ })()
;
//# sourceMappingURL=metaphorjs.ui.js.map